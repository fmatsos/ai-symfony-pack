>-
{
  "category": "PHP",
  "questions": [
    {
      "question": "Which of the following is a new feature introduced in PHP 8.0?",
      "answers": [
        {
          "value": "Match expression",
          "correct": true
        },
        {
          "value": "Arrow functions",
          "correct": false
        },
        {
          "value": "Null coalescing operator",
          "correct": false
        },
        {
          "value": "Constructor property promotion",
          "correct": true
        }
      ],
      "help": "PHP 8.0 introduced several significant features, including the Match expression and Constructor property promotion. Arrow functions were introduced in PHP 7.4, and the Null coalescing operator in PHP 7.0."
    },
    {
      "question": "In PHP 8.1, what is the purpose of the `readonly` property modifier?",
      "answers": [
        {
          "value": "To make a property immutable after initialization.",
          "correct": true
        },
        {
          "value": "To prevent a property from being accessed outside its class.",
          "correct": false
        },
        {
          "value": "To define a constant property within a class.",
          "correct": false
        },
        {
          "value": "To ensure a property can only be set in the constructor.",
          "correct": true
        }
      ],
      "help": "The `readonly` property modifier, introduced in PHP 8.1, allows properties to be initialized only once (either in the declaration or the constructor) and then become immutable. They cannot be modified thereafter."
    },
    {
      "question": "Which of the following correctly defines a class constant in PHP?",
      "answers": [
        {
          "value": "const MY_CONSTANT = 'value';",
          "correct": true
        },
        {
          "value": "define('MY_CONSTANT', 'value');",
          "correct": false
        },
        {
          "value": "public static $MY_CONSTANT = 'value';",
          "correct": false
        },
        {
          "value": "class MyClass { const MY_CONSTANT = 'value'; }",
          "correct": true
        }
      ],
      "help": "Class constants are defined using the `const` keyword inside a class. The `define()` function is used for global constants. Static properties are variables, not constants."
    },
    {
      "question": "Consider the following PHP code:\n\nphp\n<?php\nclass MyClass {\n    public function __construct(private string $name) {}\n\n    public function getName(): string {\n        return $this->name;\n    }\n}\n\n$obj = new MyClass('Test');\necho $obj->getName();\n?>\n```\n\nWhat PHP 8.0 feature is demonstrated here?",
      "answers": [
        {
          "value": "Constructor property promotion",
          "correct": true
        },
        {
          "value": "Named arguments",
          "correct": false
        },
        {
          "value": "Union types",
          "correct": false
        },
        {
          "value": "Attributes",
          "correct": false
        }
      ],
      "help": "The code `private string $name` directly in the constructor signature is an example of Constructor property promotion, introduced in PHP 8.0, which simplifies class property declaration and assignment."
    },
    {
      "question": "What is the primary purpose of namespaces in PHP?",
      "answers": [
        {
          "value": "To resolve naming conflicts between classes, functions, and constants.",
          "correct": true
        },
        {
          "value": "To improve code execution performance.",
          "correct": false
        },
        {
          "value": "To define access control for class members.",
          "correct": false
        },
        {
          "value": "To organize files on the filesystem.",
          "correct": false
        }
      ],
      "help": "Namespaces provide a way to group related code and prevent naming collisions when combining code from different sources or libraries."
    },
    {
      "question": "Given the following code, which `use` statement would correctly import the `Logger` class?",
      "answers": [
        {
          "value": "use App\\Utils\\Logger;",
          "correct": true
        },
        {
          "value": "use App\\Utils\\*;",
          "correct": false
        },
        {
          "value": "use Logger from App\\Utils;",
          "correct": false
        },
        {
          "value": "use function App\\Utils\\Logger;",
          "correct": false
        }
      ],
      "help": "To import a class from a specific namespace, you use the `use` keyword followed by the fully qualified name of the class."
    },
    {
      "question": "Which of the following statements about PHP interfaces is true?",
      "answers": [
        {
          "value": "An interface can define properties.",
          "correct": false
        },
        {
          "value": "A class can implement multiple interfaces.",
          "correct": true
        },
        {
          "value": "All methods in an interface must be public.",
          "correct": true
        },
        {
          "value": "An interface can be instantiated directly.",
          "correct": false
        }
      ],
      "help": "Interfaces define a contract for classes. They cannot define properties, can be implemented by multiple classes, and all their methods must be public and without implementation. Interfaces cannot be instantiated."
    },
    {
      "question": "What is the correct way to define an interface in PHP?",
      "answers": [
        {
          "value": "interface MyInterface { public function doSomething(); }",
          "correct": true
        },
        {
          "value": "abstract interface MyInterface { public function doSomething(); }",
          "correct": false
        },
        {
          "value": "class MyInterface { abstract public function doSomething(); }",
          "correct": false
        },
        {
          "value": "interface MyInterface { public $property; }",
          "correct": false
        }
      ],
      "help": "Interfaces are defined using the `interface` keyword. They contain method signatures without implementations and cannot have properties."
    },
    {
      "question": "Consider the following anonymous function:\n\n```php\n<?php\n$message = 'Hello';\n$greet = function ($name) use ($message) {\n    echo \"$message, $name!\";\n};\n$greet('World');\n?>\n```\n\nWhat will be the output of this code?",
      "answers": [
        {
          "value": "Hello, World!",
          "correct": true
        },
        {
          "value": "Error: Undefined variable $message",
          "correct": false
        },
        {
          "value": ", World!",
          "correct": false
        },
        {
          "value": "Hello, !",
          "correct": false
        }
      ],
      "help": "The `use` keyword allows an anonymous function (closure) to inherit variables from the parent scope. In this case, `$message` is correctly passed into the closure's scope."
    },
    {
      "question": "Which of the following is true about `static` anonymous functions in PHP 7.4+?",
      "answers": [
        {
          "value": "They cannot access `$this`.",
          "correct": true
        },
        {
          "value": "They are faster than non-static anonymous functions.",
          "correct": false
        },
        {
          "value": "They can access variables from the parent scope using `use`.",
          "correct": true
        },
        {
          "value": "They are automatically bound to the class where they are defined.",
          "correct": false
        }
      ],
      "help": "Static anonymous functions do not have access to `$this` and are not bound to any object. They can still inherit variables from the parent scope using the `use` keyword."
    },
    {
      "question": "What is a key characteristic of an abstract class in PHP?",
      "answers": [
        {
          "value": "It cannot be instantiated directly.",
          "correct": true
        },
        {
          "value": "It must contain at least one abstract method.",
          "correct": false
        },
        {
          "value": "It can define both abstract and concrete methods.",
          "correct": true
        },
        {
          "value": "It must be implemented by other classes.",
          "correct": false
        }
      ],
      "help": "Abstract classes cannot be instantiated on their own and serve as blueprints for other classes. They can contain both abstract methods (without implementation) and concrete methods (with implementation). While they often have abstract methods, it's not strictly required to have at least one."
    },
    {
      "question": "Which keyword is used to declare an abstract method in PHP?",
      "answers": [
        {
          "value": "abstract",
          "correct": true
        },
        {
          "value": "virtual",
          "correct": false
        },
        {
          "value": "interface",
          "correct": false
        },
        {
          "value": "public",
          "correct": false
        }
      ],
      "help": "The `abstract` keyword is used to declare an abstract class or an abstract method within an abstract class. Abstract methods have no body and must be implemented by non-abstract child classes."
    },
    {
      "question": "When handling exceptions in PHP, which block is guaranteed to execute regardless of whether an exception was thrown or caught?",
      "answers": [
        {
          "value": "`finally`",
          "correct": true
        },
        {
          "value": "`catch`",
          "correct": false
        },
        {
          "value": "`try`",
          "correct": false
        },
        {
          "value": "`else`",
          "correct": false
        }
      ],
      "help": "The `finally` block, if present, will always be executed after the `try` and `catch` blocks, regardless of whether an exception was thrown or caught."
    },
    {
      "question": "Which interface should custom exceptions implement or extend in PHP?",
      "answers": [
        {
          "value": "`Throwable`",
          "correct": true
        },
        {
          "value": "`Error`",
          "correct": false
        },
        {
          "value": "`Exception`",
          "correct": true
        },
        {
          "value": "`RuntimeException`",
          "correct": false
        }
      ],
      "help": "All exceptions and errors in PHP implement the `Throwable` interface. Custom exceptions typically extend the `Exception` class, which itself implements `Throwable`."
    },
    {
      "question": "What is the primary purpose of a trait in PHP?",
      "answers": [
        {
          "value": "To enable code reuse in single inheritance languages like PHP.",
          "correct": true
        },
        {
          "value": "To enforce a contract for classes to implement.",
          "correct": false
        },
        {
          "value": "To define abstract methods that must be implemented by subclasses.",
          "correct": false
        },
        {
          "value": "To provide multiple inheritance for classes.",
          "correct": false
        }
      ],
      "help": "Traits are a mechanism for code reuse in single inheritance languages. They allow a class to use methods and properties from multiple traits, effectively mimicking some aspects of multiple inheritance without the complexities."
    },
    {
      "question": "Given two traits, `TraitA` and `TraitB`, both defining a method `doSomething()`, how can you resolve the conflict when using both in a class?",
      "answers": [
        {
          "value": "Use the `insteadof` operator.",
          "correct": true
        },
        {
          "value": "Use the `as` operator to alias one of the methods.",
          "correct": true
        },
        {
          "value": "Define the method directly in the class to override both.",
          "correct": true
        },
        {
          "value": "It's not possible to use both traits if they have conflicting method names.",
          "correct": false
        }
      ],
      "help": "PHP provides mechanisms to resolve trait conflicts: `insteadof` to specify which trait's method to use, `as` to alias a method, or defining the method directly in the class, which takes precedence."
    },
    {
      "question": "Which PHP extension is commonly used for database access, providing a consistent interface for various database drivers?",
      "answers": [
        {
          "value": "PDO",
          "correct": true
        },
        {
          "value": "MySQLi",
          "correct": false
        },
        {
          "value": "GD",
          "correct": false
        },
        {
          "value": "cURL",
          "correct": false
        }
      ],
      "help": "PDO (PHP Data Objects) is a database access layer that provides a lightweight, consistent interface for connecting to various databases. MySQLi is specific to MySQL, while GD is for image manipulation and cURL for transferring data with URLs."
    },
    {
      "question": "Which SPL class can be used to iterate over the contents of a directory?",
      "answers": [
        {
          "value": "`FilesystemIterator`",
          "correct": true
        },
        {
          "value": "`DirectoryIterator`",
          "correct": true
        },
        {
          "value": "`RecursiveDirectoryIterator`",
          "correct": true
        },
        {
          "value": "`SplFileObject`",
          "correct": false
        }
      ],
      "help": "The SPL provides several iterators for filesystem operations, including `FilesystemIterator`, `DirectoryIterator`, and `RecursiveDirectoryIterator`."
    },
    {
      "question": "What is the purpose of `spl_autoload_register()` in PHP?",
      "answers": [
        {
          "value": "To register multiple autoload functions.",
          "correct": true
        },
        {
          "value": "To load a specific class file.",
          "correct": false
        },
        {
          "value": "To define a single, global autoloader.",
          "correct": false
        },
        {
          "value": "To prevent classes from being loaded automatically.",
          "correct": false
        }
      ],
      "help": "`spl_autoload_register()` registers a given function as an `__autoload()` implementation. This allows for multiple autoload functions to be registered, which are called in the order they are registered until the class is found."
    },
    {
      "question": "Which of the following data structures is provided by the SPL?",
      "answers": [
        {
          "value": "`SplQueue`",
          "correct": true
        },
        {
          "value": "`SplStack`",
          "correct": true
        },
        {
          "value": "`SplHeap`",
          "correct": true
        },
        {
          "value": "`LinkedList`",
          "correct": false
        }
      ],
      "help": "The SPL provides several data structures, including `SplQueue` (FIFO), `SplStack` (LIFO), and `SplHeap` (a max-heap by default). `LinkedList` is not a built-in SPL class."
    },
    {
      "question": "What is the correct way to declare a typed property in a PHP class (PHP 7.4+)?",
      "answers": [
        {
          "value": "public string $name;",
          "correct": true
        },
        {
          "value": "var $name: string;",
          "correct": false
        },
        {
          "value": "private string $name = null;",
          "correct": true
        },
        {
          "value": "protected $name string;",
          "correct": false
        }
      ],
      "help": "Typed properties were introduced in PHP 7.4, allowing developers to declare the type of a class property. The type hint comes before the property name."
    },
    {
      "question": "Which magic method is called when attempting to call an inaccessible method on an object?",
      "answers": [
        {
          "value": "`__call()`",
          "correct": true
        },
        {
          "value": "`__callStatic()`",
          "correct": false
        },
        {
          "value": "`__get()`",
          "correct": false
        },
        {
          "value": "`__set()`",
          "correct": false
        }
      ],
      "help": "The `__call()` magic method is triggered when invoking inaccessible methods in an object context. `__callStatic()` is for static inaccessible methods, and `__get()`/`__set()` are for inaccessible properties."
    },
    {
      "question": "What is the output of the following PHP code?\n\n```php\n<?php\nclass ParentClass {\n    public static function foo() {\n        echo \"Parent\";\n    }\n}\n\nclass ChildClass extends ParentClass {\n    public static function foo() {\n        echo \"Child\";\n    }\n}\n\nChildClass::foo();\n?>\n```",
      "answers": [
        {
          "value": "Child",
          "correct": true
        },
        {
          "value": "Parent",
          "correct": false
        },
        {
          "value": "Fatal error",
          "correct": false
        },
        {
          "value": "Undefined method",
          "correct": false
        }
      ],
      "help": "When a static method is called on a child class, PHP's method resolution order will first look for the method in the child class. If found, it will execute that method. This is an example of static method overriding."
    },
    {
      "question": "Which of the following is a valid way to define a constant within a class in PHP?",
      "answers": [
        {
          "value": "const MAX_ITEMS = 100;",
          "correct": true
        },
        {
          "value": "define('MAX_ITEMS', 100);",
          "correct": false
        },
        {
          "value": "public static $MAX_ITEMS = 100;",
          "correct": false
        },
        {
          "value": "final const MAX_ITEMS = 100;",
          "correct": false
        }
      ],
      "help": "Class constants are defined using the `const` keyword. `define()` is for global constants. `public static $MAX_ITEMS` defines a static property, not a constant. `final` cannot be used with `const` directly in this context."
    },
    {
      "question": "What is the purpose of the `__invoke()` magic method?",
      "answers": [
        {
          "value": "It is called when an object is treated as a function.",
          "correct": true
        },
        {
          "value": "It is called when an object is serialized.",
          "correct": false
        },
        {
          "value": "It is called when an object is cloned.",
          "correct": false
        },
        {
          "value": "It is called when an object is converted to a string.",
          "correct": false
        }
      ],
      "help": "The `__invoke()` method is called when a script tries to call an object as a function. This allows objects to behave like callables."
    },
    {
      "question": "Which PHP 8.0 feature allows you to specify metadata for classes, methods, properties, and functions?",
      "answers": [
        {
          "value": "Attributes",
          "correct": true
        },
        {
          "value": "Annotations",
          "correct": false
        },
        {
          "value": "Decorators",
          "correct": false
        },
        {
          "value": "Traits",
          "correct": false
        }
      ],
      "help": "Attributes (also known as annotations in other languages) were introduced in PHP 8.0, providing a structured way to add metadata to declarations without affecting their runtime behavior."
    },
    {
      "question": "What is the correct way to declare a union type for a function parameter in PHP 8.0+?",
      "answers": [
        {
          "value": "public function process(int|string $data)",
          "correct": true
        },
        {
          "value": "public function process(int or string $data)",
          "correct": false
        },
        {
          "value": "public function process(int, string $data)",
          "correct": false
        },
        {
          "value": "public function process((int|string) $data)",
          "correct": false
        }
      ],
      "help": "Union types, introduced in PHP 8.0, allow a variable to accept values of multiple different types. They are declared using the `|` (pipe) operator between the types."
    },
    {
      "question": "Which of the following statements about `final` classes in PHP is true?",
      "answers": [
        {
          "value": "A `final` class cannot be extended.",
          "correct": true
        },
        {
          "value": "A `final` class cannot have abstract methods.",
          "correct": true
        },
        {
          "value": "All methods in a `final` class must also be `final`.",
          "correct": false
        },
        {
          "value": "A `final` class cannot implement interfaces.",
          "correct": false
        }
      ],
      "help": "A `final` class cannot be inherited from, meaning no other class can extend it. Consequently, it cannot have abstract methods because abstract methods must be implemented by child classes. It can, however, implement interfaces."
    },
    {
      "question": "What is the difference between `self::` and `static::` when referring to static members within a class hierarchy?",
      "answers": [
        {
          "value": "`self::` refers to the class where the code is defined, while `static::` refers to the class where the method was originally called (Late Static Bindings).",
          "correct": true
        },
        {
          "value": "`self::` is used for constants, and `static::` is used for static properties.",
          "correct": false
        },
        {
          "value": "`self::` is for public members, and `static::` is for protected members.",
          "correct": false
        },
        {
          "value": "There is no functional difference; they are interchangeable.",
          "correct": false
        }
      ],
      "help": "`self::` refers to the class in which the code is written. `static::` (introduced with Late Static Bindings) refers to the class that was originally called at runtime, allowing for more flexible inheritance patterns."
    },
    {
      "question": "Which of the following is the base interface for all throwables (exceptions and errors) in PHP?",
      "answers": [
        {
          "value": "`Throwable`",
          "correct": true
        },
        {
          "value": "`Exception`",
          "correct": false
        },
        {
          "value": "`Error`",
          "correct": false
        },
        {
          "value": "`RuntimeException`",
          "correct": false
        }
      ],
      "help": "The `Throwable` interface is the root interface for any object that can be thrown via a `throw` statement, including both `Exception` and `Error` classes."
    },
    {
      "question": "How can you register a custom error handler in PHP?",
      "answers": [
        {
          "value": "Using `set_error_handler()`",
          "correct": true
        },
        {
          "value": "Using `register_shutdown_function()`",
          "correct": false
        },
        {
          "value": "By extending the `ErrorException` class",
          "correct": false
        },
        {
          "value": "Using `ini_set('error_handler', 'my_handler')`",
          "correct": false
        }
      ],
      "help": "The `set_error_handler()` function is used to set a user-defined function to handle errors during script execution."
    },
    {
      "question": "Which of the following is a new feature for Enums introduced in PHP 8.1?",
      "answers": [
        {
          "value": "Backed Enums",
          "correct": true
        },
        {
          "value": "Pure Enums",
          "correct": true
        },
        {
          "value": "Enum methods",
          "correct": true
        },
        {
          "value": "Enum inheritance",
          "correct": false
        }
      ],
      "help": "PHP 8.1 introduced Enums, which can be either Pure Enums (simple cases) or Backed Enums (with scalar values). Enums can also have methods. Enum inheritance is not supported."
    },
    {
      "question": "What is the purpose of the `match` expression introduced in PHP 8.0?",
      "answers": [
        {
          "value": "It's a control structure similar to `switch` but with stricter comparisons and a return value.",
          "correct": true
        },
        {
          "value": "It's used for regular expression matching.",
          "correct": false
        },
        {
          "value": "It allows for pattern matching on arrays.",
          "correct": false
        },
        {
          "value": "It's a shorthand for multiple `if-else if` statements.",
          "correct": false
        }
      ],
      "help": "The `match` expression is a new control flow construct in PHP 8.0. It is similar to `switch` but provides stricter comparisons (identity check `===`), supports multiple expressions per arm, and returns a value, making it more concise and safer."
    },
    {
      "question": "Which of the following PHP 8.2 features allows for making properties immutable after initialization?",
      "answers": [
        {
          "value": "`readonly` classes",
          "correct": true
        },
        {
          "value": "`final` properties",
          "correct": false
        },
        {
          "value": "`const` properties",
          "correct": false
        },
        {
          "value": "`#[Immutable]` attribute",
          "correct": false
        }
      ],
      "help": "PHP 8.2 introduced `readonly` classes, which automatically make all properties within the class `readonly`. The `readonly` property modifier itself was introduced in PHP 8.1."
    },
    {
      "question": "What is the correct way to define a function that accepts either an `int` or a `float` as a parameter in PHP 8.0+?",
      "answers": [
        {
          "value": "function calculate(int|float $number)",
          "correct": true
        },
        {
          "value": "function calculate(int or float $number)",
          "correct": false
        },
        {
          "value": "function calculate(mixed $number)",
          "correct": false
        },
        {
          "value": "function calculate(numeric $number)",
          "correct": false
        }
      ],
      "help": "Union types (`|`) are the correct way to specify that a parameter can accept multiple types in PHP 8.0 and later. `mixed` accepts any type, and `numeric` is not a built-in type hint."
    },
    {
      "question": "Which of the following is a valid way to create an anonymous class in PHP?",
      "answers": [
        {
          "value": "new class { public function hello() { echo 'Hello'; } };",
          "correct": true
        },
        {
          "value": "class MyAnonymousClass extends null { public function hello() { echo 'Hello'; } };",
          "correct": false
        },
        {
          "value": "new class() { public function hello() { echo 'Hello'; } };",
          "correct": true
        },
        {
          "value": "anonymous class { public function hello() { echo 'Hello'; } };",
          "correct": false
        }
      ],
      "help": "Anonymous classes are created using `new class` followed by the class definition. They are useful for simple, one-off objects."
    },
    {
      "question": "What is the output of the following code snippet in PHP?\n\n```php\n<?php\nfunction greet(string $name, string $greeting = 'Hello') {\n    echo \"$greeting, $name!\";\n}\n\ngreet(name: 'Alice');\n?>\n```",
      "answers": [
        {
          "value": "Hello, Alice!",
          "correct": true
        },
        {
          "value": "Fatal error: Named arguments are not supported.",
          "correct": false
        },
        {
          "value": "Alice, Hello!",
          "correct": false
        },
        {
          "value": "Syntax error",
          "correct": false
        }
      ],
      "help": "This code demonstrates Named Arguments, a feature introduced in PHP 8.0, which allows passing arguments to a function based on their parameter name, regardless of their order. The default value for `$greeting` is used."
    },
    {
      "question": "Which SPL class provides an iterator for traversing arrays and objects?",
      "answers": [
        {
          "value": "`ArrayIterator`",
          "correct": true
        },
        {
          "value": "`IteratorAggregate`",
          "correct": false
        },
        {
          "value": "`RecursiveIteratorIterator`",
          "correct": false
        },
        {
          "value": "`SplFixedArray`",
          "correct": false
        }
      ],
      "help": "`ArrayIterator` allows iterating over arrays and objects as if they were arrays. `IteratorAggregate` is an interface for objects that can create an iterator. `RecursiveIteratorIterator` is for flattening recursive iterators. `SplFixedArray` is a fixed-size array."
    },
    {
      "question": "What is the purpose of the `__debugInfo()` magic method?",
      "answers": [
        {
          "value": "To customize the information displayed when `var_dump()` is called on an object.",
          "correct": true
        },
        {
          "value": "To log debug messages to a file.",
          "correct": false
        },
        {
          "value": "To provide a string representation of an object for debugging.",
          "correct": false
        },
        {
          "value": "To define properties that are only visible in debug mode.",
          "correct": false
        }
      ],
      "help": "The `__debugInfo()` magic method is called when `var_dump()` is used on an object, allowing you to customize the output and hide sensitive information or display computed properties."
    },
    {
      "question": "Which of the following is a valid way to define a typed array in PHP 7.4+?",
      "answers": [
        {
          "value": "There is no direct syntax for typed arrays in PHP; type hinting applies to elements, not the array itself.",
          "correct": true
        },
        {
          "value": "array<string> $names;",
          "correct": false
        },
        {
          "value": "string[] $names;",
          "correct": false
        },
        {
          "value": "array $names: string[];",
          "correct": false
        }
      ],
      "help": "PHP does not have built-in syntax for typed arrays. Type hints apply to scalar types, objects, or iterables, but not to the contents of an array directly. You can type-hint array parameters as `array` or `iterable`."
    },
    {
      "question": "What is the purpose of the `parent::` keyword in PHP?",
      "answers": [
        {
          "value": "To call a method or access a property from the parent class.",
          "correct": true
        },
        {
          "value": "To access a static method from any class in the hierarchy.",
          "correct": false
        },
        {
          "value": "To define an abstract method in a parent class.",
          "correct": false
        },
        {
          "value": "To refer to the current class instance.",
          "correct": false
        }
      ],
      "help": "The `parent::` keyword is used within a child class to refer to and call methods or access properties of its direct parent class."
    },
    {
      "question": "Which PHP 8.1 feature allows you to declare a property that can only be initialized once?",
      "answers": [
        {
          "value": "`readonly` properties",
          "correct": true
        },
        {
          "value": "`final` properties",
          "correct": false
        },
        {
          "value": "`const` properties",
          "correct": false
        },
        {
          "value": "`#[Immutable]` attribute",
          "correct": false
        }
      ],
      "help": "The `readonly` property modifier, introduced in PHP 8.1, ensures that a property can only be initialized once (either at declaration or in the constructor) and then cannot be modified."
    },
    {
      "question": "What is the correct way to catch multiple types of exceptions in a single `catch` block in PHP 7.1+?",
      "answers": [
        {
          "value": "catch (ExceptionA | ExceptionB $e)",
          "correct": true
        },
        {
          "value": "catch (ExceptionA, ExceptionB $e)",
          "correct": false
        },
        {
          "value": "catch (ExceptionA or ExceptionB $e)",
          "correct": false
        },
        {
          "value": "catch (array $e)",
          "correct": false
        }
      ],
      "help": "PHP 7.1 introduced the ability to catch multiple exception types in a single `catch` block using the `|` (pipe) operator."
    },
    {
      "question": "Which of the following is a valid way to define a `static` method in a PHP class?",
      "answers": [
        {
          "value": "public static function myStaticMethod() {}",
          "correct": true
        },
        {
          "value": "static public function myStaticMethod() {}",
          "correct": true
        },
        {
          "value": "function static myStaticMethod() {}",
          "correct": false
        },
        {
          "value": "public function static myStaticMethod() {}",
          "correct": false
        }
      ],
      "help": "Static methods are declared using the `static` keyword. The order of `public` and `static` does not matter."
    },
    {
      "question": "What is the purpose of the `yield` keyword in PHP?",
      "answers": [
        {
          "value": "To create a generator function.",
          "correct": true
        },
        {
          "value": "To return a value from a function and terminate execution.",
          "correct": false
        },
        {
          "value": "To pause function execution and return a value, allowing it to be resumed later.",
          "correct": true
        },
        {
          "value": "To define a coroutine.",
          "correct": false
        }
      ],
      "help": "The `yield` keyword is used to create generator functions. Generators allow you to write iterable code that can be paused and resumed, yielding values one at a time, which is memory-efficient for large datasets."
    },
    {
      "question": "Which of the following is a new function introduced in PHP 8.0 for string checking?",
      "answers": [
        {
          "value": "`str_contains()`",
          "correct": true
        },
        {
          "value": "`str_starts_with()`",
          "correct": true
        },
        {
          "value": "`str_ends_with()`",
          "correct": true
        },
        {
          "value": "`str_has()`",
          "correct": false
        }
      ],
      "help": "PHP 8.0 introduced `str_contains()`, `str_starts_with()`, and `str_ends_with()` for more convenient string checking without relying on `strpos()` or `substr()`."
    },
    {
      "question": "What is the output of the following PHP code?\n\n```php\n<?php\n$data = [1, 2, 3];\n$closure = function () use (&$data) {\n    $data[] = 4;\n};\n$closure();\nprint_r($data);\n?>\n```",
      "answers": [
        {
          "value": "Array\n(\n    [0] => 1\n    [1] => 2\n    [2] => 3\n    [3] => 4\n)\n",
          "correct": true
        },
        {
          "value": "Array\n(\n    [0] => 1\n    [1] => 2\n    [2] => 3\n)\n",
          "correct": false
        },
        {
          "value": "Error: Undefined variable $data",
          "correct": false
        },
        {
          "value": "Fatal error",
          "correct": false
        }
      ],
      "help": "When a variable is passed to a closure by reference (`&$data`), changes made to the variable inside the closure will affect the original variable in the parent scope."
    },
    {
      "question": "Which of the following SPL classes can be used to manage a collection of objects in a LIFO (Last-In, First-Out) manner?",
      "answers": [
        {
          "value": "`SplStack`",
          "correct": true
        },
        {
          "value": "`SplQueue`",
          "correct": false
        },
        {
          "value": "`SplHeap`",
          "correct": false
        },
        {
          "value": "`SplDoublyLinkedList`",
          "correct": false
        }
      ],
      "help": "`SplStack` implements a stack (LIFO). `SplQueue` implements a queue (FIFO). `SplHeap` is a heap. `SplDoublyLinkedList` is a general-purpose doubly linked list."
    },
    {
      "question": "What is the purpose of the `__serialize()` and `__unserialize()` magic methods (PHP 7.4+)?",
      "answers": [
        {
          "value": "To customize object serialization and deserialization, replacing `__sleep()` and `__wakeup()`.",
          "correct": true
        },
        {
          "value": "To convert an object to a JSON string.",
          "correct": false
        },
        {
          "value": "To define how an object is converted to a string when cast to `(string)`.",
          "correct": false
        },
        {
          "value": "To handle object cloning.",
          "correct": false
        }
      ],
      "help": "Introduced in PHP 7.4, `__serialize()` and `__unserialize()` provide a more robust and flexible way to handle object serialization and deserialization, superseding `__sleep()` and `__wakeup()`."
    },
    {
      "question": "Which PHP 8.1 feature allows you to define a string representation for an Enum case?",
      "answers": [
        {
          "value": "Backed Enums",
          "correct": true
        },
        {
          "value": "Pure Enums",
          "correct": false
        },
        {
          "value": "Enum methods",
          "correct": false
        },
        {
          "value": "Enum constants",
          "correct": false
        }
      ],
      "help": "Backed Enums in PHP 8.1 allow you to associate a scalar value (string or int) with each Enum case, which can serve as its string representation."
    },
    {
      "question": "What is the purpose of the `#[Deprecated]` attribute (PHP 8.0+)?",
      "answers": [
        {
          "value": "To mark a class, method, or property as deprecated, signaling that it should no longer be used.",
          "correct": true
        },
        {
          "value": "To prevent a method from being overridden by child classes.",
          "correct": false
        },
        {
          "value": "To remove a feature from the PHP language.",
          "correct": false
        },
        {
          "value": "To define a compile-time constant.",
          "correct": false
        }
      ],
      "help": "The `#[Deprecated]` attribute, introduced in PHP 8.0, is a standard way to mark code elements as deprecated, allowing tools and IDEs to warn developers about their usage."
    },
    {
      "question": "Which of the following is a valid way to define a constructor in a PHP class?",
      "answers": [
        {
          "value": "public function __construct() {}",
          "correct": true
        },
        {
          "value": "function MyClass() {}",
          "correct": false
        },
        {
          "value": "public function constructor() {}",
          "correct": false
        },
        {
          "value": "private function __construct() {}",
          "correct": true
        }
      ],
      "help": "The constructor method is named `__construct()`. It can have any visibility (public, protected, private)."
    },
    {
      "question": "What is the output of the following PHP code?\n\n```php\n<?php\nclass MyClass {\n    public function __toString() {\n        return 'This is MyClass';\n    }\n}\n\n$obj = new MyClass();\necho $obj;\n?>\n```",
      "answers": [
        {
          "value": "This is MyClass",
          "correct": true
        },
        {
          "value": "Fatal error: Object of class MyClass could not be converted to string",
          "correct": false
        },
        {
          "value": "MyClass",
          "correct": false
        },
        {
          "value": "Error: Call to undefined method MyClass::__toString()",
          "correct": false
        }
      ],
      "help": "The `__toString()` magic method allows a class to decide how it will react when it is treated as a string. If defined, PHP will call this method when an object is used in a string context (e.g., `echo`, string concatenation)."
    },
    {
      "question": "Which SPL class provides functionality for working with files and directories, including checking existence, permissions, and sizes?",
      "answers": [
        {
          "value": "`SplFileInfo`",
          "correct": true
        },
        {
          "value": "`SplFileObject`",
          "correct": false
        },
        {
          "value": "`FilesystemIterator`",
          "correct": false
        },
        {
          "value": "`DirectoryIterator`",
          "correct": false
        }
      ],
      "help": "`SplFileInfo` provides a high-level object-oriented interface for information about a file or directory. `SplFileObject` extends `SplFileInfo` and adds file-specific operations like reading/writing. The others are iterators."
    },
    {
      "question": "What is the purpose of the `#[AllowDynamicProperties]` attribute (PHP 8.2+)?",
      "answers": [
        {
          "value": "To explicitly allow dynamic properties on a class, suppressing deprecation warnings.",
          "correct": true
        },
        {
          "value": "To prevent dynamic properties from being created on a class.",
          "correct": false
        },
        {
          "value": "To define properties that can change their type at runtime.",
          "correct": false
        },
        {
          "value": "To enable strict type checking for all properties.",
          "correct": false
        }
      ],
      "help": "In PHP 8.2, dynamic properties were deprecated. The `#[AllowDynamicProperties]` attribute can be added to a class to explicitly allow them and suppress the deprecation warning."
    },
    {
      "question": "Which of the following is a valid way to define a constant within an interface in PHP?",
      "answers": [
        {
          "value": "interface MyInterface { const VERSION = '1.0'; }",
          "correct": true
        },
        {
          "value": "interface MyInterface { public const VERSION = '1.0'; }",
          "correct": true
        },
        {
          "value": "interface MyInterface { static $VERSION = '1.0'; }",
          "correct": false
        },
        {
          "value": "interface MyInterface { define('VERSION', '1.0'); }",
          "correct": false
        }
      ],
      "help": "Interfaces can define constants using the `const` keyword. They are implicitly public, so `public const` is also valid but redundant."
    },
    {
      "question": "What is the primary difference between an `Error` and an `Exception` in PHP?",
      "answers": [
        {
          "value": "`Error` typically represents severe, unrecoverable problems, while `Exception` represents recoverable errors.",
          "correct": true
        },
        {
          "value": "`Error` can be caught by `try-catch`, but `Exception` cannot.",
          "correct": false
        },
        {
          "value": "`Error` is for user-defined issues, `Exception` is for internal PHP issues.",
          "correct": false
        },
        {
          "value": "There is no practical difference; they are interchangeable.",
          "correct": false
        }
      ],
      "help": "In PHP 7+, `Error` classes represent internal PHP errors that typically indicate unrecoverable problems (e.g., type errors, parse errors), while `Exception` classes are for recoverable errors that can be handled gracefully by the application."
    },
    {
      "question": "Which PHP 8.0 feature allows for a more concise way to define and initialize class properties directly in the constructor?",
      "answers": [
        {
          "value": "Constructor property promotion",
          "correct": true
        },
        {
          "value": "Named arguments",
          "correct": false
        },
        {
          "value": "Union types",
          "correct": false
        },
        {
          "value": "Attributes",
          "correct": false
        }
      ],
      "help": "Constructor property promotion, introduced in PHP 8.0, allows you to declare property visibility and type directly in the constructor parameters, automatically creating and assigning the properties."
    },
    {
      "question": "What is the purpose of the `use function` statement in PHP?",
      "answers": [
        {
          "value": "To import a function from a namespace into the current scope.",
          "correct": true
        },
        {
          "value": "To define a new function using an alias.",
          "correct": false
        },
        {
          "value": "To execute a function immediately.",
          "correct": false
        },
        {
          "value": "To declare a function as deprecated.",
          "correct": false
        }
      ],
      "help": "The `use function` statement (PHP 5.6+) allows you to import specific functions from other namespaces, making them accessible without their fully qualified name."
    },
    {
      "question": "Which of the following is a valid way to define a trait in PHP?",
      "answers": [
        {
          "value": "trait MyTrait { public function doSomething() {} }",
          "correct": true
        },
        {
          "value": "abstract trait MyTrait { public function doSomething() {} }",
          "correct": false
        },
        {
          "value": "interface MyTrait { public function doSomething() {} }",
          "correct": false
        },
        {
          "value": "class MyTrait { public function doSomething() {} }",
          "correct": false
        }
      ],
      "help": "Traits are defined using the `trait` keyword. They can contain methods and properties, similar to classes, but cannot be instantiated directly."
    },
    {
      "question": "What is the output of the following PHP code?\n\n```php\n<?php\nclass A {\n    public function foo() {\n        echo \"A\";\n    }\n}\n\nclass B extends A {\n    public function foo() {\n        echo \"B\";\n    }\n}\n\n$obj = new B();\n$obj->foo();\n?>\n```",
      "answers": [
        {
          "value": "B",
          "correct": true
        },
        {
          "value": "A",
          "correct": false
        },
        {
          "value": "Fatal error",
          "correct": false
        },
        {
          "value": "Undefined method",
          "correct": false
        }
      ],
      "help": "This demonstrates method overriding. When a method is called on an object of a child class, PHP will execute the method defined in the child class if it exists, otherwise it will look in the parent class."
    },
    {
      "question": "Which SPL class provides a fixed-size array that can be faster than a regular PHP array for certain use cases?",
      "answers": [
        {
          "value": "`SplFixedArray`",
          "correct": true
        },
        {
          "value": "`ArrayObject`",
          "correct": false
        },
        {
          "value": "`SplStack`",
          "correct": false
        },
        {
          "value": "`SplQueue`",
          "correct": false
        }
      ],
      "help": "`SplFixedArray` is an SPL class that provides a fixed-size array. It can offer performance benefits over regular PHP arrays when the size is known beforehand, as it avoids reallocations."
    },
    {
      "question": "What is the purpose of the `#[Pure]` attribute (PHP 8.0+)?",
      "answers": [
        {
          "value": "To indicate that a function or method has no side effects and its output depends only on its inputs.",
          "correct": true
        },
        {
          "value": "To enforce strict type checking for function parameters.",
          "correct": false
        },
        {
          "value": "To mark a function as immutable.",
          "correct": false
        },
        {
          "value": "To define a function that can only be called once.",
          "correct": false
        }
      ],
      "help": "The `#[Pure]` attribute is a common attribute (though not built-in to PHP core, often used by static analysis tools) to indicate that a function or method is 'pure', meaning it produces no side effects and its return value is solely determined by its input parameters."
    },
    {
      "question": "Which of the following describes the `__clone()` magic method?",
      "answers": [
        {
          "value": "It is called when an object is duplicated using the `clone` keyword.",
          "correct": true
        },
        {
          "value": "It is used to create a deep copy of an object.",
          "correct": false
        },
        {
          "value": "It is called when an object is destroyed.",
          "correct": false
        },
        {
          "value": "It is used to prevent an object from being cloned.",
          "correct": false
        }
      ],
      "help": "The `__clone()` method is called when an object is cloned. It can be used to adjust properties of the cloned object, for example, to create deep copies of nested objects."
    },
    {
      "question": "What is the purpose of the `#[SensitiveParameter]` attribute (PHP 8.2+)?",
      "answers": [
        {
          "value": "To redact sensitive parameter values from stack traces.",
          "correct": true
        },
        {
          "value": "To encrypt parameter values automatically.",
          "correct": false
        },
        {
          "value": "To mark a parameter as optional.",
          "correct": false
        },
        {
          "value": "To enforce strict type checking for sensitive data.",
          "correct": false
        }
      ],
      "help": "Introduced in PHP 8.2, the `#[SensitiveParameter]` attribute allows you to mark parameters whose values should be redacted (replaced with `****`) in stack traces, preventing sensitive information from being exposed in error logs."
    },
    {
      "question": "Which of the following is a valid way to define a global constant in PHP?",
      "answers": [
        {
          "value": "define('APP_VERSION', '1.0.0');",
          "correct": true
        },
        {
          "value": "const APP_VERSION = '1.0.0';",
          "correct": false
        },
        {
          "value": "$APP_VERSION = '1.0.0';",
          "correct": false
        },
        {
          "value": "global const APP_VERSION = '1.0.0';",
          "correct": false
        }
      ],
      "help": "Global constants are defined using the `define()` function. The `const` keyword is used for class constants or top-level constants (PHP 5.3+)."
    },
    {
      "question": "What is the output of the following PHP code?\n\n```php\n<?php\nclass MyClass {\n    public function __construct(public string $name) {}\n}\n\n$obj = new MyClass('Test');\n$obj->name = 'New Test';\necho $obj->name;\n?>\n```",
      "answers": [
        {
          "value": "New Test",
          "correct": true
        },
        {
          "value": "Test",
          "correct": false
        },
        {
          "value": "Fatal error: Cannot modify readonly property",
          "correct": false
        },
        {
          "value": "Syntax error",
          "correct": false
        }
      ],
      "help": "The property `$name` is declared as `public string $name` (constructor property promotion). It is not `readonly`, so its value can be changed after initialization."
    },
    {
      "question": "Which of the following is a new feature in PHP 8.2 related to deprecations?",
      "answers": [
        {
          "value": "Deprecated dynamic properties",
          "correct": true
        },
        {
          "value": "Deprecated `mb_str_split()`",
          "correct": false
        },
        {
          "value": "Deprecated `each()` function",
          "correct": false
        },
        {
          "value": "Deprecated `create_function()`",
          "correct": false
        }
      ],
      "help": "PHP 8.2 deprecated dynamic properties, meaning assigning properties to an object that were not declared in the class definition will trigger a deprecation warning (unless the class uses `#[AllowDynamicProperties]` or implements `__get`/`__set`). `mb_str_split()` was deprecated in 8.0, `each()` in 7.2, and `create_function()` in 7.2."
    },
    {
      "question": "What is the purpose of the `#[Override]` attribute (PHP 8.3+)?",
      "answers": [
        {
          "value": "To explicitly mark a method as overriding a parent method, leading to a compile-time error if it doesn't.",
          "correct": true
        },
        {
          "value": "To prevent a method from being overridden.",
          "correct": false
        },
        {
          "value": "To indicate that a method is abstract.",
          "correct": false
        },
        {
          "value": "To force a child class to implement a specific method.",
          "correct": false
        }
      ],
      "help": "The `#[Override]` attribute (introduced in PHP 8.3, but good to know for future certification) is a new feature that allows developers to explicitly declare that a method is intended to override a method from a parent class or implemented interface. If no such method exists in the parent, a compile-time error is thrown, preventing common bugs."
    },
    {
      "question": "Which SPL class provides an iterator that can flatten a multi-dimensional array or tree structure?",
      "answers": [
        {
          "value": "`RecursiveIteratorIterator`",
          "correct": true
        },
        {
          "value": "`ArrayIterator`",
          "correct": false
        },
        {
          "value": "`CachingIterator`",
          "correct": false
        },
        {
          "value": "`FilterIterator`",
          "correct": false
        }
      ],
      "help": "`RecursiveIteratorIterator` is used to iterate over recursive iterators (like `RecursiveArrayIterator` or `RecursiveDirectoryIterator`), allowing you to flatten the structure and iterate over all elements in a single loop."
    },
    {
      "question": "What is the output of the following PHP code?\n\n```php\n<?php\nclass MyClass {\n    private string $name;\n\n    public function __construct(string $name) {\n        $this->name = $name;\n    }\n\n    public function __get($property) {\n        if ($property === 'name') {\n            return strtoupper($this->name);\n        }\n        return null;\n    }\n}\n\n$obj = new MyClass('Alice');\necho $obj->name;\n?>\n```",
      "answers": [
        {
          "value": "ALICE",
          "correct": true
        },
        {
          "value": "Alice",
          "correct": false
        },
        {
          "value": "Fatal error: Cannot access private property",
          "correct": false
        },
        {
          "value": "NULL",
          "correct": false
        }
      ],
      "help": "The `__get()` magic method is called when attempting to read an inaccessible (e.g., private or non-existent) property. In this case, it intercepts the access to `name` and returns its uppercase version."
    }
  ]
}

```
