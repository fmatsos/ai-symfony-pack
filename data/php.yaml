category: PHP
questions:
  -
    question: >
      Which of the following are new features introduced in PHP 8.0?
    answers:
      - { value: 'Named Arguments', correct: true }
      - { value: 'Attributes (Annotations)', correct: true }
      - { value: 'Match Expression', correct: true }
      - { value: 'Union Types', correct: true }
      - { value: 'Enums', correct: false }
    help: |
      PHP 8.0 introduced several significant features including Named Arguments, Attributes, Match Expression, and Union Types. Enums were introduced in PHP 8.1.
      https://www.php.net/manual/en/migration80.new-features.php
  -
    question: |
      Consider the following PHP 8.1 code snippet:
      ```php
      enum Status: string
      {
          case Active = 'active';
          case Inactive = 'inactive';
      }

      function getStatusValue(Status $status): string
      {
          return $status->value;
      }

      echo getStatusValue(Status::Active);
      ```
      What will be the output of this code?
    answers:
      - { value: 'active', correct: true }
      - { value: 'Status::Active', correct: false }
      - { value: 'Fatal error: Uncaught Error: Call to undefined method Status::value', correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      Enums in PHP 8.1 can have scalar backing types (string or int). The `value` property can be used to access the backing value of the enum case.
      https://www.php.net/manual/en/language.enumerations.php
  -
    question: >
      Which of the following statements about PHP 8.2 are true?
    answers:
      - { value: 'Readonly classes were introduced.', correct: true }
      - { value: 'Disjunctive Normal Form (DNF) Types are supported.', correct: true }
      - { value: 'New `true`, `false`, and `null` standalone types are available.', correct: false }
      - { value: 'Deprecation of dynamic properties.', correct: true }
    help: |
      PHP 8.2 introduced readonly classes, DNF types, and deprecated dynamic properties. The `true`, `false`, and `null` standalone types were introduced in PHP 8.0.
      https://www.php.net/manual/en/migration82.new-features.php
  -
    question: |
      What is the purpose of the `#[AllowDynamicProperties]` attribute in PHP 8.2?
    answers:
      - { value: 'It allows a class to define dynamic properties without triggering a deprecation warning.', correct: true }
      - { value: 'It restricts a class from having any dynamic properties.', correct: false }
      - { value: 'It enables a class to use magic methods like `__get` and `__set` without restriction.', correct: false }
      - { value: 'It marks a class as final, preventing inheritance.', correct: false }
    help: |
      In PHP 8.2, dynamic properties are deprecated. The `#[AllowDynamicProperties]` attribute can be added to a class to explicitly allow dynamic properties and suppress the deprecation warning.
      https://www.php.net/manual/en/migration82.deprecated.php#migration82.deprecated.core.dynamic-properties
  -
    question: >
      Which of the following are valid ways to define a constant in a PHP class?
    answers:
      - { value: '`const MY_CONSTANT = "value";`', correct: true }
      - { value: '`define("MY_CONSTANT", "value");` inside the class.', correct: false }
      - { value: '`public const MY_CONSTANT = "value";`', correct: true }
      - { value: '`static const MY_CONSTANT = "value";`', correct: false }
    help: |
      Class constants are defined using the `const` keyword. Since PHP 7.1, visibility modifiers (`public`, `protected`, `private`) can be used with class constants. `define()` is for global constants.
      https://www.php.net/manual/en/language.oop5.constants.php
  -
    question: |
      Consider the following PHP code:
      ```php
      class MyClass
      {
          public function __construct(
              public string $name,
              private int $age
          ) {}

          public function getAge(): int
          {
              return $this->age;
          }
      }

      $obj = new MyClass('Alice', 30);
      echo $obj->name;
      echo $obj->getAge();
      ```
      What PHP feature is demonstrated by the constructor definition?
    answers:
      - { value: 'Constructor Property Promotion', correct: true }
      - { value: 'Named Arguments', correct: false }
      - { value: 'Union Types', correct: false }
      - { value: 'Readonly Properties', correct: false }
    help: |
      Constructor Property Promotion, introduced in PHP 8.0, allows defining and initializing class properties directly in the constructor's parameter list.
      https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion
  -
    question: >
      Which of the following statements about `final` classes and methods in PHP are true?
    answers:
      - { value: 'A `final` class cannot be extended.', correct: true }
      - { value: 'A `final` method can be overridden by a child class.', correct: false }
      - { value: 'Abstract classes can be declared `final`.', correct: false }
      - { value: 'A class with at least one `final` method cannot be extended.', correct: false }
    help: |
      The `final` keyword prevents classes from being inherited and methods from being overridden. An abstract class cannot be final because it is meant to be extended.
      https://www.php.net/manual/en/language.oop5.final.php
  -
    question: |
      What is the primary purpose of `Traits` in PHP?
    answers:
      - { value: 'To enable code reuse in single inheritance languages like PHP.', correct: true }
      - { value: 'To enforce a contract that classes must adhere to.', correct: false }
      - { value: 'To define abstract methods that must be implemented by child classes.', correct: false }
      - { value: 'To provide a way to define global utility functions.', correct: false }
    help: |
      Traits are a mechanism for code reuse in single inheritance languages such as PHP. A Trait is intended to reduce the limitations of single inheritance by allowing a developer to reuse sets of methods freely in several independent classes.
      https://www.php.net/manual/en/language.oop5.traits.php
  -
    question: |
      Consider the following PHP code:
      ```php
      trait Logger
      {
          public function log(string $message)
          {
              echo "Log: " . $message . PHP_EOL;
          }
      }

      class MyService
      {
          use Logger;
      }

      $service = new MyService();
      $service->log("Operation completed.");
      ```
      What will be the output of this code?
    answers:
      - { value: 'Log: Operation completed.', correct: true }
      - { value: 'Fatal error: Call to undefined method MyService::log()', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'No output, but no error.', correct: false }
    help: |
      The `use Logger;` statement imports the `log` method from the `Logger` trait into the `MyService` class, making it available as if it were defined directly in the class.
      https://www.php.net/manual/en/language.oop5.traits.php
  -
    question: >
      Which of the following are true regarding PHP Namespaces?
    answers:
      - { value: 'They provide a way to group related classes, interfaces, functions, and constants.', correct: true }
      - { value: 'They prevent name collisions between different libraries or components.', correct: true }
      - { value: 'They are case-insensitive.', correct: false }
      - { value: 'The global namespace is implicitly defined and does not require a `namespace` declaration.', correct: true }
    help: |
      Namespaces are used to group related code and prevent name collisions. Namespace names are case-sensitive. Code without a `namespace` declaration is in the global namespace.
      https://www.php.net/manual/en/language.namespaces.php
  -
    question: |
      Given the following PHP code:
      ```php
      namespace App\Controller;

      use App\Service\Mailer;
      use App\Model\User as UserModel;

      class UserController
      {
          public function __construct(private Mailer $mailer) {}

          public function register(UserModel $user)
          {
              // ...
          }
      }
      ```
      What is the fully qualified name of the `UserModel` class within the `register` method?
    answers:
      - { value: '\App\Model\User', correct: true }
      - { value: 'App\Model\User', correct: false }
      - { value: 'UserModel', correct: false }
      - { value: '\App\Controller\UserModel', correct: false }
    help: |
      The `use App\Model\User as UserModel;` statement creates an alias `UserModel` for the fully qualified name `\App\Model\User`. When `UserModel` is used, it refers to `\App\Model\User`.
      https://www.php.net/manual/en/language.namespaces.importing.php
  -
    question: >
      What is the primary difference between an `interface` and an `abstract class` in PHP?
    answers:
      - { value: 'An interface can define properties, while an abstract class cannot.', correct: false }
      - { value: 'A class can implement multiple interfaces, but can only extend one abstract class.', correct: true }
      - { value: 'Abstract classes can contain concrete (implemented) methods, while interfaces can only declare method signatures.', correct: true }
      - { value: 'Interfaces can be instantiated, while abstract classes cannot.', correct: false }
    help: |
      Interfaces define a contract of methods that a class must implement, without providing any implementation. Abstract classes can have both abstract and concrete methods, and a class can only extend one abstract class. Neither can be instantiated directly.
      https://www.php.net/manual/en/language.oop5.interfaces.php
      https://www.php.net/manual/en/language.oop5.abstract.php
  -
    question: |
      Which of the following are valid ways to declare an anonymous function (closure) in PHP?
    answers:
      - { value: '`$func = function() { /* ... */ };`', correct: true }
      - { value: '`$func = fn() => /* ... */;` (Arrow function)', correct: true }
      - { value: '`$func = new Closure(function() { /* ... */ });`', correct: false }
      - { value: '`$func = create_function('', '');`', correct: false }
    help: |
      Anonymous functions are declared using the `function` keyword without a name. Arrow functions (`fn`) were introduced in PHP 7.4 as a more concise syntax for simple closures. `create_function` is deprecated.
      https://www.php.net/manual/en/functions.anonymous.php
      https://www.php.net/manual/en/functions.arrow.php
  -
    question: |
      Consider the following PHP code:
      ```php
      $message = 'Hello';
      $greet = function () use ($message) {
          echo $message;
      };
      $message = 'World';
      $greet();
      ```
      What will be the output of this code?
    answers:
      - { value: 'Hello', correct: true }
      - { value: 'World', correct: false }
      - { value: 'Undefined variable $message', correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      When a variable is imported into a closure using `use`, it is imported by value at the time the closure is defined, not by reference. Changes to the original variable after the closure's definition will not affect the variable inside the closure.
      https://www.php.net/manual/en/functions.anonymous.php#functions.anonymous.variables
  -
    question: >
      Which of the following statements about `abstract` methods are true?
    answers:
      - { value: 'An abstract method must be declared in an abstract class or interface.', correct: true }
      - { value: 'An abstract method must not contain any implementation (body).', correct: true }
      - { value: 'A class containing an abstract method must itself be declared abstract.', correct: true }
      - { value: 'Abstract methods can be declared `private`.', correct: false }
    help: |
      Abstract methods are declared without an implementation and must be implemented by non-abstract child classes. They can be `public` or `protected`, but not `private`.
      https://www.php.net/manual/en/language.oop5.abstract.php
  -
    question: |
      Which of the following are standard PHP extensions commonly used for web development?
    answers:
      - { value: 'PDO', correct: true }
      - { value: 'json', correct: true }
      - { value: 'gd', correct: true }
      - { value: 'imagick', correct: false }
    help: |
      PDO (PHP Data Objects), json, and gd are standard PHP extensions. Imagick is a PECL extension, not bundled with PHP by default.
      https://www.php.net/manual/en/extensions.alphabetical.php
  -
    question: >
      What is the purpose of the `SPL` (Standard PHP Library) in PHP?
    answers:
      - { value: 'To provide a collection of interfaces and classes for common data structures and iterators.', correct: true }
      - { value: 'To manage PHP extensions and their dependencies.', correct: false }
      - { value: 'To define a standard for PHP package management.', correct: false }
      - { value: 'To offer a set of low-level system programming functions.', correct: false }
    help: |
      The Standard PHP Library (SPL) is a collection of interfaces and classes that are intended to solve standard problems. It provides a set of basic interfaces and classes for common data structures (e.g., SplStack, SplQueue) and iterators.
      https://www.php.net/manual/en/book.spl.php
  -
    question: |
      Which SPL class provides a way to iterate over a directory's contents?
    answers:
      - { value: '`DirectoryIterator`', correct: true }
      - { value: '`SplFileObject`', correct: false }
      - { value: '`FilesystemIterator`', correct: true }
      - { value: '`RecursiveDirectoryIterator`', correct: true }
    help: |
      `DirectoryIterator`, `FilesystemIterator`, and `RecursiveDirectoryIterator` are SPL classes used for iterating over directory contents. `SplFileObject` is for file operations.
      https://www.php.net/manual/en/class.directoryiterator.php
      https://www.php.net/manual/en/class.filesystemiterator.php
      https://www.php.net/manual/en/class.recursivedirectoryiterator.php
  -
    question: >
      Which of the following are valid ways to catch multiple types of exceptions in PHP 8.0+?
    answers:
      - { value: '`catch (InvalidArgumentException|RuntimeException $e)`', correct: true }
      - { value: '`catch (InvalidArgumentException $e) catch (RuntimeException $e)`', correct: false }
      - { value: '`catch (Throwable $e)`', correct: true }
      - { value: '`catch (Exception $e)`', correct: true }
    help: |
      PHP 7 introduced the ability to catch multiple exception types in a single `catch` block using the `|` operator. `Throwable` is the base interface for all throwables (Errors and Exceptions) in PHP 7+. `Exception` is the base class for most userland exceptions.
      https://www.php.net/manual/en/language.exceptions.php
  -
    question: |
      Consider the following PHP code:
      ```php
      function divide(int $a, int $b): float
      {
          if ($b === 0) {
              throw new InvalidArgumentException("Cannot divide by zero.");
          }
          return $a / $b;
      }

      try {
          echo divide(10, 0);
      } catch (InvalidArgumentException $e) {
          echo "Error: " . $e->getMessage();
      } finally {
          echo "Division attempt finished.";
      }
      ```
      What will be the output of this code?
    answers:
      - { value: 'Error: Cannot divide by zero.Division attempt finished.', correct: true }
      - { value: 'Division attempt finished.Error: Cannot divide by zero.', correct: false }
      - { value: 'Fatal error: Uncaught InvalidArgumentException: Cannot divide by zero.', correct: false }
      - { value: 'Error: Cannot divide by zero.', correct: false }
    help: |
      The `try` block attempts the division. When `InvalidArgumentException` is thrown, the `catch` block executes. The `finally` block always executes, regardless of whether an exception was thrown or caught.
      https://www.php.net/manual/en/language.exceptions.php#language.exceptions.finally
  -
    question: >
      Which of the following are valid ways to define properties in a PHP class?
    answers:
      - { value: '`public $propertyName;`', correct: true }
      - { value: '`private string $propertyName;`', correct: true }
      - { value: '`var $propertyName;`', correct: true }
      - { value: '`const $propertyName;`', correct: false }
    help: |
      Properties are defined using visibility keywords (`public`, `protected`, `private`) followed by the property name. Type declarations are optional since PHP 7.4. `var` is an older keyword equivalent to `public`. `const` is for constants, not properties.
      https://www.php.net/manual/en/language.oop5.properties.php
  -
    question: |
      What is the purpose of the `__invoke()` magic method in PHP?
    answers:
      - { value: 'It is called when an object is used as a function.', correct: true }
      - { value: 'It is called when an object is cloned.', correct: false }
      - { value: 'It is called when an object is converted to a string.', correct: false }
      - { value: 'It is called when a non-existent method is called on an object.', correct: false }
    help: |
      The `__invoke()` method is called when a script tries to call an object as a function.
      https://www.php.net/manual/en/language.oop5.magic.php#object.invoke
  -
    question: >
      Which of the following are considered "magic methods" in PHP?
    answers:
      - { value: '`__construct`', correct: true }
      - { value: '`__get`', correct: true }
      - { value: '`__set`', correct: true }
      - { value: '`__toString`', correct: true }
      - { value: '`__callStatic`', correct: true }
    help: |
      PHP provides a set of special methods that are automatically called under certain circumstances. These are known as magic methods and include `__construct`, `__destruct`, `__call`, `__callStatic`, `__get`, `__set`, `__isset`, `__unset`, `__sleep`, `__wakeup`, `__serialize`, `__unserialize`, `__toString`, `__invoke`, `__set_state`, `__clone`, and `__debugInfo`.
      https://www.php.net/manual/en/language.oop5.magic.php
  -
    question: |
      Consider the following PHP code:
      ```php
      class MyClass
      {
          public function __toString(): string
          {
              return "This is MyClass object.";
          }
      }

      $obj = new MyClass();
      echo $obj;
      ```
      What will be the output of this code?
    answers:
      - { value: 'This is MyClass object.', correct: true }
      - { value: 'Fatal error: Object of class MyClass could not be converted to string', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'No output', correct: false }
    help: |
      The `__toString()` method allows a class to decide how it will react when it is treated as a string. When `echo $obj;` is called, PHP automatically invokes `__toString()`.
      https://www.php.net/manual/en/language.oop5.magic.php#object.tostring
  -
    question: >
      What is the purpose of the `static` keyword when used with methods in PHP?
    answers:
      - { value: 'It allows a method to be called without instantiating the class.', correct: true }
      - { value: 'It makes the method accessible only within the class where it is defined.', correct: false }
      - { value: 'It ensures the method cannot be overridden by child classes.', correct: false }
      - { value: 'It binds the method to the specific instance of the object.', correct: false }
    help: |
      Static methods can be called directly on the class without creating an instance of the class. They do not have access to `$this`.
      https://www.php.net/manual/en/language.oop5.static.php
  -
    question: |
      Which of the following are valid ways to access a static property within the same class in PHP?
    answers:
      - { value: '`self::$propertyName`', correct: true }
      - { value: '`static::$propertyName`', correct: true }
      - { value: '`$this->propertyName`', correct: false }
      - { value: '`MyClass::$propertyName`', correct: true }
    help: |
      Static properties are accessed using the `::` operator. `self::` refers to the class where the code is written, `static::` refers to the class that was called at runtime (Late Static Bindings), and `ClassName::` is also valid. `$this` is for instance properties.
      https://www.php.net/manual/en/language.oop5.static.php#language.oop5.static.properties
      https://www.php.net/manual/en/language.oop5.late-static-bindings.php
  -
    question: >
      What is the difference between `Error` and `Exception` in PHP 7+?
    answers:
      - { value: '`Error` represents internal PHP errors, while `Exception` represents errors that can be caught and handled by userland code.', correct: true }
      - { value: 'Both `Error` and `Exception` implement the `Throwable` interface.', correct: true }
      - { value: '`Error` can be caught using a `try-catch` block, but `Exception` cannot.', correct: false }
      - { value: '`Error` is a subclass of `Exception`.', correct: false }
    help: |
      In PHP 7, `Throwable` became the base interface for both `Error` and `Exception`. `Error` objects are thrown for most internal PHP errors, while `Exception` objects are used for user-defined error conditions. Both can be caught.
      https://www.php.net/manual/en/language.exceptions.php#language.exceptions.php7
  -
    question: |
      Which of the following SPL data structures implements a LIFO (Last-In, First-Out) principle?
    answers:
      - { value: '`SplStack`', correct: true }
      - { value: '`SplQueue`', correct: false }
      - { value: '`SplPriorityQueue`', correct: false }
      - { value: '`SplDoublyLinkedList`', correct: false }
    help: |
      `SplStack` implements a LIFO stack. `SplQueue` implements a FIFO queue. `SplPriorityQueue` is a max-heap. `SplDoublyLinkedList` is a general-purpose doubly linked list.
      https://www.php.net/manual/en/class.splstack.php
  -
    question: >
      What is the purpose of `declare(strict_types=1);` in PHP?
    answers:
      - { value: 'It enables strict type checking for scalar type declarations in the current file.', correct: true }
      - { value: 'It makes all type declarations in the entire application strict.', correct: false }
      - { value: 'It must be the very first statement in a file, excluding comments and whitespace.', correct: true }
      - { value: 'It only affects return type declarations, not parameter types.', correct: false }
    help: |
      `declare(strict_types=1);` enables strict mode for scalar type declarations for the current file. It must be at the top of the file.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
  -
    question: |
      Consider the following PHP code:
      ```php
      function sum(int $a, int $b): int
      {
          return $a + $b;
      }

      echo sum(5, '3');
      ```
      What will be the output if `declare(strict_types=1);` is NOT present?
    answers:
      - { value: '8', correct: true }
      - { value: 'Fatal error: Uncaught TypeError', correct: false }
      - { value: '53', correct: false }
      - { value: 'Warning: A non-numeric value encountered', correct: false }
    help: |
      Without `strict_types`, PHP will attempt to coerce the string '3' to an integer, resulting in 5 + 3 = 8.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
  -
    question: |
      What will be the output if `declare(strict_types=1);` IS present in the previous code example?
      ```php
      declare(strict_types=1);
      function sum(int $a, int $b): int
      {
          return $a + $b;
      }

      echo sum(5, '3');
      ```
    answers:
      - { value: 'Fatal error: Uncaught TypeError: sum(): Argument #2 ($b) must be of type int, string given', correct: true }
      - { value: '8', correct: false }
      - { value: '53', correct: false }
      - { value: 'Warning: A non-numeric value encountered', correct: false }
    help: |
      With `strict_types=1`, PHP will enforce strict type checking, and a `TypeError` will be thrown because '3' is a string, not an integer.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
  -
    question: >
      Which of the following are valid type declarations in PHP 8.0+?
    answers:
      - { value: '`string|int` (Union Type)', correct: true }
      - { value: '`?string` (Nullable Type)', correct: true }
      - { value: '`mixed`', correct: true }
      - { value: '`void`', correct: true }
      - { value: '`array<string>` (Generic Type)', correct: false }
    help: |
      PHP 8.0 introduced Union Types. Nullable types (`?Type`) have been available since PHP 7.1. `mixed` and `void` are also valid types. Generic types like `array<string>` are not natively supported in PHP's type system.
      https://www.php.net/manual/en/language.types.declarations.php
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.union
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.mixed
  -
    question: |
      What is the purpose of the `match` expression introduced in PHP 8.0?
    answers:
      - { value: 'It is a new control structure similar to `switch` but with stricter comparisons and return value.', correct: true }
      - { value: 'It allows pattern matching on complex data structures.', correct: false }
      - { value: 'It is used for regular expression matching on strings.', correct: false }
      - { value: 'It replaces the `if-else if-else` construct entirely.', correct: false }
    help: |
      The `match` expression is similar to `switch` but offers several improvements: it is an expression (returns a value), uses strict comparisons (`===`), and does not have fall-through behavior by default.
      https://www.php.net/manual/en/control-structures.match.php
  -
    question: |
      Consider the following PHP 8.0 code:
      ```php
      $status = 200;
      $message = match ($status) {
          200 => 'OK',
          300, 301 => 'Redirect',
          400, 404 => 'Client Error',
          default => 'Unknown Status',
      };
      echo $message;
      ```
      What will be the output of this code?
    answers:
      - { value: 'OK', correct: true }
      - { value: 'Unknown Status', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'Client Error', correct: false }
    help: |
      The `match` expression evaluates the `$status` variable. Since `200` matches the first arm, 'OK' is returned and assigned to `$message`.
      https://www.php.net/manual/en/control-structures.match.php
  -
    question: >
      Which of the following are true about `readonly` properties in PHP 8.1?
    answers:
      - { value: 'A `readonly` property can only be initialized once, either at declaration or in the constructor.', correct: true }
      - { value: '`readonly` properties can be re-assigned outside the constructor.', correct: false }
      - { value: '`readonly` properties cannot have a default value.', correct: false }
      - { value: '`readonly` properties must be typed.', correct: true }
    help: |
      Readonly properties, introduced in PHP 8.1, can only be initialized once and must be typed. They can have default values.
      https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly
  -
    question: |
      Consider the following PHP 8.1 code:
      ```php
      class User
      {
          public readonly string $name;

          public function __construct(string $name)
          {
              $this->name = $name;
          }

          public function setName(string $newName)
          {
              $this->name = $newName; // Line A
          }
      }

      $user = new User('Alice');
      $user->setName('Bob'); // Line B
      ```
      What will happen when Line B is executed?
    answers:
      - { value: 'A `Error` will be thrown because a readonly property cannot be re-assigned.', correct: true }
      - { value: 'The `$user->name` property will be successfully updated to "Bob".', correct: false }
      - { value: 'A deprecation warning will be issued, but the assignment will proceed.', correct: false }
      - { value: 'Nothing, the `setName` method will be ignored.', correct: false }
    help: |
      Attempting to re-assign a `readonly` property after its initial assignment (which happens in the constructor here) will result in an `Error`.
      https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly
  -
    question: >
      What is the purpose of the `__debugInfo()` magic method?
    answers:
      - { value: 'It is called when `var_dump()` is used on an object.', correct: true }
      - { value: 'It is called when an object is serialized.', correct: false }
      - { value: 'It provides a custom string representation for logging.', correct: false }
      - { value: 'It defines the properties that should be included in `print_r()`.', correct: false }
    help: |
      The `__debugInfo()` method is called when `var_dump()` is used on an object to provide a customized representation of the object's properties.
      https://www.php.net/manual/en/language.oop5.magic.php#object.debuginfo
  -
    question: |
      Which of the following are true about `static` properties in PHP?
    answers:
      - { value: 'They belong to the class itself, not to any specific instance of the class.', correct: true }
      - { value: 'They can be accessed using `$this->propertyName` from within the class.', correct: false }
      - { value: 'Their value is shared among all instances of the class.', correct: true }
      - { value: 'They must be declared with a visibility keyword (public, protected, private).', correct: true }
    help: |
      Static properties are class-level properties, shared across all instances. They are accessed using `self::`, `static::`, or `ClassName::`, not `$this->`. They require a visibility keyword.
      https://www.php.net/manual/en/language.oop5.static.php#language.oop5.static.properties
  -
    question: >
      Which of the following SPL interfaces can be implemented by a class to allow it to be iterated over using `foreach`?
    answers:
      - { value: '`Iterator`', correct: true }
      - { value: '`IteratorAggregate`', correct: true }
      - { value: '`ArrayAccess`', correct: false }
      - { value: '`Countable`', correct: false }
    help: |
      Classes that implement `Iterator` can be iterated directly. Classes that implement `IteratorAggregate` provide an external `Iterator` object via `getIterator()`. `ArrayAccess` allows array-like access, and `Countable` allows the use of `count()`.
      https://www.php.net/manual/en/class.iterator.php
      https://www.php.net/manual/en/class.iteratoraggregate.php
  -
    question: |
      Consider the following PHP code:
      ```php
      class MyCollection implements IteratorAggregate
      {
          private array $items = [];

          public function add(string $item)
          {
              $this->items[] = $item;
          }

          public function getIterator(): Traversable
          {
              return new ArrayIterator($this->items);
          }
      }

      $collection = new MyCollection();
      $collection->add('Apple');
      $collection->add('Banana');

      foreach ($collection as $item) {
          echo $item . PHP_EOL;
      }
      ```
      What will be the output of this code?
    answers:
      - { value: 'Apple' . PHP_EOL . 'Banana' . PHP_EOL, correct: true }
      - { value: 'Fatal error: Class MyCollection cannot be iterated.', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'No output', correct: false }
    help: |
      By implementing `IteratorAggregate` and returning an `ArrayIterator` in `getIterator()`, the `MyCollection` object becomes traversable using `foreach`.
      https://www.php.net/manual/en/class.iteratoraggregate.php
  -
    question: >
      Which of the following are true about `finally` blocks in PHP exception handling?
    answers:
      - { value: 'A `finally` block will always be executed, regardless of whether an exception was thrown or caught.', correct: true }
      - { value: 'A `finally` block is optional.', correct: true }
      - { value: 'If a `return` statement is present in both the `try` and `finally` blocks, the `finally` block''s `return` value will take precedence.', correct: true }
      - { value: 'A `finally` block can catch exceptions that were not caught by a preceding `catch` block.', correct: false }
    help: |
      The `finally` block is executed after the `try` and `catch` blocks, regardless of whether an exception occurred. It's often used for cleanup. If both `try` and `finally` have `return` statements, the `finally`'s return value is used.
      https://www.php.net/manual/en/language.exceptions.php#language.exceptions.finally
  -
    question: |
      What is the purpose of the `yield` keyword in PHP?
    answers:
      - { value: 'To create a generator function, allowing iteration over a set of data without building an array in memory.', correct: true }
      - { value: 'To pause execution of a function and return a value, resuming later from where it left off.', correct: true }
      - { value: 'To define a coroutine for asynchronous programming.', correct: false }
      - { value: 'To explicitly return `null` from a function.', correct: false }
    help: |
      The `yield` keyword is used to create generator functions. Generators allow you to write iterable code that can produce a sequence of values on demand, without needing to build an entire array in memory.
      https://www.php.net/manual/en/language.generators.php
  -
    question: |
      Consider the following PHP code:
      ```php
      function generateNumbers()
      {
          for ($i = 1; $i <= 3; $i++) {
              yield $i;
          }
      }

      foreach (generateNumbers() as $number) {
          echo $number;
      }
      ```
      What will be the output of this code?
    answers:
      - { value: '123', correct: true }
      - { value: 'Fatal error: Function generateNumbers() must return a value.', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'No output', correct: false }
    help: |
      The `generateNumbers` function is a generator. Each `yield` statement returns a value and pauses execution, resuming from that point on the next iteration.
      https://www.php.net/manual/en/language.generators.php
  -
    question: >
      Which of the following are true about `readonly` classes introduced in PHP 8.2?
    answers:
      - { value: 'All properties declared in a `readonly` class are implicitly `readonly`.', correct: true }
      - { value: '`readonly` classes cannot have dynamic properties.', correct: true }
      - { value: '`readonly` classes can be extended.', correct: true }
      - { value: '`readonly` classes cannot have static properties.', correct: false }
    help: |
      Readonly classes ensure that all properties are readonly. They cannot have dynamic properties. They can be extended, and they can have static properties (which are not implicitly readonly).
      https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly-classes
  -
    question: |
      What is the purpose of the `__clone()` magic method?
    answers:
      - { value: 'It is called when an object is duplicated using the `clone` keyword.', correct: true }
      - { value: 'It is called when an object is serialized.', correct: false }
      - { value: 'It prevents an object from being cloned.', correct: false }
      - { value: 'It is used to create a new instance of a class.', correct: false }
    help: |
      When an object is cloned, PHP will perform a shallow copy of all its properties. If the `__clone()` method is defined, then the newly created object's `__clone()` method will be called, which can be used to perform deep copies or other custom logic.
      https://www.php.net/manual/en/language.oop5.cloning.php
  -
    question: >
      Which of the following are valid ways to define a constant in PHP (outside of a class)?
    answers:
      - { value: '`define("APP_NAME", "My App");`', correct: true }
      - { value: '`const APP_VERSION = "1.0";`', correct: true }
      - { value: '`$APP_URL = "http://example.com";`', correct: false }
      - { value: '`define APP_DEBUG true;`', correct: false }
    help: |
      Global constants can be defined using `define()` or the `const` keyword. `const` is preferred for compile-time constants.
      https://www.php.net/manual/en/language.constants.php
  -
    question: |
      What is the purpose of the `__sleep()` and `__wakeup()` magic methods?
    answers:
      - { value: '`__sleep()` is called before serialization, and `__wakeup()` is called after unserialization.', correct: true }
      - { value: '`__sleep()` is called when an object is destroyed, and `__wakeup()` is called when it is created.', correct: false }
      - { value: 'They are used to manage database connections in an object.', correct: false }
      - { value: 'They control the visibility of properties during debugging.', correct: false }
    help: |
      `__sleep()` is called prior to serialization and can return an array of property names to be serialized. `__wakeup()` is called after unserialization and can be used to re-establish resources.
      https://www.php.net/manual/en/language.oop5.magic.php#object.sleep
      https://www.php.net/manual/en/language.oop5.magic.php#object.wakeup
  -
    question: >
      Which of the following statements about `final` methods are true?
    answers:
      - { value: 'A `final` method cannot be overridden by a child class.', correct: true }
      - { value: 'A class containing a `final` method cannot be extended.', correct: false }
      - { value: 'Abstract methods can be declared `final`.', correct: false }
      - { value: '`final` methods can be declared `private`.', correct: true }
    help: |
      `final` methods prevent overriding. A class can be extended even if it has final methods. Abstract methods cannot be final as they must be implemented. `final` methods can have any visibility.
      https://www.php.net/manual/en/language.oop5.final.php
  -
    question: |
      Consider the following PHP code:
      ```php
      class ParentClass
      {
          public function foo()
          {
              echo "Parent foo" . PHP_EOL;
          }
      }

      class ChildClass extends ParentClass
      {
          public function foo()
          {
              echo "Child foo" . PHP_EOL;
          }

          public function bar()
          {
              parent::foo();
          }
      }

      $obj = new ChildClass();
      $obj->bar();
      ```
      What will be the output of this code?
    answers:
      - { value: 'Parent foo', correct: true }
      - { value: 'Child foo', correct: false }
      - { value: 'Fatal error: Call to undefined method parent::foo()', correct: false }
      - { value: 'No output', correct: false }
    help: |
      The `parent::` keyword is used to call a method from the parent class, even if it has been overridden in the child class.
      https://www.php.net/manual/en/language.oop5.paamayim-nekudotayim.php
  -
    question: >
      What is the purpose of the `static` keyword when used with properties in PHP?
    answers:
      - { value: 'It makes the property accessible only within the class where it is defined.', correct: false }
      - { value: 'It makes the property belong to the class itself, rather than to an instance of the class.', correct: true }
      - { value: 'It ensures the property cannot be modified after initialization.', correct: false }
      - { value: 'It allows the property to be accessed from outside the class without instantiation.', correct: true }
    help: |
      Static properties are class-level properties. They are shared across all instances and can be accessed directly on the class using `ClassName::$propertyName`.
      https://www.php.net/manual/en/language.oop5.static.php#language.oop5.static.properties
  -
    question: |
      Which of the following are valid ways to define an abstract class in PHP?
    answers:
      - { value: '`abstract class MyAbstractClass {}`', correct: true }
      - { value: '`class abstract MyAbstractClass {}`', correct: false }
      - { value: '`interface MyAbstractClass {}`', correct: false }
      - { value: '`final abstract class MyAbstractClass {}`', correct: false }
    help: |
      An abstract class is declared using the `abstract` keyword before `class`. An abstract class cannot be `final`.
      https://www.php.net/manual/en/language.oop5.abstract.php
  -
    question: >
      Which of the following are true about the `Throwable` interface in PHP 7+?
    answers:
      - { value: 'It is the base interface for all objects that can be thrown via the `throw` statement.', correct: true }
      - { value: 'Both `Error` and `Exception` classes implement `Throwable`.', correct: true }
      - { value: 'Userland classes can implement `Throwable` directly.', correct: false }
      - { value: 'It provides methods like `getMessage()`, `getCode()`, and `getFile()`.', correct: true }
    help: |
      `Throwable` is the root of the error/exception hierarchy. Userland classes cannot implement `Throwable` directly; they must extend `Exception`. It defines common methods for getting information about the throwable.
      https://www.php.net/manual/en/class.throwable.php
  -
    question: |
      What is the purpose of the `use` keyword when importing namespaces in PHP?
    answers:
      - { value: 'To bring a namespace into the current scope, allowing classes, functions, or constants from that namespace to be referenced without their fully qualified name.', correct: true }
      - { value: 'To define a new namespace.', correct: false }
      - { value: 'To include an external PHP file.', correct: false }
      - { value: 'To declare a trait to be used in a class.', correct: false }
    help: |
      The `use` keyword is used for importing namespaces, classes, functions, or constants into the current file's scope, making them easier to reference.
      https://www.php.net/manual/en/language.namespaces.importing.php
  -
    question: >
      Which of the following are true about PHP's `null` type?
    answers:
      - { value: 'A variable is considered `null` if it has been assigned the constant `NULL`.', correct: true }
      - { value: 'A variable is considered `null` if it has not been set to any value yet.', correct: true }
      - { value: 'A variable is considered `null` if it has been `unset()`.', correct: true }
      - { value: '`null` is equivalent to an empty string (`""`).', correct: false }
    help: |
      A variable is `null` if it's assigned `NULL`, hasn't been set, or has been `unset()`. `null` is not equivalent to an empty string or zero.
      https://www.php.net/manual/en/language.types.null.php
  -
    question: |
      Consider the following PHP code:
      ```php
      $value = null;
      if (isset($value)) {
          echo "Value is set.";
      } else {
          echo "Value is not set.";
      }
      ```
      What will be the output of this code?
    answers:
      - { value: 'Value is not set.', correct: true }
      - { value: 'Value is set.', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'Fatal error', correct: false }
    help: |
      `isset()` returns `false` for `null` values.
      https://www.php.net/manual/en/function.isset.php
  -
    question: >
      Which of the following are true about PHP's `array` type?
    answers:
      - { value: 'Arrays in PHP are ordered maps.', correct: true }
      - { value: 'They can be used as lists (numeric keys) or hash maps (string keys).', correct: true }
      - { value: 'Array keys can be integers or strings.', correct: true }
      - { value: 'Arrays are always passed by reference to functions by default.', correct: false }
    help: |
      PHP arrays are ordered maps. They can hold mixed types and use integer or string keys. Arrays are passed by value by default, unless explicitly passed by reference using `&`.
      https://www.php.net/manual/en/language.types.array.php
  -
    question: |
      What is the purpose of the `fn` (arrow function) syntax introduced in PHP 7.4?
    answers:
      - { value: 'To provide a more concise syntax for anonymous functions with a single expression.', correct: true }
      - { value: 'To automatically capture variables from the parent scope by value.', correct: true }
      - { value: 'To define generator functions more easily.', correct: false }
      - { value: 'To allow named arguments in function calls.', correct: false }
    help: |
      Arrow functions provide a shorthand for anonymous functions. They automatically capture variables from the parent scope by value, making the `use` keyword unnecessary.
      https://www.php.net/manual/en/functions.arrow.php
  -
    question: |
      Consider the following PHP 7.4+ code:
      ```php
      $x = 10;
      $y = 20;
      $sum = fn($z) => $x + $y + $z;
      echo $sum(5);
      ```
      What will be the output of this code?
    answers:
      - { value: '35', correct: true }
      - { value: 'Fatal error: Undefined variable $x', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: '25', correct: false }
    help: |
      Arrow functions automatically capture variables from the parent scope by value, so `$x` and `$y` are available inside the arrow function.
      https://www.php.net/manual/en/functions.arrow.php
  -
    question: >
      Which of the following are true about PHP's `void` return type?
    answers:
      - { value: 'A function declared with `void` must not return any value.', correct: true }
      - { value: 'It can return `null` explicitly.', correct: false }
      - { value: 'It can be used for methods that only perform side effects.', correct: true }
      - { value: 'If a `void` function contains a `return;` statement, it will cause an error.', correct: false }
    help: |
      A `void` function must not return a value. An explicit `return;` statement without a value is allowed. Returning `null` explicitly from a `void` function will result in a `TypeError`.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.void
  -
    question: |
      What is the purpose of the `readonly` modifier for properties in PHP 8.1?
    answers:
      - { value: 'To ensure that a property can only be initialized once and then cannot be changed.', correct: true }
      - { value: 'To make a property accessible only for reading, not writing, from outside the class.', correct: false }
      - { value: 'To declare a property that is shared across all instances of the class.', correct: false }
      - { value: 'To prevent a property from being serialized.', correct: false }
    help: |
      The `readonly` modifier ensures that a property can only be assigned a value once. Subsequent attempts to modify it will result in an `Error`.
      https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly
  -
    question: >
      Which of the following are true about PHP's `iterable` pseudo-type?
    answers:
      - { value: 'It accepts `array`s or objects that implement `Traversable`.', correct: true }
      - { value: 'It was introduced in PHP 7.1.', correct: true }
      - { value: 'It can be used for both parameter and return type declarations.', correct: true }
      - { value: 'It is a concrete class that can be instantiated.', correct: false }
    help: |
      `iterable` is a pseudo-type introduced in PHP 7.1 that can be used in type declarations. It accepts arrays or objects that implement the `Traversable` interface. It is not a class.
      https://www.php.net/manual/en/language.types.iterable.php
  -
    question: |
      Consider the following PHP code:
      ```php
      function processData(iterable $data)
      {
          foreach ($data as $item) {
              echo $item . ' ';
          }
      }

      processData([1, 2, 3]);
      processData(new ArrayIterator(['a', 'b']));
      ```
      What will be the output of this code?
    answers:
      - { value: '1 2 3 a b ', correct: true }
      - { value: 'Fatal error: Argument 1 passed to processData() must be of type iterable, array given', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: '1 2 3', correct: false }
    help: |
      The `iterable` type declaration allows both arrays and objects implementing `Traversable` (like `ArrayIterator`) to be passed to the function.
      https://www.php.net/manual/en/language.types.iterable.php
  -
    question: >
      Which of the following are true about PHP's `callable` pseudo-type?
    answers:
      - { value: 'It accepts functions, static methods, and object methods.', correct: true }
      - { value: 'It can be used for both parameter and return type declarations.', correct: true }
      - { value: 'It ensures that the passed value can be called as a function.', correct: true }
      - { value: 'It is a concrete class that can be instantiated.', correct: false }
    help: |
      `callable` is a pseudo-type used for type hinting that a parameter or return value is a valid callable. It is not a class.
      https://www.php.net/manual/en/language.types.callable.php
  -
    question: |
      Consider the following PHP code:
      ```php
      function executeCallback(callable $callback)
      {
          $callback('Hello from callback!');
      }

      executeCallback(function($message) {
          echo $message;
      });

      class MyCallable
      {
          public function __invoke(string $message)
          {
              echo $message;
          }
      }

      executeCallback(new MyCallable());
      ```
      What will be the output of this code?
    answers:
      - { value: 'Hello from callback!Hello from callback!', correct: true }
      - { value: 'Fatal error: Argument 1 passed to executeCallback() must be of type callable', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'Hello from callback!', correct: false }
    help: |
      Both anonymous functions and objects implementing `__invoke()` are considered `callable`.
      https://www.php.net/manual/en/language.types.callable.php
  -
    question: >
      Which of the following are true about PHP's `resource` type?
    answers:
      - { value: 'It represents an external resource, such as a database connection or file handle.', correct: true }
      - { value: 'It is an object-oriented type.', correct: false }
      - { value: 'Resources are automatically freed by PHP''s garbage collector when no longer referenced.', correct: true }
      - { value: 'You can directly manipulate the underlying resource data in PHP.', correct: false }
    help: |
      The `resource` type represents external resources. They are not objects and are managed by PHP's garbage collector. You interact with them via specific PHP functions, not direct manipulation.
      https://www.php.net/manual/en/language.types.resource.php
  -
    question: |
      What is the purpose of the `__serialize()` and `__unserialize()` magic methods introduced in PHP 7.4?
    answers:
      - { value: 'They provide a more robust and flexible way to handle object serialization and unserialization compared to `__sleep()` and `__wakeup()`.', correct: true }
      - { value: '`__serialize()` returns an array of properties to be serialized, and `__unserialize()` restores them.', correct: true }
      - { value: 'They are primarily used for database persistence.', correct: false }
      - { value: 'They replace the need for the `Serializable` interface.', correct: false }
    help: |
      `__serialize()` and `__unserialize()` offer a more flexible and robust serialization mechanism than `__sleep()`/`__wakeup()`. They allow full control over the serialization process by returning a key-value array of data to be serialized and receiving that array for unserialization.
      https://www.php.net/manual/en/language.oop5.magic.php#object.serialize
      https://www.php.net/manual/en/language.oop5.magic.php#object.unserialize
  -
    question: >
      Which of the following are true about PHP's `Reflection` API?
    answers:
      - { value: 'It allows inspection of classes, interfaces, functions, methods, and extensions at runtime.', correct: true }
      - { value: 'It is primarily used for debugging purposes.', correct: false }
      - { value: 'It enables dynamic creation of classes and methods.', correct: true }
      - { value: 'It is part of the SPL.', correct: false }
    help: |
      The Reflection API provides classes that allow you to introspect and manipulate various aspects of PHP code at runtime, including classes, methods, functions, properties, and extensions. It's used for dynamic code generation, framework development, and more. It is a core PHP feature, not part of SPL.
      https://www.php.net/manual/en/book.reflection.php
  -
    question: |
      Which `Reflection` class would you use to get information about a class's methods?
    answers:
      - { value: '`ReflectionClass`', correct: true }
      - { value: '`ReflectionMethod`', correct: true }
      - { value: '`ReflectionFunction`', correct: false }
      - { value: '`ReflectionProperty`', correct: false }
    help: |
      `ReflectionClass` provides methods like `getMethods()` to retrieve `ReflectionMethod` objects. `ReflectionMethod` itself represents a single method and provides detailed information about it.
      https://www.php.net/manual/en/class.reflectionclass.php
      https://www.php.net/manual/en/class.reflectionmethod.php
  -
    question: >
      Which of the following are true about PHP's `Generator` objects?
    answers:
      - { value: 'They implement the `Iterator` interface.', correct: true }
      - { value: 'They allow functions to return a traversable object without building an array in memory.', correct: true }
      - { value: 'They can be rewound multiple times by default.', correct: false }
      - { value: 'They are created using the `yield` keyword.', correct: true }
    help: |
      Generators implement `Iterator` and use `yield` to provide values on demand, saving memory. By default, they are forward-only iterators and cannot be rewound.
      https://www.php.net/manual/en/language.generators.php
  -
    question: |
      Consider the following PHP code:
      ```php
      function myGenerator()
      {
          yield 1;
          yield 2;
          yield 3;
      }

      $gen = myGenerator();
      foreach ($gen as $value) {
          echo $value;
      }
      $gen->rewind(); // Line A
      foreach ($gen as $value) {
          echo $value;
      }
      ```
      What will happen when Line A is executed?
    answers:
      - { value: 'A `LogicException` will be thrown because generators cannot be rewound after iteration.', correct: true }
      - { value: 'The generator will successfully rewind and iterate again, outputting "123".', correct: false }
      - { value: 'Nothing, the `rewind()` call will be ignored.', correct: false }
      - { value: 'A `TypeError` will be thrown.', correct: false }
    help: |
      By default, generators are forward-only iterators. Once iterated, they cannot be rewound, and attempting to do so will throw a `LogicException`.
      https://www.php.net/manual/en/language.generators.php#language.generators.rewinding
  -
    question: >
      Which of the following are true about PHP's `WeakMap` class (PHP 8.0+)?
    answers:
      - { value: 'It allows objects to be used as keys without preventing them from being garbage collected.', correct: true }
      - { value: 'It is part of the SPL.', correct: true }
      - { value: 'It can store any type of value, including scalar values, as keys.', correct: false }
      - { value: 'When a key object is garbage collected, its corresponding value is automatically removed from the map.', correct: true }
    help: |
      `WeakMap` (SPL, PHP 8.0+) allows objects as keys without preventing their garbage collection. When a key object is collected, its entry is removed. Only objects can be keys.
      https://www.php.net/manual/en/class.weakmap.php
  -
    question: |
      Consider the following PHP 8.0+ code:
      ```php
      $map = new WeakMap();
      $obj1 = new stdClass();
      $obj2 = new stdClass();

      $map[$obj1] = 'value1';
      $map[$obj2] = 'value2';

      unset($obj1); // $obj1 is no longer referenced

      gc_collect_cycles(); // Force garbage collection (for demonstration)

      echo count($map);
      ```
      What will be the output of this code?
    answers:
      - { value: '1', correct: true }
      - { value: '2', correct: false }
      - { value: '0', correct: false }
      - { value: 'Fatal error', correct: false }
    help: |
      When `$obj1` is `unset()`, it becomes eligible for garbage collection. Since `WeakMap` holds weak references to its keys, the entry for `$obj1` is removed from the map, leaving only the entry for `$obj2`.
      https://www.php.net/manual/en/class.weakmap.php
  -
    question: >
      Which of the following are true about PHP's `Attributes` (PHP 8.0+)?
    answers:
      - { value: 'They provide a way to add metadata to classes, methods, properties, and functions.', correct: true }
      - { value: 'They are defined using `#[AttributeName]` syntax.', correct: true }
      - { value: 'They can directly modify the runtime behavior of the code they annotate.', correct: false }
      - { value: 'They can be retrieved at runtime using the Reflection API.', correct: true }
    help: |
      Attributes (PHP 8.0+) are structured metadata. They are defined with `#[...]` and can be retrieved via Reflection. They do not directly modify behavior; rather, frameworks or libraries read them and act upon them.
      https://www.php.net/manual/en/language.attributes.php
  -
    question: |
      Consider the following PHP 8.0+ code:
      ```php
      #[Attribute(Attribute::TARGET_METHOD)]
      class Route
      {
          public function __construct(public string $path) {}
      }

      class MyController
      {
          #[Route('/users')]
          public function listUsers()
          {
              // ...
          }
      }

      $reflectionMethod = new ReflectionMethod(MyController::class, 'listUsers');
      $attributes = $reflectionMethod->getAttributes(Route::class);

      foreach ($attributes as $attribute) {
          $route = $attribute->newInstance();
          echo $route->path;
      }
      ```
      What will be the output of this code?
    answers:
      - { value: '/users', correct: true }
      - { value: 'Fatal error: Class "Route" not found', correct: false }
      - { value: 'No output', correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      The `Route` attribute is defined and applied to the `listUsers` method. The Reflection API is used to retrieve instances of this attribute, and its `path` property is then accessed.
      https://www.php.net/manual/en/language.attributes.php
  -
    question: >
      Which of the following are true about PHP's `Union Types` (PHP 8.0+)?
    answers:
      - { value: 'They allow a variable to accept values of multiple different types.', correct: true }
      - { value: 'They are specified using the `|` separator.', correct: true }
      - { value: '`void` can be part of a Union Type.', correct: false }
      - { value: '`null` can be part of a Union Type, e.g., `string|null`.', correct: true }
    help: |
      Union Types allow a variable to be one of several types, separated by `|`. `void` cannot be part of a union type. `null` can be, or the `?` prefix can be used for nullable types.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.union
  -
    question: |
      Consider the following PHP 8.0+ code:
      ```php
      function processInput(string|int $input): string|int
      {
          if (is_string($input)) {
              return strtoupper($input);
          }
          return $input * 2;
      }

      echo processInput('hello');
      echo processInput(10);
      ```
      What will be the output of this code?
    answers:
      - { value: 'HELLO20', correct: true }
      - { value: 'hello10', correct: false }
      - { value: 'Fatal error: Uncaught TypeError', correct: false }
      - { value: 'HELLO20.0', correct: false }
    help: |
      The `processInput` function accepts either a string or an integer. If it's a string, it's converted to uppercase. If it's an integer, it's multiplied by 2.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.union
  -
    question: >
      Which of the following are true about PHP's `Named Arguments` (PHP 8.0+)?
    answers:
      - { value: 'They allow passing arguments to a function based on their parameter name, rather than their position.', correct: true }
      - { value: 'They improve readability for functions with many parameters or optional parameters.', correct: true }
      - { value: 'They can be combined with positional arguments, but positional arguments must come before named arguments.', correct: true }
      - { value: 'They are only available for built-in PHP functions.', correct: false }
    help: |
      Named Arguments (PHP 8.0+) allow passing arguments by name, improving readability. They work for both user-defined and built-in functions, and can be mixed with positional arguments (positional first).
      https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments
  -
    question: |
      Consider the following PHP 8.0+ code:
      ```php
      function createUser(string $name, int $age, string $email, bool $isActive = true)
      {
          return "User: $name, Age: $age, Email: $email, Active: " . ($isActive ? 'Yes' : 'No');
      }

      echo createUser(age: 30, name: 'Alice', email: 'alice@example.com');
      ```
      What will be the output of this code?
    answers:
      - { value: 'User: Alice, Age: 30, Email: alice@example.com, Active: Yes', correct: true }
      - { value: 'Fatal error: Named parameter $name must be passed before positional parameters.', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'User: , Age: 30, Email: alice@example.com, Active: Yes', correct: false }
    help: |
      Named arguments allow you to specify arguments by their parameter name, in any order. The default value for `$isActive` is used since it's not provided.
      https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments
  -
    question: >
      Which of the following are true about PHP's `Enums` (PHP 8.1+)?
    answers:
      - { value: 'They provide a way to define a set of distinct named values.', correct: true }
      - { value: 'Enum cases are singleton objects.', correct: true }
      - { value: 'Enums can have methods.', correct: true }
      - { value: 'Enums can implement interfaces.', correct: true }
      - { value: 'Enums can extend classes.', correct: false }
    help: |
      Enums (PHP 8.1+) define a fixed set of named values. Cases are singleton objects. Enums can have methods and implement interfaces, but cannot extend classes.
      https://www.php.net/manual/en/language.enumerations.php
  -
    question: |
      Consider the following PHP 8.1+ code:
      ```php
      enum Role: string
      {
          case Admin = 'admin';
          case Editor = 'editor';
          case Viewer = 'viewer';

          public function label(): string
          {
              return match ($this) {
                  self::Admin => 'Administrator',
                  self::Editor => 'Content Editor',
                  self::Viewer => 'Guest Viewer',
              };
          }
      }

      echo Role::Editor->label();
      ```
      What will be the output of this code?
    answers:
      - { value: 'Content Editor', correct: true }
      - { value: 'editor', correct: false }
      - { value: 'Fatal error: Call to undefined method Role::label()', correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      Enums in PHP 8.1 can define methods, which can be called on enum cases. The `match` expression is used to return a specific label based on the enum case.
      https://www.php.net/manual/en/language.enumerations.php#language.enumerations.methods
  -
    question: >
      What is the purpose of the `readonly` modifier for classes in PHP 8.2?
    answers:
      - { value: 'To ensure that all properties declared within the class are implicitly `readonly`.', correct: true }
      - { value: 'To prevent the class from being extended.', correct: false }
      - { value: 'To make all methods within the class `final`.', correct: false }
      - { value: 'To prevent the creation of dynamic properties on instances of the class.', correct: true }
    help: |
      A `readonly` class (PHP 8.2) implicitly makes all its declared properties `readonly` and prevents the creation of dynamic properties on its instances. It does not prevent extension or make methods final.
      https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly-classes
  -
    question: |
      Which of the following are true about `Disjunctive Normal Form (DNF) Types` in PHP 8.2?
    answers:
      - { value: 'They allow combining Union Types and Intersection Types in a more flexible way.', correct: true }
      - { value: 'They are specified using parentheses and `&` (intersection) and `|` (union) operators.', correct: true }
      - { value: 'Example: `(A&B)|C` is a valid DNF type.', correct: true }
      - { value: 'They simplify type declarations for complex scenarios.', correct: true }
    help: |
      DNF Types (PHP 8.2) allow more complex type declarations by combining `&` (intersection) and `|` (union) types, following the Disjunctive Normal Form.
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.complex
  -
    question: |
      Consider the following PHP 8.2 code:
      ```php
      interface HasName { public function getName(): string; }
      interface HasId { public function getId(): int; }

      class User implements HasName, HasId {
          public function __construct(private string $name, private int $id) {}
          public function getName(): string { return $this->name; }
          public function getId(): int { return $this->id; }
      }

      class Product implements HasName {
          public function __construct(private string $name) {}
          public function getName(): string { return $this->name; }
      }

      function processEntity((HasName&HasId)|HasName $entity) {
          echo $entity->getName() . PHP_EOL;
          if ($entity instanceof HasId) {
              echo $entity->getId() . PHP_EOL;
          }
      }

      processEntity(new User('Alice', 1));
      processEntity(new Product('Laptop'));
      ```
      What will be the output of this code?
    answers:
      - { value: 'Alice' . PHP_EOL . '1' . PHP_EOL . 'Laptop' . PHP_EOL, correct: true }
      - { value: 'Fatal error: Uncaught TypeError', correct: false }
      - { value: 'Alice' . PHP_EOL . 'Laptop' . PHP_EOL, correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      The DNF type `(HasName&HasId)|HasName` means the parameter can be an object that implements both `HasName` and `HasId` (like `User`), OR an object that just implements `HasName` (like `Product`).
      https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.complex
  -
    question: >
      What is the purpose of the `__destruct()` magic method in PHP?
    answers:
      - { value: 'It is called when an object is about to be destroyed or garbage collected.', correct: true }
      - { value: 'It is used to explicitly free memory allocated by the object.', correct: false }
      - { value: 'It is called when an object is cloned.', correct: false }
      - { value: 'It is called at the end of the script execution for all objects.', correct: true }
    help: |
      The destructor method `__destruct()` is called as soon as there are no other references to a particular object, or in any shutdown sequence. It's used for cleanup operations.
      https://www.php.net/manual/en/language.oop5.decon.php#object.destruct
  -
    question: |
      Consider the following PHP code:
      ```php
      class MyResource
      {
          public function __construct()
          {
              echo "Resource acquired." . PHP_EOL;
          }

          public function __destruct()
          {
              echo "Resource released." . PHP_EOL;
          }
      }

      function doSomething()
      {
          $res = new MyResource();
          echo "Doing work..." . PHP_EOL;
      }

      doSomething();
      echo "Script end." . PHP_EOL;
      ```
      What will be the output of this code?
    answers:
      - { value: 'Resource acquired.' . PHP_EOL . 'Doing work...' . PHP_EOL . 'Resource released.' . PHP_EOL . 'Script end.' . PHP_EOL, correct: true }
      - { value: 'Resource acquired.' . PHP_EOL . 'Doing work...' . PHP_EOL . 'Script end.' . PHP_EOL . 'Resource released.' . PHP_EOL, correct: false }
      - { value: 'Resource acquired.' . PHP_EOL . 'Doing work...' . PHP_EOL, correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      The destructor is called when the object goes out of scope (at the end of the `doSomething()` function in this case) or when the script ends.
      https://www.php.net/manual/en/language.oop5.decon.php#object.destruct
  -
    question: >
      Which of the following are true about PHP's `DateTime` and `DateTimeImmutable` classes?
    answers:
      - { value: '`DateTime` objects are mutable, meaning their state can be changed after creation.', correct: true }
      - { value: '`DateTimeImmutable` objects are immutable, meaning their state cannot be changed after creation.', correct: true }
      - { value: 'Modifying a `DateTimeImmutable` object returns a new instance.', correct: true }
      - { value: 'Both classes extend the `DateTimeInterface`.', correct: true }
    help: |
      `DateTime` is mutable, `DateTimeImmutable` is immutable. Operations on `DateTimeImmutable` return new objects. Both implement `DateTimeInterface`.
      https://www.php.net/manual/en/class.datetime.php
      https://www.php.net/manual/en/class.datetimeimmutable.php
  -
    question: |
      Consider the following PHP code:
      ```php
      $date = new DateTime('2023-01-15');
      $date->modify('+1 day');
      echo $date->format('Y-m-d');

      $immutableDate = new DateTimeImmutable('2023-01-15');
      $newImmutableDate = $immutableDate->modify('+1 day');
      echo $immutableDate->format('Y-m-d');
      echo $newImmutableDate->format('Y-m-d');
      ```
      What will be the output of this code?
    answers:
      - { value: '2023-01-162023-01-152023-01-16', correct: true }
      - { value: '2023-01-162023-01-162023-01-16', correct: false }
      - { value: '2023-01-152023-01-152023-01-16', correct: false }
      - { value: 'Syntax error', correct: false }
    help: |
      `DateTime` is modified in place. `DateTimeImmutable` returns a new object when modified, leaving the original unchanged.
      https://www.php.net/manual/en/class.datetime.php
      https://www.php.net/manual/en/class.datetimeimmutable.php
  -
    question: >
      Which of the following are true about PHP's `Closure` class?
    answers:
      - { value: 'It is the internal class used to represent anonymous functions.', correct: true }
      - { value: 'Instances of `Closure` can be bound to an object and a scope.', correct: true }
      - { value: 'It provides methods like `bindTo()` and `fromCallable()`.', correct: true }
      - { value: 'It can be directly instantiated with `new Closure();`.', correct: false }
    help: |
      `Closure` is the internal class for anonymous functions. You cannot directly instantiate it with `new Closure()`. It offers methods to bind a closure to an object and scope.
      https://www.php.net/manual/en/class.closure.php
  -
    question: |
      Consider the following PHP code:
      ```php
      class MyObject
      {
          private string $name = 'MyObject';

          public function getNameClosure(): Closure
          {
              return function () {
                  return $this->name;
              };
          }
      }

      $obj = new MyObject();
      $closure = $obj->getNameClosure();
      $boundClosure = $closure->bindTo($obj, MyObject::class);

      echo $boundClosure();
      ```
      What will be the output of this code?
    answers:
      - { value: 'MyObject', correct: true }
      - { value: 'Fatal error: Undefined property: Closure::$name', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'No output', correct: false }
    help: |
      The anonymous function initially does not have `$this` bound. `bindTo()` explicitly binds it to `$obj` and the scope of `MyObject::class`, allowing access to `$this->name`.
      https://www.php.net/manual/en/closure.bindto.php
  -
    question: >
      Which of the following are true about PHP's `PDO` extension?
    answers:
      - { value: 'It provides a lightweight, consistent interface for accessing databases.', correct: true }
      - { value: 'It supports various database drivers (e.g., MySQL, PostgreSQL, SQLite).', correct: true }
      - { value: 'It offers prepared statements to prevent SQL injection vulnerabilities.', correct: true }
      - { value: 'It is a database abstraction layer that replaces the need for specific database extensions.', correct: true }
    help: |
      PDO (PHP Data Objects) is a database access layer that provides a uniform interface for interacting with various databases, supporting prepared statements for security.
      https://www.php.net/manual/en/book.pdo.php
  -
    question: |
      Which of the following are valid ways to connect to a MySQL database using PDO?
    answers:
      - { value: '`new PDO("mysql:host=localhost;dbname=testdb", "user", "pass");`', correct: true }
      - { value: '`new PDO("mysqli://localhost/testdb", "user", "pass");`', correct: false }
      - { value: '`new PDO("mysql:host=localhost;dbname=testdb", ["user", "pass"]);`', correct: false }
      - { value: '`new PDO("mysql://localhost/testdb", "user", "pass");`', correct: false }
    help: |
      The DSN (Data Source Name) for MySQL uses `mysql:host=...;dbname=...`. The second and third arguments are username and password, respectively.
      https://www.php.net/manual/en/ref.pdo-mysql.connection.php
  -
    question: >
      Which of the following are true about PHP's `json` extension?
    answers:
      - { value: 'It provides functions for encoding and decoding JSON data.', correct: true }
      - { value: '`json_encode()` converts PHP values to JSON strings.', correct: true }
      - { value: '`json_decode()` converts JSON strings to PHP values (arrays or objects).', correct: true }
      - { value: 'It automatically handles all data types without issues.', correct: false }
    help: |
      The `json` extension provides `json_encode()` and `json_decode()`. While powerful, it has limitations with certain PHP data types (e.g., resources, closures) and can fail silently without proper error checking.
      https://www.php.net/manual/en/book.json.php
  -
    question: |
      Consider the following PHP code:
      ```php
      $data = [
          'name' => 'Alice',
          'age' => 30,
          'isStudent' => false,
          'courses' => ['Math', 'Science']
      ];

      $jsonString = json_encode($data);
      echo $jsonString;
      ```
      What will be the output of this code?
    answers:
      - { value: '{"name":"Alice","age":30,"isStudent":false,"courses":["Math","Science"]}', correct: true }
      - { value: '{"name":"Alice","age":30,"isStudent":0,"courses":["Math","Science"]}', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'Fatal error', correct: false }
    help: |
      `json_encode()` converts a PHP array into a JSON string. PHP `false` is converted to JSON `false`.
      https://www.php.net/manual/en/function.json-encode.php
  -
    question: >
      Which of the following are true about PHP's `gd` extension?
    answers:
      - { value: 'It provides functions for image creation and manipulation.', correct: true }
      - { value: 'It can be used to generate thumbnails, watermarks, and charts.', correct: true }
      - { value: 'It supports various image formats like JPEG, PNG, GIF.', correct: true }
      - { value: 'It requires external libraries like ImageMagick to function.', correct: false }
    help: |
      The `gd` extension is a powerful image manipulation library built into PHP, supporting various formats. It does not require ImageMagick, which is a separate extension.
      https://www.php.net/manual/en/book.image.php
  -
    question: |
      Which SPL class provides a way to access an array or object as if it were an array?
    answers:
      - { value: '`ArrayAccess` (interface)', correct: true }
      - { value: '`ArrayObject` (class)', correct: true }
      - { value: '`SplFixedArray`', correct: false }
      - { value: '`SplQueue`', correct: false }
    help: |
      The `ArrayAccess` interface allows objects to use array syntax. `ArrayObject` is a class that implements `ArrayAccess` (among others) and provides array-like behavior for objects or arrays.
      https://www.php.net/manual/en/class.arrayaccess.php
      https://www.php.net/manual/en/class.arrayobject.php
  -
    question: |
      Consider the following PHP code:
      ```php
      class MyData implements ArrayAccess
      {
          private array $container = [];

          public function offsetSet(mixed $offset, mixed $value): void
          {
              if (is_null($offset)) {
                  $this->container[] = $value;
              } else {
                  $this->container[$offset] = $value;
              }
          }

          public function offsetExists(mixed $offset): bool
          {
              return isset($this->container[$offset]);
          }

          public function offsetUnset(mixed $offset): void
          {
              unset($this->container[$offset]);
          }

          public function offsetGet(mixed $offset): mixed
          {
              return $this->offsetExists($offset) ? $this->container[$offset] : null;
          }
      }

      $data = new MyData();
      $data['name'] = 'John Doe';
      echo $data['name'];
      ```
      What will be the output of this code?
    answers:
      - { value: 'John Doe', correct: true }
      - { value: 'Fatal error: Class MyData does not implement ArrayAccess', correct: false }
      - { value: 'Syntax error', correct: false }
      - { value: 'No output', correct: false }
    help: |
      By implementing the `ArrayAccess` interface and its required methods (`offsetSet`, `offsetExists`, `offsetUnset`, `offsetGet`), the `MyData` object can be accessed using array-like syntax.
      https://www.php.net/manual/en/class.arrayaccess.php