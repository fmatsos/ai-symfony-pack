category: Routing

questions:
  -
    question: >
      Which of the following PHP attribute configurations correctly defines a route named `blog_list` for the `/blog` URL?
    answers:
      - { value: "```php\n#[Route('/blog', name: 'blog_list')]\npublic function list(): Response {}\n```", correct: true }
      - { value: "```php\n#[Path('/blog', name: 'blog_list')]\npublic function list(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(path: '/blog', id: 'blog_list')]\npublic function list(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(url: '/blog', alias: 'blog_list')]\npublic function list(): Response {}\n```", correct: false }
    help: |
      The `#[Route]` attribute is used to define routes directly on controller methods. The `path` argument specifies the URL pattern, and `name` defines the route's unique identifier.
      https://symfony.com/doc/current/routing.html#defining-routes-as-php-attributes

  -
    question: |
      Given the following YAML configuration, which route is defined?

      ```yaml
      # config/routes.yaml
      product_show:
          path: /product/{id}
          controller: App\Controller\ProductController::show
      ```
    answers:
      - { value: "A route named `product_show` that matches `/product/{id}` and executes `App\\Controller\\ProductController::show`.", correct: true }
      - { value: "A route named `product_id` that matches `/product/{show}` and executes `App\\Controller\\ProductController::show`.", correct: false }
      - { value: "A service definition for `product_show`.", correct: false }
      - { value: "An invalid routing configuration.", correct: false }
    help: |
      In YAML, routes are defined with a unique name (e.g., `product_show`), followed by the `path` and `controller` keys.
      https://symfony.com/doc/current/routing.html#defining-routes-in-yaml

  -
    question: >
      To enable attribute-based routing for controllers located in `src/Controller/` within the `App\Controller` namespace, which YAML configuration is correct?
    answers:
      - { value: "```yaml\ncontrollers:\n    resource:\n        path: ../../src/Controller/\n        namespace: App\\Controller\n    type: attribute\n```", correct: true }
      - { value: "```yaml\napp_controllers:\n    path: ../../src/Controller/\n    type: annotation\n```", correct: false }
      - { value: "```yaml\nroutes:\n    import: App\\Controller\n    format: attributes\n```", correct: false }
      - { value: "```yaml\nattributes:\n    dir: src/Controller/\n    namespace: App\\Controller\n```", correct: false }
    help: |
      The `resource` key specifies the path to scan, `namespace` defines the base namespace, and `type: attribute` indicates that PHP attributes should be used for route definitions.
      https://symfony.com/doc/current/routing.html#loading-routes-from-php-attributes

  -
    question: |
      Which PHP configurator snippet correctly imports routes from the `src/Controller/` directory using attributes?
    answers:
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute');\n};\n```", correct: true }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->load('../../src/Controller/', 'attribute');\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->addResource('../../src/Controller/', 'attribute');\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->fromAttributes('../../src/Controller/');\n};\n```", correct: false }
    help: |
      The `import()` method of `RoutingConfigurator` is used to load routes from a given resource, specifying the type (e.g., 'attribute').
      https://symfony.com/doc/current/routing.html#loading-routes-from-php-attributes

  -
    question: |
      How would you define a route `/blog/{page}` where `page` is a required integer parameter using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/blog/{page<\\d+>}', name: 'blog_list')]\npublic function list(int $page): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])]\npublic function list(int $page): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{page}', name: 'blog_list', defaults: ['page' => 'int'])]\npublic function list(int $page): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/blog/{page:int}', name: 'blog_list')]\npublic function list(int $page): Response {}\n```", correct: false }
    help: |
      Route parameters can be restricted using inline regular expressions (e.g., `<\\d+>`) or by defining `requirements` in the `#[Route]` attribute.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      In YAML, how do you define a route `/blog/{page}` where `page` is a required integer parameter?
    answers:
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    requirements:\n        page: '\\d+'\n```", correct: true }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page<\\d+>}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    defaults:\n        page: int\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page:integer}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
    help: |
      In YAML, parameter requirements are defined under the `requirements` key, where the key is the parameter name and the value is the regular expression.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      To set a default value for a route parameter `name` to `'World'` in a route `/hello/{name}` using PHP attributes, which is the correct syntax?
    answers:
      - { value: "```php\n#[Route('/hello/{name}', name: 'hello_page', defaults: ['name' => 'World'])]\npublic function hello(string $name): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/hello/{name?World}', name: 'hello_page')]\npublic function hello(string $name): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/hello/{name}', name: 'hello_page', options: ['default_name' => 'World'])]\npublic function hello(string $name): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/hello/{name}', name: 'hello_page', parameters: ['name' => 'World'])]\npublic function hello(string $name): Response {}\n```", correct: false }
    help: |
      Default values for route parameters are specified using the `defaults` option in the `#[Route]` attribute.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: |
      How do you define a default value for the `page` parameter to `1` for the route `/blog/{page}` in YAML?
    answers:
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    defaults:\n        page: 1\n```", correct: true }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page?1}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    options:\n        default_page: 1\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    parameter_defaults:\n        page: 1\n```", correct: false }
    help: |
      In YAML, default values for route parameters are defined under the `defaults` key.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: |
      Which PHP attribute configuration correctly restricts the `slug` parameter in `/blog/{slug}` to only allow alphanumeric characters and hyphens?
    answers:
      - { value: "```php\n#[Route('/blog/{slug}', name: 'blog_show', requirements: ['slug' => '[a-zA-Z0-9-]+'])]\npublic function show(string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{slug<[a-zA-Z0-9-]+>}', name: 'blog_show')]\npublic function show(string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{slug}', name: 'blog_show', regex: ['slug' => '[a-zA-Z0-9-]+'])]\npublic function show(string $slug): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/blog/{slug}', name: 'blog_show', validation: ['slug' => 'alphanumeric_hyphen'])]\npublic function show(string $slug): Response {}\n```", correct: false }
    help: |
      Route parameters can be restricted using regular expressions, either inline within the path or via the `requirements` option.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      In YAML, how do you restrict the `id` parameter in `/product/{id}` to be a UUID (e.g., `[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`)?
    answers:
      - { value: "```yaml\nproduct_show:\n    path: /product/{id}\n    controller: App\\Controller\\ProductController::show\n    requirements:\n        id: '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'\n```", correct: true }
      - { value: "```yaml\nproduct_show:\n    path: /product/{id<[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}>}\n    controller: App\\Controller\\ProductController::show\n```", correct: false }
      - { value: "```yaml\nproduct_show:\n    path: /product/{id}\n    controller: App\\Controller\\ProductController::show\n    format: uuid\n```", correct: false }
      - { value: "```yaml\nproduct_show:\n    path: /product/{id}\n    controller: App\\Controller\\ProductController::show\n    constraints:\n        id: uuid\n```", correct: false }
    help: |
      Regular expression requirements for route parameters are specified under the `requirements` key in YAML.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      By default, Symfony route parameters do not match the `/` (slash) character. How can you allow a route parameter `token` in `/share/{token}` to contain slashes using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/share/{token}', name: 'share', requirements: ['token' => '.+'])]\npublic function share(string $token): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/share/{token<.+>}', name: 'share')]\npublic function share(string $token): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/share/{token}', name: 'share', allow_slashes: true)]\npublic function share(string $token): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/share/{token}', name: 'share', options: ['slash_tolerant' => true])]\npublic function share(string $token): Response {}\n```", correct: false }
    help: |
      To allow slashes in a route parameter, you must define a requirement that includes the slash character, typically `.+` to match any character one or more times.
      https://symfony.com/doc/current/routing.html#allowing-a-slash-character-in-a-route-parameter

  -
    question: |
      In YAML, how do you configure a route `/files/{path}` to allow the `path` parameter to include `/` (slash) characters?
    answers:
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path}\n    controller: App\\Controller\\FileController::view\n    requirements:\n        path: '.+'\n```", correct: true }
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path<.+>}\n    controller: App\\Controller\\FileController::view\n```", correct: false }
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path}\n    controller: App\\Controller\\FileController::view\n    options:\n        allow_slash: true\n```", correct: false }
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path}\n    controller: App\\Controller\\FileController::view\n    slash_allowed: true\n```", correct: false }
    help: |
      The `.+` regular expression allows a parameter to match any character, including slashes, one or more times.
      https://symfony.com/doc/current/routing.html#allowing-a-slash-character-in-a-route-parameter

  -
    question: >
      Symfony 7 supports PHP backed enums as route parameters. If you have an `OrderStatusEnum` backed by strings, how would Symfony handle a route `/orders/list/{status}` where `status` is an `OrderStatusEnum`?
    answers:
      - { value: "Symfony automatically converts the scalar value from the URL to the corresponding `OrderStatusEnum` instance.", correct: true }
      - { value: "You must manually convert the string status to an `OrderStatusEnum` instance in the controller.", correct: false }
      - { value: "Symfony will throw an error if a non-enum scalar value is provided in the URL.", correct: false }
      - { value: "PHP backed enums cannot be used directly as route parameters; they must be converted to strings first.", correct: false }
    help: |
      Symfony's ParamConverter automatically handles the conversion of route parameters to PHP backed enum instances, provided the enum is backed by a scalar type.
      https://symfony.com/doc/current/routing.html#route-parameter-with-php-backed-enum

  -
    question: |
      Given the following controller method:

      ```php
      // src/Controller/ProductController.php
      class ProductController extends AbstractController
      {
          #[Route('/product/{id}', name: 'product_show')]
          public function show(int $id = 1): Response
          {
              // ...
          }
      }
      ```
      What will be the value of `$id` if the URL `/product` is accessed?
    answers:
      - { value: "1", correct: true }
      - { value: "null", correct: false }
      - { value: "An exception will be thrown because `id` is missing.", correct: false }
      - { value: "0", correct: false }
    help: |
      If a route parameter has a default value in the controller method signature, and the parameter is not provided in the URL, Symfony will use the default value.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: |
      Consider the following YAML route definition:

      ```yaml
      # config/routes.yaml
      article_page:
          path: /articles/{page}
          controller: App\Controller\ArticleController::show
          defaults:
              page: 'home'
      ```
      What URL would match this route and result in `page` being `'home'`?
    answers:
      - { value: "`/articles`", correct: true }
      - { value: "`/articles/home`", correct: false }
      - { value: "`/articles/`", correct: true }
      - { value: "`/articles/index`", correct: false }
    help: |
      When a route parameter has a default value, the parameter becomes optional in the URL. If the parameter is omitted, its default value is used.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: >
      Within a Symfony controller that extends `AbstractController`, which method is used to generate a URL for a given route name and parameters?
    answers:
      - { value: "`$this->generateUrl('route_name', ['param' => 'value'])`", correct: true }
      - { value: "`$this->getUrl('route_name', ['param' => 'value'])`", correct: false }
      - { value: "`$this->router->generate('route_name', ['param' => 'value'])`", correct: false }
      - { value: "`$this->createUrl('route_name', ['param' => 'value'])`", correct: false }
    help: |
      The `AbstractController` provides a `generateUrl()` helper method for generating URLs.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      To generate an absolute URL (e.g., `http://example.com/blog`) for a route named `blog_list` from within a Symfony controller, what is the correct `generateUrl()` call?
    answers:
      - { value: "`$this->generateUrl('blog_list', [], UrlGeneratorInterface::ABSOLUTE_URL)`", correct: true }
      - { value: "`$this->generateUrl('blog_list', [], true)`", correct: false }
      - { value: "`$this->generateAbsoluteUrl('blog_list')`", correct: false }
      - { value: "`$this->generateUrl('blog_list', ['_absolute' => true])`", correct: false }
    help: |
      The third argument to `generateUrl()` can be a constant from `UrlGeneratorInterface` to specify the reference type, such as `ABSOLUTE_URL`.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      You have a localized route `about_us` with paths `en: /about-us` and `nl: /over-ons`. If the current request locale is `en`, how would you generate the URL for `about_us` in Dutch (`/over-ons`) from a controller?
    answers:
      - { value: "`$this->generateUrl('about_us', ['_locale' => 'nl'])`", correct: true }
      - { value: "`$this->generateUrl('about_us', ['locale' => 'nl'])`", correct: false }
      - { value: "`$this->generateUrl('about_us', [], 'nl')`", correct: false }
      - { value: "`$this->generateUrl('about_us', ['_language' => 'nl'])`", correct: false }
    help: |
      To explicitly set the locale for a generated URL, pass the `_locale` parameter in the arguments array.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which interface should be injected into a Symfony service to enable URL generation?
    answers:
      - { value: "`Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface`", correct: true }
      - { value: "`Symfony\\Component\\HttpFoundation\\UrlGeneratorInterface`", correct: false }
      - { value: "`Symfony\\Component\\Routing\\RouterInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\UriGeneratorInterface`", correct: false }
    help: |
      The `UrlGeneratorInterface` is the primary interface for generating URLs in Symfony.
      https://symfony.com/doc/current/routing.html#generating-urls-in-services

  -
    question: >
      When passing an object (e.g., a `Uuid` object) as an "extra" parameter to `generateUrl()` that is not part of the route pattern, what is the recommended practice to avoid issues?
    answers:
      - { value: "Explicitly cast the object to a string before passing it: `(string) $entity->getUuid()`.", correct: true }
      - { value: "Symfony automatically converts objects to strings if they implement `__toString()`.", correct: false }
      - { value: "Pass the object directly; Symfony's serializer handles the conversion.", correct: false }
      - { value: "Encode the object as JSON before passing it as a parameter.", correct: false }
    help: |
      For extra parameters that are not part of the route pattern, it's best practice to explicitly convert objects to strings to ensure they are correctly included in the query string.
      https://symfony.com/doc/current/routing.html#extra-parameters-in-urls

  -
    question: |
      To configure a route named `doc_shortcut` that redirects `/doc` to an internal route `doc_page` with `page: 'index'` and `version: 'current'`, and makes the redirect permanent (HTTP 301), which YAML configuration is correct?
    answers:
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\n    defaults:\n        route: 'doc_page'\n        page: 'index'\n        version: 'current'\n        permanent: true\n```", correct: true }
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    redirect_to: doc_page\n    parameters:\n        page: index\n        version: current\n    status: 301\n```", correct: false }
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    controller: RedirectController\n    options:\n        target_route: doc_page\n        params: { page: index, version: current }\n        permanent: true\n```", correct: false }
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    action: redirect\n    route_name: doc_page\n    route_params: { page: index, version: current }\n    http_status: 301\n```", correct: false }
    help: |
      The `RedirectController` is used for redirects. Internal redirects specify the `route` and any additional parameters in `defaults`. `permanent: true` sets the HTTP status code to 301.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: |
      You want to redirect `/legacy/doc` to an external URL `https://legacy.example.com/doc` with a permanent redirect. Which YAML configuration achieves this?
    answers:
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\n    defaults:\n        path: 'https://legacy.example.com/doc'\n        permanent: true\n```", correct: true }
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    redirect_to_url: 'https://legacy.example.com/doc'\n    status: 301\n```", correct: false }
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    controller: RedirectController\n    options:\n        url: 'https://legacy.example.com/doc'\n        permanent: true\n```", correct: false }
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    action: external_redirect\n    target: 'https://legacy.example.com/doc'\n    type: permanent\n```", correct: false }
    help: |
      For external redirects, the `path` default parameter is used to specify the target URL. `permanent: true` ensures a 301 redirect.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      When using `RedirectController` for a permanent redirect that also needs to preserve the original HTTP method (e.g., POST), what HTTP status code does Symfony use?
    answers:
      - { value: "308 (Permanent Redirect)", correct: true }
      - { value: "301 (Moved Permanently)", correct: false }
      - { value: "307 (Temporary Redirect)", correct: false }
      - { value: "303 (See Other)", correct: false }
    help: |
      If `keepRequestMethod` is `true` for a permanent redirect, Symfony uses HTTP 308. For temporary redirects, it uses 307.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      What is the primary purpose of the `_controller` special route parameter in Symfony?
    answers:
      - { value: "To determine which controller and action is executed when the route is matched.", correct: true }
      - { value: "To define the HTTP method allowed for the route.", correct: false }
      - { value: "To set the default locale for the route.", correct: false }
      - { value: "To specify the template to render for the route.", correct: false }
    help: |
      The `_controller` parameter is fundamental for routing, directly linking a matched URL to its corresponding PHP controller method.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      The `_format` special route parameter in Symfony is used for which purpose?
    answers:
      - { value: "To set the \"request format\" of the `Request` object, influencing the `Content-Type` of the response.", correct: true }
      - { value: "To define the expected data format for incoming POST requests.", correct: false }
      - { value: "To specify the output format of generated URLs.", correct: false }
      - { value: "To validate the format of route parameters.", correct: false }
    help: |
      The `_format` parameter helps Symfony determine the desired response format (e.g., HTML, JSON, XML) and sets the appropriate `Content-Type` header.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      What is the role of the `_locale` special route parameter in Symfony?
    answers:
      - { value: "It is used to set the locale on the `Request` object.", correct: true }
      - { value: "It defines the default language for the application.", correct: false }
      - { value: "It specifies the language of the route path itself.", correct: false }
      - { value: "It's a placeholder for user-defined language preferences.", correct: false }
    help: |
      The `_locale` parameter is crucial for internationalization, allowing Symfony to adapt content based on the user's preferred language.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: |
      Which PHP attribute configuration correctly defines a route `/articles/{_locale}/search.{_format}` with default locale `en`, default format `html`, and requirements for `_locale` (`en|fr`) and `_format` (`html|xml`)?
    answers:
      - { value: "```php\n#[Route(\n    path: '/articles/{_locale}/search.{_format}',\n    locale: 'en',\n    format: 'html',\n    requirements: [\n        '_locale' => 'en|fr',\n        '_format' => 'html|xml',\n    ],\n)]\npublic function search(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route(\n    path: '/articles/{_locale}/search.{_format}',\n    defaults: ['_locale' => 'en', '_format' => 'html'],\n    requirements: ['_locale' => 'en|fr', '_format' => 'html|xml'],\n)]\npublic function search(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/articles/{_locale}/search.{_format}',\n    name: 'article_search',\n    options: { 'locale': 'en', 'format': 'html' },\n    constraints: { '_locale': 'en|fr', '_format': 'html|xml' },\n)]\npublic function search(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/articles/{_locale}/search.{_format}',\n    default_locale: 'en',\n    default_format: 'html',\n    regex: { '_locale': 'en|fr', '_format': 'html|xml' },\n)]\npublic function search(): Response {}\n```", correct: false }
    help: |
      Special route parameters like `_locale` and `_format` can have default values and requirements defined directly in the `#[Route]` attribute.
      https://symfony.com/doc/current/routing.html#configuring-special-route-parameters

  -
    question: |
      In YAML, how do you define a route `/products/{_locale}.{_format}` with a default `_locale` of `en`, a default `_format` of `json`, and requirements that `_locale` is `en|de` and `_format` is `json|xml`?
    answers:
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    locale: en\n    format: json\n    requirements:\n        _locale: en|de\n        _format: json|xml\n```", correct: true }
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    defaults:\n        _locale: en\n        _format: json\n    requirements:\n        _locale: en|de\n        _format: json|xml\n```", correct: true }
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    options:\n        default_locale: en\n        default_format: json\n    constraints:\n        _locale: en|de\n        _format: json|xml\n```", correct: false }
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    locale_default: en\n    format_default: json\n    regex:\n        _locale: en|de\n        _format: json|xml\n```", correct: false }
    help: |
      In YAML, `locale` and `format` keys are used for default values of `_locale` and `_format` respectively, while `requirements` are used for their validation.
      https://symfony.com/doc/current/routing.html#configuring-special-route-parameters

  -
    question: >
      To mark a route named `homepage` for `/` as `stateless` using PHP attributes, preventing session usage during request matching, which is the correct configuration?
    answers:
      - { value: "```php\n#[Route('/', name: 'homepage', stateless: true)]\npublic function homepage(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/', name: 'homepage', options: ['stateless' => true])]\npublic function homepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'homepage', session_less: true)]\npublic function homepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'homepage', cacheable: true)]\npublic function homepage(): Response {}\n```", correct: false }
    help: |
      The `stateless` option in the `#[Route]` attribute indicates that the route does not require session state.
      https://symfony.com/doc/current/routing.html#stateless-routes

  -
    question: |
      How do you mark a route named `api_endpoint` for `/api` as `stateless` in YAML?
    answers:
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    stateless: true\n```", correct: true }
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    options:\n        stateless: true\n```", correct: false }
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    session_management: false\n```", correct: false }
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    no_session: true\n```", correct: false }
    help: |
      In YAML, the `stateless: true` option is used to mark a route as stateless.
      https://symfony.com/doc/current/routing.html#stateless-routes

  -
    question: >
      To define a route `/` that only matches the host `m.example.com` using PHP attributes, which is the correct configuration?
    answers:
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', host: 'm.example.com')]\npublic function mobileHomepage(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', domain: 'm.example.com')]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', options: ['host' => 'm.example.com'])]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', hostname: 'm.example.com')]\npublic function mobileHomepage(): Response {}\n```", correct: false }
    help: |
      The `host` option in the `#[Route]` attribute is used to match a specific domain or subdomain.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      How do you define a route `admin_dashboard` for `/dashboard` that only matches the host `admin.example.com` in YAML?
    answers:
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    host: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: true }
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    domain: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: false }
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    hostname: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: false }
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    options:\n        host: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: false }
    help: |
      In YAML, the `host` key is used to specify the required hostname for a route.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      Which PHP attribute configuration correctly defines a route `/` for `mobile_homepage` that matches `*.example.com`, has a default `subdomain` of `m`, and requires `subdomain` to be `m` or `mobile`?
    answers:
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    host: '{subdomain}.example.com',\n    defaults: ['subdomain' => 'm'],\n    requirements: ['subdomain' => 'm|mobile'],\n)]\npublic function mobileHomepage(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    host: '{subdomain}.example.com',\n    default_subdomain: 'm',\n    subdomain_regex: 'm|mobile',\n)]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    domain: '{subdomain}.example.com',\n    defaults: ['subdomain' => 'm'],\n    requirements: ['subdomain' => 'm|mobile'],\n)]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    host: '{subdomain}.example.com',\n    options: { 'subdomain_default': 'm', 'subdomain_pattern': 'm|mobile' },\n)]\npublic function mobileHomepage(): Response {}\n```", correct: false }
    help: |
      Dynamic host parameters are defined within the `host` option, and their defaults and requirements are set using `defaults` and `requirements` respectively.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      In YAML, how do you define a route `/` for `api_root` that matches `api.{version}.example.com`, has a default `version` of `v1`, and requires `version` to be `v1|v2`?
    answers:
      - { value: "```yaml\napi_root:\n    path: /\n    host: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    defaults:\n        version: v1\n    requirements:\n        version: v1|v2\n```", correct: true }
      - { value: "```yaml\napi_root:\n    path: /\n    host: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    default_version: v1\n    version_regex: v1|v2\n```", correct: false }
      - { value: "```yaml\napi_root:\n    path: /\n    domain: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    defaults:\n        version: v1\n    requirements:\n        version: v1|v2\n```", correct: false }
      - { value: "```yaml\napi_root:\n    path: /\n    host: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    options:\n        version_default: v1\n        version_pattern: v1|v2\n```", correct: false }
    help: |
      YAML allows for dynamic host parameters. Defaults are set under `defaults`, and requirements under `requirements`.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      Which PHP configurator snippet correctly imports routes from `src/Controller/` and applies host-based routing, mapping `www.example.com` to English (`en`) and `www.example.nl` to Dutch (`nl`)?
    answers:
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute')\n        ->host([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: true }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute')\n        ->hosts([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->load('../../src/Controller/', 'attribute')\n        ->domainMapping([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute')\n        ->mapHost([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: false }
    help: |
      The `host()` method on the imported route collection allows defining locale-specific host requirements.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      Which PHP attribute configuration correctly defines a route `/contact` that only matches GET or HEAD requests and where the `User-Agent` header matches `/firefox/i`?
    answers:
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    condition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n)]\npublic function contact(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    methods: ['GET', 'HEAD'],\n    headers: ['User-Agent' => '/firefox/i'],\n)]\npublic function contact(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    when: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n)]\npublic function contact(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    expression: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n)]\npublic function contact(): Response {}\n```", correct: false }
    help: |
      The `condition` option in the `#[Route]` attribute allows defining complex matching logic using Symfony's Expression Language.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: |
      In YAML, how do you define a route `/posts/{id}` that only matches if the `id` parameter is less than `1000`?
    answers:
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    condition: \"params['id'] < 1000\"\n```", correct: true }
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    requirements:\n        id: '<1000'\n```", correct: false }
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    when: \"id < 1000\"\n```", correct: false }
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    filter: \"id < 1000\"\n```", correct: false }
    help: |
      The `condition` key in YAML allows using Expression Language, where `params` variable provides access to route parameters.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: >
      Which built-in variables are available for use within Symfony's routing condition expressions?
    answers:
      - { value: "`context` (Symfony\\Component\\Routing\\RequestContext)", correct: true }
      - { value: "`request` (Symfony\\Component\\HttpFoundation\\Request)", correct: true }
      - { value: "`params` (array of matched route parameters)", correct: true }
      - { value: "`session` (Symfony\\Component\\HttpFoundation\\Session\\SessionInterface)", correct: false }
      - { value: "`container` (Symfony\\Component\\DependencyInjection\\ContainerInterface)", correct: false }
    help: |
      The `context`, `request`, and `params` variables are directly available in routing conditions.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: >
      Which built-in functions are available for use within Symfony's routing condition expressions?
    answers:
      - { value: "`env(string $name)`: Returns the value of an environment variable.", correct: true }
      - { value: "`service(string $alias)`: Returns a routing condition service.", correct: true }
      - { value: "`param(string $name)`: Returns the value of a configuration parameter.", correct: false }
      - { value: "`is_granted(string $attribute, mixed $subject)`: Checks if the user has a specific role or permission.", correct: false }
    help: |
      The `env()` and `service()` functions are specifically designed for use in routing conditions.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: |
      How do you define a route `/submit` that only accepts POST requests using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/submit', name: 'form_submit', methods: ['POST'])]\npublic function submit(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/submit', name: 'form_submit', allow_methods: ['POST'])]\npublic function submit(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/submit', name: 'form_submit', http_method: 'POST')]\npublic function submit(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/submit', name: 'form_submit', request_method: 'POST')]\npublic function submit(): Response {}\n```", correct: false }
    help: |
      The `methods` option in the `#[Route]` attribute specifies the allowed HTTP methods for a route.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: |
      In YAML, how do you configure a route `api_data` for `/api/data` to only respond to GET and PUT requests?
    answers:
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    methods: [GET, PUT]\n```", correct: true }
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    http_methods: [GET, PUT]\n```", correct: false }
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    allow_methods: [GET, PUT]\n```", correct: false }
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    verbs: [GET, PUT]\n```", correct: false }
    help: |
      The `methods` key in YAML is used to specify the allowed HTTP methods for a route.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      Which of the following is NOT a common way Symfony guesses the user's locale for routing?
    answers:
      - { value: "From a `_locale` route parameter.", correct: false }
      - { value: "From the `Accept-Language` HTTP header.", correct: false }
      - { value: "From the user's browser default font settings.", correct: true }
      - { value: "From the session.", correct: false }
    help: |
      Symfony primarily uses the `_locale` route parameter, `Accept-Language` header, and session to determine the locale. Browser font settings are irrelevant to locale guessing.
      https://symfony.com/doc/current/translation/locale.html#the-locale-and-the-url

  -
    question: >
      When generating a URL for a localized route, if you want to explicitly specify a locale different from the current request's locale, which parameter should you pass to `generateUrl()`?
    answers:
      - { value: "`_locale`", correct: true }
      - { value: "`locale`", correct: false }
      - { value: "`lang`", correct: false }
      - { value: "`language`", correct: false }
    help: |
      The `_locale` parameter is a special route parameter used to explicitly set the locale for URL generation.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which command-line tool is used to list all registered routes in a Symfony application?
    answers:
      - { value: "`php bin/console debug:router`", correct: true }
      - { value: "`php bin/console router:list`", correct: false }
      - { value: "`php bin/console app:routes`", correct: false }
      - { value: "`php bin/console show:routes`", correct: false }
    help: |
      The `debug:router` command provides a comprehensive list of all defined routes.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      To display detailed information for a specific route named `product_show`, which command would you use?
    answers:
      - { value: "`php bin/console debug:router product_show`", correct: true }
      - { value: "`php bin/console router:show product_show`", correct: false }
      - { value: "`php bin/console route:info product_show`", correct: false }
      - { value: "`php bin/console debug:route product_show`", correct: false }
    help: |
      Passing the route name as an argument to `debug:router` displays its specific details.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      Which option can be used with `php bin/console debug:router` to filter the displayed routes by a specific HTTP method, for example, to see only GET routes?
    answers:
      - { value: "`--method=GET`", correct: true }
      - { value: "`--http-method=GET`", correct: false }
      - { value: "`--filter-method=GET`", correct: false }
      - { value: "`--get-only`", correct: false }
    help: |
      The `--method` option allows filtering routes by their associated HTTP method.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      You are debugging a routing issue and want to see which route Symfony matches for a given URL, for example, `/lucky/number/8`. Which command helps you with this?
    answers:
      - { value: "`php bin/console router:match /lucky/number/8`", correct: true }
      - { value: "`php bin/console debug:url /lucky/number/8`", correct: false }
      - { value: "`php bin/console route:test /lucky/number/8`", correct: false }
      - { value: "`php bin/console match:route /lucky/number/8`", correct: false }
    help: |
      The `router:match` command is specifically designed to determine which route matches a given URL path.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      You attempt to generate a URL for a route `blog_show` which has a required `slug` parameter, but you forget to provide the `slug`. What common error message would you expect from Symfony?
    answers:
      - { value: "Some mandatory parameters are missing (\"slug\") to generate a URL for route \"blog_show\".", correct: true }
      - { value: "The route \"blog_show\" requires a \"slug\" parameter, which was not provided.", correct: false }
      - { value: "Cannot generate URL for route \"blog_show\": missing required argument \"slug\".", correct: false }
      - { value: "Invalid arguments for route \"blog_show\": \"slug\" is required.", correct: false }
    help: |
      Symfony provides clear error messages when mandatory route parameters are missing during URL generation.
      https://symfony.com/doc/current/routing.html#troubleshooting

  -
    question: >
      If a controller method `App\Controller\BlogController::show()` expects a `$slug` argument, but the matched route's path does not define a `{slug}` parameter, what kind of error message would Symfony typically show?
    answers:
      - { value: "Controller \"App\\Controller\\BlogController::show()\" requires that you provide a value for the \"$slug\" argument.", correct: true }
      - { value: "Missing argument 1 for App\\Controller\\BlogController::show().", correct: false }
      - { value: "Undefined parameter \"slug\" for controller \"App\\Controller\\BlogController::show()\".", correct: false }
      - { value: "Route mismatch: controller expects \"slug\" but route does not provide it.", correct: false }
    help: |
      Symfony's routing and controller resolver provide specific error messages when there's a mismatch between expected controller arguments and available route parameters.
      https://symfony.com/doc/current/routing.html#troubleshooting

  -
    question: >
      Which of the following describes the purpose of the `priority` option in Symfony routing?
    answers:
      - { value: "It defines the order in which routes are evaluated; higher priority routes are matched first.", correct: true }
      - { value: "It determines the HTTP status code returned for the route.", correct: false }
      - { value: "It specifies the security level required to access the route.", correct: false }
      - { value: "It sets the cache lifetime for the route's response.", correct: false }
    help: |
      The `priority` option is crucial for resolving conflicts between routes, especially when dealing with greedy patterns. Routes with higher priority are checked first.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: |
      Given two routes:
      1. `#[Route('/blog/{slug}', name: 'blog_show')]`
      2. `#[Route('/blog/list', name: 'blog_list')]`
      If `/blog/list` is requested, which route will Symfony match by default and why?
    answers:
      - { value: "`blog_show` because `{slug}` is a greedy pattern and it's defined first.", correct: true }
      - { value: "`blog_list` because it's a more specific static path.", correct: false }
      - { value: "It's ambiguous, Symfony will throw an error.", correct: false }
      - { value: "`blog_show` because it has a higher default priority.", correct: false }
    help: |
      Without explicit `priority` settings, greedy patterns like `{slug}` can match more specific static paths if they are defined earlier.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      How can you ensure that the `blog_list` route in the previous example (`/blog/list`) is matched before `blog_show` (`/blog/{slug}`)?
    answers:
      - { value: "Assign a higher `priority` value to `blog_list` (e.g., `priority: 1` or `priority: 2`).", correct: true }
      - { value: "Define `blog_list` before `blog_show` in the routing configuration.", correct: false }
      - { value: "Add a `requirements` constraint to `blog_list` to make it more specific.", correct: false }
      - { value: "Use a different HTTP method for `blog_list`.", correct: false }
    help: |
      Explicitly setting a higher `priority` for the more specific route ensures it is evaluated before more general (greedy) routes.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file using `RoutingConfigurator`?
    answers:
      - { value: "```php\n$routes->add('blog_list', '/blog')\n    ->controller([BlogController::class, 'list']);\n```", correct: true }
      - { value: "```php\n$routes->route('blog_list', '/blog')\n    ->to(BlogController::class, 'list');\n```", correct: false }
      - { value: "```php\n$routes->define('blog_list', '/blog')\n    ->action(BlogController::class, 'list');\n```", correct: false }
      - { value: "```php\n$routes->set('blog_list', '/blog')\n    ->handler(BlogController::class, 'list');\n```", correct: false }
    help: |
      The `add()` method of `RoutingConfigurator` is used to define a new route, followed by `controller()` to specify the target.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      When defining a route in a PHP configuration file, if the controller action is implemented as the `__invoke()` method of the controller class, how can you specify the controller?
    answers:
      - { value: "By passing only the controller class name: `->controller(BlogController::class)`", correct: true }
      - { value: "By passing the class name and `__invoke`: `->controller([BlogController::class, '__invoke'])`", correct: false }
      - { value: "By passing the class name with a special suffix: `->controller('App\\Controller\\BlogController::invoke')`", correct: false }
      - { value: "You cannot use `__invoke()` with PHP routing configurators.", correct: false }
    help: |
      If a controller implements `__invoke()`, you can simply provide the class name as the controller.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      What is the recommended way to check if a route exists in Symfony without negatively impacting performance by regenerating the routing cache?
    answers:
      - { value: "Attempt to generate the URL and catch `Symfony\\Component\\Routing\\Exception\\RouteNotFoundException`.", correct: true }
      - { value: "Call `$router->getRouteCollection()->has('route_name')`.", correct: false }
      - { value: "Use `$router->match('url_path')` in a try-catch block.", correct: false }
      - { value: "Check if the route is defined in `config/routes.yaml` directly.", correct: false }
    help: |
      Generating a URL and catching the `RouteNotFoundException` is the most performant way to check for route existence, as it leverages the compiled router.
      https://symfony.com/doc/current/routing.html#checking-for-route-existence

  -
    question: >
      Which of the following is NOT a valid way to define a route alias in Symfony 7?
    answers:
      - { value: "Using the `alias` option in the `#[Route]` attribute.", correct: false }
      - { value: "Using the `alias` key in YAML route definition.", correct: false }
      - { value: "Using the `alias()` method on `RoutingConfigurator` in PHP.", correct: false }
      - { value: "Using the `#[Alias]` attribute on a controller method.", correct: true }
    help: |
      Symfony 7 supports route aliases via the `alias` option in `#[Route]`, the `alias` key in YAML, and the `alias()` method in PHP configurator. There is no `#[Alias]` attribute.
      https://symfony.com/doc/current/routing.html#route-aliases

  -
    question: >
      When deprecating a route alias in Symfony, what information can be provided in the deprecation configuration (e.g., `DeprecatedAlias` attribute or `deprecated` key in YAML)?
    answers:
      - { value: "The `package` name and `version` of the package introducing the deprecation.", correct: true }
      - { value: "A custom `message` for the deprecation, optionally using the `%alias_id%` placeholder.", correct: true }
      - { value: "The date when the alias will be removed.", correct: false }
      - { value: "A list of alternative route names.", correct: false }
    help: |
      Deprecation configuration allows specifying the package, version, and a custom message for the deprecation warning.
      https://symfony.com/doc/current/routing.html#deprecating-route-aliases

  -
    question: >
      To apply an HTTPS scheme requirement to an entire group of imported routes (e.g., all routes from `src/Controller/`), which PHP configurator method would you use?
    answers:
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->schemes(['https']);\n```", correct: true }
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->requireScheme('https');\n```", correct: false }
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->forceHttps();\n```", correct: false }
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->setScheme('https');\n```", correct: false }
    help: |
      The `schemes()` method on an imported route collection allows setting scheme requirements for all routes within that group.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: |
      Which YAML configuration correctly applies an HTTPS scheme requirement to all routes imported from `src/Controller/`?
    answers:
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    schemes: [https]\n```", correct: true }
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    scheme: https\n```", correct: false }
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    security: https\n```", correct: false }
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    force_https: true\n```", correct: false }
    help: |
      In YAML, the `schemes` key is used to define scheme requirements for imported routes.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      When importing routes from a directory using PHP attributes, how can you exclude specific files or subdirectories (e.g., `Debug*Controller.php`) from being loaded?
    answers:
      - { value: "By providing an `exclude` option as a string or array of PHP glob patterns to the `import()` method.", correct: true }
      - { value: "By adding a `#[NoRoute]` attribute to the excluded controller classes.", correct: false }
      - { value: "By configuring a `blacklist` option in the routing configuration.", correct: false }
      - { value: "By manually specifying each controller to include, instead of importing the directory.", correct: false }
    help: |
      The `import()` method supports an optional fourth argument for `exclude` patterns.
      https://symfony.com/doc/current/routing.html#excluding-files-or-subdirectories

  -
    question: >
      Which of the following is a valid way to define a route group with a common URL prefix `/admin` and a name prefix `admin_` for all routes within a controller using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/admin', name: 'admin_')]\nclass AdminController extends AbstractController {}\n```", correct: true }
      - { value: "```php\n#[RouteGroup('/admin', namePrefix: 'admin_')]\nclass AdminController extends AbstractController {}\n```", correct: false }
      - { value: "```php\n#[Prefix('/admin'), NamePrefix('admin_')]\nclass AdminController extends AbstractController {}\n```", correct: false }
      - { value: "```php\n#[Route(path: '/admin', id_prefix: 'admin_')]\nclass AdminController extends AbstractController {}\n```", correct: false }
    help: |
      The `#[Route]` attribute can be applied to a controller class to define common options like `path` (prefix) and `name` (prefix) for all routes within that controller.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: |
      In YAML, how do you configure a route group for imported routes, applying a URL prefix `/api` and a name prefix `api_`?
    answers:
      - { value: "```yaml\napi_routes:\n    resource: '../../src/Controller/'\n    type: attribute\n    prefix: /api\n    name_prefix: api_\n```", correct: true }
      - { value: "```yaml\napi_routes:\n    path: /api\n    name: api_\n    import: '../../src/Controller/'\n    type: attribute\n```", correct: false }
      - { value: "```yaml\napi_routes:\n    group:\n        prefix: /api\n        name_prefix: api_\n    resource: '../../src/Controller/'\n    type: attribute\n```", correct: false }
      - { value: "```yaml\napi_routes:\n    resource: '../../src/Controller/'\n    type: attribute\n    url_prefix: /api\n    route_name_prefix: api_\n```", correct: false }
    help: |
      The `prefix` and `name_prefix` options are used directly under the import definition in YAML to group routes.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      You have a route `/products/{id}`. If you want to ensure the `id` parameter is always a positive integer, which requirement would you use in PHP attributes?
    answers:
      - { value: "```php\n#[Route('/products/{id}', name: 'product_detail', requirements: ['id' => '\\d+'])]\npublic function detail(int $id): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/products/{id<[1-9]\\d*>}', name: 'product_detail')]\npublic function detail(int $id): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/products/{id}', name: 'product_detail', validate: ['id' => 'positive_int'])]\npublic function detail(int $id): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/products/{id}', name: 'product_detail', constraints: ['id' => 'int > 0'])]\npublic function detail(int $id): Response {}\n```", correct: false }
    help: |
      Regular expressions are used to define parameter requirements. `\\d+` matches one or more digits.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary benefit of using `#[Route]` attributes on controller classes for grouping routes?
    answers:
      - { value: "It allows applying common URL prefixes, name prefixes, and requirements to multiple routes within that controller.", correct: true }
      - { value: "It automatically generates a sitemap for all routes in the controller.", correct: false }
      - { value: "It enables lazy loading of controllers, improving performance.", correct: false }
      - { value: "It restricts access to the controller based on user roles.", correct: false }
    help: |
      Class-level `#[Route]` attributes provide a convenient way to define shared configuration for a group of routes.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      When defining a route with a parameter like `/users/{username}`, what happens if the `username` parameter is not provided in the URL and no default value is set?
    answers:
      - { value: "Symfony will throw a `ResourceNotFoundException`.", correct: true }
      - { value: "The `username` parameter will be `null` in the controller.", correct: false }
      - { value: "Symfony will attempt to guess the `username` from the request context.", correct: false }
      - { value: "The route will simply not match.", correct: true }
    help: |
      If a required parameter is missing and no default is provided, the route will not match, leading to a 404 Not Found error.
      https://symfony.com/doc/current/routing.html#route-parameters

  -
    question: >
      Which of the following is a valid way to define a route in a Symfony application using PHP attributes that is only active in the `dev` environment?
    answers:
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', env: 'dev')]\npublic function debugTools(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', environments: ['dev'])]\npublic function debugTools(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', if_env: 'dev')]\npublic function debugTools(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', condition: \"kernel.environment == 'dev'\")]\npublic function debugTools(): Response {}\n```", correct: false }
    help: |
      The `env` option in the `#[Route]` attribute allows restricting a route to specific environments.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the purpose of the `_fragment` special route parameter?
    answers:
      - { value: "It is used to set the fragment identifier (the part of a URL starting with `#`) for a generated URL.", correct: true }
      - { value: "It defines a partial view or component to be rendered.", correct: false }
      - { value: "It specifies a section within a document to scroll to.", correct: false }
      - { value: "It's an internal parameter for caching route fragments.", correct: false }
    help: |
      The `_fragment` parameter is used when generating URLs to include a hash fragment.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      When generating a URL, if you provide extra parameters that are not defined in the route's path, how does Symfony handle them?
    answers:
      - { value: "They are added as query parameters to the generated URL.", correct: true }
      - { value: "They are ignored.", correct: false }
      - { value: "They cause an error if not explicitly allowed by the route.", correct: false }
      - { value: "They are appended as path segments after the route.", correct: false }
    help: |
      Any parameters passed to `generateUrl()` that are not part of the route's path will be appended as query string parameters.
      https://symfony.com/doc/current/routing.html#extra-parameters-in-urls

  -
    question: >
      What is the significance of the `UrlGeneratorInterface::ABSOLUTE_PATH` constant when generating URLs in Symfony?
    answers:
      - { value: "It generates a URL relative to the web root, starting with a slash (e.g., `/blog/post`).", correct: true }
      - { value: "It generates a full URL including the scheme and host (e.g., `http://example.com/blog/post`).", correct: false }
      - { value: "It generates a URL relative to the current page (e.g., `../post`).", correct: false }
      - { value: "It generates a URL that is always absolute, regardless of the current request.", correct: false }
    help: |
      `ABSOLUTE_PATH` is the default behavior for `generateUrl()` and produces URLs like `/path/to/resource`.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which of the following is true about the order of route matching in Symfony?
    answers:
      - { value: "Routes are matched in the order they are defined in the configuration, unless `priority` is explicitly set.", correct: true }
      - { value: "Routes with more specific patterns are always matched before more general patterns, regardless of definition order.", correct: false }
      - { value: "Routes defined in PHP attributes are always matched before routes defined in YAML.", correct: false }
      - { value: "Symfony uses a randomized algorithm to determine route matching order.", correct: false }
    help: |
      The order of route definition matters, but the `priority` option can override this default behavior.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      When importing routes from a controller directory, how can you apply locale-specific URL prefixes (e.g., `/en/` for English, `/nl/` for Dutch)?
    answers:
      - { value: "By providing a map of locales to prefixes in the `prefix` option of the import configuration.", correct: true }
      - { value: "By defining separate import statements for each locale with a fixed prefix.", correct: false }
      - { value: "By using the `#[LocalePrefix]` attribute on the controller classes.", correct: false }
      - { value: "Symfony automatically handles locale prefixes based on the `_locale` parameter.", correct: false }
    help: |
      The `prefix` option for imported routes can accept an associative array mapping locales to their respective prefixes.
      https://symfony.com/doc/current/routing.html#prefixing-routes-based-on-locale

  -
    question: >
      What is the purpose of the `UrlMatcher` class in the Symfony Routing component?
    answers:
      - { value: "To match an incoming request URL path against a collection of defined routes.", correct: true }
      - { value: "To generate URLs based on route names and parameters.", correct: false }
      - { value: "To load route definitions from configuration files.", correct: false }
      - { value: "To validate route parameters against their requirements.", correct: false }
    help: |
      `UrlMatcher` is responsible for finding the best-matching route for a given URL.
      https://symfony.com/doc/current/create_framework/routing.html#matching-urls

  -
    question: >
      Which class represents a single route definition in the Symfony Routing component?
    answers:
      - { value: "`Symfony\\Component\\Routing\\Route`", correct: true }
      - { value: "`Symfony\\Component\\Routing\\RouteDefinition`", correct: false }
      - { value: "`Symfony\\Component\\HttpFoundation\\Route`", correct: false }
      - { value: "`Symfony\\Component\\Routing\\UrlRoute`", correct: false }
    help: |
      The `Route` class encapsulates all information about a single route, including its path, requirements, and defaults.
      https://symfony.com/doc/current/routing/custom_route_loader.html#the-routing-component-api

  -
    question: >
      What is the role of `Symfony\\Component\\Routing\\RouteCollection`?
    answers:
      - { value: "It is a collection of `Route` objects, representing all defined routes in an application.", correct: true }
      - { value: "It's a database table that stores route configurations.", correct: false }
      - { value: "It's an interface for loading routes from various sources.", correct: false }
      - { value: "It's a service that manages route caching.", correct: false }
    help: |
      `RouteCollection` aggregates multiple `Route` objects, forming the complete routing map.
      https://symfony.com/doc/current/routing/custom_route_loader.html#the-routing-component-api

  -
    question: >
      When using `router:match` to debug a URL, what information does the command typically output if a match is found?
    answers:
      - { value: "The matched route name, controller, and parameters.", correct: true }
      - { value: "The generated URL for the matched route.", correct: false }
      - { value: "A list of all routes that partially match the URL.", correct: false }
      - { value: "Only the HTTP status code for the URL.", correct: false }
    help: |
      `router:match` provides details about the matched route, including its name and the values of its parameters.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the purpose of the `RequestContext` class in Symfony's Routing component?
    answers:
      - { value: "It holds fundamental information about the current request, such as the HTTP method, host, and base URL, which is used by the `UrlMatcher`.", correct: true }
      - { value: "It stores user session data for routing decisions.", correct: false }
      - { value: "It defines the security context for route access.", correct: false }
      - { value: "It's a container for all route parameters.", correct: false }
    help: |
      `RequestContext` provides the necessary context for the router to match incoming requests.
      https://symfony.com/doc/current/create_framework/routing.html#matching-urls

  -
    question: >
      Which of the following is a valid way to define a route in YAML that only accepts `GET` requests?
    answers:
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    methods: [GET]\n```", correct: true }
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    method: GET\n```", correct: false }
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    http_method: GET\n```", correct: false }
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    request_method: GET\n```", correct: false }
    help: |
      The `methods` key in YAML is used to specify allowed HTTP methods as a list.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      When defining a route using PHP attributes, how can you specify that it should match both `GET` and `POST` requests?
    answers:
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', methods: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', method: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', http_methods: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', verbs: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: false }
    help: |
      The `methods` option in `#[Route]` accepts an array of HTTP method strings.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      What is the default HTTP status code for a temporary redirect configured with Symfony's `RedirectController` without `keepRequestMethod: true`?
    answers:
      - { value: "302 (Found)", correct: true }
      - { value: "307 (Temporary Redirect)", correct: false }
      - { value: "301 (Moved Permanently)", correct: false }
      - { value: "303 (See Other)", correct: false }
    help: |
      By default, temporary redirects use the 302 status code.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      If you have a route `/articles/{_locale}/show` and you want to ensure `_locale` is always `en` or `fr`, which requirement would you add in YAML?
    answers:
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    requirements:\n        _locale: 'en|fr'\n```", correct: true }
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    locale_options: 'en|fr'\n```", correct: false }
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    constraints:\n        _locale: 'en|fr'\n```", correct: false }
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    locale_regex: 'en|fr'\n```", correct: false }
    help: |
      Requirements for special parameters like `_locale` are defined under the `requirements` key.
      https://symfony.com/doc/current/routing.html#configuring-special-route-parameters

  -
    question: >
      What happens if a route's `condition` expression evaluates to `false`?
    answers:
      - { value: "The route will not be matched, and Symfony will continue to try matching other routes.", correct: true }
      - { value: "Symfony will throw a `ConditionNotMetException`.", correct: false }
      - { value: "The controller associated with the route will still be executed, but with a warning.", correct: false }
      - { value: "The application will return a 403 Forbidden response.", correct: false }
    help: |
      Conditions act as additional filters. If a condition is not met, the route is effectively skipped during the matching process.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: >
      Which command would you use to list all routes, including their aliases?
    answers:
      - { value: "`php bin/console debug:router --show-aliases`", correct: true }
      - { value: "`php bin/console debug:router --with-aliases`", correct: false }
      - { value: "`php bin/console router:list-all`", correct: false }
      - { value: "`php bin/console debug:router --aliases`", correct: false }
    help: |
      The `--show-aliases` option explicitly includes route aliases in the `debug:router` output.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the primary benefit of using `#[AsRoutingConditionService]` for custom routing conditions?
    answers:
      - { value: "It allows you to define complex, reusable routing logic as a service that can be injected and used in `condition` expressions.", correct: true }
      - { value: "It automatically caches the results of the condition, improving performance.", correct: false }
      - { value: "It enables the condition to be evaluated on the client-side.", correct: false }
      - { value: "It provides a graphical interface for building routing conditions.", correct: false }
    help: |
      Custom routing condition services allow encapsulating complex logic, making conditions cleaner and more maintainable.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: >
      Consider a route `/articles/{year}/{title}.{_format}`. If you access `/articles/2023/my-post.html`, what will be the value of the `_format` parameter in the controller?
    answers:
      - { value: "`html`", correct: true }
      - { value: "`null`", correct: false }
      - { value: "An empty string.", correct: false }
      - { value: "The default format configured for the application.", correct: false }
    help: |
      The `_format` parameter automatically captures the extension part of the URL.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      Which of the following is true regarding route parameters and their corresponding controller arguments?
    answers:
      - { value: "The name of the route parameter in the path must exactly match the name of the argument in the controller method.", correct: true }
      - { value: "Route parameters are automatically type-hinted in the controller based on their requirements.", correct: false }
      - { value: "Controller arguments can be named differently from route parameters, as long as their order matches.", correct: false }
      - { value: "Only scalar types can be used for controller arguments that correspond to route parameters.", correct: false }
    help: |
      For Symfony to automatically inject route parameters into controller arguments, their names must match.
      https://symfony.com/doc/current/routing.html#route-parameters-in-controllers

  -
    question: >
      What is the purpose of the `UrlGenerator` class in the Symfony Routing component?
    answers:
      - { value: "To generate URLs based on a given route name and parameters.", correct: true }
      - { value: "To match incoming URLs to routes.", correct: false }
      - { value: "To load route definitions from various sources.", correct: false }
      - { value: "To compile the routing cache.", correct: false }
    help: |
      `UrlGenerator` is the counterpart to `UrlMatcher`, handling the creation of URLs from route definitions.
      https://symfony.com/doc/current/create_framework/routing.html#generating-urls

  -
    question: >
      When generating a URL for a route with a dynamic host parameter (e.g., `{subdomain}.example.com`), how do you provide the value for the `subdomain`?
    answers:
      - { value: "By passing it as a regular parameter in the `generateUrl()` method's arguments array.", correct: true }
      - { value: "By setting it in the `RequestContext` before generating the URL.", correct: false }
      - { value: "By defining it as a default value in the route configuration.", correct: false }
      - { value: "It's automatically inferred from the current request's host.", correct: false }
    help: |
      Dynamic host parameters are treated like regular route parameters when generating URLs.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file that only accepts `GET` requests?
    answers:
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->methods(['GET']);\n```", correct: true }
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->method('GET');\n```", correct: false }
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->allowMethods('GET');\n```", correct: false }
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->httpMethod('GET');\n```", correct: false }
    help: |
      The `methods()` method on the route configurator is used to specify allowed HTTP methods.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      What is the primary function of the `router:debug` command (alias for `debug:router`)?
    answers:
      - { value: "To inspect and troubleshoot the routing configuration of a Symfony application.", correct: true }
      - { value: "To generate a visual graph of all routes.", correct: false }
      - { value: "To clear the routing cache.", correct: false }
      - { value: "To test the performance of route matching.", correct: false }
    help: |
      The `debug:router` command is the main tool for understanding and debugging Symfony's routing system.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      If you define a route `/blog/{page}` and then a route `/blog/new`, and both are configured with PHP attributes in the same controller, what is the default matching behavior if `/blog/new` is requested?
    answers:
      - { value: "The route `/blog/{page}` will be matched first if it's defined before `/blog/new` due to its greedy nature, with `page` being `new`.", correct: true }
      - { value: "The route `/blog/new` will always be matched because it's more specific.", correct: false }
      - { value: "Symfony will throw an ambiguity error.", correct: false }
      - { value: "The route `/blog/{page}` will be matched, but `page` will be `null`.", correct: false }
    help: |
      Without explicit priority, greedy patterns can "eat" more specific paths if defined earlier.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `name` option?
    answers:
      - { value: "To provide a unique identifier for the route, used for URL generation and referencing.", correct: true }
      - { value: "To define the URL path for the route.", correct: false }
      - { value: "To specify the controller method that handles the route.", correct: false }
      - { value: "To set the title displayed in the browser tab for the route.", correct: false }
    help: |
      The `name` option is essential for generating URLs and referring to routes programmatically.
      https://symfony.com/doc/current/routing.html#defining-routes-as-php-attributes

  -
    question: >
      Which of the following describes a scenario where `UrlGeneratorInterface::ABSOLUTE_URL` would be most appropriate for generating a URL?
    answers:
      - { value: "Generating a link in an email or an RSS feed where the full domain is required.", correct: true }
      - { value: "Generating a link within the same Symfony application to navigate between pages.", correct: false }
      - { value: "Generating a path for an asset (e.g., an image) within a Twig template.", correct: false }
      - { value: "Generating a URL for a console command.", correct: false }
    help: |
      `ABSOLUTE_URL` is used when the generated URL needs to be fully qualified with the scheme and host.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      What is the impact of marking a route as `stateless: true`?
    answers:
      - { value: "It prevents Symfony from starting or using a session for requests matching this route, which can improve caching.", correct: true }
      - { value: "It makes the route accessible without any authentication or authorization.", correct: false }
      - { value: "It forces the route to use HTTP/2 protocol.", correct: false }
      - { value: "It disables all logging for requests to this route.", correct: false }
    help: |
      Stateless routes are optimized for caching by ensuring no session-related headers are sent.
      https://symfony.com/doc/current/routing.html#stateless-routes

  -
    question: >
      If you have a route `/articles/{year}/{slug}` and you want to ensure `year` is a 4-digit number and `slug` contains only lowercase letters, numbers, and hyphens, how would you configure this in PHP attributes?
    answers:
      - { value: "```php\n#[Route('/articles/{year}/{slug}', name: 'article_show', requirements: ['year' => '\\d{4}', 'slug' => '[a-z0-9-]+'])]\npublic function show(int $year, string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/articles/{year<\\d{4}>}/{slug<[a-z0-9-]+>}', name: 'article_show')]\npublic function show(int $year, string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/articles/{year}/{slug}', name: 'article_show', regex: ['year' => '\\d{4}', 'slug' => '[a-z0-9-]+'])]\npublic function show(int $year, string $slug): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/articles/{year}/{slug}', name: 'article_show', types: ['year' => 'int:4', 'slug' => 'slug_string'])]\npublic function show(int $year, string $slug): Response {}\n```", correct: false }
    help: |
      Multiple requirements can be defined for different parameters within the `requirements` option or inline.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary benefit of using `RoutingConfigurator` in PHP files for defining routes compared to YAML or XML?
    answers:
      - { value: "It provides a fluent interface for defining routes programmatically, allowing for more complex logic and dynamic route generation.", correct: true }
      - { value: "It is the only way to define routes that use PHP attributes.", correct: false }
      - { value: "It offers better performance due to direct PHP execution without parsing.", correct: false }
      - { value: "It allows defining routes that are not tied to specific controllers.", correct: false }
    help: |
      The PHP routing configurator offers a powerful and flexible way to define routes with programmatic control.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      When debugging routing, what does the `router:match` command tell you if a URL does NOT match any defined route?
    answers:
      - { value: "It will indicate that no route was found for the given path.", correct: true }
      - { value: "It will suggest alternative routes that are similar to the provided URL.", correct: false }
      - { value: "It will list all routes that were attempted but failed to match.", correct: false }
      - { value: "It will return a 404 HTTP status code.", correct: false }
    help: |
      If no route matches, `router:match` will explicitly state that no route was found.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `host` option?
    answers:
      - { value: "To restrict the route to match only requests coming from a specific hostname or a pattern of hostnames.", correct: true }
      - { value: "To define the default host for generated URLs.", correct: false }
      - { value: "To specify the server IP address where the route is hosted.", correct: false }
      - { value: "To set the virtual host configuration for the web server.", correct: false }
    help: |
      The `host` option enables host-based routing, allowing different routes for different domains or subdomains.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: >
      Which of the following is true about route requirements in Symfony?
    answers:
      - { value: "They are regular expressions used to validate the format of route parameters.", correct: true }
      - { value: "They define the minimum and maximum length of route parameters.", correct: false }
      - { value: "They specify the data type of route parameters (e.g., string, int).", correct: false }
      - { value: "They are used to define default values for optional route parameters.", correct: false }
    help: |
      Requirements are powerful tools for ensuring that route parameters conform to expected patterns.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::RELATIVE_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the current request's path (e.g., `../sibling-page`).", correct: true }
      - { value: "It generates a URL relative to the web root, starting with a slash (e.g., `/blog/post`).", correct: false }
      - { value: "It generates a full URL including the scheme and host.", correct: false }
      - { value: "It is an alias for `ABSOLUTE_PATH`.", correct: false }
    help: |
      `RELATIVE_PATH` is useful for generating URLs that are relative to the current location, often for internal navigation.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When defining a route with a parameter, what is the significance of the `<` and `>` characters in the path (e.g., `/blog/{page<\\d+>}`)?
    answers:
      - { value: "They are used to embed inline regular expression requirements for the parameter.", correct: true }
      - { value: "They indicate that the parameter is optional.", correct: false }
      - { value: "They define the default value for the parameter.", correct: false }
      - { value: "They are used for type hinting the parameter in the controller.", correct: false }
    help: |
      Inline requirements provide a concise way to define regular expressions directly within the route path.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary purpose of the `#[Route]` attribute's `schemes` option?
    answers:
      - { value: "To restrict the route to match only requests using specific URL schemes (e.g., `http`, `https`).", correct: true }
      - { value: "To define the default scheme for generated URLs.", correct: false }
      - { value: "To specify the security protocols allowed for the route.", correct: false }
      - { value: "To enable or disable HTTP/2 for the route.", correct: false }
    help: |
      The `schemes` option ensures that a route is only matched if the request uses one of the specified schemes.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      Which of the following is a valid way to define a route in YAML that only accepts HTTPS requests?
    answers:
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    schemes: [https]\n```", correct: true }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    scheme: https\n```", correct: false }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    secure: true\n```", correct: false }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    protocol: https\n```", correct: false }
    help: |
      The `schemes` key in YAML is used to define scheme requirements as a list.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      What is the main advantage of using route aliases in Symfony?
    answers:
      - { value: "To provide backward compatibility when route names change, allowing old names to still work.", correct: true }
      - { value: "To create multiple URLs for the same route, improving SEO.", correct: false }
      - { value: "To define routes that can be accessed without a controller.", correct: false }
      - { value: "To simplify the process of generating localized URLs.", correct: false }
    help: |
      Route aliases are primarily used for smooth transitions when refactoring route names.
      https://symfony.com/doc/current/routing.html#route-aliases

  -
    question: >
      When defining a route with a `condition` using Expression Language, how can you access a configuration parameter named `app.allowed_browsers`?
    answers:
      - { value: "By using `'%app.allowed_browsers%'` directly in the expression.", correct: true }
      - { value: "By using `parameter('app.allowed_browsers')` in the expression.", correct: false }
      - { value: "By injecting the parameter into the controller and then using it in the condition.", correct: false }
      - { value: "Configuration parameters are not accessible in routing conditions.", correct: false }
    help: |
      Configuration parameters can be directly embedded in Expression Language conditions using the `%parameter_name%` syntax.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `defaults` option?
    answers:
      - { value: "To set default values for route parameters if they are not provided in the URL.", correct: true }
      - { value: "To define default HTTP methods for the route.", correct: false }
      - { value: "To specify default values for query parameters.", correct: false }
      - { value: "To set the default controller and action for the route.", correct: false }
    help: |
      The `defaults` option makes route parameters optional and provides fallback values.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: >
      Which of the following describes the `_route_params` attribute available on the `Request` object?
    answers:
      - { value: "An array containing all matched route parameters for the current request.", correct: true }
      - { value: "A string representing the current route's path.", correct: false }
      - { value: "The name of the currently matched route.", correct: false }
      - { value: "A collection of all query parameters from the request.", correct: false }
    help: |
      The `_route_params` attribute provides programmatic access to the values of the parameters that were matched by the router.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the primary purpose of the `_route` attribute available on the `Request` object?
    answers:
      - { value: "It holds the name of the currently matched route.", correct: true }
      - { value: "It contains the full URL of the current request.", correct: false }
      - { value: "It stores the controller and action executed for the current request.", correct: false }
      - { value: "It provides access to the routing configuration.", correct: false }
    help: |
      The `_route` attribute is a convenient way to get the name of the route that was successfully matched.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the main benefit of organizing routes into groups using prefixes and name prefixes?
    answers:
      - { value: "It improves the readability and maintainability of routing configurations, especially for large applications.", correct: true }
      - { value: "It significantly reduces the size of the compiled routing cache.", correct: false }
      - { value: "It enables automatic generation of API documentation.", correct: false }
      - { value: "It enhances security by isolating routes.", correct: false }
    help: |
      Route grouping helps in managing complex routing setups by applying common configurations.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      Which of the following is a valid way to define a route in YAML that is only active in the `prod` environment?
    answers:
      - { value: "```yaml\nprod_route:\n    path: /prod-only\n    controller: App\\Controller\\ProdController::index\n    env: prod\n```", correct: true }
      - { value: "```yaml\nprod_route:\n    path: /prod-only\n    controller: App\\Controller\\ProdController::index\n    environments: [prod]\n```", correct: false }
      - { value: "```yaml\nprod_route:\n    path: /prod-only\n    controller: App\\Controller\\ProdController::index\n    if_env: prod\n```", correct: false }
      - { value: "```yaml\nprod_route:\n    path: /prod-only\n    controller: App\\Controller\\ProdController::index\n    condition: \"kernel.environment == 'prod'\"\n```", correct: false }
    help: |
      The `env` key in YAML is used to restrict a route to a specific environment.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::NETWORK_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the scheme (e.g., `//example.com/blog/post`), useful for avoiding mixed content warnings.", correct: true }
      - { value: "It generates a URL that is only accessible within the local network.", correct: false }
      - { value: "It generates a URL that uses a specific network protocol (e.g., FTP).", correct: false }
      - { value: "It is an alias for `ABSOLUTE_URL` but without the scheme.", correct: false }
    help: |
      `NETWORK_PATH` creates protocol-relative URLs, which adapt to the current scheme (HTTP or HTTPS).
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepQueryParams: true`?
    answers:
      - { value: "It preserves the original query string parameters when redirecting to the target URL or route.", correct: true }
      - { value: "It ensures that the redirect is always a GET request, even if the original was POST.", correct: false }
      - { value: "It appends a unique query parameter to prevent caching of the redirect.", correct: false }
      - { value: "It only redirects if query parameters are present in the original request.", correct: false }
    help: |
      `keepQueryParams: true` is useful for maintaining context across redirects.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following is true about the `UrlMatcher` and `UrlGenerator` in a typical Symfony application?
    answers:
      - { value: "The `UrlMatcher` is used to map incoming requests to routes, while the `UrlGenerator` is used to create URLs from route names.", correct: true }
      - { value: "Both are used for matching incoming requests to routes.", correct: false }
      - { value: "Both are used for generating URLs from route names.", correct: false }
      - { value: "The `UrlMatcher` is for console commands, and `UrlGenerator` is for web requests.", correct: false }
    help: |
      They are complementary components of the routing system, handling the two main aspects: matching and generating.
      https://symfony.com/doc/current/create_framework/routing.html

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `priority` option?
    answers:
      - { value: "To explicitly define the order in which routes are evaluated during the matching process.", correct: true }
      - { value: "To set the importance of the route for caching mechanisms.", correct: false }
      - { value: "To determine the HTTP status code returned by the route.", correct: false }
      - { value: "To specify the minimum PHP version required for the route.", correct: false }
    help: |
      Higher priority routes are checked before lower priority ones, which is essential for resolving route conflicts.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      When defining a route with a dynamic host, such as `{subdomain}.example.com`, what does `{subdomain}` represent?
    answers:
      - { value: "A dynamic parameter that will be captured from the hostname and passed to the controller.", correct: true }
      - { value: "A fixed string literal that must be present in the hostname.", correct: false }
      - { value: "A placeholder for the application's environment variable.", correct: false }
      - { value: "A special keyword that automatically matches any subdomain.", correct: false }
    help: |
      Host parameters work similarly to path parameters, allowing dynamic parts in the hostname.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: >
      What is the primary reason for using `#[Route]` attributes directly on controller methods instead of separate YAML or XML files?
    answers:
      - { value: "It keeps the route definition directly with the code that handles it, improving colocation and discoverability.", correct: true }
      - { value: "It offers significantly better performance than YAML or XML routing.", correct: false }
      - { value: "It is the only way to define routes with conditional logic.", correct: false }
      - { value: "It allows for more complex routing patterns than other formats.", correct: false }
    help: |
      Attribute-based routing is often preferred for its convenience and colocation of concerns.
      https://symfony.com/doc/current/routing.html#defining-routes-as-php-attributes

  -
    question: >
      When configuring a route alias, what is the relationship between the alias and the original route?
    answers:
      - { value: "The alias points to the original route's definition, allowing it to be referenced by multiple names.", correct: true }
      - { value: "The alias creates a duplicate of the original route with a different name.", correct: false }
      - { value: "The alias replaces the original route's name.", correct: false }
      - { value: "The alias is a separate route that redirects to the original route.", correct: false }
    help: |
      An alias is simply an alternative name for an existing route.
      https://symfony.com/doc/current/routing.html#route-aliases

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `condition` option?
    answers:
      - { value: "To define an Expression Language expression that must evaluate to `true` for the route to be matched.", correct: true }
      - { value: "To specify a database condition that must be met for the route to be active.", correct: false }
      - { value: "To set a timeout for the route's execution.", correct: false }
      - { value: "To define a redirect target if the route is not matched.", correct: false }
    help: |
      Conditions allow for highly flexible and dynamic route matching based on various request properties.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: >
      Which of the following is a valid way to define a route in YAML that has a default value for a parameter `page` set to `1`?
    answers:
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    defaults:\n        page: 1\n```", correct: true }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page?1}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    default_page: 1\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    options:\n        page_default: 1\n```", correct: false }
    help: |
      The `defaults` key in YAML is used to set default values for route parameters.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: >
      When debugging routing, what does the `php bin/console debug:router --method=ANY` command do?
    answers:
      - { value: "It displays all routes, regardless of their HTTP method requirements.", correct: true }
      - { value: "It displays only routes that accept any HTTP method.", correct: false }
      - { value: "It displays routes that have no explicit HTTP method requirements.", correct: false }
      - { value: "It displays routes that match the `ANY` method in their definition.", correct: false }
    help: |
      The `ANY` value for the `--method` option acts as a wildcard to show all routes.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::ABSOLUTE_URL` constant when generating URLs?
    answers:
      - { value: "It generates a full URL including the scheme, host, and path (e.g., `https://example.com/blog/post`).", correct: true }
      - { value: "It generates a URL relative to the web root.", correct: false }
      - { value: "It generates a URL that is always absolute, regardless of the current request.", correct: false }
      - { value: "It generates a URL that only works on the production environment.", correct: false }
    help: |
      `ABSOLUTE_URL` is used when a complete, self-contained URL is needed.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file that has a requirement for the `id` parameter to be numeric (`\\d+`)?
    answers:
      - { value: "```php\n$routes->add('product_show', '/product/{id}')\n    ->controller([ProductController::class, 'show'])\n    ->requirements(['id' => '\\d+']);\n```", correct: true }
      - { value: "```php\n$routes->add('product_show', '/product/{id<\\d+>}')\n    ->controller([ProductController::class, 'show']);\n```", correct: true }
      - { value: "```php\n$routes->add('product_show', '/product/{id}')\n    ->controller([ProductController::class, 'show'])\n    ->require('id', '\\d+');\n```", correct: false }
      - { value: "```php\n$routes->add('product_show', '/product/{id}')\n    ->controller([ProductController::class, 'show'])\n    ->pattern('id', '\\d+');\n```", correct: false }
    help: |
      The `requirements()` method or inline regex can be used to define parameter requirements in PHP configurator.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary purpose of the `Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator` class?
    answers:
      - { value: "To provide a fluent API for defining and configuring routes in PHP files.", correct: true }
      - { value: "To load routes from YAML and XML files.", correct: false }
      - { value: "To compile the routing cache for performance optimization.", correct: false }
      - { value: "To match incoming requests to routes.", correct: false }
    help: |
      `RoutingConfigurator` simplifies the process of defining routes programmatically in Symfony.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      When importing routes from a controller directory, how can you apply a common URL prefix `/blog` to all imported routes, ensuring that an imported route with an empty URL becomes `/blog` instead of `/blog/`?
    answers:
      - { value: "By setting `prefix: '/blog'` and `trailing_slash_on_root: false` in the import configuration.", correct: true }
      - { value: "By setting `prefix: '/blog'` and `strip_trailing_slash: true`.", correct: false }
      - { value: "By setting `prefix: '/blog'` and `no_trailing_slash: true`.", correct: false }
      - { value: "By setting `prefix: '/blog'` and `remove_slash_on_root: true`.", correct: false }
    help: |
      The `trailing_slash_on_root: false` option is used to remove the trailing slash for the root of the prefixed group.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      What is the default priority value for a Symfony route if not explicitly set?
    answers:
      - { value: "0", correct: true }
      - { value: "1", correct: false }
      - { value: "null", correct: false }
      - { value: "It depends on the order of definition.", correct: false }
    help: |
      Routes have a default priority of 0, and higher values mean higher priority.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      When using `RedirectController`, what is the effect of setting `keepRequestMethod: true` for a temporary redirect?
    answers:
      - { value: "It changes the redirect status code from 302 to 307, preserving the HTTP method.", correct: true }
      - { value: "It forces the redirect to always be a GET request.", correct: false }
      - { value: "It ensures that the original request body is also sent with the redirect.", correct: false }
      - { value: "It prevents the browser from caching the redirect.", correct: false }
    help: |
      The 307 status code is specifically for temporary redirects that preserve the request method.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following is true about localized routes in Symfony?
    answers:
      - { value: "They allow defining different URL paths for the same route name based on the active locale.", correct: true }
      - { value: "They automatically translate the content of the page based on the route.", correct: false }
      - { value: "They require a separate controller for each locale.", correct: false }
      - { value: "They are only supported when using the `_locale` parameter in the URL.", correct: false }
    help: |
      Localized routes provide flexibility in URL structure for internationalized applications.
      https://symfony.com/doc/current/routing.html#define-localized-routes

  -
    question: >
      What is the purpose of the `env` option in a Symfony route definition (PHP attributes or YAML)?
    answers:
      - { value: "To make the route active only in a specific Symfony environment (e.g., `dev`, `prod`).", correct: true }
      - { value: "To define environment variables that are accessible within the route's controller.", correct: false }
      - { value: "To specify the deployment environment for the route.", correct: false }
      - { value: "To set the default environment for generated URLs.", correct: false }
    help: |
      The `env` option provides fine-grained control over route activation based on the application environment.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file that has a default value for a parameter `name` set to `'Guest'`?
    answers:
      - { value: "```php\n$routes->add('greet', '/greet/{name}')\n    ->controller([AppController::class, 'greet'])\n    ->defaults(['name' => 'Guest']);\n```", correct: true }
      - { value: "```php\n$routes->add('greet', '/greet/{name?Guest}')\n    ->controller([AppController::class, 'greet']);\n```", correct: false }
      - { value: "```php\n$routes->add('greet', '/greet/{name}')\n    ->controller([AppController::class, 'greet'])\n    ->default('name', 'Guest');\n```", correct: false }
      - { value: "```php\n$routes->add('greet', '/greet/{name}')\n    ->controller([AppController::class, 'greet'])\n    ->withDefault('name', 'Guest');\n```", correct: false }
    help: |
      The `defaults()` method on the route configurator is used to set default parameter values.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: >
      What is the primary benefit of using `#[Route]` attributes for routing in Symfony?
    answers:
      - { value: "It allows route definitions to be colocated directly with the controller logic, improving readability and maintainability.", correct: true }
      - { value: "It eliminates the need for a routing cache, improving development speed.", correct: false }
      - { value: "It provides a visual representation of the routing tree.", correct: false }
      - { value: "It automatically generates API documentation from route definitions.", correct: false }
    help: |
      Colocation of route and controller code is a significant advantage of attributes.
      https://symfony.com/doc/current/routing.html#defining-routes-as-php-attributes

  -
    question: >
      When generating a URL, what is the effect of passing an array of parameters to `generateUrl()` that includes both route parameters and extra parameters?
    answers:
      - { value: "Route parameters are used to build the path, and extra parameters are appended as query string parameters.", correct: true }
      - { value: "All parameters are treated as route parameters, and an error occurs if any are not defined in the route path.", correct: false }
      - { value: "Extra parameters are ignored unless explicitly allowed by the route configuration.", correct: false }
      - { value: "The order of parameters in the array determines whether they are treated as route or query parameters.", correct: false }
    help: |
      Symfony intelligently distinguishes between path parameters and query parameters during URL generation.
      https://symfony.com/doc/current/routing.html#extra-parameters-in-urls

  -
    question: >
      Which of the following is a valid way to define a route in YAML that accepts both `GET` and `HEAD` HTTP methods?
    answers:
      - { value: "```yaml\nmy_route:\n    path: /my-resource\n    controller: App\\Controller\\MyController::view\n    methods: [GET, HEAD]\n```", correct: true }
      - { value: "```yaml\nmy_route:\n    path: /my-resource\n    controller: App\\Controller\\MyController::view\n    method: GET|HEAD\n```", correct: false }
      - { value: "```yaml\nmy_route:\n    path: /my-resource\n    controller: App\\Controller\\MyController::view\n    http_methods: [GET, HEAD]\n```", correct: false }
      - { value: "```yaml\nmy_route:\n    path: /my-resource\n    controller: App\\Controller\\MyController::view\n    verbs: [GET, HEAD]\n```", correct: false }
    help: |
      The `methods` key in YAML accepts a list of HTTP methods.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Routing\\RequestContext` class?
    answers:
      - { value: "It encapsulates the necessary information about the current request (e.g., base URL, host, scheme, method) for route matching and URL generation.", correct: true }
      - { value: "It stores the user's security credentials for route access.", correct: false }
      - { value: "It provides access to environment variables for routing conditions.", correct: false }
      - { value: "It manages the lifecycle of route objects.", correct: false }
    help: |
      `RequestContext` provides the router with the context it needs to operate.
      https://symfony.com/doc/current/create_framework/routing.html#matching-urls

  -
    question: >
      When defining a route with a `condition` using Expression Language, how can you access the current HTTP method of the request?
    answers:
      - { value: "Using `context.getMethod()`.", correct: true }
      - { value: "Using `request.getMethod()`.", correct: true }
      - { value: "Using `params.method`.", correct: false }
      - { value: "Using `http_method()` function.", correct: false }
    help: |
      Both `context` and `request` variables provide access to the HTTP method.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: >
      What is the primary benefit of using `php bin/console debug:router` during development?
    answers:
      - { value: "It helps in quickly identifying and troubleshooting issues related to route matching and URL generation.", correct: true }
      - { value: "It automatically fixes routing errors in configuration files.", correct: false }
      - { value: "It generates a visual map of all routes in the application.", correct: false }
      - { value: "It optimizes the routing cache for production environments.", correct: false }
    help: |
      The `debug:router` command is an indispensable tool for developers working with Symfony routing.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file that only accepts HTTPS requests?
    answers:
      - { value: "```php\n$routes->add('secure_route', '/secure')\n    ->controller([SecureController::class, 'index'])\n    ->schemes(['https']);\n```", correct: true }
      - { value: "```php\n$routes->add('secure_route', '/secure')\n    ->controller([SecureController::class, 'index'])\n    ->scheme('https');\n```", correct: false }
      - { value: "```php\n$routes->add('secure_route', '/secure')\n    ->controller([SecureController::class, 'index'])\n    ->forceHttps();\n```", correct: false }
      - { value: "```php\n$routes->add('secure_route', '/secure')\n    ->controller([SecureController::class, 'index'])\n    ->setScheme('https');\n```", correct: false }
    help: |
      The `schemes()` method on the route configurator is used to specify allowed URL schemes.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::ABSOLUTE_URL` constant when generating URLs?
    answers:
      - { value: "It generates a full URL including the scheme, host, and path (e.g., `https://example.com/blog/post`).", correct: true }
      - { value: "It generates a URL relative to the web root.", correct: false }
      - { value: "It generates a URL that is always absolute, regardless of the current request.", correct: false }
      - { value: "It generates a URL that only works on the production environment.", correct: false }
    help: |
      `ABSOLUTE_URL` is used when a complete, self-contained URL is needed.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which of the following is true about route requirements in Symfony?
    answers:
      - { value: "They are regular expressions used to validate the format of route parameters.", correct: true }
      - { value: "They define the minimum and maximum length of route parameters.", correct: false }
      - { value: "They specify the data type of route parameters (e.g., string, int).", correct: false }
      - { value: "They are used to define default values for optional route parameters.", correct: false }
    help: |
      Requirements are powerful tools for ensuring that route parameters conform to expected patterns.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the significance of the `UrlGeneratorInterface::RELATIVE_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the current request's path (e.g., `../sibling-page`).", correct: true }
      - { value: "It generates a URL relative to the web root, starting with a slash (e.g., `/blog/post`).", correct: false }
      - { value: "It generates a full URL including the scheme and host.", correct: false }
      - { value: "It is an alias for `ABSOLUTE_PATH`.", correct: false }
    help: |
      `RELATIVE_PATH` is useful for generating URLs that are relative to the current location, often for internal navigation.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When defining a route with a parameter, what is the significance of the `<` and `>` characters in the path (e.g., `/blog/{page<\\d+>}`)?
    answers:
      - { value: "They are used to embed inline regular expression requirements for the parameter.", correct: true }
      - { value: "They indicate that the parameter is optional.", correct: false }
      - { value: "They define the default value for the parameter.", correct: false }
      - { value: "They are used for type hinting the parameter in the controller.", correct: false }
    help: |
      Inline requirements provide a concise way to define regular expressions directly within the route path.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary purpose of the `#[Route]` attribute's `schemes` option?
    answers:
      - { value: "To restrict the route to match only requests using specific URL schemes (e.g., `http`, `https`).", correct: true }
      - { value: "To define the default scheme for generated URLs.", correct: false }
      - { value: "To specify the security protocols allowed for the route.", correct: false }
      - { value: "To enable or disable HTTP/2 for the route.", correct: false }
    help: |
      The `schemes` option ensures that a route is only matched if the request uses one of the specified schemes.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      Which of the following is a valid way to define a route in YAML that only accepts HTTPS requests?
    answers:
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    schemes: [https]\n```", correct: true }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    scheme: https\n```", correct: false }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    secure: true\n```", correct: false }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    protocol: https\n```", correct: false }
    help: |
      The `schemes` key in YAML is used to define scheme requirements as a list.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      What is the main advantage of using route aliases in Symfony?
    answers:
      - { value: "To provide backward compatibility when route names change, allowing old names to still work.", correct: true }
      - { value: "To create multiple URLs for the same route, improving SEO.", correct: false }
      - { value: "To define routes that can be accessed without a controller.", correct: false }
      - { value: "To simplify the process of generating localized URLs.", correct: false }
    help: |
      Route aliases are primarily used for smooth transitions when refactoring route names.
      https://symfony.com/doc/current/routing.html#route-aliases

  -
    question: >
      When configuring a route alias, what information can be provided in the deprecation configuration (e.g., `DeprecatedAlias` attribute or `deprecated` key in YAML)?
    answers:
      - { value: "The `package` name and `version` of the package introducing the deprecation.", correct: true }
      - { value: "A custom `message` for the deprecation, optionally using the `%alias_id%` placeholder.", correct: true }
      - { value: "The date when the alias will be removed.", correct: false }
      - { value: "A list of alternative route names.", correct: false }
    help: |
      Deprecation configuration allows specifying the package, version, and a custom message for the deprecation warning.
      https://symfony.com/doc/current/routing.html#deprecating-route-aliases

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepQueryParams: true`?
    answers:
      - { value: "It preserves the original query string parameters when redirecting to the target URL or route.", correct: true }
      - { value: "It ensures that the redirect is always a GET request, even if the original was POST.", correct: false }
      - { value: "It appends a unique query parameter to prevent caching of the redirect.", correct: false }
      - { value: "It only redirects if query parameters are present in the original request.", correct: false }
    help: |
      `keepQueryParams: true` is useful for maintaining context across redirects.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following is true about localized routes in Symfony?
    answers:
      - { value: "They allow defining different URL paths for the same route name based on the active locale.", correct: true }
      - { value: "They automatically translate the content of the page based on the route.", correct: false }
      - { value: "They require a separate controller for each locale.", correct: false }
      - { value: "They are only supported when using the `_locale` parameter in the URL.", correct: false }
    help: |
      Localized routes provide flexibility in URL structure for internationalized applications.
      https://symfony.com/doc/current/routing.html#define-localized-routes

  -
    question: >
      What is the purpose of the `env` option in a Symfony route definition (PHP attributes or YAML)?
    answers:
      - { value: "To make the route active only in a specific Symfony environment (e.g., `dev`, `prod`).", correct: true }
      - { value: "To define environment variables that are accessible within the route's controller.", correct: false }
      - { value: "To specify the deployment environment for the route.", correct: false }
      - { value: "To set the default environment for generated URLs.", correct: false }
    help: |
      The `env` option provides fine-grained control over route activation based on the application environment.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the primary benefit of using `php bin/console debug:router` during development?
    answers:
      - { value: "It helps in quickly identifying and troubleshooting issues related to route matching and URL generation.", correct: true }
      - { value: "It automatically fixes routing errors in configuration files.", correct: false }
      - { value: "It generates a visual map of all routes in the application.", correct: false }
      - { value: "It optimizes the routing cache for production environments.", correct: false }
    help: |
      The `debug:router` command is an indispensable tool for developers working with Symfony routing.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepRequestMethod: true` for a temporary redirect?
    answers:
      - { value: "It changes the redirect status code from 302 to 307, preserving the HTTP method.", correct: true }
      - { value: "It forces the redirect to always be a GET request.", correct: false }
      - { value: "It ensures that the original request body is also sent with the redirect.", correct: false }
      - { value: "It prevents the browser from caching the redirect.", correct: false }
    help: |
      The 307 status code is specifically for temporary redirects that preserve the request method.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following describes the `_route_params` attribute available on the `Request` object?
    answers:
      - { value: "An array containing all matched route parameters for the current request.", correct: true }
      - { value: "A string representing the current route's path.", correct: false }
      - { value: "The name of the currently matched route.", correct: false }
      - { value: "A collection of all query parameters from the request.", correct: false }
    help: |
      The `_route_params` attribute provides programmatic access to the values of the parameters that were matched by the router.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the primary purpose of the `_route` attribute available on the `Request` object?
    answers:
      - { value: "It holds the name of the currently matched route.", correct: true }
      - { value: "It contains the full URL of the current request.", correct: false }
      - { value: "It stores the controller and action executed for the current request.", correct: false }
      - { value: "It provides access to the routing configuration.", correct: false }
    help: |
      The `_route` attribute is a convenient way to get the name of the route that was successfully matched.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the main benefit of organizing routes into groups using prefixes and name prefixes?
    answers:
      - { value: "It improves the readability and maintainability of routing configurations, especially for large applications.", correct: true }
      - { value: "It significantly reduces the size of the compiled routing cache.", correct: false }
      - { value: "It enables automatic generation of API documentation.", correct: false }
      - { value: "It enhances security by isolating routes.", correct: false }
    help: |
      Route grouping helps in managing complex routing setups by applying common configurations.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::NETWORK_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the scheme (e.g., `//example.com/blog/post`), useful for avoiding mixed content warnings.", correct: true }
      - { value: "It generates a URL that is only accessible within the local network.", correct: false }
      - { value: "It generates a URL that uses a specific network protocol (e.g., FTP).", correct: false }
      - { value: "It is an alias for `ABSOLUTE_URL` but without the scheme.", correct: false }
    help: |
      `NETWORK_PATH` creates protocol-relative URLs, which adapt to the current scheme (HTTP or HTTPS).
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepQueryParams: true`?
    answers:
      - { value: "It preserves the original query string parameters when redirecting to the target URL or route.", correct: true }
      - { value: "It ensures that the redirect is always a GET request, even if the original was POST.", correct: false }
      - { value: "It appends a unique query parameter to prevent caching of the redirect.", correct: false }
      - { value: "It only redirects if query parameters are present in the original request.", correct: false }
    help: |
      `keepQueryParams: true` is useful for maintaining context across redirects.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following is true about localized routes in Symfony?
    answers:
      - { value: "They allow defining different URL paths for the same route name based on the active locale.", correct: true }
      - { value: "They automatically translate the content of the page based on the route.", correct: false }
      - { value: "They require a separate controller for each locale.", correct: false }
      - { value: "They are only supported when using the `_locale` parameter in the URL.", correct: false }
    help: |
      Localized routes provide flexibility in URL structure for internationalized applications.
      https://symfony.com/doc/current/routing.html#define-localized-routes

  -
    question: >
      What is the purpose of the `env` option in a Symfony route definition (PHP attributes or YAML)?
    answers:
      - { value: "To make the route active only in a specific Symfony environment (e.g., `dev`, `prod`).", correct: true }
      - { value: "To define environment variables that are accessible within the route's controller.", correct: false }
      - { value: "To specify the deployment environment for the route.", correct: false }
      - { value: "To set the default environment for generated URLs.", correct: false }
    help: |
      The `env` option provides fine-grained control over route activation based on the application environment.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the primary benefit of using `php bin/console debug:router` during development?
    answers:
      - { value: "It helps in quickly identifying and troubleshooting issues related to route matching and URL generation.", correct: true }
      - { value: "It automatically fixes routing errors in configuration files.", correct: false }
      - { value: "It generates a visual map of all routes in the application.", correct: false }
      - { value: "It optimizes the routing cache for production environments.", correct: false }
    help: |
      The `debug:router` command is an indispensable tool for developers working with Symfony routing.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepRequestMethod: true` for a temporary redirect?
    answers:
      - { value: "It changes the redirect status code from 302 to 307, preserving the HTTP method.", correct: true }
      - { value: "It forces the redirect to always be a GET request.", correct: false }
      - { value: "It ensures that the original request body is also sent with the redirect.", correct: false }
      - { value: "It prevents the browser from caching the redirect.", correct: false }
    help: |
      The 307 status code is specifically for temporary redirects that preserve the request method.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following describes the `_route_params` attribute available on the `Request` object?
    answers:
      - { value: "An array containing all matched route parameters for the current request.", correct: true }
      - { value: "A string representing the current route's path.", correct: false }
      - { value: "The name of the currently matched route.", correct: false }
      - { value: "A collection of all query parameters from the request.", correct: false }
    help: |
      The `_route_params` attribute provides programmatic access to the values of the parameters that were matched by the router.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the primary purpose of the `_route` attribute available on the `Request` object?
    answers:
      - { value: "It holds the name of the currently matched route.", correct: true }
      - { value: "It contains the full URL of the current request.", correct: false }
      - { value: "It stores the controller and action executed for the current request.", correct: false }
      - { value: "It provides access to the routing configuration.", correct: false }
    help: |
      The `_route` attribute is a convenient way to get the name of the route that was successfully matched.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the main benefit of organizing routes into groups using prefixes and name prefixes?
    answers:
      - { value: "It improves the readability and maintainability of routing configurations, especially for large applications.", correct: true }
      - { value: "It significantly reduces the size of the compiled routing cache.", correct: false }
      - { value: "It enables automatic generation of API documentation.", correct: false }
      - { value: "It enhances security by isolating routes.", correct: false }
    help: |
      Route grouping helps in managing complex routing setups by applying common configurations.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::NETWORK_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the scheme (e.g., `//example.com/blog/post`), useful for avoiding mixed content warnings.", correct: true }
      - { value: "It generates a URL that is only accessible within the local network.", correct: false }
      - { value: "It generates a URL that uses a specific network protocol (e.g., FTP).", correct: false }
      - { value: "It is an alias for `ABSOLUTE_URL` but without the scheme.", correct: false }
    help: |
      `NETWORK_PATH` creates protocol-relative URLs, which adapt to the current scheme (HTTP or HTTPS).
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepQueryParams: true`?
    answers:
      - { value: "It preserves the original query string parameters when redirecting to the target URL or route.", correct: true }
      - { value: "It ensures that the redirect is always a GET request, even if the original was POST.", correct: false }
      - { value: "It appends a unique query parameter to prevent caching of the redirect.", correct: false }
      - { value: "It only redirects if query parameters are present in the original request.", correct: false }
    help: |
      `keepQueryParams: true` is useful for maintaining context across redirects.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following is true about localized routes in Symfony?
    answers:
      - { value: "They allow defining different URL paths for the same route name based on the active locale.", correct: true }
      - { value: "They automatically translate the content of the page based on the route.", correct: false }
      - { value: "They require a separate controller for each locale.", correct: false }
      - { value: "They are only supported when using the `_locale` parameter in the URL.", correct: false }
    help: |
      Localized routes provide flexibility in URL structure for internationalized applications.
      https://symfony.com/doc/current/routing.html#define-localized-routes

  -
    question: >
      What is the purpose of the `env` option in a Symfony route definition (PHP attributes or YAML)?
    answers:
      - { value: "To make the route active only in a specific Symfony environment (e.g., `dev`, `prod`).", correct: true }
      - { value: "To define environment variables that are accessible within the route's controller.", correct: false }
      - { value: "To specify the deployment environment for the route.", correct: false }
      - { value: "To set the default environment for generated URLs.", correct: false }
    help: |
      The `env` option provides fine-grained control over route activation based on the application environment.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the primary benefit of using `php bin/console debug:router` during development?
    answers:
      - { value: "It helps in quickly identifying and troubleshooting issues related to route matching and URL generation.", correct: true }
      - { value: "It automatically fixes routing errors in configuration files.", correct: false }
      - { value: "It generates a visual map of all routes in the application.", correct: false }
      - { value: "It optimizes the routing cache for production environments.", correct: false }
    help: |
      The `debug:router` command is an indispensable tool for developers working with Symfony routing.
      https://symfony.com/doc/current/routing.html#router-debuggingcategory: Routing

questions:
  -
    question: >
      Which of the following PHP attribute configurations correctly defines a route named `blog_list` for the `/blog` URL?
    answers:
      - { value: "```php\n#[Route('/blog', name: 'blog_list')]\npublic function list(): Response {}\n```", correct: true }
      - { value: "```php\n#[Path('/blog', name: 'blog_list')]\npublic function list(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(path: '/blog', id: 'blog_list')]\npublic function list(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(url: '/blog', alias: 'blog_list')]\npublic function list(): Response {}\n```", correct: false }
    help: |
      The `#[Route]` attribute is used to define routes directly on controller methods. The `path` argument specifies the URL pattern, and `name` defines the route's unique identifier.
      https://symfony.com/doc/current/routing.html#defining-routes-as-php-attributes

  -
    question: |
      Given the following YAML configuration, which route is defined?

      ```yaml
      # config/routes.yaml
      product_show:
          path: /product/{id}
          controller: App\Controller\ProductController::show
      ```
    answers:
      - { value: "A route named \"product_show\" that matches `/product/{id}` and executes `App\\Controller\\ProductController::show`.", correct: true }
      - { value: "A route named \"product_id\" that matches `/product/{show}` and executes `App\\Controller\\ProductController::show`.", correct: false }
      - { value: "A service definition for \"product_show\".", correct: false }
      - { value: "An invalid routing configuration.", correct: false }
    help: |
      In YAML, routes are defined with a unique name (e.g., `product_show`), followed by the `path` and `controller` keys.
      https://symfony.com/doc/current/routing.html#defining-routes-in-yaml

  -
    question: >
      To enable attribute-based routing for controllers located in `src/Controller/` within the `App\Controller` namespace, which YAML configuration is correct?
    answers:
      - { value: "```yaml\ncontrollers:\n    resource:\n        path: ../../src/Controller/\n        namespace: App\\Controller\n    type: attribute\n```", correct: true }
      - { value: "```yaml\napp_controllers:\n    path: ../../src/Controller/\n    type: annotation\n```", correct: false }
      - { value: "```yaml\nroutes:\n    import: App\\Controller\n    format: attributes\n```", correct: false }
      - { value: "```yaml\nattributes:\n    dir: src/Controller/\n    namespace: App\\Controller\n```", correct: false }
    help: |
      The `resource` key specifies the path to scan, `namespace` defines the base namespace, and `type: attribute` indicates that PHP attributes should be used for route definitions.
      https://symfony.com/doc/current/routing.html#loading-routes-from-php-attributes

  -
    question: |
      Which PHP configurator snippet correctly imports routes from the `src/Controller/` directory using attributes?
    answers:
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute');\n};\n```", correct: true }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->load('../../src/Controller/', 'attribute');\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->addResource('../../src/Controller/', 'attribute');\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->fromAttributes('../../src/Controller/');\n};\n```", correct: false }
    help: |
      The `import()` method of `RoutingConfigurator` is used to load routes from a given resource, specifying the type (e.g., 'attribute').
      https://symfony.com/doc/current/routing.html#loading-routes-from-php-attributes

  -
    question: |
      How would you define a route `/blog/{page}` where `page` is a required integer parameter using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/blog/{page<\\\\d+>}', name: 'blog_list')]\npublic function list(int $page): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\\\d+'])]\npublic function list(int $page): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{page}', name: 'blog_list', defaults: ['page' => 'int'])]\npublic function list(int $page): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/blog/{page:int}', name: 'blog_list')]\npublic function list(int $page): Response {}\n```", correct: false }
    help: |
      Route parameters can be restricted using inline regular expressions (e.g., `<\\d+>`) or by defining `requirements` in the `#[Route]` attribute.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      In YAML, how do you define a route `/blog/{page}` where `page` is a required integer parameter?
    answers:
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    requirements:\n        page: '\\d+'\n```", correct: true }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page<\\\\d+>}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    defaults:\n        page: int\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page:integer}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
    help: |
      In YAML, parameter requirements are defined under the `requirements` key, where the key is the parameter name and the value is the regular expression.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      To set a default value for a route parameter `name` to `'World'` in a route `/hello/{name}` using PHP attributes, which is the correct syntax?
    answers:
      - { value: "```php\n#[Route('/hello/{name}', name: 'hello_page', defaults: ['name' => 'World'])]\npublic function hello(string $name): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/hello/{name?World}', name: 'hello_page')]\npublic function hello(string $name): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/hello/{name}', name: 'hello_page', options: ['default_name' => 'World'])]\npublic function hello(string $name): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/hello/{name}', name: 'hello_page', parameters: ['name' => 'World'])]\npublic function hello(string $name): Response {}\n```", correct: false }
    help: |
      Default values for route parameters are specified using the `defaults` option in the `#[Route]` attribute.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: |
      How do you define a default value for the `page` parameter to `1` for the route `/blog/{page}` in YAML?
    answers:
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    defaults:\n        page: 1\n```", correct: true }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page?1}\n    controller: App\\Controller\\BlogController::list\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    options:\n        default_page: 1\n```", correct: false }
      - { value: "```yaml\nblog_list:\n    path: /blog/{page}\n    controller: App\\Controller\\BlogController::list\n    parameter_defaults:\n        page: 1\n```", correct: false }
    help: |
      In YAML, default values for route parameters are defined under the `defaults` key.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: |
      Which PHP attribute configuration correctly restricts the `slug` parameter in `/blog/{slug}` to only allow alphanumeric characters and hyphens?
    answers:
      - { value: "```php\n#[Route('/blog/{slug}', name: 'blog_show', requirements: ['slug' => '[a-zA-Z0-9-]+'])]\npublic function show(string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{slug<[a-zA-Z0-9-]+>}', name: 'blog_show')]\npublic function show(string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/blog/{slug}', name: 'blog_show', regex: ['slug' => '[a-zA-Z0-9-]+'])]\npublic function show(string $slug): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/blog/{slug}', name: 'blog_show', validation: ['slug' => 'alphanumeric_hyphen'])]\npublic function show(string $slug): Response {}\n```", correct: false }
    help: |
      Route parameters can be restricted using regular expressions, either inline within the path or via the `requirements` option.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      In YAML, how do you restrict the `id` parameter in `/product/{id}` to be a UUID (e.g., `[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`)?
    answers:
      - { value: "```yaml\nproduct_show:\n    path: /product/{id}\n    controller: App\\Controller\\ProductController::show\n    requirements:\n        id: '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'\n```", correct: true }
      - { value: "```yaml\nproduct_show:\n    path: /product/{id<[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}>}\n    controller: App\\Controller\\ProductController::show\n```", correct: false }
      - { value: "```yaml\nproduct_show:\n    path: /product/{id}\n    controller: App\\Controller\\ProductController::show\n    format: uuid\n```", correct: false }
      - { value: "```yaml\nproduct_show:\n    path: /product/{id}\n    controller: App\\Controller\\ProductController::show\n    constraints:\n        id: uuid\n```", correct: false }
    help: |
      Regular expression requirements for route parameters are specified under the `requirements` key in YAML.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: |
      By default, Symfony route parameters do not match the `/` (slash) character. How can you allow a route parameter `token` in `/share/{token}` to contain slashes using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/share/{token}', name: 'share', requirements: ['token' => '.+'])]\npublic function share(string $token): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/share/{token<.+>}', name: 'share')]\npublic function share(string $token): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/share/{token}', name: 'share', allow_slashes: true)]\npublic function share(string $token): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/share/{token}', name: 'share', options: ['slash_tolerant' => true])]\npublic function share(string $token): Response {}\n```", correct: false }
    help: |
      To allow slashes in a route parameter, you must define a requirement that includes the slash character, typically `.+` to match any character one or more times.
      https://symfony.com/doc/current/routing.html#allowing-a-slash-character-in-a-route-parameter

  -
    question: |
      In YAML, how do you configure a route `/files/{path}` to allow the `path` parameter to include `/` (slash) characters?
    answers:
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path}\n    controller: App\\Controller\\FileController::view\n    requirements:\n        path: '.+'\n```", correct: true }
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path<.+>}\n    controller: App\\Controller\\FileController::view\n```", correct: false }
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path}\n    controller: App\\Controller\\FileController::view\n    options:\n        allow_slash: true\n```", correct: false }
      - { value: "```yaml\nfile_viewer:\n    path: /files/{path}\n    controller: App\\Controller\\FileController::view\n    slash_allowed: true\n```", correct: false }
    help: |
      The `.+` regular expression allows a parameter to match any character, including slashes, one or more times.
      https://symfony.com/doc/current/routing.html#allowing-a-slash-character-in-a-route-parameter

  -
    question: >
      Symfony 7 supports PHP backed enums as route parameters. If you have an `OrderStatusEnum` backed by strings, how would Symfony handle a route `/orders/list/{status}` where `status` is an `OrderStatusEnum`?
    answers:
      - { value: "Symfony automatically converts the scalar value from the URL to the corresponding `OrderStatusEnum` instance.", correct: true }
      - { value: "You must manually convert the string status to an `OrderStatusEnum` instance in the controller.", correct: false }
      - { value: "Symfony will throw an error if a non-enum scalar value is provided in the URL.", correct: false }
      - { value: "PHP backed enums cannot be used directly as route parameters; they must be converted to strings first.", correct: false }
    help: |
      Symfony's ParamConverter automatically handles the conversion of route parameters to PHP backed enum instances, provided the enum is backed by a scalar type.
      https://symfony.com/doc/current/routing.html#route-parameter-with-php-backed-enum

  -
    question: |
      Given the following controller method:

      ```php
      // src/Controller/ProductController.php
      class ProductController extends AbstractController
      {
          #[Route('/product/{id}', name: 'product_show')]
          public function show(int $id = 1): Response
          {
              // ...
          }
      }
      ```
      What will be the value of `$id` if the URL `/product` is accessed?
    answers:
      - { value: "1", correct: true }
      - { value: "null", correct: false }
      - { value: "An exception will be thrown because `id` is missing.", correct: false }
      - { value: "0", correct: false }
    help: |
      If a route parameter has a default value in the controller method signature, and the parameter is not provided in the URL, Symfony will use the default value.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: |
      Consider the following YAML route definition:

      ```yaml
      # config/routes.yaml
      article_page:
          path: /articles/{page}
          controller: App\Controller\ArticleController::show
          defaults:
              page: 'home'
      ```
      What URL would match this route and result in `page` being `'home'`?
    answers:
      - { value: "`/articles`", correct: true }
      - { value: "`/articles/home`", correct: false }
      - { value: "`/articles/`", correct: true }
      - { value: "`/articles/index`", correct: false }
    help: |
      When a route parameter has a default value, the parameter becomes optional in the URL. If the parameter is omitted, its default value is used.
      https://symfony.com/doc/current/routing.html#setting-default-values-for-parameters

  -
    question: >
      Within a Symfony controller that extends `AbstractController`, which method is used to generate a URL for a given route name and parameters?
    answers:
      - { value: "`$this->generateUrl('route_name', ['param' => 'value'])`", correct: true }
      - { value: "`$this->getUrl('route_name', ['param' => 'value'])`", correct: false }
      - { value: "`$this->router->generate('route_name', ['param' => 'value'])`", correct: false }
      - { value: "`$this->createUrl('route_name', ['param' => 'value'])`", correct: false }
    help: |
      The `AbstractController` provides a `generateUrl()` helper method for generating URLs.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      To generate an absolute URL (e.g., `http://example.com/blog`) for a route named `blog_list` from within a Symfony controller, what is the correct `generateUrl()` call?
    answers:
      - { value: "`$this->generateUrl('blog_list', [], UrlGeneratorInterface::ABSOLUTE_URL)`", correct: true }
      - { value: "`$this->generateUrl('blog_list', [], true)`", correct: false }
      - { value: "`$this->generateAbsoluteUrl('blog_list')`", correct: false }
      - { value: "`$this->generateUrl('blog_list', ['_absolute' => true])`", correct: false }
    help: |
      The third argument to `generateUrl()` can be a constant from `UrlGeneratorInterface` to specify the reference type, such as `ABSOLUTE_URL`.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      You have a localized route `about_us` with paths `en: /about-us` and `nl: /over-ons`. If the current request locale is `en`, how would you generate the URL for `about_us` in Dutch (`/over-ons`) from a controller?
    answers:
      - { value: "`$this->generateUrl('about_us', ['_locale' => 'nl'])`", correct: true }
      - { value: "`$this->generateUrl('about_us', ['locale' => 'nl'])`", correct: false }
      - { value: "`$this->generateUrl('about_us', [], 'nl')`", correct: false }
      - { value: "`$this->generateUrl('about_us', ['_language' => 'nl'])`", correct: false }
    help: |
      To explicitly set the locale for a generated URL, pass the `_locale` parameter in the arguments array.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which interface should be injected into a Symfony service to enable URL generation?
    answers:
      - { value: "`Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface`", correct: true }
      - { value: "`Symfony\\Component\\HttpFoundation\\UrlGeneratorInterface`", correct: false }
      - { value: "`Symfony\\Component\\Routing\\RouterInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\UriGeneratorInterface`", correct: false }
    help: |
      The `UrlGeneratorInterface` is the primary interface for generating URLs in Symfony.
      https://symfony.com/doc/current/routing.html#generating-urls-in-services

  -
    question: >
      When passing an object (e.g., a `Uuid` object) as an "extra" parameter to `generateUrl()` that is not part of the route pattern, what is the recommended practice to avoid issues?
    answers:
      - { value: "Explicitly cast the object to a string before passing it: `(string) $entity->getUuid()`.", correct: true }
      - { value: "Symfony automatically converts objects to strings if they implement `__toString()`.", correct: false }
      - { value: "Pass the object directly; Symfony's serializer handles the conversion.", correct: false }
      - { value: "Encode the object as JSON before passing it as a parameter.", correct: false }
    help: |
      For extra parameters that are not part of the route pattern, it's best practice to explicitly convert objects to strings to ensure they are correctly included in the query string.
      https://symfony.com/doc/current/routing.html#extra-parameters-in-urls

  -
    question: |
      To configure a route named `doc_shortcut` that redirects `/doc` to an internal route `doc_page` with `page: 'index'` and `version: 'current'`, and makes the redirect permanent (HTTP 301), which YAML configuration is correct?
    answers:
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\n    defaults:\n        route: 'doc_page'\n        page: 'index'\n        version: 'current'\n        permanent: true\n```", correct: true }
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    redirect_to: doc_page\n    parameters:\n        page: index\n        version: current\n    status: 301\n```", correct: false }
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    controller: RedirectController\n    options:\n        target_route: doc_page\n        params: { page: index, version: current }\n        permanent: true\n```", correct: false }
      - { value: "```yaml\ndoc_shortcut:\n    path: /doc\n    action: redirect\n    route_name: doc_page\n    route_params: { page: index, version: current }\n    http_status: 301\n```", correct: false }
    help: |
      The `RedirectController` is used for redirects. Internal redirects specify the `route` and any additional parameters in `defaults`. `permanent: true` sets the HTTP status code to 301.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: |
      You want to redirect `/legacy/doc` to an external URL `https://legacy.example.com/doc` with a permanent redirect. Which YAML configuration achieves this?
    answers:
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\n    defaults:\n        path: 'https://legacy.example.com/doc'\n        permanent: true\n```", correct: true }
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    redirect_to_url: 'https://legacy.example.com/doc'\n    status: 301\n```", correct: false }
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    controller: RedirectController\n    options:\n        url: 'https://legacy.example.com/doc'\n        permanent: true\n```", correct: false }
      - { value: "```yaml\nlegacy_doc:\n    path: /legacy/doc\n    action: external_redirect\n    target: 'https://legacy.example.com/doc'\n    type: permanent\n```", correct: false }
    help: |
      For external redirects, the `path` default parameter is used to specify the target URL. `permanent: true` ensures a 301 redirect.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      When using `RedirectController` for a permanent redirect that also needs to preserve the original HTTP method (e.g., POST), what HTTP status code does Symfony use?
    answers:
      - { value: "308 (Permanent Redirect)", correct: true }
      - { value: "301 (Moved Permanently)", correct: false }
      - { value: "307 (Temporary Redirect)", correct: false }
      - { value: "303 (See Other)", correct: false }
    help: |
      If `keepRequestMethod` is `true` for a permanent redirect, Symfony uses HTTP 308. For temporary redirects, it uses 307.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      What is the primary purpose of the `_controller` special route parameter in Symfony?
    answers:
      - { value: "To determine which controller and action is executed when the route is matched.", correct: true }
      - { value: "To define the HTTP method allowed for the route.", correct: false }
      - { value: "To set the default locale for the route.", correct: false }
      - { value: "To specify the template to render for the route.", correct: false }
    help: |
      The `_controller` parameter is fundamental for routing, directly linking a matched URL to its corresponding PHP controller method.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      The `_format` special route parameter in Symfony is used for which purpose?
    answers:
      - { value: "To set the \"request format\" of the `Request` object, influencing the `Content-Type` of the response.", correct: true }
      - { value: "To define the expected data format for incoming POST requests.", correct: false }
      - { value: "To specify the output format of generated URLs.", correct: false }
      - { value: "To validate the format of route parameters.", correct: false }
    help: |
      The `_format` parameter helps Symfony determine the desired response format (e.g., HTML, JSON, XML) and sets the appropriate `Content-Type` header.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      What is the role of the `_locale` special route parameter in Symfony?
    answers:
      - { value: "It is used to set the locale on the `Request` object.", correct: true }
      - { value: "It defines the default language for the application.", correct: false }
      - { value: "It specifies the language of the route path itself.", correct: false }
      - { value: "It's a placeholder for user-defined language preferences.", correct: false }
    help: |
      The `_locale` parameter is crucial for internationalization, allowing Symfony to adapt content based on the user's preferred language.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: |
      Which PHP attribute configuration correctly defines a route `/articles/{_locale}/search.{_format}` with default locale `en`, default format `html`, and requirements for `_locale` (`en|fr`) and `_format` (`html|xml`)?
    answers:
      - { value: "```php\n#[Route(\n    path: '/articles/{_locale}/search.{_format}',\n    locale: 'en',\n    format: 'html',\n    requirements: [\n        '_locale' => 'en|fr',\n        '_format' => 'html|xml',\n    ],\n)]\npublic function search(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route(\n    path: '/articles/{_locale}/search.{_format}',\n    defaults: ['_locale' => 'en', '_format' => 'html'],\n    requirements: ['_locale' => 'en|fr', '_format' => 'html|xml'],\n)]\npublic function search(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/articles/{_locale}/search.{_format}',\n    name: 'article_search',\n    options: { 'locale': 'en', 'format': 'html' },\n    constraints: { '_locale': 'en|fr', '_format': 'html|xml' },\n)]\npublic function search(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/articles/{_locale}/search.{_format}',\n    default_locale: 'en',\n    default_format: 'html',\n    regex: { '_locale': 'en|fr', '_format': 'html|xml' },\n)]\npublic function search(): Response {}\n```", correct: false }
    help: |
      Special route parameters like `_locale` and `_format` can have default values and requirements defined directly in the `#[Route]` attribute.
      https://symfony.com/doc/current/routing.html#configuring-special-route-parameters

  -
    question: |
      In YAML, how do you define a route `/products/{_locale}.{_format}` with a default `_locale` of `en`, a default `_format` of `json`, and requirements that `_locale` is `en|de` and `_format` is `json|xml`?
    answers:
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    locale: en\n    format: json\n    requirements:\n        _locale: en|de\n        _format: json|xml\n```", correct: true }
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    defaults:\n        _locale: en\n        _format: json\n    requirements:\n        _locale: en|de\n        _format: json|xml\n```", correct: true }
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    options:\n        default_locale: en\n        default_format: json\n    constraints:\n        _locale: en|de\n        _format: json|xml\n```", correct: false }
      - { value: "```yaml\nproduct_feed:\n    path: /products/{_locale}.{_format}\n    controller: App\\Controller\\ProductController::feed\n    locale_default: en\n    format_default: json\n    regex:\n        _locale: en|de\n        _format: json|xml\n```", correct: false }
    help: |
      In YAML, `locale` and `format` keys are used for default values of `_locale` and `_format` respectively, while `requirements` are used for their validation.
      https://symfony.com/doc/current/routing.html#configuring-special-route-parameters

  -
    question: >
      To mark a route named `homepage` for `/` as `stateless` using PHP attributes, preventing session usage during request matching, which is the correct configuration?
    answers:
      - { value: "```php\n#[Route('/', name: 'homepage', stateless: true)]\npublic function homepage(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/', name: 'homepage', options: ['stateless' => true])]\npublic function homepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'homepage', session_less: true)]\npublic function homepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'homepage', cacheable: true)]\npublic function homepage(): Response {}\n```", correct: false }
    help: |
      The `stateless` option in the `#[Route]` attribute indicates that the route does not require session state.
      https://symfony.com/doc/current/routing.html#stateless-routes

  -
    question: |
      How do you mark a route named `api_endpoint` for `/api` as `stateless` in YAML?
    answers:
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    stateless: true\n```", correct: true }
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    options:\n        stateless: true\n```", correct: false }
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    session_management: false\n```", correct: false }
      - { value: "```yaml\napi_endpoint:\n    path: /api\n    controller: App\\Controller\\ApiController::index\n    no_session: true\n```", correct: false }
    help: |
      In YAML, the `stateless: true` option is used to mark a route as stateless.
      https://symfony.com/doc/current/routing.html#stateless-routes

  -
    question: >
      To define a route `/` that only matches the host `m.example.com` using PHP attributes, which is the correct configuration?
    answers:
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', host: 'm.example.com')]\npublic function mobileHomepage(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', domain: 'm.example.com')]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', options: ['host' => 'm.example.com'])]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/', name: 'mobile_homepage', hostname: 'm.example.com')]\npublic function mobileHomepage(): Response {}\n```", correct: false }
    help: |
      The `host` option in the `#[Route]` attribute is used to match a specific domain or subdomain.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      How do you define a route `admin_dashboard` for `/dashboard` that only matches the host `admin.example.com` in YAML?
    answers:
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    host: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: true }
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    domain: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: false }
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    hostname: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: false }
      - { value: "```yaml\nadmin_dashboard:\n    path: /dashboard\n    options:\n        host: admin.example.com\n    controller: App\\Controller\\AdminController::dashboard\n```", correct: false }
    help: |
      In YAML, the `host` key is used to specify the required hostname for a route.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      Which PHP attribute configuration correctly defines a route `/` for `mobile_homepage` that matches `*.example.com`, has a default `subdomain` of `m`, and requires `subdomain` to be `m` or `mobile`?
    answers:
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    host: '{subdomain}.example.com',\n    defaults: ['subdomain' => 'm'],\n    requirements: ['subdomain' => 'm|mobile'],\n)]\npublic function mobileHomepage(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    host: '{subdomain}.example.com',\n    default_subdomain: 'm',\n    subdomain_regex: 'm|mobile',\n)]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    domain: '{subdomain}.example.com',\n    defaults: ['subdomain' => 'm'],\n    requirements: ['subdomain' => 'm|mobile'],\n)]\npublic function mobileHomepage(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/',\n    name: 'mobile_homepage',\n    host: '{subdomain}.example.com',\n    options: { 'subdomain_default': 'm', 'subdomain_pattern': 'm|mobile' },\n)]\npublic function mobileHomepage(): Response {}\n```", correct: false }
    help: |
      Dynamic host parameters are defined within the `host` option, and their defaults and requirements are set using `defaults` and `requirements` respectively.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      In YAML, how do you define a route `/` for `api_root` that matches `api.{version}.example.com`, has a default `version` of `v1`, and requires `version` to be `v1|v2`?
    answers:
      - { value: "```yaml\napi_root:\n    path: /\n    host: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    defaults:\n        version: v1\n    requirements:\n        version: v1|v2\n```", correct: true }
      - { value: "```yaml\napi_root:\n    path: /\n    host: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    default_version: v1\n    version_regex: v1|v2\n```", correct: false }
      - { value: "```yaml\napi_root:\n    path: /\n    domain: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    defaults:\n        version: v1\n    requirements:\n        version: v1|v2\n```", correct: false }
      - { value: "```yaml\napi_root:\n    path: /\n    host: \"api.{version}.example.com\"\n    controller: App\\Controller\\ApiController::root\n    options:\n        version_default: v1\n        version_pattern: v1|v2\n```", correct: false }
    help: |
      YAML allows for dynamic host parameters. Defaults are set under `defaults`, and requirements under `requirements`.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      Which PHP configurator snippet correctly imports routes from `src/Controller/` and applies host-based routing, mapping `www.example.com` to English (`en`) and `www.example.nl` to Dutch (`nl`)?
    answers:
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute')\n        ->host([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: true }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute')\n        ->hosts([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->load('../../src/Controller/', 'attribute')\n        ->domainMapping([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: false }
      - { value: "```php\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->import('../../src/Controller/', 'attribute')\n        ->mapHost([\n            'en' => 'www.example.com',\n            'nl' => 'www.example.nl',\n        ])\n    ;\n};\n```", correct: false }
    help: |
      The `host()` method on the imported route collection allows defining locale-specific host requirements.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: |
      Which PHP attribute configuration correctly defines a route `/contact` that only matches GET or HEAD requests and where the `User-Agent` header matches `/firefox/i`?
    answers:
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    condition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n)]\npublic function contact(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    methods: ['GET', 'HEAD'],\n    headers: ['User-Agent' => '/firefox/i'],\n)]\npublic function contact(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    when: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n)]\npublic function contact(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route(\n    '/contact',\n    name: 'contact',\n    expression: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n)]\npublic function contact(): Response {}\n```", correct: false }
    help: |
      The `condition` option in the `#[Route]` attribute allows defining complex matching logic using Symfony's Expression Language.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: |
      In YAML, how do you define a route `/posts/{id}` that only matches if the `id` parameter is less than `1000`?
    answers:
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    condition: \"params['id'] < 1000\"\n```", correct: true }
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    requirements:\n        id: '<1000'\n```", correct: false }
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    when: \"id < 1000\"\n```", correct: false }
      - { value: "```yaml\npost_show:\n    path: /posts/{id}\n    controller: App\\Controller\\DefaultController::showPost\n    filter: \"id < 1000\"\n```", correct: false }
    help: |
      The `condition` key in YAML allows using Expression Language, where `params` variable provides access to route parameters.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: >
      Which built-in variables are available for use within Symfony's routing condition expressions?
    answers:
      - { value: "`context` (Symfony\\Component\\Routing\\RequestContext)", correct: true }
      - { value: "`request` (Symfony\\Component\\HttpFoundation\\Request)", correct: true }
      - { value: "`params` (array of matched route parameters)", correct: true }
      - { value: "`session` (Symfony\\Component\\HttpFoundation\\Session\\SessionInterface)", correct: false }
      - { value: "`container` (Symfony\\Component\\DependencyInjection\\ContainerInterface)", correct: false }
    help: |
      The `context`, `request`, and `params` variables are directly available in routing conditions.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: >
      Which built-in functions are available for use within Symfony's routing condition expressions?
    answers:
      - { value: "`env(string $name)`: Returns the value of an environment variable.", correct: true }
      - { value: "`service(string $alias)`: Returns a routing condition service.", correct: true }
      - { value: "`param(string $name)`: Returns the value of a configuration parameter.", correct: false }
      - { value: "`is_granted(string $attribute, mixed $subject)`: Checks if the user has a specific role or permission.", correct: false }
    help: |
      The `env()` and `service()` functions are specifically designed for use in routing conditions.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: |
      How do you define a route `/submit` that only accepts POST requests using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/submit', name: 'form_submit', methods: ['POST'])]\npublic function submit(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/submit', name: 'form_submit', allow_methods: ['POST'])]\npublic function submit(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/submit', name: 'form_submit', http_method: 'POST')]\npublic function submit(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/submit', name: 'form_submit', request_method: 'POST')]\npublic function submit(): Response {}\n```", correct: false }
    help: |
      The `methods` option in the `#[Route]` attribute specifies the allowed HTTP methods for a route.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: |
      In YAML, how do you configure a route `api_data` for `/api/data` to only respond to GET and PUT requests?
    answers:
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    methods: [GET, PUT]\n```", correct: true }
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    http_methods: [GET, PUT]\n```", correct: false }
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    allow_methods: [GET, PUT]\n```", correct: false }
      - { value: "```yaml\napi_data:\n    path: /api/data\n    controller: App\\Controller\\ApiController::getData\n    verbs: [GET, PUT]\n```", correct: false }
    help: |
      The `methods` key in YAML is used to specify the allowed HTTP methods for a route.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      Which of the following is NOT a common way Symfony guesses the user's locale for routing?
    answers:
      - { value: "From a `_locale` route parameter.", correct: false }
      - { value: "From the `Accept-Language` HTTP header.", correct: false }
      - { value: "From the user's browser default font settings.", correct: true }
      - { value: "From the session.", correct: false }
    help: |
      Symfony primarily uses the `_locale` route parameter, `Accept-Language` header, and session to determine the locale. Browser font settings are irrelevant to locale guessing.
      https://symfony.com/doc/current/translation/locale.html#the-locale-and-the-url

  -
    question: >
      When generating a URL for a localized route, if you want to explicitly specify a locale different from the current request's locale, which parameter should you pass to `generateUrl()`?
    answers:
      - { value: "`_locale`", correct: true }
      - { value: "`locale`", correct: false }
      - { value: "`lang`", correct: false }
      - { value: "`language`", correct: false }
    help: |
      The `_locale` parameter is a special route parameter used to explicitly set the locale for URL generation.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which command-line tool is used to list all registered routes in a Symfony application?
    answers:
      - { value: "`php bin/console debug:router`", correct: true }
      - { value: "`php bin/console router:list`", correct: false }
      - { value: "`php bin/console app:routes`", correct: false }
      - { value: "`php bin/console show:routes`", correct: false }
    help: |
      The `debug:router` command provides a comprehensive list of all defined routes.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      To display detailed information for a specific route named `product_show`, which command would you use?
    answers:
      - { value: "`php bin/console debug:router product_show`", correct: true }
      - { value: "`php bin/console router:show product_show`", correct: false }
      - { value: "`php bin/console route:info product_show`", correct: false }
      - { value: "`php bin/console debug:route product_show`", correct: false }
    help: |
      Passing the route name as an argument to `debug:router` displays its specific details.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      Which option can be used with `php bin/console debug:router` to filter the displayed routes by a specific HTTP method, for example, to see only GET routes?
    answers:
      - { value: "`--method=GET`", correct: true }
      - { value: "`--http-method=GET`", correct: false }
      - { value: "`--filter-method=GET`", correct: false }
      - { value: "`--get-only`", correct: false }
    help: |
      The `--method` option allows filtering routes by their associated HTTP method.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      You are debugging a routing issue and want to see which route Symfony matches for a given URL, for example, `/lucky/number/8`. Which command helps you with this?
    answers:
      - { value: "`php bin/console router:match /lucky/number/8`", correct: true }
      - { value: "`php bin/console debug:url /lucky/number/8`", correct: false }
      - { value: "`php bin/console route:test /lucky/number/8`", correct: false }
      - { value: "`php bin/console match:route /lucky/number/8`", correct: false }
    help: |
      The `router:match` command is specifically designed to determine which route matches a given URL path.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      You attempt to generate a URL for a route `blog_show` which has a required `slug` parameter, but you forget to provide the `slug`. What common error message would you expect from Symfony?
    answers:
      - { value: "Some mandatory parameters are missing (\"slug\") to generate a URL for route \"blog_show\".", correct: true }
      - { value: "The route \"blog_show\" requires a \"slug\" parameter, which was not provided.", correct: false }
      - { value: "Cannot generate URL for route \"blog_show\": missing required argument \"slug\".", correct: false }
      - { value: "Invalid arguments for route \"blog_show\": \"slug\" is required.", correct: false }
    help: |
      Symfony provides clear error messages when mandatory route parameters are missing during URL generation.
      https://symfony.com/doc/current/routing.html#troubleshooting

  -
    question: >
      If a controller method `App\Controller\BlogController::show()` expects a `$slug` argument, but the matched route's path does not define a `{slug}` parameter, what kind of error message would Symfony typically show?
    answers:
      - { value: "Controller \"App\\\\Controller\\\\BlogController::show()\" requires that you provide a value for the \"$slug\" argument.", correct: true }
      - { value: "Missing argument 1 for App\\Controller\\BlogController::show().", correct: false }
      - { value: "Undefined parameter \"slug\" for controller \"App\\Controller\\BlogController::show()\".", correct: false }
      - { value: "Route mismatch: controller expects \"slug\" but route does not provide it.", correct: false }
    help: |
      Symfony's routing and controller resolver provide specific error messages when there's a mismatch between expected controller arguments and available route parameters.
      https://symfony.com/doc/current/routing.html#troubleshooting

  -
    question: >
      Which of the following describes the purpose of the `priority` option in Symfony routing?
    answers:
      - { value: "It defines the order in which routes are evaluated; higher priority routes are matched first.", correct: true }
      - { value: "It determines the HTTP status code returned for the route.", correct: false }
      - { value: "It specifies the security level required to access the route.", correct: false }
      - { value: "It sets the cache lifetime for the route's response.", correct: false }
    help: |
      The `priority` option is crucial for resolving conflicts between routes, especially when dealing with greedy patterns. Routes with higher priority are checked first.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: |
      Given two routes:
      1. `#[Route('/blog/{slug}', name: 'blog_show')]`
      2. `#[Route('/blog/list', name: 'blog_list')]`
      If `/blog/list` is requested, which route will Symfony match by default and why?
    answers:
      - { value: "`blog_show` because `{slug}` is a greedy pattern and it's defined first.", correct: true }
      - { value: "`blog_list` because it's a more specific static path.", correct: false }
      - { value: "It's ambiguous, Symfony will throw an error.", correct: false }
      - { value: "`blog_show` because it has a higher default priority.", correct: false }
    help: |
      Without explicit `priority` settings, greedy patterns like `{slug}` can match more specific static paths if they are defined earlier.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      How can you ensure that the `blog_list` route in the previous example (`/blog/list`) is matched before `blog_show` (`/blog/{slug}`)?
    answers:
      - { value: "Assign a higher `priority` value to `blog_list` (e.g., `priority: 1` or `priority: 2`).", correct: true }
      - { value: "Define `blog_list` before `blog_show` in the routing configuration.", correct: false }
      - { value: "Add a `requirements` constraint to `blog_list` to make it more specific.", correct: false }
      - { value: "Use a different HTTP method for `blog_list`.", correct: false }
    help: |
      Explicitly setting a higher `priority` for the more specific route ensures it is evaluated before more general (greedy) routes.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file using `RoutingConfigurator`?
    answers:
      - { value: "```php\n$routes->add('blog_list', '/blog')\n    ->controller([BlogController::class, 'list']);\n```", correct: true }
      - { value: "```php\n$routes->route('blog_list', '/blog')\n    ->to(BlogController::class, 'list');\n```", correct: false }
      - { value: "```php\n$routes->define('blog_list', '/blog')\n    ->action(BlogController::class, 'list');\n```", correct: false }
      - { value: "```php\n$routes->set('blog_list', '/blog')\n    ->handler(BlogController::class, 'list');\n```", correct: false }
    help: |
      The `add()` method of `RoutingConfigurator` is used to define a new route, followed by `controller()` to specify the target.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      When defining a route in a PHP configuration file, if the controller action is implemented as the `__invoke()` method of the controller class, how can you specify the controller?
    answers:
      - { value: "By passing only the controller class name: `->controller(BlogController::class)`", correct: true }
      - { value: "By passing the class name and `__invoke`: `->controller([BlogController::class, '__invoke'])`", correct: false }
      - { value: "By passing the class name with a special suffix: `->controller('App\\Controller\\BlogController::invoke')`", correct: false }
      - { value: "You cannot use `__invoke()` with PHP routing configurators.", correct: false }
    help: |
      If a controller implements `__invoke()`, you can simply provide the class name as the controller.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      What is the recommended way to check if a route exists in Symfony without negatively impacting performance by regenerating the routing cache?
    answers:
      - { value: "Attempt to generate the URL and catch `Symfony\\Component\\Routing\\Exception\\RouteNotFoundException`.", correct: true }
      - { value: "Call `$router->getRouteCollection()->has('route_name')`.", correct: false }
      - { value: "Use `$router->match('url_path')` in a try-catch block.", correct: false }
      - { value: "Check if the route is defined in `config/routes.yaml` directly.", correct: false }
    help: |
      Generating a URL and catching the `RouteNotFoundException` is the most performant way to check for route existence, as it leverages the compiled router.
      https://symfony.com/doc/current/routing.html#checking-for-route-existence

  -
    question: >
      Which of the following is NOT a valid way to define a route alias in Symfony 7?
    answers:
      - { value: "Using the `alias` option in the `#[Route]` attribute.", correct: false }
      - { value: "Using the `alias` key in YAML route definition.", correct: false }
      - { value: "Using the `alias()` method on `RoutingConfigurator` in PHP.", correct: false }
      - { value: "Using the `#[Alias]` attribute on a controller method.", correct: true }
    help: |
      Symfony 7 supports route aliases via the `alias` option in `#[Route]`, the `alias` key in YAML, and the `alias()` method in PHP configurator. There is no `#[Alias]` attribute.
      https://symfony.com/doc/current/routing.html#route-aliases

  -
    question: >
      When deprecating a route alias in Symfony, what information can be provided in the deprecation configuration (e.g., `DeprecatedAlias` attribute or `deprecated` key in YAML)?
    answers:
      - { value: "The `package` name and `version` of the package introducing the deprecation.", correct: true }
      - { value: "A custom `message` for the deprecation, optionally using the `%alias_id%` placeholder.", correct: true }
      - { value: "The date when the alias will be removed.", correct: false }
      - { value: "A list of alternative route names.", correct: false }
    help: |
      Deprecation configuration allows specifying the package, version, and a custom message for the deprecation warning.
      https://symfony.com/doc/current/routing.html#deprecating-route-aliases

  -
    question: >
      To apply an HTTPS scheme requirement to an entire group of imported routes (e.g., all routes from `src/Controller/`), which PHP configurator method would you use?
    answers:
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->schemes(['https']);\n```", correct: true }
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->requireScheme('https');\n```", correct: false }
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->forceHttps();\n```", correct: false }
      - { value: "```php\n$routes->import('../../src/Controller/', 'attribute')\n    ->setScheme('https');\n```", correct: false }
    help: |
      The `schemes()` method on an imported route collection allows setting scheme requirements for all routes within that group.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: |
      Which YAML configuration correctly applies an HTTPS scheme requirement to all routes imported from `src/Controller/`?
    answers:
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    schemes: [https]\n```", correct: true }
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    scheme: https\n```", correct: false }
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    security: https\n```", correct: false }
      - { value: "```yaml\ncontrollers:\n    resource: '../../src/Controller/'\n    type: attribute\n    force_https: true\n```", correct: false }
    help: |
      In YAML, the `schemes` key is used to define scheme requirements for imported routes.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      When importing routes from a directory using PHP attributes, how can you exclude specific files or subdirectories (e.g., `Debug*Controller.php`) from being loaded?
    answers:
      - { value: "By providing an `exclude` option as a string or array of PHP glob patterns to the `import()` method.", correct: true }
      - { value: "By adding a `#[NoRoute]` attribute to the excluded controller classes.", correct: false }
      - { value: "By configuring a `blacklist` option in the routing configuration.", correct: false }
      - { value: "By manually specifying each controller to include, instead of importing the directory.", correct: false }
    help: |
      The `import()` method supports an optional fourth argument for `exclude` patterns.
      https://symfony.com/doc/current/routing.html#excluding-files-or-subdirectories

  -
    question: >
      Which of the following is a valid way to define a route group with a common URL prefix `/admin` and a name prefix `admin_` for all routes within a controller using PHP attributes?
    answers:
      - { value: "```php\n#[Route('/admin', name: 'admin_')]\nclass AdminController extends AbstractController {}\n```", correct: true }
      - { value: "```php\n#[RouteGroup('/admin', namePrefix: 'admin_')]\nclass AdminController extends AbstractController {}\n```", correct: false }
      - { value: "```php\n#[Prefix('/admin'), NamePrefix('admin_')]\nclass AdminController extends AbstractController {}\n```", correct: false }
      - { value: "```php\n#[Route(path: '/admin', id_prefix: 'admin_')]\nclass AdminController extends AbstractController {}\n```", correct: false }
    help: |
      The `#[Route]` attribute can be applied to a controller class to define common options like `path` (prefix) and `name` (prefix) for all routes within that controller.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: |
      In YAML, how do you configure a route group for imported routes, applying a URL prefix `/api` and a name prefix `api_`?
    answers:
      - { value: "```yaml\napi_routes:\n    resource: '../../src/Controller/'\n    type: attribute\n    prefix: /api\n    name_prefix: api_\n```", correct: true }
      - { value: "```yaml\napi_routes:\n    path: /api\n    name: api_\n    import: '../../src/Controller/'\n    type: attribute\n```", correct: false }
      - { value: "```yaml\napi_routes:\n    group:\n        prefix: /api\n        name_prefix: api_\n    resource: '../../src/Controller/'\n    type: attribute\n```", correct: false }
      - { value: "```yaml\napi_routes:\n    resource: '../../src/Controller/'\n    type: attribute\n    url_prefix: /api\n    route_name_prefix: api_\n```", correct: false }
    help: |
      The `prefix` and `name_prefix` options are used directly under the import definition in YAML to group routes.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      You have a route `/products/{id}`. If you want to ensure the `id` parameter is always a positive integer, which requirement would you use in PHP attributes?
    answers:
      - { value: "```php\n#[Route('/products/{id}', name: 'product_detail', requirements: ['id' => '\\\\d+'])]\npublic function detail(int $id): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/products/{id<[1-9]\\\\d*>}', name: 'product_detail')]\npublic function detail(int $id): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/products/{id}', name: 'product_detail', validate: ['id' => 'positive_int'])]\npublic function detail(int $id): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/products/{id}', name: 'product_detail', constraints: ['id' => 'int > 0'])]\npublic function detail(int $id): Response {}\n```", correct: false }
    help: |
      Regular expressions are used to define parameter requirements. `\\d+` matches one or more digits.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary benefit of using `#[Route]` attributes on controller classes for grouping routes?
    answers:
      - { value: "It allows applying common URL prefixes, name prefixes, and requirements to multiple routes within that controller.", correct: true }
      - { value: "It automatically generates a sitemap for all routes in the controller.", correct: false }
      - { value: "It enables lazy loading of controllers, improving performance.", correct: false }
      - { value: "It restricts access to the controller based on user roles.", correct: false }
    help: |
      Class-level `#[Route]` attributes provide a convenient way to define shared configuration for a group of routes.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      When defining a route with a parameter like `/users/{username}`, what happens if the `username` parameter is not provided in the URL and no default value is set?
    answers:
      - { value: "Symfony will throw a `ResourceNotFoundException`.", correct: true }
      - { value: "The `username` parameter will be `null` in the controller.", correct: false }
      - { value: "Symfony will attempt to guess the `username` from the request context.", correct: false }
      - { value: "The route will simply not match.", correct: true }
    help: |
      If a required parameter is missing and no default is provided, the route will not match, leading to a 404 Not Found error.
      https://symfony.com/doc/current/routing.html#route-parameters

  -
    question: >
      Which of the following is a valid way to define a route in a Symfony application using PHP attributes that is only active in the `dev` environment?
    answers:
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', env: 'dev')]\npublic function debugTools(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', environments: ['dev'])]\npublic function debugTools(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', if_env: 'dev')]\npublic function debugTools(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/debug-tools', name: 'dev_tools', condition: \"kernel.environment == 'dev'\")]\npublic function debugTools(): Response {}\n```", correct: false }
    help: |
      The `env` option in the `#[Route]` attribute allows restricting a route to specific environments.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the purpose of the `_fragment` special route parameter?
    answers:
      - { value: "It is used to set the fragment identifier (the part of a URL starting with `#`) for a generated URL.", correct: true }
      - { value: "It defines a partial view or component to be rendered.", correct: false }
      - { value: "It specifies a section within a document to scroll to.", correct: false }
      - { value: "It's an internal parameter for caching route fragments.", correct: false }
    help: |
      The `_fragment` parameter is used when generating URLs to include a hash fragment.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      When generating a URL, if you provide extra parameters that are not defined in the route's path, how does Symfony handle them?
    answers:
      - { value: "They are added as query parameters to the generated URL.", correct: true }
      - { value: "They are ignored.", correct: false }
      - { value: "They cause an error if not explicitly allowed by the route.", correct: false }
      - { value: "They are appended as path segments after the route.", correct: false }
    help: |
      Any parameters passed to `generateUrl()` that are not part of the route's path will be appended as query string parameters.
      https://symfony.com/doc/current/routing.html#extra-parameters-in-urls

  -
    question: >
      What is the significance of the `UrlGeneratorInterface::ABSOLUTE_PATH` constant when generating URLs in Symfony?
    answers:
      - { value: "It generates a URL relative to the web root, starting with a slash (e.g., `/blog/post`).", correct: true }
      - { value: "It generates a full URL including the scheme and host (e.g., `http://example.com/blog/post`).", correct: false }
      - { value: "It generates a URL relative to the current page (e.g., `../post`).", correct: false }
      - { value: "It generates a URL that is always absolute, regardless of the current request.", correct: false }
    help: |
      `ABSOLUTE_PATH` is the default behavior for `generateUrl()` and produces URLs like `/path/to/resource`.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      Which of the following is true about the order of route matching in Symfony?
    answers:
      - { value: "Routes are matched in the order they are defined in the configuration, unless `priority` is explicitly set.", correct: true }
      - { value: "Routes with more specific patterns are always matched before more general patterns, regardless of definition order.", correct: false }
      - { value: "Routes defined in PHP attributes are always matched before routes defined in YAML.", correct: false }
      - { value: "Symfony uses a randomized algorithm to determine route matching order.", correct: false }
    help: |
      The order of route definition matters, but the `priority` option can override this default behavior.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      When importing routes from a controller directory, how can you apply locale-specific URL prefixes (e.g., `/en/` for English, `/nl/` for Dutch)?
    answers:
      - { value: "By providing a map of locales to prefixes in the `prefix` option of the import configuration.", correct: true }
      - { value: "By defining separate import statements for each locale with a fixed prefix.", correct: false }
      - { value: "By using the `#[LocalePrefix]` attribute on the controller classes.", correct: false }
      - { value: "Symfony automatically handles locale prefixes based on the `_locale` parameter.", correct: false }
    help: |
      The `prefix` option for imported routes can accept an associative array mapping locales to their respective prefixes.
      https://symfony.com/doc/current/routing.html#prefixing-routes-based-on-locale

  -
    question: >
      What is the purpose of the `UrlMatcher` class in the Symfony Routing component?
    answers:
      - { value: "To match an incoming request URL path against a collection of defined routes.", correct: true }
      - { value: "To generate URLs based on route names and parameters.", correct: false }
      - { value: "To load route definitions from configuration files.", correct: false }
      - { value: "To validate route parameters against their requirements.", correct: false }
    help: |
      `UrlMatcher` is responsible for finding the best-matching route for a given URL.
      https://symfony.com/doc/current/create_framework/routing.html#matching-urls

  -
    question: >
      Which class represents a single route definition in the Symfony Routing component?
    answers:
      - { value: "`Symfony\\Component\\Routing\\Route`", correct: true }
      - { value: "`Symfony\\Component\\Routing\\RouteDefinition`", correct: false }
      - { value: "`Symfony\\Component\\HttpFoundation\\Route`", correct: false }
      - { value: "`Symfony\\Component\\Routing\\UrlRoute`", correct: false }
    help: |
      The `Route` class encapsulates all information about a single route, including its path, requirements, and defaults.
      https://symfony.com/doc/current/routing/custom_route_loader.html#the-routing-component-api

  -
    question: >
      What is the role of `Symfony\\Component\\Routing\\RouteCollection`?
    answers:
      - { value: "It is a collection of `Route` objects, representing all defined routes in an application.", correct: true }
      - { value: "It's a database table that stores route configurations.", correct: false }
      - { value: "It's an interface for loading routes from various sources.", correct: false }
      - { value: "It's a service that manages route caching.", correct: false }
    help: |
      `RouteCollection` aggregates multiple `Route` objects, forming the complete routing map.
      https://symfony.com/doc/current/routing.html#the-routing-component-api

  -
    question: >
      When debugging routing, what does the `router:match` command typically output if a match is found?
    answers:
      - { value: "The matched route name, controller, and parameters.", correct: true }
      - { value: "The generated URL for the matched route.", correct: false }
      - { value: "A list of all routes that partially match the URL.", correct: false }
      - { value: "Only the HTTP status code for the URL.", correct: false }
    help: |
      `router:match` provides details about the matched route, including its name and the values of its parameters.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the purpose of the `RequestContext` class in Symfony's Routing component?
    answers:
      - { value: "It holds fundamental information about the current request, such as the HTTP method, host, and base URL, which is used by the `UrlMatcher`.", correct: true }
      - { value: "It stores user session data for routing decisions.", correct: false }
      - { value: "It defines the security context for route access.", correct: false }
      - { value: "It's a container for all route parameters.", correct: false }
    help: |
      `RequestContext` provides the necessary context for the router to match incoming requests.
      https://symfony.com/doc/current/create_framework/routing.html#matching-urls

  -
    question: >
      Which of the following is a valid way to define a route in YAML that only accepts `GET` requests?
    answers:
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    methods: [GET]\n```", correct: true }
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    method: GET\n```", correct: false }
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    http_method: GET\n```", correct: false }
      - { value: "```yaml\nmy_route:\n    path: /my-path\n    controller: App\\Controller\\MyController::index\n    request_method: GET\n```", correct: false }
    help: |
      The `methods` key in YAML is used to specify allowed HTTP methods as a list.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      When defining a route using PHP attributes, how can you specify that it should match both `GET` and `POST` requests?
    answers:
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', methods: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', method: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', http_methods: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/data', name: 'data_endpoint', verbs: ['GET', 'POST'])]\npublic function data(): Response {}\n```", correct: false }
    help: |
      The `methods` option in `#[Route]` accepts an array of HTTP method strings.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      What is the default HTTP status code for a temporary redirect configured with Symfony's `RedirectController` without `keepRequestMethod: true`?
    answers:
      - { value: "302 (Found)", correct: true }
      - { value: "307 (Temporary Redirect)", correct: false }
      - { value: "301 (Moved Permanently)", correct: false }
      - { value: "303 (See Other)", correct: false }
    help: |
      By default, temporary redirects use the 302 status code.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      If you have a route `/articles/{_locale}/show` and you want to ensure `_locale` is always `en` or `fr`, which requirement would you add in YAML?
    answers:
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    requirements:\n        _locale: 'en|fr'\n```", correct: true }
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    locale_options: 'en|fr'\n```", correct: false }
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    constraints:\n        _locale: 'en|fr'\n```", correct: false }
      - { value: "```yaml\narticle_show:\n    path: /articles/{_locale}/show\n    controller: App\\Controller\\ArticleController::show\n    locale_regex: 'en|fr'\n```", correct: false }
    help: |
      Requirements for special parameters like `_locale` are defined under the `requirements` key.
      https://symfony.com/doc/current/routing.html#configuring-special-route-parameters

  -
    question: >
      What happens if a route's `condition` expression evaluates to `false`?
    answers:
      - { value: "The route will not be matched, and Symfony will continue to try matching other routes.", correct: true }
      - { value: "Symfony will throw a `ConditionNotMetException`.", correct: false }
      - { value: "The controller associated with the route will still be executed, but with a warning.", correct: false }
      - { value: "The application will return a 403 Forbidden response.", correct: false }
    help: |
      Conditions act as additional filters. If a condition is not met, the route is effectively skipped during the matching process.
      https://symfony.com/doc/current/routing.html#conditional-request-matching

  -
    question: >
      Which command would you use to list all routes, including their aliases?
    answers:
      - { value: "`php bin/console debug:router --show-aliases`", correct: true }
      - { value: "`php bin/console debug:router --with-aliases`", correct: false }
      - { value: "`php bin/console router:list-all`", correct: false }
      - { value: "`php bin/console debug:router --aliases`", correct: false }
    help: |
      The `--show-aliases` option explicitly includes route aliases in the `debug:router` output.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the primary benefit of using `#[AsRoutingConditionService]` for custom routing conditions?
    answers:
      - { value: "It allows you to define complex, reusable routing logic as a service that can be injected and used in `condition` expressions.", correct: true }
      - { value: "It automatically caches the results of the condition, improving performance.", correct: false }
      - { value: "It enables the condition to be evaluated on the client-side.", correct: false }
      - { value: "It provides a graphical interface for building routing conditions.", correct: false }
    help: |
      Custom routing condition services allow encapsulating complex logic, making conditions cleaner and more maintainable.
      https://symfony.com/doc/current/routing.html#expression-language-variables-and-functions

  -
    question: >
      Consider a route `/articles/{year}/{title}.{_format}`. If you access `/articles/2023/my-post.html`, what will be the value of the `_format` parameter in the controller?
    answers:
      - { value: "`html`", correct: true }
      - { value: "`null`", correct: false }
      - { value: "An empty string.", correct: false }
      - { value: "The default format configured for the application.", correct: false }
    help: |
      The `_format` parameter automatically captures the extension part of the URL.
      https://symfony.com/doc/current/routing.html#special-internal-routing-attributes

  -
    question: >
      Which of the following is true regarding route parameters and their corresponding controller arguments?
    answers:
      - { value: "The name of the route parameter in the path must exactly match the name of the argument in the controller method.", correct: true }
      - { value: "Route parameters are automatically type-hinted in the controller based on their requirements.", correct: false }
      - { value: "Controller arguments can be named differently from route parameters, as long as their order matches.", correct: false }
      - { value: "Only scalar types can be used for controller arguments that correspond to route parameters.", correct: false }
    help: |
      For Symfony to automatically inject route parameters into controller arguments, their names must match.
      https://symfony.com/doc/current/routing.html#route-parameters-in-controllers

  -
    question: >
      What is the purpose of the `UrlGenerator` class in the Symfony Routing component?
    answers:
      - { value: "To generate URLs based on a given route name and parameters.", correct: true }
      - { value: "To match incoming URLs to routes.", correct: false }
      - { value: "To load route definitions from configuration files.", correct: false }
      - { value: "To compile the routing cache.", correct: false }
    help: |
      `UrlGenerator` is the counterpart to `UrlMatcher`, handling the creation of URLs from route definitions.
      https://symfony.com/doc/current/create_framework/routing.html#generating-urls

  -
    question: >
      When generating a URL for a route with a dynamic host parameter (e.g., `{subdomain}.example.com`), how do you provide the value for the `subdomain`?
    answers:
      - { value: "By passing it as a regular parameter in the `generateUrl()` method's arguments array.", correct: true }
      - { value: "By setting it in the `RequestContext` before generating the URL.", correct: false }
      - { value: "By defining it as a default value in the route configuration.", correct: false }
      - { value: "It's automatically inferred from the current request's host.", correct: false }
    help: |
      Dynamic host parameters are treated like regular route parameters when generating URLs.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: >
      Which of the following is a valid way to define a route in a PHP configuration file that only accepts `GET` requests?
    answers:
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->methods(['GET']);\n```", correct: true }
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->method('GET');\n```", correct: false }
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->allowMethods('GET');\n```", correct: false }
      - { value: "```php\n$routes->add('my_route', '/my-path')\n    ->controller([MyController::class, 'index'])\n    ->httpMethod('GET');\n```", correct: false }
    help: |
      The `methods()` method on the route configurator is used to specify allowed HTTP methods.
      https://symfony.com/doc/current/routing.html#http-method-requirements

  -
    question: >
      What is the primary function of the `router:debug` command (alias for `debug:router`)?
    answers:
      - { value: "To inspect and troubleshoot the routing configuration of a Symfony application.", correct: true }
      - { value: "To generate a visual graph of all routes.", correct: false }
      - { value: "To clear the routing cache.", correct: false }
      - { value: "To test the performance of route matching.", correct: false }
    help: |
      The `debug:router` command is the main tool for understanding and debugging Symfony's routing system.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      If you define a route `/blog/{page}` and then a route `/blog/new`, and both are configured with PHP attributes in the same controller, what is the default matching behavior if `/blog/new` is requested?
    answers:
      - { value: "The route `/blog/{page}` will be matched first if it's defined before `/blog/new` due to its greedy nature, with `page` being `new`.", correct: true }
      - { value: "The route `/blog/new` will always be matched because it's more specific.", correct: false }
      - { value: "Symfony will throw an ambiguity error.", correct: false }
      - { value: "The route `/blog/{page}` will be matched, but `page` will be `null`.", correct: false }
    help: |
      Without explicit priority, greedy patterns can "eat" more specific paths if defined earlier.
      https://symfony.com/doc/current/routing.html#route-priority

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `name` option?
    answers:
      - { value: "To provide a unique identifier for the route, used for URL generation and referencing.", correct: true }
      - { value: "To define the URL path for the route.", correct: false }
      - { value: "To specify the controller method that handles the route.", correct: false }
      - { value: "To set the title displayed in the browser tab for the route.", correct: false }
    help: |
      The `name` option is essential for generating URLs and referring to routes programmatically.
      https://symfony.com/doc/current/routing.html#defining-routes-as-php-attributes

  -
    question: >
      Which of the following describes a scenario where `UrlGeneratorInterface::ABSOLUTE_URL` would be most appropriate for generating a URL?
    answers:
      - { value: "Generating a link in an email or an RSS feed where the full domain is required.", correct: true }
      - { value: "Generating a link within the same Symfony application to navigate between pages.", correct: false }
      - { value: "Generating a path for an asset (e.g., an image) within a Twig template.", correct: false }
      - { value: "Generating a URL for a console command.", correct: false }
    help: |
      `ABSOLUTE_URL` is used when the generated URL needs to be fully qualified with the scheme and host.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      What is the impact of marking a route as `stateless: true`?
    answers:
      - { value: "It prevents Symfony from starting or using a session for requests matching this route, which can improve caching.", correct: true }
      - { value: "It makes the route accessible without any authentication or authorization.", correct: false }
      - { value: "It forces the route to use HTTP/2 protocol.", correct: false }
      - { value: "It disables all logging for requests to this route.", correct: false }
    help: |
      Stateless routes are optimized for caching by ensuring no session-related headers are sent.
      https://symfony.com/doc/current/routing.html#stateless-routes

  -
    question: >
      If you have a route `/articles/{year}/{slug}` and you want to ensure `year` is a 4-digit number and `slug` contains only lowercase letters, numbers, and hyphens, how would you configure this in PHP attributes?
    answers:
      - { value: "```php\n#[Route('/articles/{year}/{slug}', name: 'article_show', requirements: ['year' => '\\\\d{4}', 'slug' => '[a-z0-9-]+'])]\npublic function show(int $year, string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/articles/{year<\\\\d{4}>}/{slug<[a-z0-9-]+>}', name: 'article_show')]\npublic function show(int $year, string $slug): Response {}\n```", correct: true }
      - { value: "```php\n#[Route('/articles/{year}/{slug}', name: 'article_show', regex: ['year' => '\\\\d{4}', 'slug' => '[a-z0-9-]+'])]\npublic function show(int $year, string $slug): Response {}\n```", correct: false }
      - { value: "```php\n#[Route('/articles/{year}/{slug}', name: 'article_show', types: ['year' => 'int:4', 'slug' => 'slug_string'])]\npublic function show(int $year, string $slug): Response {}\n```", correct: false }
    help: |
      Multiple requirements can be defined for different parameters within the `requirements` option or inline.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary benefit of using `RoutingConfigurator` in PHP files for defining routes compared to YAML or XML?
    answers:
      - { value: "It provides a fluent interface for defining routes programmatically, allowing for more complex logic and dynamic route generation.", correct: true }
      - { value: "It is the only way to define routes that use PHP attributes.", correct: false }
      - { value: "It offers better performance due to direct PHP execution without parsing.", correct: false }
      - { value: "It allows defining routes that are not tied to specific controllers.", correct: false }
    help: |
      The PHP routing configurator offers a powerful and flexible way to define routes with programmatic control.
      https://symfony.com/doc/current/routing.html#defining-routes-in-php-files

  -
    question: >
      When debugging routing, what does the `router:match` command tell you if a URL does NOT match any defined route?
    answers:
      - { value: "It will indicate that no route was found for the given path.", correct: true }
      - { value: "It will suggest alternative routes that are similar to the provided URL.", correct: false }
      - { value: "It will list all routes that were attempted but failed to match.", correct: false }
      - { value: "It will return a 404 HTTP status code.", correct: false }
    help: |
      If no route matches, `router:match` will explicitly state that no route was found.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      What is the purpose of the `#[Route]` attribute's `host` option?
    answers:
      - { value: "To restrict the route to match only requests coming from a specific hostname or a pattern of hostnames.", correct: true }
      - { value: "To define the default host for generated URLs.", correct: false }
      - { value: "To specify the server IP address where the route is hosted.", correct: false }
      - { value: "To set the virtual host configuration for the web server.", correct: false }
    help: |
      The `host` option enables host-based routing, allowing different routes for different domains or subdomains.
      https://symfony.com/doc/current/routing.html#host-based-routing

  -
    question: >
      Which of the following is true about route requirements in Symfony?
    answers:
      - { value: "They are regular expressions used to validate the format of route parameters.", correct: true }
      - { value: "They define the minimum and maximum length of route parameters.", correct: false }
      - { value: "They specify the data type of route parameters (e.g., string, int).", correct: false }
      - { value: "They are used to define default values for optional route parameters.", correct: false }
    help: |
      Requirements are powerful tools for ensuring that route parameters conform to expected patterns.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::RELATIVE_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the current request's path (e.g., `../sibling-page`).", correct: true }
      - { value: "It generates a URL relative to the web root, starting with a slash (e.g., `/blog/post`).", correct: false }
      - { value: "It generates a full URL including the scheme and host.", correct: false }
      - { value: "It is an alias for `ABSOLUTE_PATH`.", correct: false }
    help: |
      `RELATIVE_PATH` is useful for generating URLs that are relative to the current location, often for internal navigation.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When defining a route with a parameter, what is the significance of the `<` and `>` characters in the path (e.g., `/blog/{page<\\\\d+>}`)?
    answers:
      - { value: "They are used to embed inline regular expression requirements for the parameter.", correct: true }
      - { value: "They indicate that the parameter is optional.", correct: false }
      - { value: "They define the default value for the parameter.", correct: false }
      - { value: "They are used for type hinting the parameter in the controller.", correct: false }
    help: |
      Inline requirements provide a concise way to define regular expressions directly within the route path.
      https://symfony.com/doc/current/routing.html#route-parameters-requirements

  -
    question: >
      What is the primary purpose of the `#[Route]` attribute's `schemes` option?
    answers:
      - { value: "To restrict the route to match only requests using specific URL schemes (e.g., `http`, `https`).", correct: true }
      - { value: "To define the default scheme for generated URLs.", correct: false }
      - { value: "To specify the security protocols allowed for the route.", correct: false }
      - { value: "To enable or disable HTTP/2 for the route.", correct: false }
    help: |
      The `schemes` option ensures that a route is only matched if the request uses one of the specified schemes.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      Which of the following is a valid way to define a route in YAML that only accepts HTTPS requests?
    answers:
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    schemes: [https]\n```", correct: true }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    scheme: https\n```", correct: false }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    secure: true\n```", correct: false }
      - { value: "```yaml\nsecure_page:\n    path: /secure\n    controller: App\\Controller\\SecureController::index\n    protocol: https\n```", correct: false }
    help: |
      The `schemes` key in YAML is used to define scheme requirements as a list.
      https://symfony.com/doc/current/routing.html#forcing-a-scheme-https

  -
    question: >
      What is the main advantage of using route aliases in Symfony?
    answers:
      - { value: "To provide backward compatibility when route names change, allowing old names to still work.", correct: true }
      - { value: "To create multiple URLs for the same route, improving SEO.", correct: false }
      - { value: "To define routes that can be accessed without a controller.", correct: false }
      - { value: "To simplify the process of generating localized URLs.", correct: false }
    help: |
      Route aliases are primarily used for smooth transitions when refactoring route names.
      https://symfony.com/doc/current/routing.html#route-aliases

  -
    question: >
      When configuring a route alias, what information can be provided in the deprecation configuration (e.g., `DeprecatedAlias` attribute or `deprecated` key in YAML)?
    answers:
      - { value: "The `package` name and `version` of the package introducing the deprecation.", correct: true }
      - { value: "A custom `message` for the deprecation, optionally using the `%alias_id%` placeholder.", correct: true }
      - { value: "The date when the alias will be removed.", correct: false }
      - { value: "A list of alternative route names.", correct: false }
    help: |
      Deprecation configuration allows specifying the package, version, and a custom message for the deprecation warning.
      https://symfony.com/doc/current/routing.html#deprecating-route-aliases

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepQueryParams: true`?
    answers:
      - { value: "It preserves the original query string parameters when redirecting to the target URL or route.", correct: true }
      - { value: "It ensures that the redirect is always a GET request, even if the original was POST.", correct: false }
      - { value: "It appends a unique query parameter to prevent caching of the redirect.", correct: false }
      - { value: "It only redirects if query parameters are present in the original request.", correct: false }
    help: |
      `keepQueryParams: true` is useful for maintaining context across redirects.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following is true about localized routes in Symfony?
    answers:
      - { value: "They allow defining different URL paths for the same route name based on the active locale.", correct: true }
      - { value: "They automatically translate the content of the page based on the route.", correct: false }
      - { value: "They require a separate controller for each locale.", correct: false }
      - { value: "They are only supported when using the `_locale` parameter in the URL.", correct: false }
    help: |
      Localized routes provide flexibility in URL structure for internationalized applications.
      https://symfony.com/doc/current/routing.html#define-localized-routes

  -
    question: >
      What is the purpose of the `env` option in a Symfony route definition (PHP attributes or YAML)?
    answers:
      - { value: "To make the route active only in a specific Symfony environment (e.g., `dev`, `prod`).", correct: true }
      - { value: "To define environment variables that are accessible within the route's controller.", correct: false }
      - { value: "To specify the deployment environment for the route.", correct: false }
      - { value: "To set the default environment for generated URLs.", correct: false }
    help: |
      The `env` option provides fine-grained control over route activation based on the application environment.
      https://symfony.com/doc/current/routing.html#environment-specific-routes

  -
    question: >
      What is the primary benefit of using `php bin/console debug:router` during development?
    answers:
      - { value: "It helps in quickly identifying and troubleshooting issues related to route matching and URL generation.", correct: true }
      - { value: "It automatically fixes routing errors in configuration files.", correct: false }
      - { value: "It generates a visual map of all routes in the application.", correct: false }
      - { value: "It optimizes the routing cache for production environments.", correct: false }
    help: |
      The `debug:router` command is an indispensable tool for developers working with Symfony routing.
      https://symfony.com/doc/current/routing.html#router-debugging

  -
    question: >
      When using the `RedirectController`, what is the effect of setting `keepRequestMethod: true` for a temporary redirect?
    answers:
      - { value: "It changes the redirect status code from 302 to 307, preserving the HTTP method.", correct: true }
      - { value: "It forces the redirect to always be a GET request.", correct: false }
      - { value: "It ensures that the original request body is also sent with the redirect.", correct: false }
      - { value: "It prevents the browser from caching the redirect.", correct: false }
    help: |
      The 307 status code is specifically for temporary redirects that preserve the request method.
      https://symfony.com/doc/current/routing.html#redirecting-routes

  -
    question: >
      Which of the following describes the `_route_params` attribute available on the `Request` object?
    answers:
      - { value: "An array containing all matched route parameters for the current request.", correct: true }
      - { value: "A string representing the current route's path.", correct: false }
      - { value: "The name of the currently matched route.", correct: false }
      - { value: "A collection of all query parameters from the request.", correct: false }
    help: |
      The `_route_params` attribute provides programmatic access to the values of the parameters that were matched by the router.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the primary purpose of the `_route` attribute available on the `Request` object?
    answers:
      - { value: "It holds the name of the currently matched route.", correct: true }
      - { value: "It contains the full URL of the current request.", correct: false }
      - { value: "It stores the controller and action executed for the current request.", correct: false }
      - { value: "It provides access to the routing configuration.", correct: false }
    help: |
      The `_route` attribute is a convenient way to get the name of the route that was successfully matched.
      https://symfony.com/doc/current/routing.html#accessing-route-name-and-parameters-from-request-object

  -
    question: >
      What is the main benefit of organizing routes into groups using prefixes and name prefixes?
    answers:
      - { value: "It improves the readability and maintainability of routing configurations, especially for large applications.", correct: true }
      - { value: "It significantly reduces the size of the compiled routing cache.", correct: false }
      - { value: "It enables automatic generation of API documentation.", correct: false }
      - { value: "It enhances security by isolating routes.", correct: false }
    help: |
      Route grouping helps in managing complex routing setups by applying common configurations.
      https://symfony.com/doc/current/routing.html#defining-route-groups

  -
    question: >
      What is the purpose of the `UrlGeneratorInterface::NETWORK_PATH` constant when generating URLs?
    answers:
      - { value: "It generates a URL relative to the scheme (e.g., `//example.com/blog/post`), useful for avoiding mixed content warnings.", correct: true }
      - { value: "It generates a URL that is only accessible within the local network.", correct: false }
      - { value: "It generates a URL that uses a specific network protocol (e.g., FTP).", correct: false }
      - { value: "It is an alias for `ABSOLUTE_URL` but without the scheme.", correct: false }
    help: |
      `NETWORK_PATH` creates protocol-relative URLs, which adapt to the current scheme (HTTP or HTTPS).
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: >
      When using the `RedirectController`, what is the effect of