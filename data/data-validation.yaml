category: Data Validation
questions:
  - question: Which service is primarily responsible for performing validation
      checks on objects or values in Symfony?
    answers:
      - value: "`validator`"
        correct: true
      - value: "`validation_factory`"
        correct: false
      - value: "`form.validator`"
        correct: false
      - value: "`constraint_builder`"
        correct: false
    help: The `validator` service (an instance of
      `Symfony\Component\Validator\Validator\ValidatorInterface`) is the main
      entry point for all validation operations in Symfony.
  - question: Given the following PHP attribute, what is the purpose of the
      `#[Assert\NotBlank]` constraint?
    answers:
      - value: To ensure a string is not empty.
        correct: true
      - value: To check if a value is not null.
        correct: true
      - value: To verify that a collection is not blank.
        correct: true
      - value: To validate that a number is greater than zero.
        correct: false
    help: The `NotBlank` constraint asserts that the value is not blank. A blank
      value is defined as null, an empty string, or an array with no elements.
  - question: Which of the following are valid ways to define validation constraints
      for a Symfony entity in Symfony 7?
    answers:
      - value: PHP Attributes
        correct: true
      - value: YAML configuration files
        correct: true
      - value: XML configuration files
        correct: true
      - value: Through a static `loadValidatorMetadata` method in the entity class
        correct: true
      - value: Directly in the entity's constructor
        correct: false
    help: Symfony supports defining validation constraints using PHP attributes,
      YAML, XML, or programmatically via a static `loadValidatorMetadata`
      method.
  - question: You have an `Author` object with constraints defined for the
      `registration` group. How would you validate this object, applying only
      the constraints belonging to the `registration` group?
    answers:
      - value: |-
          ```php
          $errors = $validator->validate($author, null, ['registration']);
          ```
        correct: true
      - value: |-
          ```php
          $errors = $validator->validate($author, ['groups' => 'registration']);
          ```
        correct: false
      - value: |-
          ```php
          $errors = $validator->validate($author)->forGroup('registration');
          ```
        correct: false
      - value: >-
          ```php

          $errors = $validator->validate($author, new
          Assert\Group('registration'));

          ```
        correct: false
    help: The `validate()` method of `ValidatorInterface` accepts an optional third
      argument, which is a string or an array of strings representing the
      validation groups to apply.
  - question: After validating an object, you receive a `$errors` variable of type
      `ConstraintViolationListInterface`. How can you easily get a string
      representation of all validation errors for debugging purposes?
    answers:
      - value: |-
          ```php
          $errorsString = (string) $errors;
          ```
        correct: true
      - value: |-
          ```php
          $errorsString = $errors->toString();
          ```
        correct: false
      - value: |-
          ```php
          $errorsString = implode('\n', $errors->getMessages());
          ```
        correct: false
      - value: |-
          ```php
          $errorsString = json_encode($errors->toArray());
          ```
        correct: false
    help: The `ConstraintViolationList` object (which implements
      `ConstraintViolationListInterface`) has a `__toString()` method that
      provides a convenient string representation of all violations.
  - question: Which of the following `Length` constraint options would ensure a
      string value is exactly 10 characters long?
    answers:
      - value: |-
          ```php
          new Assert\Length(exactly: 10)
          ```
        correct: true
      - value: |-
          ```php
          new Assert\Length(min: 10, max: 10)
          ```
        correct: true
      - value: |-
          ```php
          new Assert\Length(10)
          ```
        correct: true
      - value: |-
          ```php
          new Assert\Length(value: 10)
          ```
        correct: false
    help: The `exactly` option sets the exact required length. If no named argument
      is provided, the first argument is treated as the `exactly` value. Setting
      both `min` and `max` to the same value also achieves this.
  - question: To implement a custom class-level validation method within an entity,
      what interface should the method accept as its first argument?
    answers:
      - value: "`Symfony\\Component\\Validator\\Context\\ExecutionContextInterface`"
        correct: true
      - value: "`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`"
        correct: false
      - value: "`Symfony\\Component\\HttpFoundation\\Request`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\ConstraintViolationListInterface`"
        correct: false
    help: Custom callback validation methods defined within a class must accept
      `ExecutionContextInterface` as their first argument to allow access to the
      validation context and to build violations.
  - question: Consider a `User` entity where you want to validate `username` and
      `password` first (default group), and only if they are valid, then check
      if the `password` is 'safe' (e.g., not matching the username) using a
      `Strict` group. How would you define this group sequence using PHP
      attributes?
    answers:
      - value: |-
          ```php
          #[Assert\GroupSequence(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          #[Assert\GroupSequenceProvider(groups: ['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\SequentialValidation(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\ValidationSequence(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: false
    help: The `#[Assert\GroupSequence]` attribute is used at the class level to
      define an ordered sequence of validation groups. Validation stops at the
      first group where a violation is found.
  - question: How would you validate a single scalar value, such as an email string,
      using the Symfony Validator component without an entity object?
    answers:
      - value: >-
          ```php

          use Symfony\Component\Validator\Constraints as Assert;

          use Symfony\Component\Validator\Validator\ValidatorInterface;


          // ...

          public function validateEmail(string $email, ValidatorInterface
          $validator): void

          {
              $emailConstraint = new Assert\Email();
              $errors = $validator->validate($email, $emailConstraint);
              // ...
          }

          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\Validator\Constraints as Assert;
          use Symfony\Component\Validator\Validation;

          // ...
          public function validateEmail(string $email): void
          {
              $validator = Validation::createValidator();
              $errors = $validator->validate($email, new Assert\Email());
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          $errors = $validator->validateScalar($email, 'email');
          ```
        correct: false
      - value: |-
          ```php
          $errors = $validator->validateValue($email, ['Email']);
          ```
        correct: false
    help: The `validate()` method of the `ValidatorInterface` can be used to
      validate any value (scalar, array, or object) by passing the value and the
      specific constraint(s) to apply.
  - question: What is the primary purpose of the `#[Assert\Valid]` constraint when
      applied to a property in a Symfony entity?
    answers:
      - value: To ensure that the object assigned to that property is itself validated.
        correct: true
      - value: To mark the property as valid if it's not null.
        correct: false
      - value: To apply a default set of validation rules to the property.
        correct: false
      - value: To skip validation for the property if it's already valid.
        correct: false
    help: The `Valid` constraint is used to cascade validation to nested objects.
      When applied to a property, it tells the validator to also validate the
      object assigned to that property.
  - question: "Which of the following YAML configurations correctly applies a
      `NotBlank` constraint and a `Length` constraint (min: 4) to the
      `firstName` property of an `App\\Entity\\Author` class?"
    answers:
      - value: |-
          ```yaml
          # config/validator/validation.yaml
          App\Entity\Author:
              properties:
                  firstName:
                      - NotBlank: ~
                      - Length:
                          min: 4
          ```
        correct: true
      - value: |-
          ```yaml
          # config/validator/validation.yaml
          App\Entity\Author:
              firstName:
                  NotBlank: ~
                  Length:
                      min: 4
          ```
        correct: false
      - value: |-
          ```yaml
          # config/validator/validation.yaml
          App\Entity\Author:
              constraints:
                  firstName:
                      - NotBlank: ~
                      - Length:
                          min: 4
          ```
        correct: false
      - value: |-
          ```yaml
          # config/validator/validation.yaml
          App\Entity\Author:
              validation:
                  firstName:
                      - NotBlank: ~
                      - Length:
                          min: 4
          ```
        correct: false
    help: In YAML validation configuration, constraints for properties are defined
      under the `properties` key, with each property listing its constraints as
      an array of mappings.
  - question: When building a custom validation violation using
      `ExecutionContextInterface`, what is the purpose of the `atPath()` method?
    answers:
      - value: To specify the property path where the violation occurred.
        correct: true
      - value: To set the URL path for the violation message.
        correct: false
      - value: To define the file path of the violating class.
        correct: false
      - value: To add a custom attribute to the violation.
        correct: false
    help: The `atPath()` method allows you to specify the property path relative to
      the validated object where the violation should be reported. This is
      crucial for accurate error reporting.
  - question: Which built-in Symfony constraint is used to validate that a string
      value is a valid email address?
    answers:
      - value: "`#[Assert\\Email]`"
        correct: true
      - value: "`#[Assert\\IsEmail]`"
        correct: false
      - value: "`#[Assert\\Mail]`"
        correct: false
      - value: "`#[Assert\\Address]`"
        correct: false
    help: The `Email` constraint is specifically designed to validate if a given
      string is a syntactically valid email address.
  - question: When no specific validation groups are provided to the
      `ValidatorInterface::validate()` method, which group's constraints are
      applied by default?
    answers:
      - value: "`Default`"
        correct: true
      - value: "`All`"
        correct: false
      - value: "`Standard`"
        correct: false
      - value: No groups are applied.
        correct: false
    help: By default, if no groups are specified, only constraints belonging to the
      `Default` validation group are applied. The `Valid` constraint is an
      exception as it always applies by default.
  - question: What is the primary purpose of implementing
      `Symfony\Component\Validator\GroupSequenceProviderInterface` on an entity?
    answers:
      - value: To dynamically determine which validation groups should be applied based
          on the object's state.
        correct: true
      - value: To define a fixed, ordered sequence of validation groups for the entity.
        correct: false
      - value: To provide custom error messages for validation group failures.
        correct: false
      - value: To register new validation groups with the validator.
        correct: false
    help: The `GroupSequenceProviderInterface` allows an object to provide a dynamic
      group sequence at runtime, enabling conditional validation based on the
      object's properties or state.
  - question: When defining a custom callback validator method, what is the
      significance of the second optional argument, `$payload`?
    answers:
      - value: It allows passing arbitrary custom data to the validator.
        correct: true
      - value: It contains the validated value.
        correct: false
      - value: It holds the constraint instance being validated.
        correct: false
      - value: It is deprecated in Symfony 7.
        correct: false
    help: The `$payload` argument is an optional parameter that can be passed to a
      callback validator, allowing you to attach arbitrary custom data to the
      validation process, which can be useful for more complex validation
      scenarios.
  - question: You need to validate an array of data, ensuring specific keys exist
      and have certain types or lengths. Which built-in Symfony constraint is
      best suited for this task?
    answers:
      - value: "`#[Assert\\Collection]`"
        correct: true
      - value: "`#[Assert\\Array]`"
        correct: false
      - value: "`#[Assert\\Map]`"
        correct: false
      - value: "`#[Assert\\Hash]`"
        correct: false
    help: The `Collection` constraint is designed to validate arrays, allowing you
      to define constraints for specific keys within the array and handle
      optional or missing keys.
  - question: Which of the following code snippets correctly defines a `NotBlank`
      constraint for the `firstName` property of an `Author` class using the
      `loadValidatorMetadata` static method?
    answers:
      - value: >-
          ```php

          // src/Entity/Author.php

          namespace App\Entity;


          use Symfony\Component\Validator\Constraints as Assert;

          use Symfony\Component\Validator\Mapping\ClassMetadata;


          class Author

          {
              private string $firstName;

              public static function loadValidatorMetadata(ClassMetadata $metadata): void
              {
                  $metadata->addPropertyConstraint('firstName', new Assert\NotBlank());
              }
          }

          ```
        correct: true
      - value: >-
          ```php

          // src/Entity/Author.php

          namespace App\Entity;


          use Symfony\Component\Validator\Constraints as Assert;

          use Symfony\Component\Validator\Mapping\ClassMetadata;


          class Author

          {
              private string $firstName;

              public function __construct(ClassMetadata $metadata)
              {
                  $metadata->addPropertyConstraint('firstName', new Assert\NotBlank());
              }
          }

          ```
        correct: false
      - value: >-
          ```php

          // src/Entity/Author.php

          namespace App\Entity;


          use Symfony\Component\Validator\Constraints as Assert;


          class Author

          {
              private string $firstName;

              #[Assert\NotBlank]
              public static function loadValidatorMetadata(ClassMetadata $metadata): void
              {
                  // ...
              }
          }

          ```
        correct: false
    help: The `loadValidatorMetadata` static method is used to programmatically
      define constraints. You use `ClassMetadata::addPropertyConstraint()` to
      add constraints to properties.
  - question: When building a validation violation, what is the purpose of the
      `setParameter()` method?
    answers:
      - value: To replace placeholders in the violation message with dynamic values.
        correct: true
      - value: To define the severity level of the violation.
        correct: false
      - value: To set a custom error code for the violation.
        correct: false
      - value: To specify the validation group for the violation.
        correct: false
    help: The `setParameter()` method allows you to define values for placeholders
      (e.g., `{{ limit }}`, `{{ value }}`) within your constraint's error
      message, making the messages more informative.
  - question: What is the correct signature for the `validate()` method of the
      `ValidatorInterface` in Symfony 7?
    answers:
      - value: |-
          ```php
          validate(
            $value: object,
            $constraints: ?Constraint = null,
            $groups: array|string|null = null
          ): ConstraintViolationListInterface
          ```
        correct: true
      - value: |-
          ```php
          validate(
            $value: mixed,
            $constraints: ?Constraint = null,
            $groups: array|string|null = null
          ): ConstraintViolationListInterface
          ```
        correct: true
      - value: |-
          ```php
          validate(
            $value: object|array|string|int|float|bool,
            $constraints: ?Constraint = null,
            $groups: array|string|null = null
          ): ConstraintViolationListInterface
          ```
        correct: true
      - value: |-
          ```php
          validate(
            $value: object,
            $constraints: Constraint[] = [],
            $groups: array = []
          ): ConstraintViolationListInterface
          ```
        correct: false
    help: The `validate()` method can accept any `mixed` value for validation, not
      just objects. The `$constraints` and `$groups` arguments are optional,
      allowing for flexible validation scenarios.
  - question: You have a `Product` entity with a `category` property that must be
      one of 'electronics', 'books', or 'clothing'. Which constraint would you
      use to enforce this, and how would you configure it?
    answers:
      - value: |-
          ```php
          #[Assert\Choice(choices: ['electronics', 'books', 'clothing'])]
          private string $category;
          ```
        correct: true
      - value: |-
          ```php
          #[Assert\InArray(values: ['electronics', 'books', 'clothing'])]
          private string $category;
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\Enum(enumClass: CategoryEnum::class)]
          private string $category;
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\OneOf(options: ['electronics', 'books', 'clothing'])]
          private string $category;
          ```
        correct: false
    help: The `Choice` constraint ensures that the value of a property is one of a
      predefined set of choices. The `choices` option accepts an array of valid
      values.
  - question: In a Symfony Form, how can you dynamically determine the validation
      groups to apply based on the submitted data?
    answers:
      - value: By providing a `Closure` to the `validation_groups` option in
          `configureOptions()`.
        correct: true
      - value: By implementing `GroupSequenceProviderInterface` on the form type.
        correct: false
      - value: By overriding the `getValidationGroups()` method in the form type.
        correct: false
      - value: By using a data transformer to set the groups.
        correct: false
    help: The `validation_groups` option in a form's `configureOptions()` method can
      accept a `Closure` that receives the `FormInterface` object, allowing you
      to inspect the form data and return the appropriate validation groups
      dynamically.
  - question: When defining a group sequence using
      `#[Assert\GroupSequence(['GroupA', ['GroupB', 'GroupC'], 'GroupD'])]`,
      what is the behavior if violations occur within `GroupB` or `GroupC`?
    answers:
      - value: All constraints in `GroupB` and `GroupC` will be validated, even if
          violations occur, before proceeding to `GroupD`.
        correct: true
      - value: Validation will stop immediately if any violation is found in `GroupB` or
          `GroupC`.
        correct: false
      - value: Only `GroupB` will be validated, and `GroupC` will be skipped if `GroupB`
          has violations.
        correct: false
      - value: "`GroupB` and `GroupC` are treated as separate, non-sequential groups."
        correct: false
    help: A nested array within a `GroupSequence` means that all groups within that
      nested array will be validated, even if violations occur, before the
      validator moves on to the next top-level group in the sequence.
  - question: What is the correct class that a custom constraint validator must
      extend in Symfony?
    answers:
      - value: "`Symfony\\Component\\Validator\\ConstraintValidator`"
        correct: true
      - value: "`Symfony\\Component\\Validator\\AbstractValidator`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\BaseValidator`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\Validator`"
        correct: false
    help: All custom constraint validators must extend
      `Symfony\Component\Validator\ConstraintValidator`, which provides access
      to the validation context and helper methods.
  - question: After building a validation violation using `buildViolation()` and
      setting its parameters, what is the final method you must call on the
      violation builder to register the violation with the validation context?
    answers:
      - value: "`addViolation()`"
        correct: true
      - value: "`commit()`"
        correct: false
      - value: "`dispatch()`"
        correct: false
      - value: "`save()`"
        correct: false
    help: The `addViolation()` method is the final step in the violation building
      process, which adds the constructed violation to the
      `ConstraintViolationList`.
  - question: Consider the `#[Assert\Regex]` constraint. If you set the `match`
      option to `false`, what does it signify?
    answers:
      - value: Validation passes if the given string does NOT match the pattern.
        correct: true
      - value: Validation passes if the given string exactly matches the pattern.
        correct: false
      - value: The pattern is case-insensitive.
        correct: false
      - value: The pattern is treated as a literal string, not a regex.
        correct: false
    help: The `match` option (defaulting to `true`) determines if the validation
      passes when the string matches the pattern. Setting it to `false` inverts
      this logic, meaning validation passes if the string *does not* match the
      pattern.
  - question: Which of the following XML configurations correctly applies a
      `NotBlank` constraint to the `name` property of an `App\Entity\Author`
      class?
    answers:
      - value: |-
          ```xml
          <!-- config/validator/validation.xml -->
          <class name="App\Entity\Author">
              <property name="name">
                  <constraint name="NotBlank"/>
              </property>
          </class>
          ```
        correct: true
      - value: |-
          ```xml
          <!-- config/validator/validation.xml -->
          <entity name="App\Entity\Author">
              <field name="name">
                  <constraint name="NotBlank"/>
              </field>
          </entity>
          ```
        correct: false
      - value: |-
          ```xml
          <!-- config/validator/validation.xml -->
          <mapping class="App\Entity\Author">
              <property name="name" constraint="NotBlank"/>
          </mapping>
          ```
        correct: false
      - value: |-
          ```xml
          <!-- config/validator/validation.xml -->
          <constraint-definition class="App\Entity\Author">
              <property name="name">
                  <NotBlank/>
              </property>
          </constraint-definition>
          ```
        correct: false
    help: In XML validation configuration, constraints are defined within
      `<property>` tags nested inside `<class>` tags, using `<constraint
      name="ConstraintName"/>`.
  - question: What is the recommended way to get an instance of the Symfony
      Validator service in a controller or service?
    answers:
      - value: Autowiring `Symfony\Component\Validator\Validator\ValidatorInterface`
        correct: true
      - value: "`$this->get('validator')` (if extending `AbstractController`)"
        correct: true
      - value: "`Validation::createValidator()`"
        correct: false
      - value: "`new Validator()`"
        correct: false
    help: The recommended way is to autowire `ValidatorInterface`. If extending
      `AbstractController`, the `get()` method can also retrieve the `validator`
      service. `Validation::createValidator()` is for standalone component
      usage, not typically within a full Symfony application.
  - question: You have a collection (e.g., an array or `Countable` object) and need
      to ensure it contains at least 3 but no more than 10 elements. Which
      constraint and options would you use?
    answers:
      - value: |-
          ```php
          #[Assert\Count(min: 3, max: 10)]
          ```
        correct: true
      - value: |-
          ```php
          #[Assert\CollectionSize(min: 3, max: 10)]
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\Range(min: 3, max: 10, property: 'count')]
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\Length(min: 3, max: 10)]
          ```
        correct: false
    help: The `Count` constraint is used to validate the number of elements in a
      collection. It provides `min` and `max` options to define the allowed
      range.
  - question: How would you set validation groups for a form created directly in a
      Symfony controller?
    answers:
      - value: |-
          ```php
          $form = $this->createFormBuilder($user, [
              'validation_groups' => ['registration'],
          ])->add(/* ... */);
          ```
        correct: true
      - value: |-
          ```php
          $form = $this->createFormBuilder($user)->setValidationGroups(['registration'])->add(/* ... */);
          ```
        correct: false
      - value: >-
          ```php

          $form = $this->createFormBuilder($user)->add(/* ... */,
          ['validation_groups' => ['registration']]);

          ```
        correct: false
      - value: >-
          ```php

          $form =
          $this->createFormBuilder($user)->setOptions(['validation_groups' =>
          ['registration']])->add(/* ... */);

          ```
        correct: false
    help: When creating a form builder, you can pass an array of options as the
      second argument, including `validation_groups` to specify which groups
      should be validated.
  - question: In a Symfony `GroupSequence`, what happens if a violation is found in
      an earlier group within the sequence?
    answers:
      - value: Validation stops, and subsequent groups in the sequence are not
          validated.
        correct: true
      - value: Validation continues to all subsequent groups, and all violations are
          collected.
        correct: false
      - value: The validator attempts to fix the violation before proceeding.
        correct: false
      - value: The group with the violation is skipped, and the next group is validated.
        correct: false
    help: A key characteristic of a `GroupSequence` (when defined as a simple array)
      is that validation is sequential. If any constraint in an earlier group
      fails, the validation process stops, and subsequent groups are not
      checked.
  - question: When implementing the `validate()` method for a custom constraint
      validator, why is it important to check the type of the `$value` argument
      and throw an `UnexpectedValueException` if it's not the expected type?
    answers:
      - value: To ensure the validator can only process values it's designed for,
          preventing unexpected behavior.
        correct: true
      - value: To provide a clear error message to the developer during debugging.
        correct: true
      - value: To automatically convert the value to the correct type.
        correct: false
      - value: To skip validation if the value's type is incorrect.
        correct: false
    help: Throwing an `UnexpectedValueException` when the `$value` is not of the
      expected type signals that the validator cannot handle the given input,
      which helps in debugging and ensures the validator operates on valid data
      types.
  - question: How can you set a custom translation domain for a specific validation
      violation when building it within a custom validator?
    answers:
      - value: |-
          ```php
          $this->context->buildViolation($constraint->message)
              ->setTranslationDomain('validation_errors')
              ->addViolation();
          ```
        correct: true
      - value: >-
          ```php

          $this->context->buildViolation($constraint->message, domain:
          'validation_errors')
              ->addViolation();
          ```
        correct: false
      - value: >-
          ```php

          $this->context->addViolation($constraint->message, ['domain' =>
          'validation_errors']);

          ```
        correct: false
      - value: |-
          ```php
          $this->context->setTranslationDomain('validation_errors')->buildViolation($constraint->message)->addViolation();
          ```
        correct: false
    help: The `setTranslationDomain()` method on the violation builder allows you to
      specify a custom translation domain for that particular violation,
      overriding the default domain.
  - question: Which built-in Symfony constraint is used to validate that a string
      represents a valid CSS color (e.g., `#RRGGBB`, `rgb(R,G,B)`, `hsl(H,S,L)`,
      or named colors)?
    answers:
      - value: "`#[Assert\\CssColor]`"
        correct: true
      - value: "`#[Assert\\Color]`"
        correct: false
      - value: "`#[Assert\\HexColor]`"
        correct: false
      - value: "`#[Assert\\RgbColor]`"
        correct: false
    help: The `CssColor` constraint specifically validates if a string is a valid
      CSS color notation.
  - question: You want to apply a constraint to a property only if a certain
      condition is met (e.g., validate a `discountValue` only if `discountType`
      is 'percent'). Which constraint allows for this conditional validation?
    answers:
      - value: "`#[Assert\\When]`"
        correct: true
      - value: "`#[Assert\\Conditional]`"
        correct: false
      - value: >-
          ```php

          #[Assert\Expression(expression: 'this.discountType == "percent"',
          constraints: [new Assert\NotBlank()])]

          ```
        correct: false
      - value: "`#[Assert\\Callback(callback: 'validateDiscount', groups:
          ['percent_only'])]`"
        correct: false
    help: The `When` constraint allows you to apply a set of constraints only if a
      given expression evaluates to a truthy value. It also supports an
      `otherwise` option for alternative constraints.
  - question: When using Doctrine ORM with Symfony, how does the `auto_mapping`
      feature typically influence validation?
    answers:
      - value: It can automatically infer basic validation constraints (like `NotNull`
          from `nullable=false`) from Doctrine's database mapping.
        correct: true
      - value: It automatically generates all necessary validation attributes for
          entities based on database schema.
        correct: false
      - value: It disables Symfony's validation in favor of Doctrine's internal
          validation mechanisms.
        correct: false
      - value: It requires manual synchronization of validation rules with database
          schema changes.
        correct: false
    help: Symfony's Validator component can integrate with Doctrine's `auto_mapping`
      to automatically infer basic constraints like `NotNull` from database
      column definitions (e.g., `nullable=false` in ORM mapping).
  - question: For the `#[Assert\Valid]` constraint, what is the default behavior of
      the `traverse` option when applied to a property that holds a
      `Traversable` object (e.g., an `ArrayObject`)?
    answers:
      - value: It is `true` by default, meaning all containing values will be validated.
        correct: true
      - value: It is `false` by default, meaning only the `Traversable` object itself is
          validated, not its contents.
        correct: false
      - value: It has no effect on `Traversable` objects; only arrays are traversed.
        correct: false
      - value: It only applies if a specific validation group is defined.
        correct: false
    help: The `traverse` option of the `Valid` constraint is `true` by default. If
      the constraint is applied to a `Traversable` object, all containing values
      will be validated. For arrays, traversal always happens regardless of this
      option.
  - question: Is it possible to combine different constraint definition methods
      (e.g., PHP attributes, YAML, and `loadValidatorMetadata`) for the same
      entity in a Symfony application?
    answers:
      - value: Yes, Symfony merges the constraints defined by all enabled methods.
        correct: true
      - value: No, you must choose only one method per entity to avoid conflicts.
        correct: false
      - value: Only if you explicitly configure the validator to merge them.
        correct: false
      - value: Only for class-level constraints, not property-level constraints.
        correct: false
    help: Symfony's Validator component is designed to merge constraints defined
      through different mechanisms (attributes, YAML, XML,
      `loadValidatorMetadata`). This allows for flexible and modular constraint
      definitions.
  - question: When creating a translatable validation violation message, how would
      you specify the translation key and domain using `buildViolation()`?
    answers:
      - value: >-
          ```php

          $context->buildViolation(new TranslatableMessage('author.name.fake',
          [], 'validators'))
              ->atPath('firstName')
              ->addViolation();
          ```
        correct: true
      - value: |-
          ```php
          $context->buildViolation('author.name.fake')
              ->setTranslationDomain('validators')
              ->atPath('firstName')
              ->addViolation();
          ```
        correct: true
      - value: |-
          ```php
          $context->buildViolation('validators:author.name.fake')
              ->atPath('firstName')
              ->addViolation();
          ```
        correct: false
      - value: >-
          ```php

          $context->addViolation('author.name.fake', domain: 'validators', path:
          'firstName');

          ```
        correct: false
    help: You can use `TranslatableMessage` directly as the message for
      `buildViolation()`, specifying the message key, parameters, and domain.
      Alternatively, you can use `setTranslationDomain()` on the violation
      builder.
  - question: Which Symfony console command can you use to inspect all validation
      constraints applied to a specific class or a directory of classes?
    answers:
      - value: "`php bin/console debug:validator App\\Entity\\MyClass`"
        correct: true
      - value: "`php bin/console debug:validator src/Entity`"
        correct: true
      - value: "`php bin/console validator:debug App\\Entity\\MyClass`"
        correct: false
      - value: "`php bin/console list:constraints App\\Entity\\MyClass`"
        correct: false
    help: The `debug:validator` command is used to display all validation
      constraints configured for a given class or all classes within a specified
      directory.
  - question: What is the purpose of the `minMessage` option in the `Length` constraint?
    answers:
      - value: To customize the error message when the value's length is less than the
          `min` option.
        correct: true
      - value: To set the minimum length for the error message itself.
        correct: false
      - value: To define a message displayed when the `min` option is not set.
        correct: false
      - value: To provide a default message for all length violations.
        correct: false
    help: The `minMessage` option allows you to define a specific error message that
      will be displayed when the validated value's length falls below the
      specified `min` length.
  - question: Which constraint would you use to ensure a string value is within a
      specific numeric range (e.g., a number between 1 and 100)?
    answers:
      - value: "`#[Assert\\Range(min: 1, max: 100)]`"
        correct: true
      - value: "`#[Assert\\Between(min: 1, max: 100)]`"
        correct: false
      - value: "`#[Assert\\NumericRange(min: 1, max: 100)]`"
        correct: false
      - value: "`#[Assert\\Length(min: 1, max: 100)]`"
        correct: false
    help: The `Range` constraint is used to validate that a numeric value falls
      within a specified minimum and maximum range.
  - question: When handling validation errors in a Symfony controller, how can you
      return a `Response` containing the string representation of the errors if
      validation fails?
    answers:
      - value: |-
          ```php
          if (count($errors) > 0) {
              return new Response((string) $errors, 400);
          }
          ```
        correct: true
      - value: |-
          ```php
          if ($errors->hasErrors()) {
              return new Response($errors->toJson(), 400);
          }
          ```
        correct: false
      - value: |-
          ```php
          if (!$errors->isValid()) {
              return new Response($errors->getHtml(), 400);
          }
          ```
        correct: false
      - value: |-
          ```php
          if ($errors) {
              return new Response(implode('\n', $errors->getMessages()), 400);
          }
          ```
        correct: false
    help: The `ConstraintViolationList` object can be cast to a string, which
      provides a readable representation of the errors. Returning it with a 400
      (Bad Request) status code is common for validation failures.
  - question: How can you pass a `ConstraintViolationListInterface` object
      containing validation errors to a Twig template for rendering?
    answers:
      - value: |-
          ```php
          if (count($errors) > 0) {
              return $this->render('author/validation.html.twig', [
                  'errors' => $errors,
              ]);
          }
          ```
        correct: true
      - value: |-
          ```php
          if ($errors->hasViolations()) {
              return $this->render('author/validation.html.twig', [
                  'violations' => $errors->toArray(),
              ]);
          }
          ```
        correct: false
      - value: |-
          ```php
          return $this->render('author/validation.html.twig', [
              'errors' => $errors->getIterator(),
          ]);
          ```
        correct: false
      - value: |-
          ```php
          return $this->render('author/validation.html.twig', [
              'validation_results' => $errors,
          ]);
          ```
        correct: true
    help: You can directly pass the `ConstraintViolationListInterface` object to
      your Twig template. It implements `IteratorAggregate`, allowing you to
      loop over the violations in Twig.
  - question: When using dynamic validation groups with a Closure in a Symfony Form,
      how can you ensure that the `Default` validation group is *always*
      included along with your dynamically chosen groups?
    answers:
      - value: |-
          ```php
          'validation_groups' => function (FormInterface $form): array {
              $data = $form->getData();
              if (Client::TYPE_PERSON == $data->getType()) {
                  return ['Default', 'person'];
              }
              return ['Default', 'company'];
          },
          ```
        correct: true
      - value: |-
          ```php
          'validation_groups' => function (FormInterface $form): array {
              $groups = [];
              if (Client::TYPE_PERSON == $data->getType()) {
                  $groups[] = 'person';
              }
              return array_merge(['Default'], $groups);
          },
          ```
        correct: true
      - value: >-
          ```php

          'validation_groups' => ['Default', function (FormInterface $form):
          array {
              // ...
          }],

          ```
        correct: false
      - value: >-
          ```php

          'validation_groups' => 'Default' && function (FormInterface $form):
          array {
              // ...
          },

          ```
        correct: false
    help: To ensure the `Default` group is always included, you must explicitly add
      it to the array of groups returned by your Closure, typically by merging
      it with the dynamically determined groups.
  - question: When unit testing a custom Symfony constraint validator, which base
      class should your test extend to gain access to helpful assertion methods
      like `assertNoViolation()`?
    answers:
      - value: "`Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`"
        correct: true
      - value: "`PHPUnit\\Framework\\TestCase`"
        correct: false
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\Test\\ValidatorTestCase`"
        correct: false
    help: The `ConstraintValidatorTestCase` provides a convenient way to test custom
      validators by setting up the necessary validation context and offering
      specific assertion methods for violations.
  - question: What is the primary role of the `atPath()` method when building a
      violation using `ExecutionContextInterface::buildViolation()`?
    answers:
      - value: To specify the property path relative to the validated object where the
          violation occurred.
        correct: true
      - value: To define the full path to the constraint definition file.
        correct: false
      - value: To set the base URL for the violation message.
        correct: false
      - value: To indicate the method that caused the violation.
        correct: false
    help: The `atPath()` method is crucial for associating a violation with a
      specific property or nested property within the validated object, allowing
      for precise error reporting.
  - question: When using the `#[Assert\When]` constraint, which variables are
      typically available within the `expression` string or Closure?
    answers:
      - value: "`this` (the object being validated)"
        correct: true
      - value: "`value` (the value of the property being validated, if applicable)"
        correct: true
      - value: "`context` (the `ExecutionContextInterface` object)"
        correct: true
      - value: "`container` (the service container)"
        correct: false
    help: The `expression` option of `Assert\When` provides access to `this` (the
      validated object), `value` (the property's value), and `context` (the
      execution context) for building conditional logic.
  - question: What is the Composer command to install the Symfony Validator component?
    answers:
      - value: "`composer require symfony/validator`"
        correct: true
      - value: "`composer install symfony/validator`"
        correct: false
      - value: "`composer add symfony/validator`"
        correct: false
      - value: "`composer get symfony/validator`"
        correct: false
    help: The `composer require` command is used to add new packages to your
      project, including Symfony components like the Validator.
  - question: How can you integrate Symfony's Validator component to validate user
      input for a console command's question?
    answers:
      - value: By using `Validation::createCallable()` with `Question::setValidator()`.
        correct: true
      - value: By manually calling the validator service within the command's
          `execute()` method.
        correct: false
      - value: By implementing `ValidatableInputInterface` on the `Question` object.
        correct: false
      - value: By passing constraints directly to the `Question` constructor.
        correct: false
    help: The `Question` helper provides a `setValidator()` method that accepts a
      callable. `Validation::createCallable()` is a convenient way to generate
      such a callable from a constraint or a list of constraints.
  - question: Which constraint would you use to ensure a string value contains only
      alphanumeric characters?
    answers:
      - value: "`#[Assert\\Regex(pattern: '/^[a-zA-Z0-9]+$/')]`"
        correct: true
      - value: "`#[Assert\\Alphanumeric]`"
        correct: false
      - value: "`#[Assert\\Type(type: 'alnum')]`"
        correct: false
      - value: "`#[Assert\\ContainsAlphanumeric]` (unless it's a custom constraint)"
        correct: false
    help: The `Regex` constraint is the standard way to validate a string against a
      regular expression pattern. While a custom `ContainsAlphanumeric`
      constraint could exist, `Regex` is the built-in solution.
  - question: What is the default error message for the `NotBlank` constraint?
    answers:
      - value: This value should not be blank.
        correct: true
      - value: This field cannot be empty.
        correct: false
      - value: This value is required.
        correct: false
      - value: Value is missing.
        correct: false
    help: The default message for `NotBlank` is 'This value should not be blank.'
      You can customize it using the `message` option.
  - question: Which constraint is used to validate that a property's value is a
      valid URL?
    answers:
      - value: "`#[Assert\\Url]`"
        correct: true
      - value: "`#[Assert\\Link]`"
        correct: false
      - value: "`#[Assert\\WebAddress]`"
        correct: false
      - value: "`#[Assert\\Uri]`"
        correct: false
    help: The `Url` constraint checks if a given string is a syntactically valid URL.
  - question: What is the purpose of the `min` option in the `Length` constraint?
    answers:
      - value: To specify the minimum allowed length for the value.
        correct: true
      - value: To set the minimum number of characters for the error message.
        correct: false
      - value: To define the minimum value if the property is numeric.
        correct: false
      - value: To indicate the minimum number of elements in a collection.
        correct: false
    help: The `min` option in the `Length` constraint defines the minimum number of
      characters (or elements for arrays/Countable objects) that the validated
      value must have.
  - question: Which constraint is used to validate that a string value is a valid IP
      address?
    answers:
      - value: "`#[Assert\\Ip]`"
        correct: true
      - value: "`#[Assert\\IpAddress]`"
        correct: false
      - value: "`#[Assert\\NetworkAddress]`"
        correct: false
      - value: "`#[Assert\\Host]`"
        correct: false
    help: The `Ip` constraint validates if a string is a valid IP address (IPv4 or
      IPv6).
  - question: What is the purpose of the `maxMessage` option in the `Length` constraint?
    answers:
      - value: To customize the error message when the value's length exceeds the `max`
          option.
        correct: true
      - value: To set the maximum length for the error message itself.
        correct: false
      - value: To define a message displayed when the `max` option is not set.
        correct: false
      - value: To provide a default message for all length violations.
        correct: false
    help: The `maxMessage` option allows you to define a specific error message that
      will be displayed when the validated value's length is greater than the
      specified `max` length.
  - question: Which constraint is used to validate that a value is a valid date,
      time, or datetime string?
    answers:
      - value: "`#[Assert\\DateTime]`"
        correct: true
      - value: "`#[Assert\\Date]`"
        correct: true
      - value: "`#[Assert\\Time]`"
        correct: true
      - value: "`#[Assert\\Timestamp]`"
        correct: false
    help: Symfony provides `DateTime`, `Date`, and `Time` constraints to validate if
      a string represents a valid date, time, or datetime respectively.
  - question: "What is the primary difference between `#[Assert\\Length(min: 5)]`
      and `#[Assert\\Length(max: 5)]`?"
    answers:
      - value: "`min: 5` requires at least 5 characters, while `max: 5` allows at most 5
          characters."
        correct: true
      - value: "`min: 5` applies to numbers, `max: 5` applies to strings."
        correct: false
      - value: "`min: 5` is for arrays, `max: 5` is for strings."
        correct: false
      - value: They are equivalent, just different syntax.
        correct: false
    help: The `min` option sets a lower bound for length, while `max` sets an upper
      bound. They are distinct and serve opposite purposes.
  - question: Which constraint would you use to ensure a file upload is of a
      specific MIME type (e.g., 'image/jpeg')?
    answers:
      - value: "`#[Assert\\File(mimeTypes: ['image/jpeg'])]`"
        correct: true
      - value: "`#[Assert\\Image(mimeTypes: ['image/jpeg'])]`"
        correct: false
      - value: "`#[Assert\\Upload(type: 'image/jpeg')]`"
        correct: false
      - value: "`#[Assert\\MimeType(type: 'image/jpeg')]`"
        correct: false
    help: The `File` constraint is used for validating uploaded files and includes
      an option `mimeTypes` to restrict the allowed MIME types.
  - question: What is the purpose of the `message` option in most built-in Symfony
      validation constraints?
    answers:
      - value: To override the default error message displayed when the constraint is
          violated.
        correct: true
      - value: To provide a description of the constraint's purpose.
        correct: false
      - value: To define a success message when validation passes.
        correct: false
      - value: To specify the translation key for the error message.
        correct: false
    help: The `message` option allows you to provide a custom error message that
      will be used instead of the constraint's default message when a violation
      occurs.
  - question: Which constraint is used to validate that a value is a valid UUID
      (Universally Unique Identifier)?
    answers:
      - value: "`#[Assert\\Uuid]`"
        correct: true
      - value: "`#[Assert\\Guid]`"
        correct: false
      - value: "`#[Assert\\UniqueId]`"
        correct: false
      - value: "`#[Assert\\Identifier]`"
        correct: false
    help: The `Uuid` constraint validates if a string is a valid UUID, supporting
      different versions.
  - question: You want to ensure a string value is a valid JSON string. Which
      constraint would you use?
    answers:
      - value: "`#[Assert\\Json]`"
        correct: true
      - value: "`#[Assert\\IsJson]`"
        correct: false
      - value: "`#[Assert\\ValidJson]`"
        correct: false
      - value: "`#[Assert\\Format(format: 'json')]`"
        correct: false
    help: The `Json` constraint validates if a string contains valid JSON data.
  - question: Which constraint is used to validate that a value is a valid country
      code (e.g., 'US', 'FR')?
    answers:
      - value: "`#[Assert\\Country]`"
        correct: true
      - value: "`#[Assert\\Locale]`"
        correct: false
      - value: "`#[Assert\\Region]`"
        correct: false
      - value: "`#[Assert\\IsoCountry]`"
        correct: false
    help: The `Country` constraint validates if a string is a valid ISO 3166-1
      alpha-2 country code.
  - question: What is the purpose of the `payload` option that can be added to any
      constraint?
    answers:
      - value: To attach arbitrary custom data to the violation object for later
          retrieval.
        correct: true
      - value: To define the HTTP payload for the validation request.
        correct: false
      - value: To specify the data type of the validated value.
        correct: false
      - value: To set the priority of the constraint.
        correct: false
    help: The `payload` option allows you to embed custom data directly into the
      constraint violation object. This data can be retrieved later from the
      violation, which is useful for custom error handling or frontend
      integration.
  - question: Which constraint is used to validate that a value is a valid language
      code (e.g., 'en', 'fr')?
    answers:
      - value: "`#[Assert\\Language]`"
        correct: true
      - value: "`#[Assert\\Locale]`"
        correct: false
      - value: "`#[Assert\\IsoLanguage]`"
        correct: false
      - value: "`#[Assert\\Culture]`"
        correct: false
    help: The `Language` constraint validates if a string is a valid ISO 639-1
      alpha-2 language code.
  - question: What is the purpose of the `groups` option when defining a constraint?
    answers:
      - value: To assign the constraint to one or more validation groups.
        correct: true
      - value: To define a new validation group.
        correct: false
      - value: To specify the order in which constraints are validated.
        correct: false
      - value: To enable or disable the constraint conditionally.
        correct: false
    help: The `groups` option allows you to associate a constraint with specific
      validation groups. When validating, only constraints belonging to the
      active groups will be checked.
  - question: Which constraint is used to validate that a value is a valid currency
      code (e.g., 'USD', 'EUR')?
    answers:
      - value: "`#[Assert\\Currency]`"
        correct: true
      - value: "`#[Assert\\Money]`"
        correct: false
      - value: "`#[Assert\\IsoCurrency]`"
        correct: false
      - value: "`#[Assert\\FinancialCode]`"
        correct: false
    help: The `Currency` constraint validates if a string is a valid ISO 4217
      currency code.
  - question: What happens if you apply a `#[Assert\NotBlank]` constraint to a
      property that is `null`?
    answers:
      - value: A violation will be generated, as `null` is considered blank.
        correct: true
      - value: No violation will be generated, as `NotBlank` only applies to empty
          strings.
        correct: false
      - value: An `UnexpectedValueException` will be thrown.
        correct: false
      - value: The value will be automatically converted to an empty string.
        correct: false
    help: The `NotBlank` constraint considers `null`, empty strings, and empty
      arrays as 'blank' values and will trigger a violation.
  - question: Which constraint is used to validate that a value is a valid ISBN
      (International Standard Book Number)?
    answers:
      - value: "`#[Assert\\Isbn]`"
        correct: true
      - value: "`#[Assert\\BookCode]`"
        correct: false
      - value: "`#[Assert\\ProductCode]`"
        correct: false
      - value: "`#[Assert\\Ean]`"
        correct: false
    help: The `Isbn` constraint validates if a string is a valid ISBN-10 or ISBN-13.
  - question: What is the purpose of the `normalizer` option available in some
      constraints (e.g., `Email`, `Url`)?
    answers:
      - value: To apply a PHP callable to normalize the value before validation.
        correct: true
      - value: To convert the value to a standard format for display.
        correct: false
      - value: To define a custom error message for normalization failures.
        correct: false
      - value: To specify the character encoding for the value.
        correct: false
    help: The `normalizer` option allows you to provide a PHP callable (e.g., a
      Closure) that will be applied to the value *before* the actual validation
      logic runs. This is useful for cleaning or transforming input.
  - question: Which constraint is used to validate that a value is a valid BIC (Bank
      Identifier Code) or SWIFT code?
    answers:
      - value: "`#[Assert\\Bic]`"
        correct: true
      - value: "`#[Assert\\Swift]`"
        correct: false
      - value: "`#[Assert\\BankCode]`"
        correct: false
      - value: "`#[Assert\\Iban]`"
        correct: false
    help: The `Bic` constraint validates if a string is a valid BIC (Bank Identifier
      Code) or SWIFT code.
  - question: "What is the purpose of the `strict` option in the `Type` constraint
      (e.g., `#[Assert\\Type('integer', strict: true)]`)?"
    answers:
      - value: To enforce a strict type check, disallowing type coercion.
        correct: true
      - value: To enable validation only for strict PHP types.
        correct: false
      - value: To make the constraint apply only to non-nullable values.
        correct: false
      - value: To ensure the value is exactly the specified type, including its class.
        correct: false
    help: When `strict` is `true` for the `Type` constraint, PHP's loose type
      comparison is bypassed, and the type check is performed strictly (e.g.,
      '5' would not be considered an integer).
  - question: Which constraint is used to validate that a value is a valid IBAN
      (International Bank Account Number)?
    answers:
      - value: "`#[Assert\\Iban]`"
        correct: true
      - value: "`#[Assert\\BankAccount]`"
        correct: false
      - value: "`#[Assert\\AccountNumber]`"
        correct: false
      - value: "`#[Assert\\BankDetails]`"
        correct: false
    help: The `Iban` constraint validates if a string is a valid IBAN (International
      Bank Account Number).
  - question: What is the main advantage of defining validation constraints using
      PHP attributes directly in entity classes?
    answers:
      - value: Constraints are colocated with the properties they validate, improving
          readability.
        correct: true
      - value: It provides the best performance compared to other methods.
        correct: false
      - value: It allows for dynamic constraint definition based on runtime logic.
        correct: false
      - value: It is the only method that supports validation groups.
        correct: false
    help: PHP attributes offer a concise and intuitive way to define constraints
      directly within the class, making the validation rules immediately visible
      alongside the property definitions.
  - question: Which constraint is used to validate that a value is a valid credit
      card number?
    answers:
      - value: "`#[Assert\\CardScheme]`"
        correct: true
      - value: "`#[Assert\\CreditCard]`"
        correct: false
      - value: "`#[Assert\\PaymentCard]`"
        correct: false
      - value: "`#[Assert\\Luhn]`"
        correct: false
    help: The `CardScheme` constraint validates if a string is a valid credit card
      number for specified schemes (e.g., Visa, Mastercard).
  - question: What is the purpose of the `allowEmptyString` option in some
      constraints (e.g., `Length`, `Regex`)?
    answers:
      - value: To allow an empty string to pass validation, even if other rules would
          fail it.
        correct: true
      - value: To treat an empty string as `null` for validation purposes.
        correct: false
      - value: To automatically convert `null` values to empty strings.
        correct: false
      - value: To prevent empty strings from being validated at all.
        correct: false
    help: The `allowEmptyString` option, when set to `true`, means that if the
      validated value is an empty string, the constraint will consider it valid
      and will not trigger a violation, regardless of other options.
  - question: Which constraint is used to validate that a value is a valid phone number?
    answers:
      - value: "`#[Assert\\PhoneNumber]`"
        correct: true
      - value: "`#[Assert\\Tel]`"
        correct: false
      - value: "`#[Assert\\MobileNumber]`"
        correct: false
      - value: "`#[Assert\\ContactNumber]`"
        correct: false
    help: The `PhoneNumber` constraint validates if a string is a valid phone
      number, often leveraging the `libphonenumber` library.
  - question: What is the primary benefit of using validation groups?
    answers:
      - value: To apply different sets of validation rules based on the context (e.g.,
          registration vs. profile update).
        correct: true
      - value: To improve validation performance by only checking relevant constraints.
        correct: true
      - value: To organize constraints into logical categories.
        correct: true
      - value: To enable or disable specific constraints at runtime.
        correct: false
    help: Validation groups allow you to selectively apply constraints, making it
      possible to validate an object differently depending on the specific
      operation or context within your application.
  - question: Which constraint is used to validate that a value is a valid callback
      (i.e., a callable PHP function or method)?
    answers:
      - value: "`#[Assert\\Callback]`"
        correct: true
      - value: "`#[Assert\\Callable]`"
        correct: false
      - value: "`#[Assert\\IsCallable]`"
        correct: false
      - value: "`#[Assert\\Function]`"
        correct: false
    help: The `Callback` constraint allows you to use any PHP callable (function,
      static method, object method) to perform custom validation logic.
  - question: What is the purpose of the `mimeTypesMessage` option in the `File`
      constraint?
    answers:
      - value: To customize the error message when the uploaded file's MIME type is not
          allowed.
        correct: true
      - value: To specify the allowed MIME types for the file.
        correct: false
      - value: To define a message for files that are too large.
        correct: false
      - value: To set the default MIME type for the file.
        correct: false
    help: The `mimeTypesMessage` option provides a custom error message when the
      uploaded file's MIME type does not match any of the allowed types
      specified in the `mimeTypes` option.
  - question: Which constraint is used to validate that a value is a valid locale
      code (e.g., 'en_US', 'fr_FR')?
    answers:
      - value: "`#[Assert\\Locale]`"
        correct: true
      - value: "`#[Assert\\LanguageCountry]`"
        correct: false
      - value: "`#[Assert\\CultureCode]`"
        correct: false
      - value: "`#[Assert\\RegionLocale]`"
        correct: false
    help: The `Locale` constraint validates if a string is a valid locale code,
      typically in the format `language_COUNTRY`.
  - question: What is the purpose of the `minSize` option in the `File` constraint?
    answers:
      - value: To specify the minimum allowed size for the uploaded file.
        correct: true
      - value: To set the minimum dimensions for an image file.
        correct: false
      - value: To define the minimum number of files allowed in an upload.
        correct: false
      - value: To limit the number of characters in the file name.
        correct: false
    help: The `minSize` option in the `File` constraint allows you to set a lower
      limit on the size of the uploaded file. If the file is smaller than this,
      a violation is triggered.
  - question: Which constraint is used to validate that a value is a valid Timezone
      identifier (e.g., 'America/New_York')?
    answers:
      - value: "`#[Assert\\Timezone]`"
        correct: true
      - value: "`#[Assert\\Zone]`"
        correct: false
      - value: "`#[Assert\\DateTimezone]`"
        correct: false
      - value: "`#[Assert\\Location]`"
        correct: false
    help: The `Timezone` constraint validates if a string is a valid timezone
      identifier according to the IANA Time Zone Database.
  - question: What is the purpose of the `maxSize` option in the `File` constraint?
    answers:
      - value: To specify the maximum allowed size for the uploaded file.
        correct: true
      - value: To set the maximum dimensions for an image file.
        correct: false
      - value: To define the maximum number of files allowed in an upload.
        correct: false
      - value: To limit the number of characters in the file name.
        correct: false
    help: The `maxSize` option in the `File` constraint allows you to set an upper
      limit on the size of the uploaded file. If the file is larger than this, a
      violation is triggered.
  - question: Which constraint is used to validate that a value is a valid UUID
      (Universally Unique Identifier)?
    answers:
      - value: "`#[Assert\\Uuid]`"
        correct: true
      - value: "`#[Assert\\Guid]`"
        correct: false
      - value: "`#[Assert\\UniqueId]`"
        correct: false
      - value: "`#[Assert\\Identifier]`"
        correct: false
    help: The `Uuid` constraint validates if a string is a valid UUID, supporting
      different versions.
  - question: What is the purpose of the `notFoundMessage` option in the `File`
      constraint?
    answers:
      - value: To customize the error message when the uploaded file is missing or not
          found.
        correct: true
      - value: To define a message for files that are too small.
        correct: false
      - value: To specify a message for files with invalid MIME types.
        correct: false
      - value: To set a default message for all file-related errors.
        correct: false
    help: The `notFoundMessage` option allows you to provide a custom error message
      when the file being validated does not exist or cannot be found.
  - question: Which constraint is used to validate that a value is a valid HTML
      color code (e.g., `#FFFFFF`, `red`)?
    answers:
      - value: "`#[Assert\\CssColor]`"
        correct: true
      - value: "`#[Assert\\HtmlColor]`"
        correct: false
      - value: "`#[Assert\\WebColor]`"
        correct: false
      - value: "`#[Assert\\ColorCode]`"
        correct: false
    help: The `CssColor` constraint validates if a string is a valid CSS color,
      which includes HTML color codes.
  - question: What is the purpose of the `uploadIniSizeErrorMessage` option in the
      `File` constraint?
    answers:
      - value: To customize the error message when the uploaded file exceeds the
          `upload_max_filesize` or `post_max_size` PHP ini limits.
        correct: true
      - value: To define a message for files that are too small.
        correct: false
      - value: To specify a message for files with invalid MIME types.
        correct: false
      - value: To set a default message for all file-related errors.
        correct: false
    help: The `uploadIniSizeErrorMessage` option provides a custom error message
      specifically for cases where the uploaded file's size exceeds the limits
      set in the PHP configuration (`upload_max_filesize` or `post_max_size`).
  - question: Which constraint is used to validate that a value is a valid type
      (e.g., `string`, `integer`, `array`, `object`)?
    answers:
      - value: "`#[Assert\\Type]`"
        correct: true
      - value: "`#[Assert\\IsType]`"
        correct: false
      - value: "`#[Assert\\InstanceOf]`"
        correct: false
      - value: "`#[Assert\\Primitive]`"
        correct: false
    help: The `Type` constraint validates if a value is of a specific PHP type or an
      instance of a given class/interface.
  - question: What is the purpose of the `disallowEmptyMessage` option in the
      `Collection` constraint?
    answers:
      - value: To customize the error message when an empty collection is not allowed.
        correct: true
      - value: To define a message for collections that are too large.
        correct: false
      - value: To specify a message for collections with invalid keys.
        correct: false
      - value: To set a default message for all collection-related errors.
        correct: false
    help: The `disallowEmptyMessage` option allows you to provide a custom error
      message when the `allowEmpty` option is `false` and the validated
      collection is empty.
  - question: Which constraint is used to validate that a value is a valid
      expression (e.g., a Symfony ExpressionLanguage expression)?
    answers:
      - value: "`#[Assert\\Expression]`"
        correct: true
      - value: "`#[Assert\\Eval]`"
        correct: false
      - value: "`#[Assert\\Syntax]`"
        correct: false
      - value: "`#[Assert\\Logic]`"
        correct: false
    help: The `Expression` constraint allows you to validate a value against a
      Symfony ExpressionLanguage expression, providing a flexible way to define
      complex validation rules.
  - question: What is the purpose of the `missingFieldsMessage` option in the
      `Collection` constraint?
    answers:
      - value: To customize the error message when required fields are missing from the
          collection.
        correct: true
      - value: To define a message for fields that are not expected in the collection.
        correct: false
      - value: To specify a message for fields with invalid values.
        correct: false
      - value: To set a default message for all field-related errors.
        correct: false
    help: The `missingFieldsMessage` option allows you to provide a custom error
      message when the `Collection` constraint is configured with required
      fields that are not present in the validated array.
  - question: Which constraint is used to validate that a value is a valid JSON Schema?
    answers:
      - value: "`#[Assert\\JsonSchema]`"
        correct: true
      - value: "`#[Assert\\Schema]`"
        correct: false
      - value: "`#[Assert\\JsonValidator]`"
        correct: false
      - value: "`#[Assert\\SchemaValidator]`"
        correct: false
    help: The `JsonSchema` constraint validates a value against a specified JSON
      Schema, ensuring its structure and data types conform to the schema.
  - question: What is the purpose of the `extraFieldsMessage` option in the
      `Collection` constraint?
    answers:
      - value: To customize the error message when unexpected fields are present in the
          collection.
        correct: true
      - value: To define a message for fields that are missing from the collection.
        correct: false
      - value: To specify a message for fields with invalid values.
        correct: false
      - value: To set a default message for all field-related errors.
        correct: false
    help: The `extraFieldsMessage` option allows you to provide a custom error
      message when the `Collection` constraint is configured to disallow extra
      fields, and such fields are found in the validated array.
