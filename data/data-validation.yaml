category: Data Validation
questions:
  - question: Which Symfony component is primarily responsible for validating PHP
      objects and arrays?
    answers:
      - value: Symfony\Component\Validator
        correct: true
      - value: Symfony\Component\Form
        correct: false
      - value: Symfony\Component\HttpFoundation
        correct: false
      - value: Symfony\Component\PropertyAccess
        correct: false
    help: The Symfony Validator component provides tools for validating data against
      a set of rules, whether it's a PHP object, an array, or a scalar value.
  - question: How do you obtain the main validator service in a Symfony application
      to validate an object?
    answers:
      - value: Inject `Symfony\Component\Validator\Validator\ValidatorInterface`.
        correct: true
      - value: Call `Validation::createValidator()` directly in a controller.
        correct: false
      - value: Use `Container::get('validator')`.
        correct: false
      - value: The validator is automatically available as `$this->validator` in all
          services.
        correct: false
    help: The `ValidatorInterface` is the primary service to inject for performing
      validation in Symfony applications. While `Validation::createValidator()`
      can be used for standalone components, it's not the recommended way within
      a full Symfony application.
  - question: Given an `Author` object, which code snippet correctly validates it
      using the injected `$validator` service?
    answers:
      - value: |-
          ```php
          $errors = $validator->validate($author);
          ```
        correct: true
      - value: |-
          ```php
          $errors = $validator->validate(new Author());
          ```
        correct: false
      - value: |-
          ```php
          $errors = $validator->validate($author, ['Default']);
          ```
        correct: false
      - value: |-
          ```php
          $errors = $validator->isValid($author);
          ```
        correct: false
    help: The `validate()` method of `ValidatorInterface` takes the value or object
      to validate as its first argument. The second and third arguments are for
      constraints and groups, respectively, which are optional.
  - question: What is the purpose of the `#[Assert\Valid]` attribute in Symfony
      validation?
    answers:
      - value: To ensure that nested objects are also validated when the parent object
          is validated.
        correct: true
      - value: To mark a property as valid without applying any constraints.
        correct: false
      - value: To define a custom validation method for the current object.
        correct: false
      - value: To validate that a collection contains valid elements.
        correct: false
    help: The `#[Assert\Valid]` constraint is crucial for validating properties that
      are themselves objects, ensuring their own constraints are checked
      recursively.
  - question: Which constraint is used to validate that each element within an array
      or `Traversable` collection satisfies a given set of constraints?
    answers:
      - value: |-
          ```php
          #[Assert\All([...])]
          ```
        correct: true
      - value: |-
          ```php
          #[Assert\Collection([...])]
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\Valid]
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\Each([...])]
          ```
        correct: false
    help: The `#[Assert\All]` constraint applies a list of constraints to each
      element of a collection, while `#[Assert\Collection]` validates the
      structure and keys of an array.
  - question: What is the default validation group used when no specific group is
      provided to the validator?
    answers:
      - value: "`Default`"
        correct: true
      - value: "`Standard`"
        correct: false
      - value: The class name of the validated object.
        correct: false
      - value: No default group; all constraints are applied.
        correct: false
    help: Constraints without an explicit group belong to the `Default` group. When
      validating without specifying groups, only constraints in the `Default`
      group are checked.
  - question: >-
      Consider the following `User` entity:


      ```php

      namespace App\Entity;


      use Symfony\Component\Validator\Constraints as Assert;


      class User

      {
          #[Assert\Email(groups: ['registration'])]
          private string $email;

          #[Assert\NotBlank]
          private string $username;
      }

      ```


      If you call `$validator->validate($user, null, ['registration']);`, which
      property's constraint will be validated?
    answers:
      - value: "`email` only."
        correct: true
      - value: "`username` only."
        correct: false
      - value: Both `email` and `username`.
        correct: false
      - value: Neither, as `Default` group is not included.
        correct: false
    help: When a specific group (e.g., 'registration') is provided, only constraints
      explicitly assigned to that group will be validated. The `NotBlank`
      constraint on `username` belongs to the `Default` group.
  - question: How can you define a validation group sequence for an entity using PHP
      attributes?
    answers:
      - value: |-
          ```php
          #[Assert\GroupSequence(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          #[Assert\Sequence(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\ValidationGroups(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          #[Assert\Order(['User', 'Strict'])]
          class User
          {
              // ...
          }
          ```
        correct: false
    help: The `#[Assert\GroupSequence]` attribute is used at the class level to
      define an ordered list of validation groups. Validation proceeds through
      the groups in the sequence, stopping if any group fails.
  - question: What is the primary benefit of using a validation group sequence
      (e.g., `['Default', 'Strict']`)?
    answers:
      - value: Validation stops immediately if a constraint in an earlier group fails,
          preventing unnecessary checks.
        correct: true
      - value: It allows applying all constraints from all listed groups simultaneously.
        correct: false
      - value: It enables parallel validation of different groups for performance
          optimization.
        correct: false
      - value: It automatically translates validation messages based on the active
          group.
        correct: false
    help: Group sequences are designed for 'fail-fast' validation. If a constraint
      in 'Default' fails, 'Strict' will not be evaluated.
  - question: Which interface must an entity implement to dynamically determine its
      validation groups based on its internal state?
    answers:
      - value: "`Symfony\\Component\\Validator\\GroupSequenceProviderInterface`"
        correct: true
      - value: "`Symfony\\Component\\Validator\\Context\\ExecutionContextInterface`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\Validator\\ValidatorInterface`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\ConstraintValidatorInterface`"
        correct: false
    help: Implementing `GroupSequenceProviderInterface` and its `getGroupSequence()`
      method allows an object to provide a custom validation group sequence at
      runtime.
  - question: To create a custom validation constraint in Symfony, which class
      should your constraint extend?
    answers:
      - value: "`Symfony\\Component\\Validator\\Constraint`"
        correct: true
      - value: "`Symfony\\Component\\Validator\\ConstraintValidator`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\Validation`"
        correct: false
      - value: "`Symfony\\Component\\Validator\\AbstractConstraint`"
        correct: false
    help: Custom constraints must extend `Symfony\Component\Validator\Constraint`.
      The actual validation logic is typically placed in a separate validator
      class that extends `ConstraintValidator`.
  - question: When implementing a custom constraint validator, which method contains
      the core validation logic?
    answers:
      - value: "`validate(mixed $value, Constraint $constraint): void`"
        correct: true
      - value: "`isValid(mixed $value, Constraint $constraint): bool`"
        correct: false
      - value: "`apply(mixed $value, Constraint $constraint): void`"
        correct: false
      - value: "`check(mixed $value, Constraint $constraint): array`"
        correct: false
    help: The `validate()` method is where you implement the logic to check if the
      given value satisfies the constraint. If not, you add violations to the
      context.
  - question: Which of the following is the correct way to add a validation
      violation using the `ExecutionContextInterface` within a custom validator?
    answers:
      - value: |-
          ```php
          $this->context->buildViolation($constraint->message)
              ->setParameter('{{ string }}', $value)
              ->addViolation();
          ```
        correct: true
      - value: >-
          ```php

          $this->context->addViolation($constraint->message, ['string' =>
          $value]);

          ```
        correct: false
      - value: |-
          ```php
          $this->context->createViolation($constraint->message)->add();
          ```
        correct: false
      - value: |-
          ```php
          $this->context->violation($constraint->message)->setParameters(['string' => $value]);
          ```
        correct: false
    help: The `buildViolation()` method returns a `ConstraintViolationBuilder` which
      allows chaining methods like `setParameter()` and `addViolation()` to
      construct and add the violation.
  - question: Which built-in constraint should you use to ensure a string property
      is not empty or contains only whitespace?
    answers:
      - value: "`#[Assert\\NotBlank]`"
        correct: true
      - value: "`#[Assert\\NotNull]`"
        correct: false
      - value: "`#[Assert\\NotEmpty]`"
        correct: false
      - value: "`#[Assert\\Length(min: 1)]`"
        correct: false
    help: "`NotBlank` specifically checks if a string is not empty and not composed
      solely of whitespace. `NotNull` only checks for `null`."
  - question: You want to validate that a user's age is between 18 and 65
      (inclusive). Which constraint is most suitable?
    answers:
      - value: "`#[Assert\\Range(min: 18, max: 65)]`"
        correct: true
      - value: "`#[Assert\\GreaterThanOrEqual(18), Assert\\LessThanOrEqual(65)]`"
        correct: true
      - value: "`#[Assert\\Between(18, 65)]`"
        correct: false
      - value: "`#[Assert\\Length(min: 18, max: 65)]`"
        correct: false
    help: The `Range` constraint is designed for checking if a value falls within a
      specified numerical or date range. You can also combine
      `GreaterThanOrEqual` and `LessThanOrEqual`.
  - question: What is the purpose of the `payload` option available on most Symfony
      validation constraints?
    answers:
      - value: To attach custom, non-validation related data to the constraint, such as
          a severity level.
        correct: true
      - value: To define the data type of the validated value.
        correct: false
      - value: To specify the validation group for the constraint.
        correct: false
      - value: To pass additional parameters to the constraint's message.
        correct: false
    help: The `payload` option allows you to attach arbitrary data to a constraint,
      which can be useful for custom error handling, logging, or rendering
      different UI elements based on the error's 'severity'.
  - question: Which command-line tool can you use to inspect the validation
      constraints applied to a specific class in your Symfony application?
    answers:
      - value: "`php bin/console debug:validator App\\Entity\\MyClass`"
        correct: true
      - value: "`php bin/console validator:debug App\\Entity\\MyClass`"
        correct: false
      - value: "`php bin/console lint:validator App\\Entity\\MyClass`"
        correct: false
      - value: "`php bin/console show:constraints App\\Entity\\MyClass`"
        correct: false
    help: The `debug:validator` command is a powerful tool for understanding how
      validation rules are configured for your entities and properties.
  - question: When validating a form, how can you dynamically set validation groups
      based on the submitted data?
    answers:
      - value: By providing a `Closure` to the `validation_groups` option in
          `configureOptions()` that receives the `FormInterface` object.
        correct: true
      - value: By implementing `GroupSequenceProviderInterface` on the form type class.
        correct: false
      - value: By using the `#[MapRequestPayload]` attribute in the controller.
        correct: false
      - value: By calling `$form->setValidationGroups()` after form submission.
        correct: false
    help: The `validation_groups` option in form types can accept a callable
      (Closure or static method reference) that dynamically determines the
      groups based on the form's data.
  - question: What is the primary difference between `#[Assert\Valid]` and
      `#[Assert\Traverse]`?
    answers:
      - value: "`#[Assert\\Valid]` validates a single nested object, while
          `#[Assert\\Traverse]` validates elements within a `Traversable`
          collection."
        correct: true
      - value: "`#[Assert\\Valid]` is for class-level validation, `#[Assert\\Traverse]`
          is for property-level."
        correct: false
      - value: "`#[Assert\\Traverse]` is deprecated in Symfony 7, `#[Assert\\Valid]` is
          the modern approach."
        correct: false
      - value: They are functionally identical; `#[Assert\Traverse]` is an alias for
          `#[Assert\Valid]`.
        correct: false
    help: "`Valid` is for single embedded objects, ensuring their constraints are
      checked. `Traverse` is specifically for collections (like
      `ArrayCollection` or arrays) where you want to validate each item within
      that collection."
  - question: Which of the following is NOT a valid way to define validation
      constraints in Symfony 7?
    answers:
      - value: Using YAML configuration files.
        correct: false
      - value: Using XML configuration files.
        correct: false
      - value: Using PHP attributes.
        correct: false
      - value: Using annotations (deprecated in Symfony 7).
        correct: true
      - value: Programmatically via `loadValidatorMetadata` static method.
        correct: false
    help: Annotations have been replaced by PHP attributes as of PHP 8.0 and Symfony
      6.0+. All other options are valid for defining constraints in Symfony 7.
  - question: You have a `Product` entity with a `price` property. You want to
      ensure the price is always greater than 0. Which constraint would you use?
    answers:
      - value: "`#[Assert\\GreaterThan(0)]`"
        correct: true
      - value: "`#[Assert\\Positive]`"
        correct: true
      - value: "`#[Assert\\Min(0)]`"
        correct: false
      - value: "`#[Assert\\NotNull]`"
        correct: false
    help: "`GreaterThan` ensures the value is strictly greater than the given limit.
      `Positive` is a shortcut for `GreaterThan(0)`."
  - question: What is the purpose of the `#[Assert\Expression]` constraint?
    answers:
      - value: To validate a value based on a complex PHP expression.
        correct: true
      - value: To define a regular expression pattern for string validation.
        correct: false
      - value: To evaluate a Twig expression for conditional rendering.
        correct: false
      - value: To check if a value is present in a predefined list of choices.
        correct: false
    help: The `Expression` constraint allows you to write custom validation logic
      using the Symfony ExpressionLanguage, which can access properties of the
      validated object (`this`) and the value being validated (`value`).
  - question: When defining a custom callback validator method within a class, what
      is the type-hint for the first argument if the method is non-static?
    answers:
      - value: The object itself (e.g., `Author $object`).
        correct: false
      - value: "`Symfony\\Component\\Validator\\Context\\ExecutionContextInterface`"
        correct: true
      - value: "`mixed`"
        correct: false
      - value: No argument is passed; use `$this` directly.
        correct: false
    help: For non-static callback methods, the first argument is the
      `ExecutionContextInterface`, and the validated object is accessed via
      `$this`. For static methods, the validated object is the first argument.
  - question: Which constraint would you use to ensure a string matches a specific
      regular expression pattern?
    answers:
      - value: "`#[Assert\\Regex(pattern: '/^\\d{5}$/')`"
        correct: true
      - value: "`#[Assert\\Pattern(regex: '/^\\d{5}$/')`"
        correct: false
      - value: "`#[Assert\\Match(pattern: '/^\\d{5}$/')`"
        correct: false
      - value: "`#[Assert\\Expression(expression: 'value matches \"/^\\\\d{5}$/\"')`"
        correct: false
    help: The `Regex` constraint is specifically designed for validating strings
      against regular expressions. The `pattern` option defines the regex.
  - question: What happens if you define a `#[Assert\Email]` constraint on a
      property without specifying a `mode` option?
    answers:
      - value: It defaults to the `html5` validation mode.
        correct: true
      - value: It defaults to the `strict` validation mode.
        correct: false
      - value: It throws an error, as `mode` is a required option.
        correct: false
      - value: It uses the `html5-allow-no-tld` mode.
        correct: false
    help: The `Email` constraint's `mode` option defaults to `html5`, which uses the
      HTML5 email input element's regex and enforces a TLD.
  - question: You want to validate that a collection (e.g., an array of tags) has at
      least 3 elements and at most 10. Which constraint is appropriate?
    answers:
      - value: "`#[Assert\\Count(min: 3, max: 10)]`"
        correct: true
      - value: "`#[Assert\\Length(min: 3, max: 10)]`"
        correct: false
      - value: "`#[Assert\\Collection(min: 3, max: 10)]`"
        correct: false
      - value: "`#[Assert\\Range(min: 3, max: 10)]`"
        correct: false
    help: The `Count` constraint is specifically designed to validate the number of
      elements in a collection (array or `Traversable`).
  - question: What is the purpose of the `atPath()` method when building a
      validation violation?
    answers:
      - value: To associate the violation with a specific property path (e.g.,
          `address.zipCode`).
        correct: true
      - value: To define the file path where the violation occurred.
        correct: false
      - value: To set the URL path for the validation error page.
        correct: false
      - value: To specify the translation key for the error message.
        correct: false
    help: "`atPath()` is essential for precise error reporting, allowing you to
      pinpoint exactly which property or nested property caused the validation
      failure."
  - question: Which of the following is true about the `#[Assert\IsTrue]` constraint?
    answers:
      - value: It can be applied to a public getter method that returns a boolean.
        correct: true
      - value: It validates that a property's value is strictly `true`.
        correct: false
      - value: It requires the `payload` option to be set to `true`.
        correct: false
      - value: It is only applicable to class-level validation.
        correct: false
    help: "`IsTrue` is commonly used on getter methods to perform custom, dynamic
      validation logic that results in a boolean outcome."
  - question: How can you ensure that validation messages are translatable in your
      Symfony application?
    answers:
      - value: By providing a translation key as the `message` option for constraints
          and creating corresponding translation files.
        correct: true
      - value: By setting the `translatable` option to `true` on each constraint.
        correct: false
      - value: Symfony automatically translates all validation messages.
        correct: false
      - value: By using the `TranslatableMessage` class directly in your entity
          properties.
        correct: false
    help: You provide a message key (e.g., `author.name.not_blank`) and then define
      the translations for that key in your `validators.xx.xlf`, `.yaml`, or
      `.php` translation files.
  - question: What is the purpose of the `#[Assert\Sequentially]` constraint?
    answers:
      - value: To apply a series of constraints in order, stopping on the first failure.
        correct: true
      - value: To validate that a collection's elements are in a specific order.
        correct: false
      - value: To define a sequence of validation groups for an object.
        correct: false
      - value: To ensure that a value is an integer and increments sequentially.
        correct: false
    help: Similar to group sequences, `Sequentially` applies to a single property or
      class, executing constraints one by one and stopping if any fails.
  - question: When using `#[MapQueryParameter]` or `#[MapRequestPayload]`
      attributes, which option allows you to specify a custom HTTP status code
      for validation failures?
    answers:
      - value: "`validationFailedStatusCode`"
        correct: true
      - value: "`statusCodeOnError`"
        correct: false
      - value: "`httpStatusOnInvalid`"
        correct: false
      - value: "`errorResponseCode`"
        correct: false
    help: The `validationFailedStatusCode` option provides control over the HTTP
      response status code when validation fails during parameter or payload
      mapping.
  - question: Which of the following is a valid `mode` for the `#[Assert\Email]`
      constraint that allows email addresses without a Top-Level Domain (TLD)?
    answers:
      - value: "`html5-allow-no-tld`"
        correct: true
      - value: "`loose`"
        correct: false
      - value: "`no-tld`"
        correct: false
      - value: "`relaxed`"
        correct: false
    help: The `html5-allow-no-tld` mode specifically uses the HTML5 regex but
      permits email addresses without a TLD.
  - question: What is the primary role of
      `Symfony\Component\Validator\Mapping\ClassMetadata` in Symfony validation?
    answers:
      - value: To programmatically define validation constraints for a class,
          properties, and getter methods.
        correct: true
      - value: To store the validated data after successful validation.
        correct: false
      - value: To provide access to the current validation context during validation.
        correct: false
      - value: To map database columns to validation constraints.
        correct: false
    help: "`ClassMetadata` is used within the `loadValidatorMetadata` static method
      to add constraints programmatically, offering an alternative to
      attributes, YAML, or XML."
  - question: When integrating the Symfony Validator with the Form component, which
      extension must be added to the `FormFactoryBuilder`?
    answers:
      - value: "`Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension`"
        correct: true
      - value: "`Symfony\\Component\\Form\\Extension\\Validation\\ValidationExtension`"
        correct: false
      - value: "`Symfony\\Component\\Form\\Extension\\Core\\CoreExtension`"
        correct: false
      - value: "`Symfony\\Component\\Form\\Extension\\Bridge\\ValidatorBridgeExtension`"
        correct: false
    help: The `ValidatorExtension` bridges the Form component with the Validator
      component, enabling automatic validation of form data.
  - question: Which constraint is suitable for validating that a string is a valid
      Universal Unique Lexicographically Sortable Identifier?
    answers:
      - value: "`#[Assert\\Ulid]`"
        correct: true
      - value: "`#[Assert\\Uuid]`"
        correct: false
      - value: "`#[Assert\\Guid]`"
        correct: false
      - value: "`#[Assert\\Id]`"
        correct: false
    help: The `Ulid` constraint specifically validates ULID format, while `Uuid`
      validates UUIDs.
  - question: You want to validate that a `User`'s `password` property is not equal
      to their `username`. How would you achieve this using a getter method and
      a built-in constraint?
    answers:
      - value: Define a `isPasswordSafe()` getter returning `true` if `password !==
          username` and apply `#[Assert\IsTrue]` to it.
        correct: true
      - value: "Apply `#[Assert\\NotEqualTo(propertyPath: 'username')]` to the
          `password` property."
        correct: false
      - value: "Use `#[Assert\\Expression(expression: 'this.password !=
          this.username')]` on the `password` property."
        correct: false
      - value: Create a custom `PasswordSafe` constraint and validator.
        correct: false
    help: The `#[Assert\IsTrue]` constraint on a getter method is a common pattern
      for class-level validation logic that depends on multiple properties.
  - question: What is the primary purpose of
      `Symfony\Component\Validator\Validation::createCallable()`?
    answers:
      - value: To create a callable that throws a `ValidationFailedException` if
          constraints are not met.
        correct: true
      - value: To create a callable that returns `true` or `false` indicating validation
          success.
        correct: false
      - value: To create a callable that generates validation messages.
        correct: false
      - value: To create a callable that applies validation groups dynamically.
        correct: false
    help: "`createCallable()` is useful for integrating validation into contexts
      like console commands or `OptionsResolver` where an exception on failure
      is desired."
  - question: When using the `#[Assert\When]` constraint, what variable is available
      in the `expression` to refer to the object being validated?
    answers:
      - value: "`this`"
        correct: true
      - value: "`object`"
        correct: false
      - value: "`entity`"
        correct: false
      - value: "`value`"
        correct: false
    help: The `this` variable in `Expression` and `When` constraints refers to the
      instance of the object on which the constraint is applied.
  - question: Which of the following is a valid way to disable validation for a
      specific submit button in a Symfony form?
    answers:
      - value: Set `validation_groups` to `false` for that button.
        correct: true
      - value: Set `validate` to `false` for that button.
        correct: false
      - value: Remove all constraints from the button's fields.
        correct: false
      - value: Set `skip_validation` to `true` for that button.
        correct: false
    help: Setting `validation_groups` to `false` on a submit button prevents any
      validation from running when that button is clicked.
  - question: You want to validate that a string is a valid International Standard
      Book Number (ISBN), accepting both ISBN-10 and ISBN-13. Which constraint
      and option would you use?
    answers:
      - value: "`#[Assert\\Isbn(type: null)]`"
        correct: true
      - value: "`#[Assert\\Isbn(type: ['isbn10', 'isbn13'])]`"
        correct: false
      - value: "`#[Assert\\Isbn]` (without `type` option)"
        correct: true
      - value: "`#[Assert\\Isbn(version: 'any')]`"
        correct: false
    help: By default, the `Isbn` constraint validates against both ISBN-10 and
      ISBN-13 if the `type` option is `null` or not specified.
  - question: What is the purpose of the `includeInternalMessages` option in
      constraints like `AtLeastOneOf`?
    answers:
      - value: To include the specific error messages from the internal, failing
          constraints in the main violation message.
        correct: true
      - value: To enable translation for the internal constraint messages.
        correct: false
      - value: To allow internal constraints to define their own validation groups.
        correct: false
      - value: To log internal validation failures to the Symfony profiler.
        correct: false
    help: When `includeInternalMessages` is true, the main error message for
      `AtLeastOneOf` will list the messages of the constraints that failed
      within it, providing more detailed feedback.
  - question: Which of the following is NOT a common way to load validation metadata
      in Symfony?
    answers:
      - value: From PHP attributes.
        correct: false
      - value: From YAML files.
        correct: false
      - value: From XML files.
        correct: false
      - value: From JSON files.
        correct: true
      - value: Programmatically via `loadValidatorMetadata` static method.
        correct: false
    help: Symfony supports PHP attributes, YAML, XML, and programmatic configuration
      for validation metadata, but not JSON files directly for this purpose.
  - question: You need to validate that a `Product`'s `stock` property is divisible
      by 5. Which constraint would you apply?
    answers:
      - value: "`#[Assert\\DivisibleBy(5)]`"
        correct: true
      - value: "`#[Assert\\MultipleOf(5)]`"
        correct: false
      - value: "`#[Assert\\Callback('isDivisibleByFive')]`"
        correct: false
      - value: "`#[Assert\\Regex(pattern: '/^\\d*[05]$/')`"
        correct: false
    help: The `DivisibleBy` constraint is specifically designed to check if a
      numeric value is a multiple of a given number.
  - question: What is the purpose of the `validator.initializer` tag in the Symfony
      Dependency Injection Container?
    answers:
      - value: To register a service that initializes objects before validation,
          ensuring lazy-loaded data is present.
        correct: true
      - value: To define the initial state of the validator service.
        correct: false
      - value: To configure the default validation groups for all services.
        correct: false
      - value: To inject the validator service into other services.
        correct: false
    help: Initializers are crucial for scenarios where an object's data might be
      lazily loaded (e.g., Doctrine entities). The initializer ensures all
      necessary data is available before validation begins.
  - question: Which constraint option allows you to apply a PHP callable to each
      element of a collection before checking if the collection is valid (e.g.,
      for trimming whitespace)?
    answers:
      - value: "`normalizer`"
        correct: true
      - value: "`transformer`"
        correct: false
      - value: "`processor`"
        correct: false
      - value: "`filter`"
        correct: false
    help: The `normalizer` option is available on constraints like `Unique` (for
      collections) and allows you to preprocess values before validation, which
      is useful for cleaning data like trimming whitespace.
  - question: When validating a scalar value, such as an email string, how do you
      apply a constraint to it directly?
    answers:
      - value: Pass the scalar value and the constraint object to
          `$validator->validate()`.
        correct: true
      - value: Wrap the scalar value in a dummy object and apply constraints to that
          object.
        correct: false
      - value: Scalar values cannot be validated directly; they must be part of an
          object.
        correct: false
      - value: Use `Validation::createValidator()->validateString($email, new
          Assert\Email());`
        correct: false
    help: The `validate()` method is versatile and can be used for objects, arrays,
      and scalar values by passing the value and the constraint(s) directly.
  - question: What is the purpose of
      `Symfony\Component\Validator\Validation::createIsValidCallable()`?
    answers:
      - value: It returns a closure that returns `false` if the constraints are not
          matched.
        correct: true
      - value: It returns a closure that throws an exception if validation fails.
        correct: false
      - value: It returns a closure that generates a list of violations.
        correct: false
      - value: It returns a closure that applies default validation groups.
        correct: false
    help: "`createIsValidCallable()` is useful when you need a simple boolean result
      from validation, for instance, in `OptionsResolver`'s `setAllowedValues`."
  - question: How can you specify a custom translation domain for a specific
      validation violation message within a custom validator?
    answers:
      - value: Use
          `$this->context->buildViolation(...)->setTranslationDomain('my_domain')->addViolation();`
        correct: true
      - value: Set the `translationDomain` option on the constraint itself.
        correct: false
      - value: Pass the domain as a parameter to `addViolation()`.
        correct: false
      - value: It's not possible to set a custom translation domain for individual
          violations.
        correct: false
    help: The `setTranslationDomain()` method on the `ConstraintViolationBuilder`
      allows fine-grained control over where the message is looked up for
      translation.
  - question: Which constraint would you use to ensure a string is a valid ISO
      3166-1 alpha-2 country code?
    answers:
      - value: "`#[Assert\\Country]`"
        correct: true
      - value: "`#[Assert\\Locale]`"
        correct: false
      - value: "`#[Assert\\Language]`"
        correct: false
      - value: "`#[Assert\\Region]`"
        correct: false
    help: The `Country` constraint validates against the ISO 3166-1 alpha-2 standard
      for country codes.
  - question: What is the default `match` value for the `#[Assert\Regex]` constraint?
    answers:
      - value: "`true` (the value must match the pattern)"
        correct: true
      - value: "`false` (the value must NOT match the pattern)"
        correct: false
      - value: It depends on the pattern itself.
        correct: false
      - value: There is no default; `match` is required.
        correct: false
    help: "By default, `Regex` asserts that the value *matches* the provided
      pattern. You can set `match: false` to assert that it *does not match*."
  - question: When defining validation constraints for a property in YAML, how do
      you specify multiple constraints?
    answers:
      - value: List them as an array under the property name.
        correct: true
      - value: Separate them with commas on a single line.
        correct: false
      - value: Nest them under a `constraints` key.
        correct: false
      - value: It's not possible to define multiple constraints for a single property in
          YAML.
        correct: false
    help: In YAML, you define constraints as a list (array) under the property key,
      with each item being a constraint definition.
  - question: Which constraint is used to validate that a value is a valid Business
      Identifier Code (BIC)?
    answers:
      - value: "`#[Assert\\Bic]`"
        correct: true
      - value: "`#[Assert\\Swift]`"
        correct: false
      - value: "`#[Assert\\BankIdentifier]`"
        correct: false
      - value: "`#[Assert\\Iban]`"
        correct: false
    help: The `Bic` constraint is specifically for validating BIC codes. `Iban` is
      for International Bank Account Numbers.
  - question: What happens if a validation group in a `GroupSequence` fails?
    answers:
      - value: Validation stops, and no subsequent groups in the sequence are validated.
        correct: true
      - value: All groups in the sequence are still validated, but errors are collected.
        correct: false
      - value: The validator attempts to fix the violation automatically.
        correct: false
      - value: It falls back to the `Default` validation group.
        correct: false
    help: This 'fail-fast' behavior is a key feature of group sequences, allowing
      you to prioritize critical validations.
  - question: When creating a custom constraint, what is the default naming
      convention Symfony uses to find its associated validator class?
    answers:
      - value: Appending `Validator` to the constraint class name (e.g., `MyConstraint`
          -> `MyConstraintValidator`).
        correct: true
      - value: Prepending `Validator` to the constraint class name (e.g., `MyConstraint`
          -> `ValidatorMyConstraint`).
        correct: false
      - value: Using a `validatedBy()` method in the constraint to explicitly return the
          validator service ID.
        correct: false
      - value: It uses the `ConstraintValidator` interface directly.
        correct: false
    help: Symfony automatically infers the validator class name by appending
      'Validator' to the constraint class name, simplifying setup unless you
      need a custom validator name.
  - question: How can you pass custom variables into the expression context of an
      `#[Assert\When]` constraint?
    answers:
      - value: Using the `values` option.
        correct: true
      - value: Using the `parameters` option.
        correct: false
      - value: Using the `context` option.
        correct: false
      - value: It's not possible to pass custom variables; only `this` and `value` are
          available.
        correct: false
    help: The `values` option allows you to provide an array of custom variables
      that will be available within the expression, giving more flexibility to
      your conditional logic.
  - question: Which constraint is used to validate that a string represents a valid
      timezone identifier?
    answers:
      - value: "`#[Assert\\Timezone]`"
        correct: true
      - value: "`#[Assert\\DateTimezone]`"
        correct: false
      - value: "`#[Assert\\Zone]`"
        correct: false
      - value: "`#[Assert\\Locale]`"
        correct: false
    help: The `Timezone` constraint ensures that a given string corresponds to a
      recognized timezone identifier (e.g., 'Europe/Paris').
  - question: What is the purpose of the `message` option in most built-in Symfony
      validation constraints?
    answers:
      - value: To define the error message displayed when the validation fails.
        correct: true
      - value: To specify a translation key for the error message.
        correct: false
      - value: To provide a default value if the validated property is null.
        correct: false
      - value: To include additional information in the validation payload.
        correct: false
    help: The `message` option allows you to customize the user-facing error message
      for a specific constraint. It often supports placeholders like `{{ value
      }}` or `{{ limit }}`.
  - question: When validating a form, how can you combine the `Default` validation
      group with a custom group (e.g., `registration`)?
    answers:
      - value: Set `validation_groups` to `['Default', 'registration']`.
        correct: true
      - value: Set `validation_groups` to `['registration', 'Default']`.
        correct: true
      - value: By default, `Default` is always included, so just `['registration']` is
          enough.
        correct: false
      - value: It's not possible to combine `Default` with custom groups directly.
        correct: false
    help: By explicitly including `Default` in the `validation_groups` array, you
      ensure that all constraints not assigned to a specific group are also
      validated alongside your custom group.
  - question: What is the purpose of
      `Symfony\Component\Translation\TranslatableMessage` when building
      validation violations?
    answers:
      - value: To create violation messages that can be translated using Symfony's
          Translation component.
        correct: true
      - value: To automatically generate translation files for validation errors.
        correct: false
      - value: To define the default language for validation messages.
        correct: false
      - value: To mark a violation message as critical.
        correct: false
    help: Using `TranslatableMessage` allows you to define a translation key and
      parameters, letting the Translation component handle the actual
      translation of the error message based on the locale.
  - question: Which constraint option for `#[Assert\Collection]` allows you to
      specify that a field must be present and validated, even if its value is
      `null`?
    answers:
      - value: "`Required`"
        correct: true
      - value: "`NotBlank`"
        correct: false
      - value: "`NotNull`"
        correct: false
      - value: "`Mandatory`"
        correct: false
    help: The `Required` constraint within a `Collection` ensures that a specific
      key must exist in the input array and its associated constraints are
      always applied.
  - question: You have a `Discount` object with a `value` property. If the `type`
      property is 'percent', `value` must be less than or equal to 100.
      Otherwise, `value` can be any number. Which constraint would you use for
      this conditional logic?
    answers:
      - value: "`#[Assert\\When]`"
        correct: true
      - value: "`#[Assert\\Expression]`"
        correct: false
      - value: "`#[Assert\\Conditional]`"
        correct: false
      - value: "`#[Assert\\Callback]`"
        correct: false
    help: The `When` constraint is specifically designed for applying constraints
      conditionally based on an expression evaluated against the object.
  - question: What is the primary purpose of the `validator.constraint_validator`
      tag in Symfony?
    answers:
      - value: To register a custom service as a validator for a custom constraint.
        correct: true
      - value: To define the default validator for all built-in constraints.
        correct: false
      - value: To mark a service as capable of validating multiple constraints.
        correct: false
      - value: To inject the validator service into custom constraints.
        correct: false
    help: When you create a custom constraint and its validator, you tag the
      validator service with `validator.constraint_validator` so Symfony can
      discover and use it.
  - question: Which method is commonly used in an entity class to programmatically
      load validation metadata without using attributes, YAML, or XML files?
    answers:
      - value: "`public static function loadValidatorMetadata(ClassMetadata $metadata):
          void`"
        correct: true
      - value: "`public function getValidationConstraints(): array`"
        correct: false
      - value: "`public static function defineValidationRules(ValidatorBuilder
          $builder): void`"
        correct: false
      - value: "`public function configureValidator(ValidatorConfigurator
          $configurator): void`"
        correct: false
    help: The `loadValidatorMetadata` static method is a powerful way to define
      validation rules directly within your entity classes using the
      `ClassMetadata` object.
  - question: When validating an image, which option in the `#[Assert\Image]`
      constraint allows you to set a minimum aspect ratio (width / height)?
    answers:
      - value: "`minRatio`"
        correct: true
      - value: "`aspectRatioMin`"
        correct: false
      - value: "`ratioMin`"
        correct: false
      - value: "`minAspectRatio`"
        correct: false
    help: The `minRatio` option ensures the image's width-to-height ratio is above a
      specified value.
  - question: How can you filter a `ConstraintViolationList` to find violations with
      a specific error code, such as `UniqueEntity::NOT_UNIQUE_ERROR`?
    answers:
      - value: Using the `findByCodes()` method.
        correct: true
      - value: Using the `filterByCode()` method.
        correct: false
      - value: Iterating through violations and checking `getConstraint()->getCode()`.
        correct: true
      - value: Using the `hasCode()` method.
        correct: false
    help: "`findByCodes()` is a convenient method on
      `ConstraintViolationListInterface` for this purpose. You can also manually
      iterate and check each violation's code."
  - question: Which constraint is used to validate that a value is strictly `false`?
    answers:
      - value: "`#[Assert\\IsFalse]`"
        correct: true
      - value: "`#[Assert\\False]`"
        correct: false
      - value: "`#[Assert\\NotTrue]`"
        correct: false
      - value: "`#[Assert\\EqualTo(false)]`"
        correct: false
    help: The `IsFalse` constraint specifically checks for a boolean `false` value.
      It's often used on getter methods for custom validation logic.
  - question: When defining a custom callback validator, what is the type-hint for
      the first argument if the method is static?
    answers:
      - value: "`mixed $value` (the validated value/object)"
        correct: true
      - value: "`ExecutionContextInterface $context`"
        correct: false
      - value: No argument is passed; use `static` directly.
        correct: false
      - value: The class name of the validated object.
        correct: false
    help: For static callback methods, the value being validated (which could be an
      object) is passed as the first argument, followed by the
      `ExecutionContextInterface`.
  - question: What is the purpose of the `minPropertyPath` and `maxPropertyPath`
      options in the `#[Assert\Range]` constraint?
    answers:
      - value: To use the value of another property on the same object as the `min` or
          `max` limit.
        correct: true
      - value: To define the property paths where validation errors should be reported.
        correct: false
      - value: To specify the minimum and maximum length of a property path.
        correct: false
      - value: To set the property path for nested object validation.
        correct: false
    help: These options allow for dynamic range validation where the limits are
      derived from other properties of the validated object, enabling flexible
      business rules.
  - question: Which constraint is generally used to validate the structure and
      content of an array, including specific keys and their associated
      constraints?
    answers:
      - value: "`#[Assert\\Collection]`"
        correct: true
      - value: "`#[Assert\\All]`"
        correct: false
      - value: "`#[Assert\\Array]`"
        correct: false
      - value: "`#[Assert\\Map]`"
        correct: false
    help: The `Collection` constraint is powerful for validating arrays where you
      need to define rules for specific keys (fields) within that array,
      including whether they are `Required` or `Optional`.
  - question: How can you configure the Symfony Validator to load validation
      metadata from a YAML file?
    answers:
      - value: Using
          `Validation::createValidatorBuilder()->addYamlMapping('path/to/validation.yaml')->getValidator();`
        correct: true
      - value: By placing `validation.yaml` in the `config/validator/` directory.
        correct: true
      - value: By calling `Validator::loadYaml('path/to/validation.yaml');`
        correct: false
      - value: It's automatically loaded if the file exists in the project root.
        correct: false
    help: Symfony Flex configures the validator to automatically load files from
      `config/validator/`. For standalone usage or custom paths,
      `addYamlMapping()` is used.
  - question: What is the correct way to display validation error messages in a Twig
      template when `$errors` is a `ConstraintViolationList`?
    answers:
      - value: |-
          ```twig
          <ul>
          {% for error in errors %}
              <li>{{ error.message }}</li>
          {% endfor %}
          </ul>
          ```
        correct: true
      - value: |-
          ```twig
          {{ errors.join(', ') }}
          ```
        correct: false
      - value: |-
          ```twig
          {% for message in errors.getMessages() %}
              <li>{{ message }}</li>
          {% endfor %}
          ```
        correct: false
      - value: |-
          ```twig
          {{ errors.toString() }}
          ```
        correct: false
    help: The `ConstraintViolationList` is iterable, and each `error` object has a
      `message` property containing the validation error message.
  - question: Which constraint option for `#[Assert\Email]` allows you to enforce
      validation according to RFC 5322, requiring the `egulias/email-validator`
      library?
    answers:
      - value: "`mode: 'strict'`"
        correct: true
      - value: "`mode: 'rfc'`"
        correct: false
      - value: "`mode: 'full'`"
        correct: false
      - value: "`mode: 'advanced'`"
        correct: false
    help: The `strict` mode provides the most comprehensive email validation by
      adhering to RFC 5322, often requiring an additional library for full
      compliance.
  - question: What is the purpose of the `#[MapRequestPayload]` attribute in a
      controller method?
    answers:
      - value: To automatically map incoming request body data (JSON, XML, etc.) to a
          PHP object and validate it.
        correct: true
      - value: To map query parameters to a PHP object.
        correct: false
      - value: To map form data to a PHP object.
        correct: false
      - value: To map request headers to a PHP object.
        correct: false
    help: "`MapRequestPayload` simplifies API development by handling
      deserialization and validation of request bodies, often used with DTOs."
  - question: "When using `#[MapQueryParameter(filter: \\FILTER_VALIDATE_INT)]`,
      what happens if the query parameter value is not a valid integer?"
    answers:
      - value: A validation error is triggered, and the controller method might not be
          called.
        correct: true
      - value: The value is automatically cast to `0`.
        correct: false
      - value: The value is passed as `null` to the controller method.
        correct: false
      - value: A PHP warning is issued, but execution continues.
        correct: false
    help: The `filter` option with `MapQueryParameter` uses PHP's filter functions
      for basic validation and type coercion. If validation fails, it prevents
      the controller from executing with invalid data.
  - question: You have a custom constraint `MyCustomConstraint`. Which method in
      this constraint class would you override if its validator class is named
      `MyCustomConstraintValidator` (following the default convention)?
    answers:
      - value: You don't need to override any method; Symfony handles it automatically.
        correct: true
      - value: "`public function validatedBy(): string`"
        correct: false
      - value: "`public function getValidatorClass(): string`"
        correct: false
      - value: "`public function getTarget(): string`"
        correct: false
    help: Symfony's default `validatedBy()` implementation in
      `Symfony\Component\Validator\Constraint` automatically returns
      `static::class . 'Validator'`, so if your validator follows this
      convention, no override is needed.
  - question: What is the purpose of the `#[Assert\Callback]` constraint?
    answers:
      - value: To specify a method within the validated object or a static method to
          perform custom validation logic.
        correct: true
      - value: To define a JavaScript callback function for client-side validation.
        correct: false
      - value: To execute a database query for validation.
        correct: false
      - value: To call an external API for validation.
        correct: false
    help: The `Callback` constraint allows you to integrate custom PHP logic
      directly into the validation process, which is useful for complex rules
      that cannot be expressed with built-in constraints.
  - question: Which of the following is true regarding Doctrine ORM metadata and
      Symfony validation?
    answers:
      - value: Symfony can automatically infer `NotNull`, `Type`, `Length`, and
          `UniqueEntity` constraints from Doctrine metadata.
        correct: true
      - value: All Doctrine ORM constraints are automatically converted to Symfony
          validation constraints.
        correct: false
      - value: Doctrine ORM metadata completely replaces the need for Symfony validation
          constraints.
        correct: false
      - value: Only `nullable=false` is inferred as a `NotBlank` constraint.
        correct: false
    help: When `auto_mapping` is enabled and `PropertyInfo` component is installed,
      Symfony can infer several common validation constraints directly from
      Doctrine's ORM mapping, simplifying setup.
  - question: You want to ensure a user's `birthDate` is in the past. Which
      constraint would you use?
    answers:
      - value: "`#[Assert\\LessThanOrEqual('today')]`"
        correct: true
      - value: "`#[Assert\\Past]`"
        correct: true
      - value: "`#[Assert\\Date(max: 'now')]`"
        correct: false
      - value: "`#[Assert\\GreaterThan('now')]`"
        correct: false
    help: "`LessThanOrEqual` can compare against date strings like 'today' or 'now'.
      The `Past` constraint is a dedicated constraint for this purpose."
  - question: What is the role of `ConstraintViolationListInterface` in Symfony
      validation?
    answers:
      - value: It is a collection of all validation errors found during the validation
          process.
        correct: true
      - value: It defines the interface for custom validation constraints.
        correct: false
      - value: It provides methods for building new validation constraints.
        correct: false
      - value: It's a service that manages validation groups.
        correct: false
    help: The `validate()` method of the validator returns an object implementing
      `ConstraintViolationListInterface`, which you can iterate over to access
      individual violations.
  - question: Which of the following built-in constraints is used to check if a
      value is a valid International Bank Account Number (IBAN)?
    answers:
      - value: "`#[Assert\\Iban]`"
        correct: true
      - value: "`#[Assert\\BankAccount]`"
        correct: false
      - value: "`#[Assert\\Isbn]`"
        correct: false
      - value: "`#[Assert\\Bic]`"
        correct: false
    help: The `Iban` constraint specifically validates the format and checksum of an
      IBAN.
  - question: What is the primary difference between `#[Assert\NotBlank]` and
      `#[Assert\NotNull]`?
    answers:
      - value: "`NotBlank` checks for non-empty strings (and non-whitespace), while
          `NotNull` only checks if the value is not `null`."
        correct: true
      - value: "`NotBlank` applies to all data types, `NotNull` only to strings."
        correct: false
      - value: "`NotNull` is for database fields, `NotBlank` is for form fields."
        correct: false
      - value: They are aliases for each other.
        correct: false
    help: A `null` value would pass `NotBlank` if it's not a string, but it would
      fail `NotNull`. A string with only spaces would fail `NotBlank` but pass
      `NotNull`.
  - question: How can you apply a class-level validation constraint (e.g., a
      `Callback` constraint that validates the entire object) using PHP
      metadata?
    answers:
      - value: "`$metadata->addConstraint(new Assert\\Callback('validateMethod'));`"
        correct: true
      - value: "`$metadata->addClassConstraint(new
          Assert\\Callback('validateMethod'));`"
        correct: false
      - value: "`$metadata->addPropertyConstraint('this', new
          Assert\\Callback('validateMethod'));`"
        correct: false
      - value: "`$metadata->setConstraint(new Assert\\Callback('validateMethod'));`"
        correct: false
    help: The `addConstraint()` method on `ClassMetadata` is used for class-level
      constraints that apply to the object as a whole, not just a specific
      property.
  - question: Which constraint is used to validate that a value is a valid
      Universally Unique Identifier (UUID)?
    answers:
      - value: "`#[Assert\\Uuid]`"
        correct: true
      - value: "`#[Assert\\Ulid]`"
        correct: false
      - value: "`#[Assert\\Guid]`"
        correct: false
      - value: "`#[Assert\\UniqueId]`"
        correct: false
    help: The `Uuid` constraint validates strings against the various UUID formats
      (versions 1-5).
  - question: When defining a custom constraint, what is the purpose of the
      `#[Attribute]` attribute?
    answers:
      - value: It marks the class as a PHP 8 attribute, allowing it to be used directly
          on properties, methods, or classes.
        correct: true
      - value: It specifies that the constraint can be configured via YAML or XML.
        correct: false
      - value: It indicates that the constraint requires a custom validator.
        correct: false
      - value: It makes the constraint available for autowiring.
        correct: false
    help: The `#[Attribute]` attribute (from PHP 8) is essential for making your
      custom constraint usable as a native PHP attribute, which is the modern
      way to define constraints.
  - question: You have a `User` entity with a `username` property. You want to
      ensure the username has a minimum length of 5 characters. Which constraint
      would you use?
    answers:
      - value: "`#[Assert\\Length(min: 5)]`"
        correct: true
      - value: "`#[Assert\\MinLength(5)]`"
        correct: false
      - value: "`#[Assert\\Count(min: 5)]`"
        correct: false
      - value: "`#[Assert\\TextLength(min: 5)]`"
        correct: false
    help: The `Length` constraint is used to validate the length of strings, arrays,
      or countable objects.
  - question: Which of the following is a valid way to configure a `Choice`
      constraint with a callback method in XML?
    answers:
      - value: |-
          ```xml
          <constraint name="Choice">
              <option name="callback">getGenres</option>
          </constraint>
          ```
        correct: true
      - value: |-
          ```xml
          <constraint name="Choice" callback="getGenres"/>
          ```
        correct: false
      - value: |-
          ```xml
          <constraint name="Choice">
              <callback>getGenres</callback>
          </constraint>
          ```
        correct: false
      - value: |-
          ```xml
          <constraint name="Choice" method="getGenres"/>
          ```
        correct: false
    help: In XML, the `callback` option for the `Choice` constraint is specified as
      an `<option>` tag with the name `callback` and the method name as its
      value.
  - question: What is the purpose of the `messageCollection` option in constraints
      like `AtLeastOneOf`?
    answers:
      - value: It defines the message shown if an internal constraint is `All` or
          `Collection` and fails.
        correct: true
      - value: It specifies the message for when the main constraint is applied to a
          collection.
        correct: false
      - value: It's a message displayed when the collection itself is invalid.
        correct: false
      - value: It provides a default message for all nested collection errors.
        correct: false
    help: The `messageCollection` option provides a specific error message when the
      failing internal constraint within `AtLeastOneOf` is a `Collection` or
      `All` constraint, offering more context.
  - question: Which constraint would you use to ensure a string value is a valid
      International Standard Serial Number (ISSN)?
    answers:
      - value: "`#[Assert\\Issn]`"
        correct: true
      - value: "`#[Assert\\Isbn]`"
        correct: false
      - value: "`#[Assert\\Serial]`"
        correct: false
      - value: "`#[Assert\\PublicationId]`"
        correct: false
    help: The `Issn` constraint is specifically designed for validating ISSNs,
      including options for case sensitivity and hyphen requirements.
  - question: How can you specify the accepted content format (e.g., 'json', 'xml')
      for the `#[MapRequestPayload]` attribute?
    answers:
      - value: Using the `acceptFormat` option.
        correct: true
      - value: Using the `contentType` option.
        correct: false
      - value: Using the `format` option.
        correct: false
      - value: It's automatically detected from the `Content-Type` header.
        correct: false
    help: The `acceptFormat` option allows you to explicitly define which content
      types the attribute should process, ensuring the payload is in the
      expected format.
  - question: What is the purpose of the `negate` option in the
      `#[Assert\Expression]` constraint?
    answers:
      - value: If set to `false`, the validation fails when the expression returns
          `true`.
        correct: true
      - value: It inverts the result of the expression (e.g., `true` becomes `false`).
        correct: false
      - value: It allows the expression to return `null` without failing validation.
        correct: false
      - value: It negates the error message if validation fails.
        correct: false
    help: The `negate` option provides flexibility in how the expression's boolean
      result is interpreted for validation success or failure.
