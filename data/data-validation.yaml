category: Data Validation

questions:
  -
    question: >
      Which component is primarily responsible for handling data validation in Symfony applications?
    answers:
      - { value: 'The Validator component.', correct: true }
      - { value: 'The Form component.', correct: false }
      - { value: 'The Security component.', correct: false }
      - { value: 'The Doctrine ORM component.', correct: false }
    help: |
      The Validator component provides the tools for validating data against a set of rules (constraints). While the Form component uses the Validator, the core validation logic resides in the Validator component itself.
      https://symfony.com/doc/current/validation.html

  -
    question: |
      To enable validation in a Symfony application, which bundle typically needs to be configured or enabled?

      ```yaml
      # config/packages/framework.yaml
      framework:
          # ...
          validation: { enable_annotations: true } # Or enable_attributes: true in newer Symfony versions
          # ...
      ```
    answers:
      - { value: 'FrameworkBundle', correct: true }
      - { value: 'ValidatorBundle', correct: false }
      - { value: 'AnnotationsBundle', correct: false }
      - { value: 'FormBundle', correct: false }
    help: |
      The validation configuration is part of the FrameworkBundle. Enabling validation, including attribute support, is done under the `framework.validation` key.
      https://symfony.com/doc/current/reference/configuration/framework.html#validation

  -
    question: >
      What is the recommended way to define validation constraints for a PHP object in Symfony 7?
    answers:
      - { value: 'Using PHP attributes directly on properties or methods.', correct: true }
      - { value: 'Using YAML configuration files.', correct: true }
      - { value: 'Using XML configuration files.', correct: true }
      - { value: 'Using annotations (deprecated in favor of attributes).', correct: false }
      - { value: 'Implementing the `ValidatableInterface`.', correct: false }
    help: |
      Symfony 7 primarily recommends PHP attributes for defining constraints. However, YAML and XML configurations are still fully supported and valid alternatives. Annotations are technically still supported for backward compatibility but attributes are the modern approach.
      https://symfony.com/doc/current/validation.html#constraints-configuration

  -
    question: |
      Consider the following PHP class. Which attribute would you use to ensure the `email` property is a valid email address?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class User
      {
          #[Assert\NotBlank]
          private ?string $name = null;

          // ???
          private ?string $email = null;
      }
      ```
    answers:
      - { value: '`#[Assert\Email]`', correct: true }
      - { value: '`#[Assert\ValidEmail]`', correct: false }
      - { value: '`#[Assert\Type(''email'')]`', correct: false }
      - { value: '`#[Assert\Format(pattern: ''/^\S+@\S+\.\S+$/'')]`', correct: false }
    help: |
      The `Email` constraint is used to validate that a string is a valid email address.
      https://symfony.com/doc/current/reference/constraints/Email.html

  -
    question: >
      Which built-in constraint would you use to ensure a string property is not empty and not just whitespace?
    answers:
      - { value: '`NotBlank`', correct: true }
      - { value: '`NotNull`', correct: false }
      - { value: '`NotEmpty`', correct: false }
      - { value: '`Length(min: 1)`', correct: false }
    help: |
      The `NotBlank` constraint asserts that the validated value is not blank. It considers `null`, empty strings, and strings consisting only of whitespace characters as blank.
      https://symfony.com/doc/current/reference/constraints/NotBlank.html

  -
    question: |
      You have a `Product` object with a `price` property. Which constraint would you use to ensure the price is between 0.01 and 1000.00 (inclusive)?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class Product
      {
          // ???
          private float $price;
      }
      ```
    answers:
      - { value: '`#[Assert\Range(min: 0.01, max: 1000.00)]`', correct: true }
      - { value: '`#[Assert\GreaterThanOrEqual(value: 0.01), Assert\LessThanOrEqual(value: 1000.00)]`', correct: true }
      - { value: '`#[Assert\Between(0.01, 1000.00)]`', correct: false }
      - { value: '`#[Assert\Min(0.01), Assert\Max(1000.00)]`', correct: false }
    help: |
      The `Range` constraint checks if a value is between a specified minimum and maximum. Alternatively, `GreaterThanOrEqual` and `LessThanOrEqual` can be combined.
      https://symfony.com/doc/current/reference/constraints/Range.html
      https://symfony.com/doc/current/reference/constraints/GreaterThanOrEqual.html
      https://symfony.com/doc/current/reference/constraints/LessThanOrEqual.html

  -
    question: >
      What is the purpose of validation groups in Symfony?
    answers:
      - { value: 'To apply different sets of constraints depending on the context or operation.', correct: true }
      - { value: 'To group related validation errors together.', correct: false }
      - { value: 'To define the order in which constraints are executed.', correct: false }
      - { value: 'To validate multiple objects simultaneously.', correct: false }
    help: |
      Validation groups allow you to validate an object against a subset of its constraints. This is useful when the same object needs different validation rules depending on the scenario (e.g., "registration" vs. "profile update").
      https://symfony.com/doc/current/validation/groups.html

  -
    question: |
      How would you specify that a `name` property should only be validated when the `registration` group is active?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class User
      {
          // ???
          private ?string $name = null;
      }
      ```
    answers:
      - { value: '`#[Assert\NotBlank(groups: [''registration''])]`', correct: true }
      - { value: '`#[Assert\NotBlank(group: ''registration'')]`', correct: false }
      - { value: '`#[Assert\NotBlank(on: ''registration'')]`', correct: false }
      - { value: '`#[Assert\NotBlank(context: ''registration'')]`', correct: false }
    help: |
      The `groups` option is used with constraints to specify which validation groups they belong to.
      https://symfony.com/doc/current/validation/groups.html#basic-example

  -
    question: >
      By default, which validation group is always active when you validate an object without explicitly specifying groups?
    answers:
      - { value: '`Default`', correct: true }
      - { value: '`Standard`', correct: false }
      - { value: '`All`', correct: false }
      - { value: '`Global`', correct: false }
    help: |
      When no groups are specified, the `Default` group is used. Any constraint without an explicit `groups` option belongs to the `Default` group.
      https://symfony.com/doc/current/validation/groups.html#default-group

  -
    question: |
      You have a `User` entity with different validation rules for `registration` and `profile_update`. How can you define a group sequence to ensure `registration` rules are checked before `profile_update` rules?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Mapping\Attribute\GroupSequence;

      #[GroupSequence(['registration', 'profile_update'])]
      class User
      {
          // ...
      }
      ```
      What is the effect of this `GroupSequence`?
    answers:
      - { value: 'Validation will stop if any constraint in the `registration` group fails, and `profile_update` rules will not be checked.', correct: true }
      - { value: 'All `registration` and `profile_update` rules will be checked simultaneously.', correct: false }
      - { value: 'Validation will proceed to `profile_update` rules even if `registration` rules fail.', correct: false }
      - { value: 'It defines a new combined group named `registration_profile_update`.', correct: false }
    help: |
      A group sequence ensures that validation groups are executed in a specific order. If a violation is found in an earlier group, subsequent groups in the sequence are not validated.
      https://symfony.com/doc/current/validation/group_sequence.html

  -
    question: >
      When would you typically use a custom callback validator?
    answers:
      - { value: 'When the validation logic is too complex for built-in constraints.', correct: true }
      - { value: 'When you need to perform validation that depends on multiple properties of an object.', correct: true }
      - { value: 'When you need to interact with a database or external service for validation.', correct: true }
      - { value: 'When you want to override the behavior of a built-in constraint.', correct: false }
    help: |
      Callback validators are ideal for complex validation logic, cross-property validation, or when external dependencies (like a database) are required for validation.
      https://symfony.com/doc/current/validation/custom_constraint.html#callback-constraint

  -
    question: |
      How do you define a callback method for validation using PHP attributes?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;
      use Symfony\Component\Validator\Context\ExecutionContextInterface;

      class User
      {
          private ?string $password = null;
          private ?string $confirmPassword = null;

          // ???
          public function validatePasswordMatch(ExecutionContextInterface $context, mixed $payload): void
          {
              if ($this->password !== $this->confirmPassword) {
                  $context->buildViolation('Passwords do not match.')
                      ->atPath('confirmPassword')
                      ->addViolation();
              }
          }
      }
      ```
    answers:
      - { value: '`#[Assert\Callback(callback: [self::class, ''validatePasswordMatch''])]`', correct: true }
      - { value: '`#[Assert\Callback(''validatePasswordMatch'')]`', correct: true }
      - { value: '`#[Assert\Custom(method: ''validatePasswordMatch'')]`', correct: false }
      - { value: '`#[Assert\Expression(expression: ''this.password === this.confirmPassword'')]`', correct: false }
    help: |
      The `Callback` constraint allows you to specify a method on the validated object (or a static method) that will perform the validation. You can pass the method name as a string or an array `[self::class, 'methodName']`.
      https://symfony.com/doc/current/reference/constraints/Callback.html

  -
    question: >
      What is the purpose of the `ExecutionContextInterface` object passed to a custom callback validator method?
    answers:
      - { value: 'To add validation violations and access the validator.', correct: true }
      - { value: 'To retrieve the validated object''s properties.', correct: false }
      - { value: 'To define new validation constraints dynamically.', correct: false }
      - { value: 'To configure the validation groups for the current validation process.', correct: false }
    help: |
      The `ExecutionContextInterface` provides methods to add violations (`buildViolation`), access the root object, and other validation-related utilities.
      https://symfony.com/doc/current/validation/custom_constraint.html#callback-constraint

  -
    question: |
      When building a custom violation using `buildViolation()`, which method is used to specify the property path where the violation occurred?

      ```php
      // Inside a custom validator or callback
      $context->buildViolation('Invalid value.')
          // ???
          ->addViolation();
      ```
    answers:
      - { value: '`atPath(''propertyName'')`', correct: true }
      - { value: '`setPropertyPath(''propertyName'')`', correct: false }
      - { value: '`onProperty(''propertyName'')`', correct: false }
      - { value: '`forPath(''propertyName'')`', correct: false }
    help: |
      The `atPath()` method is used to set the property path for the violation. This is crucial for displaying errors correctly in forms.
      https://symfony.com/doc/current/validation/custom_constraint.html#adding-violations-with-the-violations-builder

  -
    question: >
      Which built-in constraint is used to validate that an associated object or collection of objects is also valid?
    answers:
      - { value: '`Valid`', correct: true }
      - { value: '`Nested`', correct: false }
      - { value: '`Object`', correct: false }
      - { value: '`Collection`', correct: false }
    help: |
      The `Valid` constraint is used to recursively validate the referenced object or each object in a collection.
      https://symfony.com/doc/current/reference/constraints/Valid.html

  -
    question: |
      Given the following `Address` class, how would you ensure that when a `User` object is validated, its `address` property is also validated?

      ```php
      // App\Entity\User.php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class User
      {
          // ...
          // ???
          private ?Address $address = null;
      }

      // App\Entity\Address.php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class Address
      {
          #[Assert\NotBlank]
          private ?string $street = null;
      }
      ```
    answers:
      - { value: '`#[Assert\Valid]`', correct: true }
      - { value: '`#[Assert\Type(type: Address::class)]`', correct: false }
      - { value: '`#[Assert\Object]`', correct: false }
      - { value: '`#[Assert\Nested]`', correct: false }
    help: |
      The `Valid` constraint is applied to properties that hold other objects (or collections of objects) that also need to be validated.
      https://symfony.com/doc/current/reference/constraints/Valid.html

  -
    question: >
      What is the correct way to retrieve the validator service from the service container in a controller?
    answers:
      - { value: 'Type-hinting `Symfony\\Component\\Validator\\Validator\\ValidatorInterface` in the constructor or action method.', correct: true }
      - { value: 'Using `$this->get(''validator'')` (if the controller extends `AbstractController`).', correct: false }
      - { value: 'Calling `Container::get(''validator'')`.', correct: false }
      - { value: 'Instantiating `new Validator()`.', correct: false }
    help: |
      The recommended way to get services in Symfony is via dependency injection (type-hinting). While `get('validator')` might work in some legacy contexts, it's not the preferred method.
      https://symfony.com/doc/current/service_container/getting_services.html

  -
    question: |
      How do you manually validate an object using the validator service?

      ```php
      namespace App\Controller;

      use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
      use Symfony\Component\HttpFoundation\Response;
      use Symfony\Component\Routing\Attribute\Route;
      use Symfony\Component\Validator\Validator\ValidatorInterface;
      use App\Entity\User;

      class UserController extends AbstractController
      {
          #[Route('/user/new', name: 'app_user_new')]
          public function new(ValidatorInterface $validator): Response
          {
              $user = new User();
              $user->setName(''); // Invalid name

              // ???
              $errors = null; // Store violations here

              // ...
              return $this->render('user/new.html.twig', ['errors' => $errors]);
          }
      }
      ```
    answers:
      - { value: '`$errors = $validator->validate($user);`', correct: true }
      - { value: '`$errors = $validator->validateObject($user);`', correct: false }
      - { value: '`$errors = $validator->validate($user, null, [''Default'']);`', correct: true }
      - { value: '`$errors = $validator->validate($user, groups: [''Default'']);`', correct: false }
    help: |
      The `validate()` method of the `ValidatorInterface` is used to validate an object. You can optionally pass an array of validation groups as the third argument.
      https://symfony.com/doc/current/validation.html#validating-objects

  -
    question: >
      After validating an object, what type of object is returned by the `ValidatorInterface::validate()` method if there are violations?
    answers:
      - { value: 'A `ConstraintViolationList` object.', correct: true }
      - { value: 'An array of strings.', correct: false }
      - { value: 'A `ValidationErrors` object.', correct: false }
      - { value: 'A boolean `true` or `false`.', correct: false }
    help: |
      The `validate()` method returns a `ConstraintViolationList` instance, which is a collection of `ConstraintViolation` objects.
      https://symfony.com/doc/current/validation.html#validating-objects

  -
    question: |
      How can you check if there are any validation violations in the `ConstraintViolationList` object?

      ```php
      use Symfony\Component\Validator\ConstraintViolationListInterface;

      function processValidation(ConstraintViolationListInterface $violations): void
      {
          if (/* ??? */) {
              echo "Validation failed!";
          } else {
              echo "Validation successful!";
          }
      }
      ```
    answers:
      - { value: '`$violations->count() > 0`', correct: true }
      - { value: '`!$violations->isEmpty()`', correct: true }
      - { value: '`$violations->hasErrors()`', correct: false }
      - { value: '`count($violations) > 0`', correct: true }
    help: |
      The `ConstraintViolationList` implements `Countable` and `IteratorAggregate`, so you can use `count()` or `isEmpty()`.
      https://symfony.com/doc/current/validation.html#validating-objects

  -
    question: >
      Which constraint would you use to ensure a string property matches a specific regular expression pattern?
    answers:
      - { value: '`Regex`', correct: true }
      - { value: '`Pattern`', correct: false }
      - { value: '`Match`', correct: false }
      - { value: '`Expression`', correct: false }
    help: |
      The `Regex` constraint validates that a string matches a given regular expression.
      https://symfony.com/doc/current/reference/constraints/Regex.html

  -
    question: |
      You want to ensure a `username` property has a minimum length of 3 and a maximum length of 20 characters. How would you apply this constraint?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class User
      {
          // ???
          private ?string $username = null;
      }
      ```
    answers:
      - { value: '`#[Assert\Length(min: 3, max: 20)]`', correct: true }
      - { value: '`#[Assert\MinLength(3), Assert\MaxLength(20)]`', correct: false }
      - { value: '`#[Assert\Size(min: 3, max: 20)]`', correct: false }
      - { value: '`#[Assert\Range(min: 3, max: 20)]`', correct: false }
    help: |
      The `Length` constraint is used to check the length of a string.
      https://symfony.com/doc/current/reference/constraints/Length.html

  -
    question: >
      Which constraint is used to ensure a property's value is one of a predefined set of options?
    answers:
      - { value: '`Choice`', correct: true }
      - { value: '`InArray`', correct: false }
      - { value: '`Options`', correct: false }
      - { value: '`Enum`', correct: false }
    help: |
      The `Choice` constraint validates that a value is one of a given list of choices.
      https://symfony.com/doc/current/reference/constraints/Choice.html

  -
    question: |
      How can you apply a constraint to an entire class (e.g., for cross-property validation) using PHP attributes?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      // ???
      class Order
      {
          private ?\DateTimeInterface $startDate = null;
          private ?\DateTimeInterface $endDate = null;
      }
      ```
    answers:
      - { value: '`#[Assert\Callback(callback: [self::class, ''validateDates''])]`', correct: true }
      - { value: '`#[Assert\Expression(expression: ''this.startDate < this.endDate'')]`', correct: true }
      - { value: '`#[Assert\ClassConstraint]`', correct: false }
      - { value: '`#[Assert\ObjectConstraint]`', correct: false }
    help: |
      Class-level constraints are applied directly to the class. `Callback` and `Expression` are common choices for validating relationships between properties.
      https://symfony.com/doc/current/validation/custom_constraint.html#callback-constraint
      https://symfony.com/doc/current/reference/constraints/Expression.html

  -
    question: >
      What is the primary benefit of using `GroupSequence` over simply listing multiple groups in the `validate()` method?
    answers:
      - { value: 'It allows validation to stop immediately if a violation is found in an earlier group.', correct: true }
      - { value: 'It makes the validation process faster by optimizing constraint checks.', correct: false }
      - { value: 'It enables parallel validation of different groups.', correct: false }
      - { value: 'It automatically reorders groups based on dependency.', correct: false }
    help: |
      The main advantage of `GroupSequence` is its "fail-fast" behavior. If a group in the sequence fails, subsequent groups are not validated, which can save processing time and provide clearer error messages.
      https://symfony.com/doc/current/validation/group_sequence.html

  -
    question: |
      You are creating a custom validator class for a new constraint. Which interface must this custom validator class implement?
    answers:
      - { value: '`Symfony\\Component\\Validator\\ConstraintValidatorInterface`', correct: true }
      - { value: '`Symfony\\Component\\Validator\\ValidatorInterface`', correct: false }
      - { value: '`Symfony\\Component\\Validator\\ConstraintInterface`', correct: false }
      - { value: '`Symfony\\Component\\Validator\\ValidationAwareInterface`', correct: false }
    help: |
      Custom validator classes must implement `ConstraintValidatorInterface` and typically extend `ConstraintValidator`.
      https://symfony.com/doc/current/validation/custom_constraint.html#creating-the-validator

  -
    question: |
      Inside a custom constraint validator's `validate()` method, how do you access the validated value?

      ```php
      // Inside MyCustomValidator.php
      use Symfony\Component\Validator\Constraint;
      use Symfony\Component\Validator\ConstraintValidator;

      class MyCustomValidator extends ConstraintValidator
      {
          public function validate(mixed $value, Constraint $constraint): void
          {
              // ???
          }
      }
      ```
    answers:
      - { value: 'The `$value` argument directly.', correct: true }
      - { value: '`$this->context->getValue()`', correct: false }
      - { value: '`$constraint->getValue()`', correct: false }
      - { value: '`$this->value`', correct: false }
    help: |
      The value being validated is passed as the first argument (`$value`) to the `validate()` method of the custom validator.
      https://symfony.com/doc/current/validation/custom_constraint.html#creating-the-validator

  -
    question: |
      When creating a custom constraint, which class should your constraint attribute extend?

      ```php
      namespace App\Validator\Constraints;

      use Symfony\Component\Validator\Constraint;

      #[\Attribute(\Attribute::TARGET_PROPERTY | \Attribute::TARGET_METHOD | \Attribute::IS_REPEATABLE)]
      class MyCustomConstraint extends /* ??? */
      {
          public string $message = 'This value is not valid.';
      }
      ```
    answers:
      - { value: '`Constraint`', correct: true }
      - { value: '`AbstractConstraint`', correct: false }
      - { value: '`ValidationAttribute`', correct: false }
      - { value: '`BaseConstraint`', correct: false }
    help: |
      All custom constraint attributes must extend `Symfony\Component\Validator\Constraint`.
      https://symfony.com/doc/current/validation/custom_constraint.html#creating-the-constraint-class

  -
    question: >
      What is the purpose of the `payload` argument in a constraint violation?
    answers:
      - { value: 'To attach custom, non-string data to a violation for later processing.', correct: true }
      - { value: 'To specify the HTTP status code for the validation error.', correct: false }
      - { value: 'To provide a unique identifier for the violation.', correct: false }
      - { value: 'To define the severity level of the violation (e.g., warning, error).', correct: false }
    help: |
      The `payload` option allows you to attach arbitrary data to a violation. This can be useful for frontend frameworks or custom error handling logic.
      https://symfony.com/doc/current/validation/payload.html

  -
    question: |
      You want to validate that a `password` property is strong, containing at least one uppercase letter, one lowercase letter, one digit, and one special character. Which built-in constraint is best suited for this?
    answers:
      - { value: '`Regex`', correct: true }
      - { value: '`Expression`', correct: false }
      - { value: '`Callback`', correct: false }
      - { value: '`PasswordStrength` (does not exist as a built-in constraint)', correct: false }
    help: |
      While `Callback` or `Expression` could work, `Regex` is the most direct and efficient built-in constraint for complex pattern matching like password strength requirements.
      https://symfony.com/doc/current/reference/constraints/Regex.html

  -
    question: >
      Which constraint would you use to ensure a numeric value is greater than a specific number?
    answers:
      - { value: '`GreaterThan`', correct: true }
      - { value: '`Min`', correct: false }
      - { value: '`Positive`', correct: false }
      - { value: '`AtLeast`', correct: false }
    help: |
      The `GreaterThan` constraint asserts that a value is strictly greater than a given value.
      https://symfony.com/doc/current/reference/constraints/GreaterThan.html

  -
    question: >
      Which constraint would you use to ensure a numeric value is greater than or equal to a specific number?
    answers:
      - { value: '`GreaterThanOrEqual`', correct: true }
      - { value: '`Min`', correct: false }
      - { value: '`AtLeast`', correct: false }
      - { value: '`PositiveOrZero`', correct: false }
    help: |
      The `GreaterThanOrEqual` constraint asserts that a value is greater than or equal to a given value.
      https://symfony.com/doc/current/reference/constraints/GreaterThanOrEqual.html

  -
    question: >
      Which constraint would you use to ensure a numeric value is less than a specific number?
    answers:
      - { value: '`LessThan`', correct: true }
      - { value: '`Max`', correct: false }
      - { value: '`Negative`', correct: false }
      - { value: '`AtMost`', correct: false }
    help: |
      The `LessThan` constraint asserts that a value is strictly less than a given value.
      https://symfony.com/doc/current/reference/constraints/LessThan.html

  -
    question: >
      Which constraint would you use to ensure a numeric value is less than or equal to a specific number?
    answers:
      - { value: '`LessThanOrEqual`', correct: true }
      - { value: '`Max`', correct: false }
      - { value: '`AtMost`', correct: false }
      - { value: '`NegativeOrZero`', correct: false }
    help: |
      The `LessThanOrEqual` constraint asserts that a value is less than or equal to a given value.
      https://symfony.com/doc/current/reference/constraints/LessThanOrEqual.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid URL?
    answers:
      - { value: '`Url`', correct: true }
      - { value: '`Link`', correct: false }
      - { value: '`WebAddress`', correct: false }
      - { value: '`Uri`', correct: false }
    help: |
      The `Url` constraint validates that a string is a valid URL.
      https://symfony.com/doc/current/reference/constraints/Url.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid IP address?
    answers:
      - { value: '`Ip`', correct: true }
      - { value: '`IpAddress`', correct: false }
      - { value: '`NetworkAddress`', correct: false }
      - { value: '`Host`', correct: false }
    help: |
      The `Ip` constraint validates that a string is a valid IP address (IPv4 or IPv6).
      https://symfony.com/doc/current/reference/constraints/Ip.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid UUID?
    answers:
      - { value: '`Uuid`', correct: true }
      - { value: '`Guid`', correct: false }
      - { value: '`UniqueId`', correct: false }
      - { value: '`Identifier`', correct: false }
    help: |
      The `Uuid` constraint validates that a string is a valid UUID (Universally Unique Identifier).
      https://symfony.com/doc/current/reference/constraints/Uuid.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid JSON string?
    answers:
      - { value: '`Json`', correct: true }
      - { value: '`IsJson`', correct: false }
      - { value: '`JsonString`', correct: false }
      - { value: '`DataFormat`', correct: false }
    help: |
      The `Json` constraint validates that a string is a valid JSON string.
      https://symfony.com/doc/current/reference/constraints/Json.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid file upload?
    answers:
      - { value: '`File`', correct: true }
      - { value: '`UploadedFile`', correct: false }
      - { value: '`Attachment`', correct: false }
      - { value: '`Resource`', correct: false }
    help: |
      The `File` constraint validates uploaded files. It can check size, MIME type, and other file-related properties.
      https://symfony.com/doc/current/reference/constraints/File.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid image file?
    answers:
      - { value: '`Image`', correct: true }
      - { value: '`Picture`', correct: false }
      - { value: '`Photo`', correct: false }
      - { value: '`Graphic`', correct: false }
    help: |
      The `Image` constraint extends the `File` constraint and adds image-specific validation rules like width, height, and aspect ratio.
      https://symfony.com/doc/current/reference/constraints/Image.html

  -
    question: |
      How can you retrieve a specific violation from a `ConstraintViolationList` by its index?

      ```php
      use Symfony\Component\Validator\ConstraintViolationListInterface;

      function getFirstViolation(ConstraintViolationListInterface $violations): ?string
      {
          if ($violations->count() > 0) {
              return $violations->get(0)->getMessage();
          }
          return null;
      }
      ```
      Which method is used to get a violation at a specific index?
    answers:
      - { value: '`get(index)`', correct: true }
      - { value: '`offsetGet(index)`', correct: false }
      - { value: '`item(index)`', correct: false }
      - { value: '`at(index)`', correct: false }
    help: |
      The `ConstraintViolationList` implements `ArrayAccess`, allowing you to access violations by index using `get()`.
      https://symfony.com/doc/current/validation.html#validating-objects (implicitly, as it behaves like an array)

  -
    question: >
      What is the purpose of the `Expression` constraint?
    answers:
      - { value: 'To validate a value based on a Symfony ExpressionLanguage expression.', correct: true }
      - { value: 'To execute a PHP callback function for validation.', correct: false }
      - { value: 'To check if a string matches a regular expression.', correct: false }
      - { value: 'To define complex validation rules using a custom DSL.', correct: false }
    help: |
      The `Expression` constraint allows you to define complex validation rules using the Symfony ExpressionLanguage component.
      https://symfony.com/doc/current/reference/constraints/Expression.html

  -
    question: |
      You want to ensure that a `User` object's `age` property is at least 18, and its `isAdult` property is `true`. How can you achieve this with a single `Expression` constraint?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      #[Assert\Expression(
          expression: '/* ??? */',
          message: 'User must be an adult.'
      )]
      class User
      {
          private int $age;
          private bool $isAdult;
      }
      ```
    answers:
      - { value: '`this.age >= 18 and this.isAdult == true`', correct: true }
      - { value: '`value.age >= 18 && value.isAdult === true`', correct: false }
      - { value: '`object.age >= 18 and object.isAdult is true`', correct: false }
      - { value: '`this.age >= 18 and this.isAdult`', correct: true }
    help: |
      Inside an `Expression` constraint applied to a class, `this` refers to the validated object. Boolean values can be checked directly.
      https://symfony.com/doc/current/reference/constraints/Expression.html#expression-language

  -
    question: >
      Which constraint is used to ensure a collection (e.g., an array or `Countable` object) has a specific number of elements?
    answers:
      - { value: '`Count`', correct: true }
      - { value: '`CollectionSize`', correct: false }
      - { value: '`Size`', correct: false }
      - { value: '`Length` (for collections)', correct: false }
    help: |
      The `Count` constraint validates that a collection has a minimum, maximum, or exact number of elements.
      https://symfony.com/doc/current/reference/constraints/Count.html

  -
    question: |
      How can you apply different validation groups when validating an object submitted through a Symfony Form?
    answers:
      - { value: 'By setting the `validation_groups` option in the form builder or form options.', correct: true }
      - { value: 'By calling `$form->handleRequest($request, [''group'' => ''my_group'']);`', correct: false }
      - { value: 'By defining groups directly in the form type class.', correct: false }
      - { value: 'By using `#[FormGroup(''my_group'')]` attribute on the form type.', correct: false }
    help: |
      The `validation_groups` option in the form type or when creating the form allows you to specify which validation groups should be applied.
      https://symfony.com/doc/current/reference/forms/types/form.html#validation-groups

  -
    question: >
      What is the purpose of the `#[Unique]` constraint in Symfony's Validator component?
    answers:
      - { value: 'There is no built-in `#[Unique]` constraint in the core Symfony Validator component for database uniqueness.', correct: true }
      - { value: 'To ensure a property''s value is unique across all instances of an object.', correct: false }
      - { value: 'To check for uniqueness against a database column.', correct: false }
      - { value: 'To prevent duplicate entries in a collection.', correct: false }
    help: |
      The core Symfony Validator component does not provide a `Unique` constraint for database uniqueness checks. This functionality is typically provided by ORM/ODM integrations (e.g., Doctrine's `UniqueEntity` constraint).
      https://symfony.com/doc/current/validation.html (This is a conceptual question to clarify the scope of Symfony's core validator)

  -
    question: |
      When using the `buildViolation()` method in a custom validator, what is the final method call to register the violation?

      ```php
      $this->context->buildViolation('My custom message.')
          ->atPath('myProperty')
          // ???
      ;
      ```
    answers:
      - { value: '`addViolation()`', correct: true }
      - { value: '`validate()`', correct: false }
      - { value: '`report()`', correct: false }
      - { value: '`create()`', correct: false }
    help: |
      After building the violation details, `addViolation()` is called to register the violation with the validation context.
      https://symfony.com/doc/current/validation/custom_constraint.html#adding-violations-with-the-violations-builder

  -
    question: >
      What is the primary difference between `NotBlank` and `NotNull` constraints?
    answers:
      - { value: '`NotBlank` checks for non-empty strings and non-whitespace strings, while `NotNull` only checks for `null`.', correct: true }
      - { value: '`NotBlank` applies to all types, `NotNull` only to strings.', correct: false }
      - { value: '`NotNull` is for database columns, `NotBlank` for form fields.', correct: false }
      - { value: '`NotBlank` allows `null`, `NotNull` does not.', correct: false }
    help: |
      `NotNull` only asserts that the value is not `null`. `NotBlank` is more strict for strings, also checking for empty strings and strings consisting only of whitespace.
      https://symfony.com/doc/current/reference/constraints/NotBlank.html
      https://symfony.com/doc/current/reference/constraints/NotNull.html

  -
    question: |
      How can you translate validation messages in Symfony?
    answers:
      - { value: 'By providing translation keys in the constraint''s `message` option and defining translations in `.xlf` or `.yaml` files.', correct: true }
      - { value: 'By using the `Translatable` attribute on constraint messages.', correct: false }
      - { value: 'Validation messages are automatically translated by Symfony.', correct: false }
      - { value: 'By injecting the `translator` service into the validator.', correct: false }
    help: |
      Validation messages are part of Symfony's translation mechanism. You provide a translation key (or the default message) and define translations in your application's translation files.
      https://symfony.com/doc/current/validation/translations.html

  -
    question: >
      What is the purpose of the `groups` option when defining a constraint?
    answers:
      - { value: 'To assign the constraint to one or more validation groups.', correct: true }
      - { value: 'To specify the order of execution for the constraint.', correct: false }
      - { value: 'To define a custom error message for a specific group.', correct: false }
      - { value: 'To enable or disable the constraint based on environment.', correct: false }
    help: |
      The `groups` option allows you to specify which validation groups a constraint belongs to. When validating, only constraints belonging to the active groups will be checked.
      https://symfony.com/doc/current/validation/groups.html

  -
    question: |
      You have a `User` entity and want to ensure that the `password` and `confirmPassword` fields match, but only when a `registration` group is active. How would you configure this using a class-level `Callback` constraint?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;
      use Symfony\Component\Validator\Context\ExecutionContextInterface;

      #[Assert\Callback(callback: [self::class, 'validatePasswordMatch'], groups: ['registration'])]
      class User
      {
          private ?string $password = null;
          private ?string $confirmPassword = null;

          public function validatePasswordMatch(ExecutionContextInterface $context, mixed $payload): void
          {
              if ($this->password !== $this->confirmPassword) {
                  $context->buildViolation('Passwords do not match.')
                      ->atPath('confirmPassword')
                      ->addViolation();
              }
          }
      }
      ```
      Which part of this configuration ensures the `registration` group dependency?
    answers:
      - { value: '`groups: [''registration'']` in the `#[Assert\Callback]` attribute.', correct: true }
      - { value: 'The `validatePasswordMatch` method name implies the group.', correct: false }
      - { value: 'The `ExecutionContextInterface` automatically handles group context.', correct: false }
      - { value: 'It requires a separate `GroupSequence` definition.', correct: false }
    help: |
      The `groups` option on the `Callback` constraint explicitly assigns it to the `registration` group, meaning it will only be executed when that group is part of the validation process.
      https://symfony.com/doc/current/reference/constraints/Callback.html#groups

  -
    question: >
      What happens if you try to validate an object with a non-existent validation group?
    answers:
      - { value: 'The validation process will proceed, but no constraints assigned to that non-existent group will be checked.', correct: true }
      - { value: 'A `GroupNotFoundException` will be thrown.', correct: false }
      - { value: 'Symfony will default to the `Default` group instead.', correct: false }
      - { value: 'All constraints on the object will be checked regardless of groups.', correct: false }
    help: |
      Symfony's validator will not throw an error for non-existent groups. It will simply ignore any constraints that are assigned to that group, as there are none.
      https://symfony.com/doc/current/validation/groups.html (Implicitly, by how groups work)

  -
    question: |
      You have a custom constraint `#[App\Validator\Constraints\ContainsAlphanumeric]`. How can you ensure its validator class `App\Validator\Constraints\ContainsAlphanumericValidator` is automatically registered with Symfony's validator?
    answers:
      - { value: 'By ensuring the validator class is located in a conventional directory (e.g., `src/Validator/Constraints`) and autowired.', correct: true }
      - { value: 'By explicitly defining the validator as a service in `services.yaml` and tagging it.', correct: false }
      - { value: 'By extending `AbstractConstraintValidator` instead of `ConstraintValidator`.', correct: false }
      - { value: 'By implementing `ValidatorAwareInterface` in the constraint.', correct: false }
    help: |
      Symfony's autoconfigure and autowire features typically handle the registration of custom constraint validators if they follow the standard naming conventions and are located in a discoverable directory.
      https://symfony.com/doc/current/validation/custom_constraint.html#creating-the-validator (Implicitly, through service autoconfigure)

  -
    question: >
      What is the purpose of the `message` option in most built-in constraints?
    answers:
      - { value: 'To define the error message displayed when the constraint is violated.', correct: true }
      - { value: 'To specify a translation key for the error message.', correct: true }
      - { value: 'To provide a unique identifier for the constraint.', correct: false }
      - { value: 'To set the severity level of the violation.', correct: false }
    help: |
      The `message` option allows you to customize the error message that is returned when the constraint fails. This message can also be a translation key.
      https://symfony.com/doc/current/validation.html#error-messages

  -
    question: |
      You want to validate that a `startDate` property is before an `endDate` property. Which constraint is most suitable for this cross-property validation without writing a full custom validator class?
    answers:
      - { value: '`Expression`', correct: true }
      - { value: '`Callback`', correct: true }
      - { value: '`Range`', correct: false }
      - { value: '`LessThan` (on `startDate` alone)', correct: false }
    help: |
      Both `Expression` and `Callback` constraints are well-suited for cross-property validation. `Expression` is good for simple comparisons, while `Callback` allows for more complex logic.
      https://symfony.com/doc/current/reference/constraints/Expression.html
      https://symfony.com/doc/current/reference/constraints/Callback.html

  -
    question: >
      When using a `GroupSequence` on an object, what happens if a constraint in an earlier group fails?
    answers:
      - { value: 'Validation stops immediately for subsequent groups in the sequence.', correct: true }
      - { value: 'All groups are still validated, but errors from earlier groups are prioritized.', correct: false }
      - { value: 'The object is considered valid, and a warning is issued.', correct: false }
      - { value: 'Symfony automatically retries the validation with a different group.', correct: false }
    help: |
      This is the "fail-fast" behavior of group sequences. If a violation is found in a group, the validation process for that object stops, and subsequent groups in the sequence are not checked.
      https://symfony.com/doc/current/validation/group_sequence.html

  -
    question: |
      Consider a scenario where you have a `User` entity and want to validate its `email` property with the `Email` constraint, but only if the `newsletter` property is `true`. How can you achieve this conditionally?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class User
      {
          private bool $newsletter = false;

          // ???
          private ?string $email = null;
      }
      ```
    answers:
      - { value: '`#[Assert\Email(groups: [''newsletter_opt_in''])]` and validate with a group sequence or conditional group.', correct: true }
      - { value: '`#[Assert\Expression(expression: ''this.newsletter ? this.email is email : true'')]`', correct: true }
      - { value: '`#[Assert\When(expression: ''this.newsletter'', constraints: [new Assert\Email()])]`', correct: false }
      - { value: 'This requires a custom validator class.', correct: false }
    help: |
      Conditional validation can be achieved using validation groups (and potentially group sequences) or directly with the `Expression` constraint on the property or class level.
      https://symfony.com/doc/current/validation/groups.html#conditional-validation
      https://symfony.com/doc/current/reference/constraints/Expression.html

  -
    question: >
      What is the purpose of the `payload` option in a constraint violation?
    answers:
      - { value: 'To attach custom, non-string data to a violation.', correct: true }
      - { value: 'To specify the HTTP status code for the error.', correct: false }
      - { value: 'To define the severity of the violation (e.g., warning, error).', correct: false }
      - { value: 'To provide a unique identifier for the violation.', correct: false }
    help: |
      The `payload` option allows you to associate custom data with a violation, which can be useful for frontend frameworks, API responses, or custom error handling.
      https://symfony.com/doc/current/validation/payload.html

  -
    question: |
      Which method of `ExecutionContextInterface` is used to get the root object being validated?

      ```php
      use Symfony\Component\Validator\Context\ExecutionContextInterface;

      function getRootObject(ExecutionContextInterface $context): object
      {
          return /* ??? */;
      }
      ```
    answers:
      - { value: '`$context->getRoot()`', correct: true }
      - { value: '`$context->getObject()`', correct: false }
      - { value: '`$context->getValidatedObject()`', correct: false }
      - { value: '`$context->getSubject()`', correct: false }
    help: |
      The `getRoot()` method of `ExecutionContextInterface` returns the root object that started the validation process.
      https://symfony.com/doc/current/validation/custom_constraint.html#accessing-the-root-object

  -
    question: |
      When creating a custom constraint, what is the purpose of the `validatedBy()` method in the constraint class?

      ```php
      namespace App\Validator\Constraints;

      use Symfony\Component\Validator\Constraint;

      #[\Attribute(\Attribute::TARGET_PROPERTY)]
      class MyCustomConstraint extends Constraint
      {
          public function validatedBy(): string
          {
              return /* ??? */;
          }
      }
      ```
    answers:
      - { value: 'To return the fully qualified class name of the associated validator.', correct: true }
      - { value: 'To specify the service ID of the validator if it''s not autowired.', correct: false }
      - { value: 'To define the validation method within the constraint itself.', correct: false }
      - { value: 'To declare the validation groups for the constraint.', correct: false }
    help: |
      The `validatedBy()` method tells Symfony which validator class is responsible for validating this specific constraint. It should return the FQCN of the validator.
      https://symfony.com/doc/current/validation/custom_constraint.html#creating-the-constraint-class

  -
    question: >
      What is the default error message for the `NotBlank` constraint?
    answers:
      - { value: '`This value should not be blank.`', correct: true }
      - { value: '`This field cannot be empty.`', correct: false }
      - { value: '`The value is required.`', correct: false }
      - { value: '`This value must not be null or empty.`', correct: false }
    help: |
      The default message for the `NotBlank` constraint is "This value should not be blank.".
      https://symfony.com/doc/current/reference/constraints/NotBlank.html#message

  -
    question: >
      Which constraint is used to ensure a property's value is a valid date?
    answers:
      - { value: '`Date`', correct: true }
      - { value: '`DateTime`', correct: false }
      - { value: '`ValidDate`', correct: false }
      - { value: '`IsDate`', correct: false }
    help: |
      The `Date` constraint validates that a string is a valid date in the `YYYY-MM-DD` format.
      https://symfony.com/doc/current/reference/constraints/Date.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid time?
    answers:
      - { value: '`Time`', correct: true }
      - { value: '`ValidTime`', correct: false }
      - { value: '`IsTime`', correct: false }
      - { value: '`HourMinute`', correct: false }
    help: |
      The `Time` constraint validates that a string is a valid time in the `HH:MM:SS` format.
      https://symfony.com/doc/current/reference/constraints/Time.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid datetime?
    answers:
      - { value: '`DateTime`', correct: true }
      - { value: '`Timestamp`', correct: false }
      - { value: '`ValidDateTime`', correct: false }
      - { value: '`IsDateTime`', correct: false }
    help: |
      The `DateTime` constraint validates that a string is a valid date and time in the `YYYY-MM-DD HH:MM:SS` format.
      https://symfony.com/doc/current/reference/constraints/DateTime.html

  -
    question: >
      What is the behavior of the `NotNull` constraint when applied to a property with an empty string value?
    answers:
      - { value: 'It passes, as an empty string is not `null`.', correct: true }
      - { value: 'It fails, as an empty string is considered `null` by this constraint.', correct: false }
      - { value: 'It fails, but only if the `allowEmptyString` option is set to `false`.', correct: false }
      - { value: 'It throws an exception.', correct: false }
    help: |
      The `NotNull` constraint only checks if the value is strictly `null`. An empty string (`''`) is not `null`, so it passes this constraint. Use `NotBlank` if you want to disallow empty strings.
      https://symfony.com/doc/current/reference/constraints/NotNull.html

  -
    question: >
      How can you retrieve the property path of a `ConstraintViolation` object?
    answers:
      - { value: '`$violation->getPropertyPath()`', correct: true }
      - { value: '`$violation->getPath()`', correct: false }
      - { value: '`$violation->getFieldName()`', correct: false }
      - { value: '`$violation->getLocation()`', correct: false }
    help: |
      The `getPropertyPath()` method of a `ConstraintViolation` object returns the path to the property that caused the violation.
      https://symfony.com/doc/current/validation.html#displaying-the-validation-errors

  -
    question: >
      How can you retrieve the error message of a `ConstraintViolation` object?
    answers:
      - { value: '`$violation->getMessage()`', correct: true }
      - { value: '`$violation->getErrorMessage()`', correct: false }
      - { value: '`$violation->getText()`', correct: false }
      - { value: '`$violation->getViolationMessage()`', correct: false }
    help: |
      The `getMessage()` method of a `ConstraintViolation` object returns the human-readable error message.
      https://symfony.com/doc/current/validation.html#displaying-the-validation-errors

  -
    question: >
      What is the role of the `payload` argument in the `ExecutionContextInterface::buildViolation()` method?
    answers:
      - { value: 'To attach custom, non-string data to the violation.', correct: true }
      - { value: 'To specify the HTTP status code for the violation.', correct: false }
      - { value: 'To define a unique identifier for the violation.', correct: false }
      - { value: 'To set the severity level of the violation.', correct: false }
    help: |
      The `payload` argument allows developers to attach custom data to a validation violation, which can be useful for advanced error handling scenarios.
      https://symfony.com/doc/current/validation/payload.html

  -
    question: |
      You are validating a `User` object that has a `roles` property, which is an array of strings (e.g., `['ROLE_USER', 'ROLE_ADMIN']`). Which constraint would you use to ensure each role in the array starts with `ROLE_`?
    answers:
      - { value: '`#[Assert\All(new Assert\Regex(pattern: ''/^ROLE_/''))]`', correct: true }
      - { value: '`#[Assert\Collection(fields: { roles: [new Assert\Regex(pattern: ''/^ROLE_/'')] })]`', correct: false }
      - { value: '`#[Assert\Each(new Assert\Regex(pattern: ''/^ROLE_/''))]`', correct: false }
      - { value: '`#[Assert\Array(constraints: [new Assert\Regex(pattern: ''/^ROLE_/'')])`', correct: false }
    help: |
      The `All` constraint applies a set of constraints to each element of a collection (array or traversable object).
      https://symfony.com/doc/current/reference/constraints/All.html

  -
    question: >
      What is the purpose of the `#[Assert\Type]` constraint?
    answers:
      - { value: 'To validate that a value is of a specific PHP data type (e.g., `string`, `int`, `array`, `bool`).', correct: true }
      - { value: 'To check if an object is an instance of a particular class or interface.', correct: true }
      - { value: 'To ensure a value matches a predefined type alias.', correct: false }
      - { value: 'To cast a value to a specific type before validation.', correct: false }
    help: |
      The `Type` constraint validates that a value is of a specific PHP type or an instance of a given class/interface.
      https://symfony.com/doc/current/reference/constraints/Type.html

  -
    question: |
      How can you apply a `GroupSequence` to a form type in Symfony?

      ```php
      namespace App\Form\Type;

      use App\Entity\User;
      use Symfony\Component\Form\AbstractType;
      use Symfony\Component\Form\FormBuilderInterface;
      use Symfony\Component\OptionsResolver\OptionsResolver;

      class UserType extends AbstractType
      {
          public function buildForm(FormBuilderInterface $builder, array $options): void
          {
              // ... add fields
          }

          public function configureOptions(OptionsResolver $resolver): void
          {
              $resolver->setDefaults([
                  'data_class' => User::class,
                  // ???
              ]);
          }
      }
      ```
    answers:
      - { value: '`validation_groups` => [''Default'', ''registration_step2'']` (if `User` has a `GroupSequence` defined)', correct: true }
      - { value: '`validation_groups` => function (FormInterface $form) { return $form->getData()->getValidationGroups(); }`', correct: true }
      - { value: '`group_sequence` => [''Default'', ''registration_step2'']`', correct: false }
      - { value: '`validation_groups` => new GroupSequence([''Default'', ''registration_step2''])`', correct: false }
    help: |
      The `validation_groups` option in `configureOptions` can accept an array of group names or a callable that returns the groups. If the entity has a `GroupSequence` attribute, you can simply list the groups in the desired order.
      https://symfony.com/doc/current/reference/forms/types/form.html#validation-groups

  -
    question: >
      What is the primary benefit of using `#[AsCommand]` attribute for console commands compared to defining them in `services.yaml`?
    answers:
      - { value: 'It allows defining command metadata (name, description) directly in the command class, making it more discoverable and self-contained.', correct: true }
      - { value: 'It makes the command execution faster.', correct: false }
      - { value: 'It automatically registers the command as a service without explicit configuration.', correct: true }
      - { value: 'It enables dependency injection without requiring a constructor.', correct: false }
    help: |
      The `#[AsCommand]` attribute simplifies command registration and configuration by allowing you to define the command's name and description directly on the class, leveraging autoconfigure.
      https://symfony.com/doc/current/console.html#configuring-the-command (This question is slightly off-topic for "Data Validation" but relates to attributes, which are used for validation, so it's a general Symfony attribute question. I will keep it as it tests knowledge of attributes in Symfony 7.)

  -
    question: >
      When is the `Default` validation group typically used?
    answers:
      - { value: 'For general-purpose validation rules that should always apply unless specific groups are provided.', correct: true }
      - { value: 'Only when no other validation groups are defined for an object.', correct: false }
      - { value: 'As a fallback when a specified group is not found.', correct: false }
      - { value: 'For validation rules that apply to all entities in the application.', correct: false }
    help: |
      The `Default` group is the implicit group for any constraint that doesn't explicitly define `groups`. It's used for rules that apply in most validation scenarios.
      https://symfony.com/doc/current/validation/groups.html#default-group

  -
    question: |
      You have a `User` object with a `username` property. You want to ensure it's `NotBlank` for the `registration` group and has a `Length` between 5 and 20 for the `profile_update` group. How would you define this?

      ```php
      namespace App\Entity;

      use Symfony\Component\Validator\Constraints as Assert;

      class User
      {
          #[Assert\NotBlank(groups: ['registration'])]
          #[Assert\Length(min: 5, max: 20, groups: ['profile_update'])]
          private ?string $username = null;
      }
      ```
      Is this a correct way to apply group-specific constraints?
    answers:
      - { value: 'Yes, this is the correct way to apply different constraints to different validation groups on the same property.', correct: true }
      - { value: 'No, you must use a `GroupSequence` for this scenario.', correct: false }
      - { value: 'No, you can only have one constraint per property.', correct: false }
      - { value: 'No, `NotBlank` and `Length` cannot be used together.', correct: false }
    help: |
      Multiple constraints can be applied to the same property, and each can be assigned to different validation groups.
      https://symfony.com/doc/current/validation/groups.html#basic-example

  -
    question: >
      What is the primary advantage of using PHP attributes for defining validation constraints over YAML or XML?
    answers:
      - { value: 'Constraints are defined directly alongside the code they validate, improving readability and maintainability.', correct: true }
      - { value: 'Attributes offer better performance during validation.', correct: false }
      - { value: 'Attributes allow for more complex validation logic than YAML or XML.', correct: false }
      - { value: 'Attributes are the only way to define custom constraints.', correct: false }
    help: |
      PHP attributes (formerly annotations) keep the validation rules close to the properties or methods they apply to, making the code more cohesive and easier to understand.
      https://symfony.com/doc/current/validation.html#constraints-configuration

  -
    question: >
      Can a single constraint belong to multiple validation groups?
    answers:
      - { value: 'Yes, by providing an array of group names to the `groups` option.', correct: true }
      - { value: 'No, each constraint can only belong to one group.', correct: false }
      - { value: 'Only if it''s a class-level constraint.', correct: false }
      - { value: 'Only if it''s a custom constraint.', correct: false }
    help: |
      A constraint can belong to multiple groups by listing them in the `groups` array.
      https://symfony.com/doc/current/validation/groups.html#basic-example

  -
    question: >
      What happens if you validate an object and do not specify any validation groups?
    answers:
      - { value: 'Only constraints belonging to the `Default` group will be checked.', correct: true }
      - { value: 'All constraints on the object will be checked, regardless of their assigned groups.', correct: false }
      - { value: 'An error will be thrown, requiring you to specify at least one group.', correct: false }
      - { value: 'Symfony will prompt you to choose a group interactively.', correct: false }
    help: |
      If no groups are explicitly passed to the validator, only constraints belonging to the `Default` group are evaluated.
      https://symfony.com/doc/current/validation/groups.html#default-group

  -
    question: >
      Is it possible to define validation constraints for a property that is a collection of objects (e.g., `ArrayCollection` of `OrderItem` objects)?
    answers:
      - { value: 'Yes, using the `#[Assert\Valid]` constraint on the collection property.', correct: true }
      - { value: 'Yes, using the `#[Assert\All]` constraint to apply rules to each element of the collection.', correct: true }
      - { value: 'No, collections cannot be directly validated; you must iterate and validate each item manually.', correct: false }
      - { value: 'Only if the collection implements `ValidatableCollectionInterface`.', correct: false }
    help: |
      The `Valid` constraint recursively validates each object in a collection. The `All` constraint allows you to apply specific constraints to each element within a collection.
      https://symfony.com/doc/current/reference/constraints/Valid.html
      https://symfony.com/doc/current/reference/constraints/All.html

  -
    question: >
      What is the primary role of the `payload` in a `ConstraintViolation`?
    answers:
      - { value: 'To carry additional, non-string data related to the violation.', correct: true }
      - { value: 'To define the severity level of the validation error.', correct: false }
      - { value: 'To specify the HTTP status code for the error response.', correct: false }
      - { value: 'To provide a unique identifier for the violation instance.', correct: false }
    help: |
      The `payload` is designed to attach custom data to a violation, allowing for more flexible error handling and integration with other systems.
      https://symfony.com/doc/current/validation/payload.html

  -
    question: >
      When using `GroupSequence`, if a violation occurs in the first group of the sequence, what happens to the subsequent groups?
    answers:
      - { value: 'They are not validated at all.', correct: true }
      - { value: 'They are validated, but their errors are ignored.', correct: false }
      - { value: 'They are validated, and their errors are merged with the first group''s errors.', correct: false }
      - { value: 'The validation process restarts from the beginning of the sequence.', correct: false }
    help: |
      The "fail-fast" nature of `GroupSequence` means that if any group in the sequence produces a violation, the validation process stops, and no further groups in that sequence are checked.
      https://symfony.com/doc/current/validation/group_sequence.html

  -
    question: >
      Which of the following is NOT a valid way to define validation constraints in Symfony 7?
    answers:
      - { value: 'Using annotations (e.g., `@Assert\NotBlank`).', correct: false }
      - { value: 'Using PHP attributes (e.g., `#[Assert\NotBlank]`).', correct: false }
      - { value: 'Using XML configuration files.', correct: false }
      - { value: 'Using INI files.', correct: true }
    help: |
      Symfony supports PHP attributes (recommended), YAML, and XML for defining validation constraints. INI files are not supported for this purpose. Annotations are still supported for backward compatibility but attributes are the modern approach.
      https://symfony.com/doc/current/validation.html#constraints-configuration

  -
    question: >
      What is the purpose of the `#[Assert\UniqueEntity]` constraint in Symfony?
    answers:
      - { value: 'It is a Doctrine ORM specific constraint, not part of the core Symfony Validator component.', correct: true }
      - { value: 'It ensures a property''s value is unique within a collection.', correct: false }
      - { value: 'It checks for uniqueness against a database table using the core Symfony Validator.', correct: false }
      - { value: 'It guarantees that an object instance is unique in memory.', correct: false }
    help: |
      The `UniqueEntity` constraint is provided by DoctrineBundle for checking database uniqueness. It is not a constraint from the core Symfony Validator component.
      https://symfony.com/doc/current/bundles/DoctrineBundle/validation.html#uniqueentity-constraint

  -
    question: >
      Can you apply validation constraints to public properties, private properties, and getter methods in Symfony?
    answers:
      - { value: 'Yes, constraints can be applied to public, private, and protected properties, as well as public getter methods.', correct: true }
      - { value: 'Only public properties and public getter methods can have constraints.', correct: false }
      - { value: 'Only public and protected properties can have constraints.', correct: false }
      - { value: 'Only properties can have constraints, not methods.', correct: false }
    help: |
      Symfony's validator can read constraints from properties (regardless of visibility) and public getter methods.
      https://symfony.com/doc/current/validation.html#constraints-configuration

  -
    question: |
      When building a custom violation using `buildViolation()`, which method is used to set the parameter for the error message?

      ```php
      $context->buildViolation('The value {{ value }} is invalid.')
          // ???
          ->addViolation();
      ```
    answers:
      - { value: '`setParameter(''{{ value }}'', $invalidValue)`', correct: true }
      - { value: '`withParameter(''{{ value }}'', $invalidValue)`', correct: false }
      - { value: '`setParam(''value'', $invalidValue)`', correct: false }
      - { value: '`addParameter(''value'', $invalidValue)`', correct: false }
    help: |
      The `setParameter()` method is used to replace placeholders in the violation message.
      https://symfony.com/doc/current/validation/custom_constraint.html#adding-violations-with-the-violations-builder

  -
    question: >
      What is the purpose of the `atPath()` method in the violations builder?
    answers:
      - { value: 'To specify the property path where the violation occurred.', correct: true }
      - { value: 'To define the file path of the validated object.', correct: false }
      - { value: 'To set the URL where the error should be redirected.', correct: false }
      - { value: 'To indicate the line number in the code where the violation originated.', correct: false }
    help: |
      `atPath()` is crucial for associating the violation with a specific property, which is used for displaying errors correctly, especially in forms.
      https://symfony.com/doc/current/validation/custom_constraint.html#adding-violations-with-the-violations-builder

  -
    question: >
      Which constraint would you use to ensure a string property contains only digits?
    answers:
      - { value: '`Type(''digit'')` (not a valid type)', correct: false }
      - { value: '`Regex(pattern: ''/^\d+$/'')`', correct: true }
      - { value: '`Digits` (does not exist as a built-in constraint)', correct: false }
      - { value: '`Numeric`', correct: false }
    help: |
      The `Regex` constraint is the appropriate choice for validating that a string consists solely of digits. `Numeric` checks if a value is a valid number, which is broader.
      https://symfony.com/doc/current/reference/constraints/Regex.html

  -
    question: >
      What is the purpose of the `cascade_validation` option in a form type?
    answers:
      - { value: 'It is deprecated; use `#[Assert\Valid]` on the underlying data class property instead.', correct: true }
      - { value: 'It enables validation for child forms automatically.', correct: false }
      - { value: 'It forces all validation groups to be applied.', correct: false }
      - { value: 'It allows validation errors to propagate up to parent forms.', correct: false }
    help: |
      The `cascade_validation` option in form types is deprecated. The recommended way to validate nested objects is by applying the `#[Assert\Valid]` constraint directly to the property in the data class.
      https://symfony.com/doc/current/reference/forms/types/form.html#cascade-validation

  -
    question: >
      When using `GroupSequence` with a form, how does the form component determine which groups to validate?
    answers:
      - { value: 'It uses the `GroupSequence` defined on the underlying data class, if present, or the `validation_groups` option.', correct: true }
      - { value: 'It always validates the `Default` group first, then any other specified groups.', correct: false }
      - { value: 'It automatically detects dependencies between groups and orders them.', correct: false }
      - { value: 'It only uses the `validation_groups` option, ignoring any `GroupSequence` on the entity.', correct: false }
    help: |
      The form component respects the `GroupSequence` defined on the data class. If `validation_groups` is also set, it can override or interact with the entity's `GroupSequence`.
      https://symfony.com/doc/current/reference/forms/types/form.html#validation-groups

  -
    question: >
      What is the primary purpose of the `ConstraintViolation` object?
    answers:
      - { value: 'To represent a single validation error, including its message, property path, and invalid value.', correct: true }
      - { value: 'To define the rules for a specific validation constraint.', correct: false }
      - { value: 'To manage the overall validation process for an object.', correct: false }
      - { value: 'To store a list of all validation errors for an object.', correct: false }
    help: |
      A `ConstraintViolation` object encapsulates all the details about a single validation error that occurred.
      https://symfony.com/doc/current/validation.html#validating-objects

  -
    question: >
      Can you apply validation constraints to properties that are `null`?
    answers:
      - { value: 'Yes, some constraints like `NotNull` or `NotBlank` are specifically designed to check for `null` or blank values.', correct: true }
      - { value: 'No, constraints are only applied to non-null values.', correct: false }
      - { value: 'Only if the property is explicitly typed as nullable.', correct: false }
      - { value: 'Only if the constraint has an `allowNull` option set to `false`.', correct: false }
    help: |
      Constraints like `NotNull` and `NotBlank` are specifically designed to validate the presence or absence of a value, including `null`. Most other constraints will simply ignore `null` values unless they are explicitly configured otherwise (e.g., `Type` with `null` as a valid type).
      https://symfony.com/doc/current/validation.html (General understanding of constraint behavior)

  -
    question: >
      What is the purpose of the `groups` option when validating an object manually using `ValidatorInterface::validate()`?
    answers:
      - { value: 'To specify which validation groups should be applied during the validation process.', correct: true }
      - { value: 'To define new validation groups dynamically.', correct: false }
      - { value: 'To retrieve the groups that caused validation failures.', correct: false }
      - { value: 'To exclude certain groups from the validation process.', correct: false }
    help: |
      The third argument to `validate()` is an array of groups. Only constraints belonging to these specified groups (and their `Default` group if applicable) will be checked.
      https://symfony.com/doc/current/validation.html#validating-objects

  -
    question: >
      Which constraint is used to ensure a property's value is a valid country code (ISO 3166-1 alpha-2)?
    answers:
      - { value: '`Country`', correct: true }
      - { value: '`Locale`', correct: false }
      - { value: '`Region`', correct: false }
      - { value: '`IsoCode`', correct: false }
    help: |
      The `Country` constraint validates that a string is a valid ISO 3166-1 alpha-2 country code.
      https://symfony.com/doc/current/reference/constraints/Country.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid language code (ISO 639-1 alpha-2)?
    answers:
      - { value: '`Language`', correct: true }
      - { value: '`Locale`', correct: false }
      - { value: '`Lang`', correct: false }
      - { value: '`IsoLanguage`', correct: false }
    help: |
      The `Language` constraint validates that a string is a valid ISO 639-1 alpha-2 language code.
      https://symfony.com/doc/current/reference/constraints/Language.html

  -
    question: >
      Which constraint is used to ensure a property's value is a valid locale code (e.g., `en_US`, `fr_FR`)?
    answers:
      - { value: '`Locale`', correct: true }
      - { value: '`LanguageCountry`', correct: false }
      - { value: '`Culture`', correct: false }
      - { value: '`IetfTag`', correct: false }
    help: |
      The `Locale` constraint validates that a string is a valid locale code.
      https://symfony.com/doc/current/reference/constraints/Locale.html

  -
    question: >
      What is the purpose of the `#[Assert\DivisibleBy]` constraint?
    answers:
      - { value: 'To assert that a numeric value is divisible by a given number.', correct: true }
      - { value: 'To check if a number can be divided without a remainder.', correct: false }
      - { value: 'To ensure a number is a multiple of another number.', correct: true }
      - { value: 'To perform division operations within validation.', correct: false }
    help: |
      The `DivisibleBy` constraint asserts that a numeric value is perfectly divisible by a given number.
      https://symfony.com/doc/current/reference/constraints/DivisibleBy.html