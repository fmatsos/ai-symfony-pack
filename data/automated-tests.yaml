category: Automated Tests

questions:
  -
    question: >
      What is the primary purpose of a unit test in a Symfony application?
    answers:
      - { value: 'To verify the functionality of a small, isolated piece of code, such as a single method or class.', correct: true }
      - { value: 'To test the interaction between multiple components and services within the application.', correct: false }
      - { value: 'To simulate user interactions with the web interface.', correct: false }
      - { value: 'To ensure the entire application works correctly from end-to-end.', correct: false }
    help: |
      Unit tests focus on testing the smallest testable parts of an application in isolation, typically individual methods or classes, without external dependencies.
      https://symfony.com/doc/current/testing.html#unit-tests

  -
    question: |
      Which PHPUnit method is typically used to set up common test fixtures before each test method in a test class?
    answers:
      - { value: '`setUp()`', correct: true }
      - { value: '`setUpBeforeClass()`', correct: false }
      - { value: '`init()`', correct: false }
      - { value: '`prepare()`', correct: false }
      - { value: '`beforeEach()`', correct: false }
    help: |
      The `setUp()` method is called before each test method within a test class, allowing you to prepare the environment for each test.
      https://phpunit.de/manual/current/en/fixtures.html#fixtures.setup-teardown

  -
    question: >
      When writing a unit test for a service that depends on another service, what is the recommended approach to avoid testing the dependency itself?
    answers:
      - { value: 'Use a mock object for the dependency.', correct: true }
      - { value: 'Instantiate the real dependency in the test.', correct: false }
      - { value: 'Skip testing the service if it has dependencies.', correct: false }
      - { value: 'Make the dependency static.', correct: false }
    help: |
      Mock objects are used in unit tests to simulate the behavior of real dependencies, allowing you to test the unit in isolation without relying on the actual implementation of its dependencies.
      https://phpunit.de/manual/current/en/test-doubles.html

  -
    question: |
      Consider the following PHPUnit assertion. What will happen if `$actualValue` is `5` and `$expectedValue` is `5`?

      ```php
      $this->assertEquals($expectedValue, $actualValue);
      ```
    answers:
      - { value: 'The test will pass.', correct: true }
      - { value: 'The test will fail.', correct: false }
      - { value: 'A warning will be issued.', correct: false }
      - { value: 'An error will occur.', correct: false }
    help: |
      The `assertEquals()` assertion checks if two values are equal. If they are, the test passes.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertEquals

  -
    question: >
      Which of the following best describes a functional test in Symfony?
    answers:
      - { value: 'A test that simulates a user''s interaction with the application, typically through HTTP requests.', correct: true }
      - { value: 'A test that verifies individual methods of a class in isolation.', correct: false }
      - { value: 'A test that checks the performance of the application under load.', correct: false }
      - { value: 'A test that ensures the database schema is correct.', correct: false }
    help: |
      Functional tests in Symfony simulate HTTP requests to your application, allowing you to test the full request-response cycle.
      https://symfony.com/doc/current/testing.html#functional-tests

  -
    question: |
      To perform functional tests in Symfony, which class should your test case extend?
    answers:
      - { value: '`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`', correct: true }
      - { value: '`PHPUnit\\Framework\\TestCase`', correct: false }
      - { value: '`Symfony\\Component\\HttpFoundation\\Response`', correct: false }
      - { value: '`Symfony\\Component\\BrowserKit\\HttpBrowser`', correct: false }
    help: |
      Functional tests in Symfony typically extend `WebTestCase`, which provides methods for creating a client and interacting with the application.
      https://symfony.com/doc/current/testing.html#functional-tests

  -
    question: |
      In a functional test, how do you create a `KernelBrowser` (client) to make requests to your application?
    answers:
      - { value: '`static::createClient()`', correct: true }
      - { value: '`$this->getClient()`', correct: false }
      - { value: '`new KernelBrowser()`', correct: false }
      - { value: '`$this->bootKernel()`', correct: false }
    help: |
      The `WebTestCase` provides the `static::createClient()` method to create a test client for making requests.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      After making a request using the client in a functional test, how can you access the response object?
    answers:
      - { value: '`$client->getResponse()`', correct: true }
      - { value: '`$client->response`', correct: false }
      - { value: '`$client->getHttpResponse()`', correct: false }
      - { value: '`$client->getLastResponse()`', correct: false }
    help: |
      The `KernelBrowser` (client) object provides the `getResponse()` method to retrieve the `Response` object of the last request.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      Which object is used in functional tests to navigate through the DOM of the response and make assertions on its content?
    answers:
      - { value: '`Crawler`', correct: true }
      - { value: '`Response`', correct: false }
      - { value: '`Client`', correct: false }
      - { value: '`DomDocument`', correct: false }
    help: |
      The `Crawler` object, returned by the client after a request, allows you to select HTML elements and extract information or make assertions.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      Given a `Crawler` object named `$crawler`, how would you select all `h1` elements on the page?
    answers:
      - { value: '`$crawler->filter(''h1'')`', correct: true }
      - { value: '`$crawler->select(''h1'')`', correct: false }
      - { value: '`$crawler->find(''h1'')`', correct: false }
      - { value: '`$crawler->css(''h1'')`', correct: false }
    help: |
      The `filter()` method of the `Crawler` object allows you to select elements using CSS selectors or XPath expressions.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      After selecting an element with the `Crawler`, how can you get its text content?
    answers:
      - { value: '`->text()`', correct: true }
      - { value: '`->html()`', correct: false }
      - { value: '`->value()`', correct: false }
      - { value: '`->textContent()`', correct: false }
    help: |
      The `text()` method on a `Crawler` node returns the text content of the selected element.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      What is the purpose of the Symfony Profiler in the context of functional tests?
    answers:
      - { value: 'To inspect the internal state of the application, such as logs, database queries, and collected data, for a specific request.', correct: true }
      - { value: 'To measure the execution time of individual test methods.', correct: false }
      - { value: 'To generate code coverage reports.', correct: false }
      - { value: 'To automatically fix errors in the application.', correct: false }
    help: |
      The Symfony Profiler allows you to access detailed information about a specific request, which is invaluable for debugging functional tests.
      https://symfony.com/doc/current/testing/profiling.html

  -
    question: |
      How can you access the Profiler data for the last request made by the test client?
    answers:
      - { value: '`$client->getProfile()`', correct: true }
      - { value: '`$client->getProfiler()`', correct: false }
      - { value: '`$client->getLastProfile()`', correct: false }
      - { value: '`$client->debugProfile()`', correct: false }
    help: |
      The `KernelBrowser` (client) provides the `getProfile()` method to retrieve the `Profile` object for the last request.
      https://symfony.com/doc/current/testing/profiling.html

  -
    question: |
      To access a service from the dependency injection container within a functional test, what is the recommended way?
    answers:
      - { value: '`static::getContainer()->get(ServiceId::class)`', correct: true }
      - { value: '`$this->container->get(ServiceId::class)`', correct: false }
      - { value: '`$client->getContainer()->get(ServiceId::class)`', correct: false }
      - { value: '`static::getService(ServiceId::class)`', correct: false }
    help: |
      The `WebTestCase` provides `static::getContainer()` to access the test container, from which you can retrieve services.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      Which of the following is a valid way to configure the test client to follow redirects automatically?
    answers:
      - { value: '`$client->followRedirects(true);`', correct: true }
      - { value: '`$client->setOption(''follow_redirects'', true);`', correct: false }
      - { value: '`$client->enableRedirects();`', correct: false }
      - { value: '`$client->request(''GET'', ''/url'', [], [], [], [], true);`', correct: false }
    help: |
      The `KernelBrowser` (client) has a `followRedirects()` method to control whether it should automatically follow HTTP redirects.
      https://symfony.com/doc/current/testing.html#following-redirects

  -
    question: |
      How can you simulate a form submission in a functional test using the `Crawler`?
    answers:
      - { value: 'Select the form, then use `submit()` with an array of values.', correct: true }
      - { value: 'Select the form''s submit button and click it.', correct: false }
      - { value: 'Manually construct a POST request with form data.', correct: false }
      - { value: 'Use `$client->submitForm()` directly.', correct: false }
    help: |
      The `Crawler` object allows you to select a form and then use its `submit()` method to simulate a form submission.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: |
      When inspecting the response object in a functional test, how can you check the HTTP status code?
    answers:
      - { value: '`$client->getResponse()->getStatusCode()`', correct: true }
      - { value: '`$client->getResponse()->status`', correct: false }
      - { value: '`$client->getResponse()->getHttpStatus()`', correct: false }
      - { value: '`$client->getResponse()->code()`', correct: false }
    help: |
      The `Response` object provides the `getStatusCode()` method to retrieve the HTTP status code.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      Which PHPUnit Bridge feature helps in identifying and handling deprecated code usage during tests?
    answers:
      - { value: 'Deprecation Helper', correct: true }
      - { value: 'Error Handler', correct: false }
      - { value: 'PHPUnit Listener', correct: false }
      - { value: 'Legacy Checker', correct: false }
    help: |
      The PHPUnit Bridge provides a "Deprecation Helper" that catches deprecation notices and can convert them into exceptions or ignore them based on configuration.
      https://symfony.com/doc/current/components/phpunit_bridge.html#handling-legacy-deprecated-code

  -
    question: |
      To ignore specific deprecation notices during tests, which environment variable can be used with PHPUnit Bridge?
    answers:
      - { value: '`SYMFONY_DEPRECATIONS_HELPER`', correct: true }
      - { value: '`PHPUNIT_IGNORE_DEPRECATIONS`', correct: false }
      - { value: '`SYMFONY_IGNORE_LEGACY`', correct: false }
      - { value: '`APP_TEST_DEPRECATIONS`', correct: false }
    help: |
      The `SYMFONY_DEPRECATIONS_HELPER` environment variable allows you to configure how deprecation notices are handled, including ignoring specific ones.
      https://symfony.com/doc/current/components/phpunit_bridge.html#ignoring-some-deprecations

  -
    question: >
      What is the primary benefit of using the PHPUnit Bridge in a Symfony application?
    answers:
      - { value: 'It provides tools for handling deprecations, managing test isolation, and improving test output.', correct: true }
      - { value: 'It replaces PHPUnit with a custom Symfony testing framework.', correct: false }
      - { value: 'It automatically generates tests for your application.', correct: false }
      - { value: 'It integrates Symfony''s profiler into PHPUnit''s default output.', correct: false }
    help: |
      The PHPUnit Bridge enhances PHPUnit for Symfony applications by providing features like deprecation handling, test isolation, and better test output.
      https://symfony.com/doc/current/components/phpunit_bridge.html

  -
    question: |
      Which of the following is a valid way to assert that a specific string is present in the response content of a functional test?
    answers:
      - { value: '`$this->assertStringContainsString(''Expected Text'', $client->getResponse()->getContent());`', correct: true }
      - { value: '`$this->assertResponseContains(''Expected Text'');`', correct: false }
      - { value: '`$client->getResponse()->assertContains(''Expected Text'');`', correct: false }
      - { value: '`$this->assertContains(''Expected Text'', $client->getResponse()->getContent());`', correct: true }
    help: |
      PHPUnit provides `assertStringContainsString()` (and `assertContains()` for older versions) to check for the presence of a substring.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertStringContainsString

  -
    question: |
      When performing a functional test, how can you simulate a click on a link?
    answers:
      - { value: '`$crawler->selectLink(''Link Text'')->link()` and then `$client->click()`', correct: true }
      - { value: '`$client->clickLink(''Link Text'');`', correct: false }
      - { value: '`$crawler->click(''Link Text'');`', correct: false }
      - { value: '`$client->request(''GET'', $crawler->selectLink(''Link Text'')->attr(''href''));`', correct: true }
    help: |
      You can select a link using the `Crawler` and then use the `link()` method to get a `Link` object, which can then be used with `$client->click()`. Alternatively, you can get the `href` attribute and make a direct request.
      https://symfony.com/doc/current/testing.html#clicking-on-links

  -
    question: |
      What is the purpose of `static::ensureKernelShutdown()` in a functional test?
    answers:
      - { value: 'To ensure the Symfony kernel is properly shut down after each test, preventing memory leaks and ensuring test isolation.', correct: true }
      - { value: 'To stop the PHPUnit test runner.', correct: false }
      - { value: 'To clear the cache before each test.', correct: false }
      - { value: 'To reset the database connection.', correct: false }
    help: |
      `static::ensureKernelShutdown()` is crucial for ensuring proper test isolation and preventing issues like memory leaks by shutting down the kernel.
      https://symfony.com/doc/current/testing.html#ensuring-test-isolation

  -
    question: |
      Which method of the `KernelBrowser` (client) allows you to simulate a file upload in a form submission?
    answers:
      - { value: 'The `submit()` method of the `Form` object, by passing `UploadedFile` instances.', correct: true }
      - { value: '`$client->uploadFile()`', correct: false }
      - { value: '`$client->request()` with a special `files` parameter.', correct: false }
      - { value: '`$crawler->upload()`', correct: false }
    help: |
      When submitting a form via the `Crawler`'s `submit()` method, you can include `UploadedFile` objects in the values array to simulate file uploads.
      https://symfony.com/doc/current/testing.html#submitting-forms-with-file-uploads

  -
    question: |
      How can you access the request object associated with the last request made by the test client?
    answers:
      - { value: '`$client->getRequest()`', correct: true }
      - { value: '`$client->request`', correct: false }
      - { value: '`$client->getLastRequest()`', correct: false }
      - { value: '`$client->getCurrentRequest()`', correct: false }
    help: |
      The `KernelBrowser` (client) provides the `getRequest()` method to retrieve the `Request` object of the last request.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the primary advantage of using a dedicated test environment (e.g., `test` environment) for functional tests?
    answers:
      - { value: 'It allows for specific configurations (e.g., different database, no caching) that are optimized for testing without affecting the development or production environments.', correct: true }
      - { value: 'It makes tests run faster.', correct: false }
      - { value: 'It enables automatic test generation.', correct: false }
      - { value: 'It provides a graphical user interface for running tests.', correct: false }
    help: |
      The `test` environment in Symfony is designed to provide an isolated and predictable environment for running tests, often with different configurations for services like databases or mailers.
      https://symfony.com/doc/current/testing.html#the-test-environment

  -
    question: |
      Which PHPUnit assertion would you use to check if a variable is `null`?
    answers:
      - { value: '`$this->assertNull($variable);`', correct: true }
      - { value: '`$this->assertEquals(null, $variable);`', correct: false }
      - { value: '`$this->assertTrue(is_null($variable));`', correct: false }
      - { value: '`$this->assertIsEmpty($variable);`', correct: false }
    help: |
      The `assertNull()` assertion is specifically designed to check if a variable is `null`.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertNull

  -
    question: |
      When writing a functional test, how can you access the session object?
    answers:
      - { value: '`$client->getRequest()->getSession()`', correct: true }
      - { value: '`$client->getSession()`', correct: false }
      - { value: '`$client->getProfile()->getCollector(''session'')`', correct: false }
      - { value: '`static::getContainer()->get(''session'')`', correct: false }
    help: |
      The session is part of the request, so you can access it via the `Request` object obtained from the client.
      https://symfony.com/doc/current/testing.html#accessing-the-session

  -
    question: |
      What is the purpose of `#[Group('my_group')]` annotation/attribute in PHPUnit?
    answers:
      - { value: 'To categorize tests, allowing you to run only a subset of tests belonging to a specific group.', correct: true }
      - { value: 'To define the order in which tests are executed.', correct: false }
      - { value: 'To specify dependencies between test methods.', correct: false }
      - { value: 'To mark tests that should be skipped.', correct: false }
    help: |
      The `@group` annotation (or `#[Group]` attribute in PHP 8+) allows you to group tests and then run only those tests belonging to a specific group using PHPUnit's `--group` option.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.group

  -
    question: |
      Which of the following describes a "data provider" in PHPUnit?
    answers:
      - { value: 'A method that returns a set of arguments to be used by a test method, allowing the same test to be run with different inputs.', correct: true }
      - { value: 'A service that provides test data from a database.', correct: false }
      - { value: 'A class that generates random test data.', correct: false }
      - { value: 'A mechanism for injecting dependencies into test classes.', correct: false }
    help: |
      Data providers allow you to write a single test method and run it multiple times with different sets of data, reducing code duplication.
      https://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.data-providers

  -
    question: |
      How can you disable the Symfony Profiler for a specific functional test?
    answers:
      - { value: 'Pass `[''debug'' => false]` as an option to `static::createClient()`.', correct: true }
      - { value: 'Set `SYMFONY_PROFILER_DISABLED=1` environment variable.', correct: false }
      - { value: 'Call `$client->disableProfiler();`', correct: false }
      - { value: 'Remove the `WebProfilerBundle` from `config/bundles.php` for the test environment.', correct: false }
    help: |
      You can disable the profiler for a specific client by passing `['debug' => false]` to `createClient()`.
      https://symfony.com/doc/current/testing/profiling.html#disabling-the-profiler

  -
    question: |
      When asserting the content of a JSON response in a functional test, which method of the `Response` object is useful?
    answers:
      - { value: '`$response->toArray()`', correct: true }
      - { value: '`$response->json()`', correct: false }
      - { value: '`json_decode($response->getContent())`', correct: true }
      - { value: '`$response->decodeJson()`', correct: false }
    help: |
      The `Response` object has a `toArray()` method for JSON responses. Alternatively, you can manually decode the content.
      https://symfony.com/doc/current/components/http_foundation.html#json-responses

  -
    question: |
      What is the primary benefit of using `#[CoversClass(MyClass::class)]` in a PHPUnit test class?
    answers:
      - { value: 'It indicates which class the test class is intended to cover, improving documentation and code coverage reporting.', correct: true }
      - { value: 'It restricts the test to only run methods from `MyClass`.', correct: false }
      - { value: 'It automatically generates tests for `MyClass`.', correct: false }
      - { value: 'It ensures `MyClass` is loaded before tests run.', correct: false }
    help: |
      The `@covers` annotation (or `#[CoversClass]` attribute) specifies which class or method a test is intended to cover, which is useful for documentation and code coverage analysis.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.covers

  -
    question: |
      Which of the following is a correct way to assert that a specific HTTP status code was returned in a functional test?
    answers:
      - { value: '`$this->assertResponseStatusCodeSame(200);`', correct: true }
      - { value: '`$this->assertEquals(200, $client->getResponse()->getStatusCode());`', correct: true }
      - { value: '`$this->assertStatusCode(200);`', correct: false }
      - { value: '`$client->getResponse()->assertStatusCode(200);`', correct: false }
    help: |
      `WebTestCase` provides `assertResponseStatusCodeSame()` for convenience. You can also directly assert on the `Response` object's status code.
      https://symfony.com/doc/current/testing.html#asserting-responses

  -
    question: |
      When should you use `static::bootKernel()` in a functional test?
    answers:
      - { value: 'When you need to access the container or other kernel-dependent services before making any requests with the client.', correct: true }
      - { value: 'Before every test method to ensure a fresh kernel instance.', correct: false }
      - { value: 'Only when running unit tests.', correct: false }
      - { value: 'It is automatically called by `createClient()`, so rarely needed directly.', correct: true }
    help: |
      `static::bootKernel()` boots the Symfony kernel. It's automatically called by `createClient()`, but you might call it manually if you need to interact with the container before making requests.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      What is the purpose of `#[UsesTrait(MyTrait::class)]` in PHPUnit?
    answers:
      - { value: 'It indicates that the test class uses a specific trait, which can be useful for documentation and static analysis.', correct: true }
      - { value: 'It automatically includes the trait in the test class.', correct: false }
      - { value: 'It ensures the trait is available during test execution.', correct: false }
      - { value: 'It provides a way to mock trait methods.', correct: false }
    help: |
      The `@uses` annotation (or `#[UsesTrait]` attribute) indicates that a test uses a specific trait.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.uses

  -
    question: |
      How can you simulate an authenticated user in a functional test?
    answers:
      - { value: 'Pass a user object or username and password to `static::createClient()` options.', correct: true }
      - { value: 'Log in through the form in the test itself.', correct: true }
      - { value: 'Set a session variable with the user''s ID.', correct: false }
      - { value: 'Use a dedicated `login()` method on the client.', correct: false }
    help: |
      You can simulate a logged-in user by passing credentials to `createClient()` or by performing a login via a form submission within the test.
      https://symfony.com/doc/current/testing/http_authentication.html

  -
    question: |
      Which of the following PHPUnit assertions is best suited for checking if an array contains a specific value?
    answers:
      - { value: '`$this->assertContains($expectedValue, $array);`', correct: true }
      - { value: '`$this->assertArrayHasKey($key, $array);`', correct: false }
      - { value: '`$this->assertEquals($expectedValue, $array[0]);`', correct: false }
      - { value: '`$this->assertIsArray($array);`', correct: false }
    help: |
      The `assertContains()` assertion checks if a value is present in an array or other traversable.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertContains

  -
    question: |
      What is the purpose of the `PHPUnit\\Framework\\MockObject\\MockObject` interface?
    answers:
      - { value: 'It is the interface implemented by all mock objects created by PHPUnit, allowing type hinting for mocks.', correct: true }
      - { value: 'It defines the methods for creating mock objects.', correct: false }
      - { value: 'It is used to verify method calls on real objects.', correct: false }
      - { value: 'It provides methods for injecting mock dependencies.', correct: false }
    help: |
      All mock objects generated by PHPUnit implement `PHPUnit\\Framework\\MockObject\\MockObject`, which can be useful for type hinting.
      https://phpunit.de/manual/current/en/test-doubles.html

  -
    question: |
      How can you assert that a specific service was called with certain arguments during a functional test, using the Profiler?
    answers:
      - { value: 'Access the `data_collector.logger` or other relevant data collectors from the Profiler and inspect their collected data.', correct: true }
      - { value: 'There is no direct way to assert service calls via the Profiler.', correct: false }
      - { value: 'Use `$client->assertServiceCalled()` method.', correct: false }
      - { value: 'Mock the service before the request and assert its methods were called.', correct: true }
    help: |
      While the Profiler can show some service interactions (e.g., logs, database queries), for precise assertion of service method calls, mocking the service before the request is generally more reliable.
      https://symfony.com/doc/current/testing/profiling.html

  -
    question: |
      What is the role of `tearDown()` in a PHPUnit test class?
    answers:
      - { value: 'It is called after each test method to clean up resources or reset the test environment.', correct: true }
      - { value: 'It is called once after all test methods in the class have run.', correct: false }
      - { value: 'It is used to define global test teardown logic.', correct: false }
      - { value: 'It is responsible for generating test reports.', correct: false }
    help: |
      The `tearDown()` method is executed after each test method, allowing for cleanup operations.
      https://phpunit.de/manual/current/en/fixtures.html#fixtures.setup-teardown

  -
    question: |
      Which of the following is a valid way to create a mock object for a class `App\\Service\\MyService`?
    answers:
      - { value: '`$this->createMock(App\\Service\\MyService::class);`', correct: true }
      - { value: '`new Mock(App\\Service\\MyService::class);`', correct: false }
      - { value: '`Mockery::mock(App\\Service\\MyService::class);`', correct: false }
      - { value: '`$this->getMockBuilder(App\\Service\\MyService::class)->getMock();`', correct: true }
    help: |
      PHPUnit provides `createMock()` as a convenient way to create a mock object. `getMockBuilder()` offers more control.
      https://phpunit.de/manual/current/en/test-doubles.html

  -
    question: |
      When writing a functional test, how can you check if the response contains a specific header?
    answers:
      - { value: '`$client->getResponse()->headers->has(''Content-Type'');`', correct: true }
      - { value: '`$client->getResponse()->hasHeader(''Content-Type'');`', correct: false }
      - { value: '`$this->assertResponseHasHeader(''Content-Type'');`', correct: false }
      - { value: '`$client->getResponse()->getHeader(''Content-Type'');` and then assert its value.', correct: true }
    help: |
      The `headers` property of the `Response` object is a `HeaderBag` which provides methods like `has()` and `get()` to inspect headers.
      https://symfony.com/doc/current/components/http_foundation.html#response-headers

  -
    question: |
      What is the purpose of `#[Depends('testMethod')]` in PHPUnit?
    answers:
      - { value: 'It specifies that a test method depends on the successful execution of another test method.', correct: true }
      - { value: 'It injects a dependency into the test method.', correct: false }
      - { value: 'It indicates that the test method should be skipped if `testMethod` fails.', correct: true }
      - { value: 'It defines the order of test execution.', correct: false }
    help: |
      The `@depends` annotation (or `#[Depends]` attribute) allows you to declare dependencies between test methods. If a dependency fails, the dependent test is skipped.
      https://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.dependencies

  -
    question: |
      How can you simulate a `PUT` request in a functional test?
    answers:
      - { value: '`$client->request(''PUT'', ''/api/resource'', [], [], [], $jsonContent);`', correct: true }
      - { value: '`$client->putRequest(''/api/resource'');`', correct: false }
      - { value: '`$client->request(''POST'', ''/api/resource'', [''_method'' => ''PUT'']);`', correct: false }
      - { value: '`$client->submit(''PUT'', ''/api/resource'');`', correct: false }
    help: |
      The `request()` method of the `KernelBrowser` (client) allows you to specify the HTTP method as the first argument.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      Which PHPUnit assertion would you use to check if an object is an instance of a specific class or interface?
    answers:
      - { value: '`$this->assertInstanceOf(ExpectedClass::class, $object);`', correct: true }
      - { value: '`$this->assertIsObject($object);`', correct: false }
      - { value: '`$this->assertEquals(ExpectedClass::class, get_class($object));`', correct: false }
      - { value: '`$this->assertType(ExpectedClass::class, $object);`', correct: false }
    help: |
      The `assertInstanceOf()` assertion verifies that a given object is an instance of a specified class or implements a specified interface.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertInstanceOf

  -
    question: |
      What is the main difference between `setUp()` and `setUpBeforeClass()` in PHPUnit?
    answers:
      - { value: '`setUp()` runs before each test method, while `setUpBeforeClass()` runs once before any test method in the class.', correct: true }
      - { value: '`setUpBeforeClass()` is for functional tests, `setUp()` is for unit tests.', correct: false }
      - { value: '`setUp()` is for setting up database connections, `setUpBeforeClass()` is for clearing the cache.', correct: false }
      - { value: '`setUpBeforeClass()` is deprecated in favor of `setUp()`.', correct: false }
    help: |
      `setUpBeforeClass()` is a static method called once per test class, while `setUp()` is called before each individual test method.
      https://phpunit.de/manual/current/en/fixtures.html#fixtures.setup-teardown

  -
    question: |
      How can you access the `Router` service from the container within a functional test?
    answers:
      - { value: '`static::getContainer()->get(''router'');`', correct: true }
      - { value: '`static::getContainer()->get(UrlGeneratorInterface::class);`', correct: true }
      - { value: '`$client->getRouter();`', correct: false }
      - { value: '`$this->router;`', correct: false }
    help: |
      You can retrieve the router service from the test container using its ID or by type-hinting against `UrlGeneratorInterface`.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      What is the purpose of `#[RunInSeparateProcess]` in PHPUnit?
    answers:
      - { value: 'To run a test method in a separate PHP process, ensuring complete isolation from other tests.', correct: true }
      - { value: 'To execute tests in parallel for faster execution.', correct: false }
      - { value: 'To prevent memory leaks by restarting the PHP process after each test.', correct: true }
      - { value: 'To run tests on a remote server.', correct: false }
    help: |
      The `@runInSeparateProcess` annotation (or `#[RunInSeparateProcess]` attribute) is used to run a test in a separate PHP process, which can help with isolation and preventing unintended side effects.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.runInSeparateProcess

  -
    question: |
      When inspecting the Profiler data, how can you access the data collected by the `logger` data collector?
    answers:
      - { value: '`$profile->getCollector(''logger'')`', correct: true }
      - { value: '`$profile->getLoggerData();`', correct: false }
      - { value: '`$profile->get(''logger'');`', correct: false }
      - { value: '`$profile->collectors->logger;`', correct: false }
    help: |
      The `Profile` object provides the `getCollector()` method to retrieve a specific data collector by its name.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      Which of the following is a common reason for a functional test to fail with a `500 Internal Server Error`?
    answers:
      - { value: 'An unhandled exception occurred in the application code during the request.', correct: true }
      - { value: 'The asserted text was not found in the response.', correct: false }
      - { value: 'The HTTP status code assertion was incorrect.', correct: false }
      - { value: 'The test client was not properly initialized.', correct: false }
    help: |
      A 500 error typically indicates a server-side error, often an unhandled exception in your Symfony application.
      https://symfony.com/doc/current/testing.html#debugging-functional-tests

  -
    question: |
      How can you debug a failing functional test by dumping the response content?
    answers:
      - { value: '`dd($client->getResponse()->getContent());`', correct: true }
      - { value: '`dump($client->getResponse()->getContent());`', correct: true }
      - { value: '`echo $client->getResponse()->getContent();`', correct: true }
      - { value: '`$client->debugResponse();`', correct: false }
    help: |
      You can use `dd()` (dump and die), `dump()`, or `echo` to output the response content for debugging purposes.
      https://symfony.com/doc/current/testing.html#debugging-functional-tests

  -
    question: |
      What is the purpose of `#[TestDox('My test description')]` in PHPUnit?
    answers:
      - { value: 'To provide a human-readable description for a test, which is used in test reports.', correct: true }
      - { value: 'To generate documentation from test methods.', correct: false }
      - { value: 'To define the test''s priority.', correct: false }
      - { value: 'To mark a test as incomplete.', correct: false }
    help: |
      The `@testdox` annotation (or `#[TestDox]` attribute) allows you to specify a more descriptive name for your tests in the PHPUnit output.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.testdox

  -
    question: |
      When performing a functional test, how can you assert that a redirect occurred to a specific URL?
    answers:
      - { value: '`$this->assertResponseRedirects(''/expected-url'');`', correct: true }
      - { value: '`$this->assertEquals(''/expected-url'', $client->getResponse()->headers->get(''Location''));`', correct: true }
      - { value: '`$client->assertRedirectsTo(''/expected-url'');`', correct: false }
      - { value: '`$client->getResponse()->isRedirect(''/expected-url'');`', correct: false }
    help: |
      `WebTestCase` provides `assertResponseRedirects()` for convenience. You can also manually check the `Location` header.
      https://symfony.com/doc/current/testing.html#asserting-redirects

  -
    question: |
      What is the primary benefit of using a `KernelBrowser` (client) over a standard `HttpClient` for functional tests?
    answers:
      - { value: 'The `KernelBrowser` directly interacts with the Symfony kernel, bypassing the web server, which makes tests faster and more reliable.', correct: true }
      - { value: 'The `HttpClient` cannot make requests to the local application.', correct: false }
      - { value: 'The `KernelBrowser` provides built-in assertions for Symfony responses.', correct: false }
      - { value: 'The `HttpClient` does not support form submissions.', correct: false }
    help: |
      The `KernelBrowser` is a specialized HTTP client that directly interacts with the Symfony kernel, making functional tests more efficient and robust as they don't rely on an actual web server.
      https://symfony.com/doc/current/testing.html#the-test-client

  -
    question: |
      How can you set a custom header for a request made by the test client?
    answers:
      - { value: 'Pass an array of headers in the fifth argument of the `request()` method.', correct: true }
      - { value: '`$client->setHeader(''X-Custom-Header'', ''Value'');`', correct: false }
      - { value: 'Add headers to the `$_SERVER` superglobal before the request.', correct: false }
      - { value: 'Configure headers in `config/packages/test/framework.yaml`.', correct: false }
    help: |
      The `request()` method of the `KernelBrowser` allows you to pass an array of server parameters (including headers) as its fifth argument.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the purpose of `#[PreserveGlobalState(false)]` in PHPUnit?
    answers:
      - { value: 'To prevent PHPUnit from backing up and restoring the global state (e.g., superglobals), which can improve performance but requires careful test isolation.', correct: true }
      - { value: 'To ensure that global variables are reset before each test.', correct: false }
      - { value: 'To disable the use of global variables in tests.', correct: false }
      - { value: 'To run tests in a separate process.', correct: false }
    help: |
      The `@preserveGlobalState` annotation (or `#[PreserveGlobalState]` attribute) controls whether PHPUnit attempts to preserve and restore the global state between tests. Setting it to `false` can improve performance but requires careful management of global state in tests.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.preserveGlobalState

  -
    question: |
      When testing a JSON API, how can you assert that the response content is valid JSON?
    answers:
      - { value: '`$this->assertJson($client->getResponse()->getContent());`', correct: true }
      - { value: '`$this->assertJsonStringEqualsJsonString($expectedJson, $client->getResponse()->getContent());`', correct: true }
      - { value: '`json_decode($client->getResponse()->getContent()) !== null;`', correct: true }
      - { value: '`$client->getResponse()->isJson();`', correct: false }
    help: |
      PHPUnit provides `assertJson()` to check for valid JSON. You can also use `assertJsonStringEqualsJsonString()` to compare JSON strings or manually decode and check.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertJson

  -
    question: |
      What is the primary reason to use `static::getContainer()->get('doctrine.orm.entity_manager')` instead of `static::getContainer()->get(EntityManagerInterface::class)` in a functional test?
    answers:
      - { value: 'To explicitly request the default entity manager by its service ID, which is sometimes necessary if multiple entity managers are configured or for specific test setups.', correct: true }
      - { value: 'The `EntityManagerInterface::class` is not a valid service ID.', correct: false }
      - { value: 'It is a deprecated way of getting the entity manager.', correct: false }
      - { value: 'It is faster to get by string ID.', correct: false }
    help: |
      While type-hinting with `EntityManagerInterface::class` is generally preferred for autowiring, explicitly using the service ID `doctrine.orm.entity_manager` ensures you get the primary entity manager, which can be important in complex configurations or specific test scenarios.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      How can you simulate a `DELETE` request in a functional test?
    answers:
      - { value: '`$client->request(''DELETE'', ''/api/resource'');`', correct: true }
      - { value: '`$client->deleteRequest(''/api/resource'');`', correct: false }
      - { value: '`$client->request(''POST'', ''/api/resource'', [''_method'' => ''DELETE'']);`', correct: false }
      - { value: '`$client->submit(''DELETE'', ''/api/resource'');`', correct: false }
    help: |
      The `request()` method of the `KernelBrowser` (client) allows you to specify the HTTP method as the first argument.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the purpose of `#[DoesNotPerformAssertions]` in PHPUnit?
    answers:
      - { value: 'To mark a test method that is not expected to perform any assertions, preventing PHPUnit from issuing a warning for "risky" tests.', correct: true }
      - { value: 'To skip the execution of assertions in a test.', correct: false }
      - { value: 'To indicate that the test method is a setup method, not a test.', correct: false }
      - { value: 'To disable code coverage for the test method.', correct: false }
    help: |
      The `@doesNotPerformAssertions` annotation (or `#[DoesNotPerformAssertions]` attribute) tells PHPUnit that a test method is intentionally not performing any assertions, thus avoiding a "risky test" warning.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.doesNotPerformAssertions

  -
    question: |
      When dealing with legacy deprecated code in tests, what is the default behavior of PHPUnit Bridge regarding deprecation notices?
    answers:
      - { value: 'It converts them into exceptions, causing tests to fail by default.', correct: true }
      - { value: 'It ignores them completely.', correct: false }
      - { value: 'It logs them as warnings but does not fail the test.', correct: false }
      - { value: 'It automatically fixes the deprecated code.', correct: false }
    help: |
      By default, PHPUnit Bridge converts deprecation notices into exceptions, making them visible and forcing you to address them.
      https://symfony.com/doc/current/components/phpunit_bridge.html#handling-legacy-deprecated-code

  -
    question: |
      How can you configure PHPUnit Bridge to only show deprecations that originate from your own code, ignoring those from vendors?
    answers:
      - { value: 'Set `SYMFONY_DEPRECATIONS_HELPER` to `weak` or a specific regex for your namespace.', correct: true }
      - { value: 'Modify `phpunit.xml.dist` to exclude vendor directories from deprecation checks.', correct: false }
      - { value: 'Use `$this->ignoreVendorDeprecations();` in your test.', correct: false }
      - { value: 'There is no such built-in feature.', correct: false }
    help: |
      The `SYMFONY_DEPRECATIONS_HELPER` environment variable allows fine-grained control over deprecation handling, including filtering by origin.
      https://symfony.com/doc/current/components/phpunit_bridge.html#ignoring-some-deprecations

  -
    question: |
      What is the main purpose of the `PHPUnit_Bridge_Autoload` class provided by Symfony PHPUnit Bridge?
    answers:
      - { value: 'It registers a custom autoloader that helps in handling deprecations and ensuring test isolation.', correct: true }
      - { value: 'It replaces Composer''s autoloader for tests.', correct: false }
      - { value: 'It provides a faster autoloader for test environments.', correct: false }
      - { value: 'It is responsible for loading test fixtures.', correct: false }
    help: |
      The `PHPUnit_Bridge_Autoload` class is part of the PHPUnit Bridge and helps in setting up the test environment, including deprecation handling.
      https://symfony.com/doc/current/components/phpunit_bridge.html

  -
    question: |
      Which of the following is a valid way to assert that a specific email was sent during a functional test using the Profiler?
    answers:
      - { value: 'Access the `data_collector.mailer` from the Profiler and inspect the collected messages.', correct: true }
      - { value: 'Use `$client->assertEmailSent();`', correct: false }
      - { value: 'Check the mail spool directory directly.', correct: false }
      - { value: 'There is no built-in way to assert emails via the Profiler.', correct: false }
    help: |
      If the `Mailer` component is used, the Profiler's mailer data collector can be used to inspect sent emails.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      When performing a functional test, how can you access the current user object if authenticated?
    answers:
      - { value: '`static::getContainer()->get(''security.token_storage'')->getToken()->getUser();`', correct: true }
      - { value: '`$client->getUser();`', correct: false }
      - { value: '`$client->getRequest()->getUser();`', correct: false }
      - { value: '`$this->getUser();`', correct: false }
    help: |
      The authenticated user can be retrieved from the security token storage service in the container.
      https://symfony.com/doc/current/security.html#accessing-the-user-object

  -
    question: |
      What is the purpose of `#[Ticket('123')]` in PHPUnit?
    answers:
      - { value: 'To link a test method to an issue tracker ticket, improving traceability.', correct: true }
      - { value: 'To mark a test as a bug fix.', correct: false }
      - { value: 'To define the priority of a test.', correct: false }
      - { value: 'To automatically create a ticket if the test fails.', correct: false }
    help: |
      The `@ticket` annotation (or `#[Ticket]` attribute) allows you to associate a test with a ticket ID from an issue tracker.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.ticket

  -
    question: |
      How can you assert that a specific form field has a certain value after a form submission in a functional test?
    answers:
      - { value: '`$crawler->filter(''#form_field_id'')->attr(''value'')` and then assert its value.', correct: true }
      - { value: '`$crawler->filter(''#form_field_id'')->text()` and then assert its value.', correct: false }
      - { value: '`$form->get(''field_name'')->getValue()` and then assert its value.', correct: true }
      - { value: '`$client->assertFormFieldValue(''field_name'', ''expected_value'');`', correct: false }
    help: |
      You can use the `Crawler` to select the input field and get its `value` attribute, or if you have the `Form` object, you can get the field's value directly.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: |
      What is the primary benefit of using `#[DataProvider('provideData')]` for a test method?
    answers:
      - { value: 'It allows the test method to be executed multiple times with different sets of data, reducing code duplication and improving test coverage.', correct: true }
      - { value: 'It automatically generates test data for the method.', correct: false }
      - { value: 'It injects dependencies into the test method.', correct: false }
      - { value: 'It runs the test method in a separate process.', correct: false }
    help: |
      Data providers allow you to parameterize tests, running the same test logic with various inputs.
      https://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.data-providers

  -
    question: |
      When debugging a functional test, what information can the `Profiler` provide about database queries?
    answers:
      - { value: 'The number of queries executed, the SQL statements, and their execution times.', correct: true }
      - { value: 'Only the total number of queries.', correct: false }
      - { value: 'It only shows Doctrine ORM queries, not raw SQL.', correct: false }
      - { value: 'It can only show if a query failed, not the query itself.', correct: false }
    help: |
      The `doctrine` data collector in the Profiler provides detailed information about all database queries executed during a request.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      How can you simulate a `PATCH` request in a functional test?
    answers:
      - { value: '`$client->request(''PATCH'', ''/api/resource'', [], [], [], $jsonContent);`', correct: true }
      - { value: '`$client->patchRequest(''/api/resource'');`', correct: false }
      - { value: '`$client->request(''POST'', ''/api/resource'', [''_method'' => ''PATCH'']);`', correct: false }
      - { value: '`$client->submit(''PATCH'', ''/api/resource'');`', correct: false }
    help: |
      The `request()` method of the `KernelBrowser` (client) allows you to specify the HTTP method as the first argument.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the purpose of `#[Test]` in PHPUnit?
    answers:
      - { value: 'It marks a method as a test method, indicating that PHPUnit should execute it as part of the test suite.', correct: true }
      - { value: 'It defines a test suite.', correct: false }
      - { value: 'It is used to group tests.', correct: false }
      - { value: 'It specifies test dependencies.', correct: false }
    help: |
      The `@test` annotation (or `#[Test]` attribute) explicitly marks a method as a test method.
      https://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.test-methods

  -
    question: |
      When writing a functional test, how can you assert that a specific flash message was set?
    answers:
      - { value: 'Access the session from the client''s request and check the flash bag.', correct: true }
      - { value: '`$client->assertFlashMessage(''success'', ''Message'');`', correct: false }
      - { value: 'Check the response content for the flash message text.', correct: true }
      - { value: 'Access the `data_collector.session` from the Profiler and inspect flash messages.', correct: true }
    help: |
      Flash messages are stored in the session. You can access the session via the request, inspect the response content, or use the Profiler's session data collector.
      https://symfony.com/doc/current/testing.html#accessing-the-session

  -
    question: |
      What is the primary benefit of using `static::getContainer()->get('service_id')` over autowiring services directly into test methods?
    answers:
      - { value: 'It allows you to explicitly retrieve services that might not be autowirable or to get a specific instance when multiple exist.', correct: true }
      - { value: 'It is the only way to access services in functional tests.', correct: false }
      - { value: 'It makes tests run faster.', correct: false }
      - { value: 'It prevents memory leaks.', correct: false }
    help: |
      While autowiring is convenient, explicitly getting services from the container by ID offers more control, especially for services that are not autowirable by default or when dealing with multiple implementations of an interface.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      How can you assert that a specific number of elements are found by the `Crawler`?
    answers:
      - { value: '`$this->assertCount(5, $crawler->filter(''div''));`', correct: true }
      - { value: '`$crawler->filter(''div'')->count()` and then assert its value.', correct: true }
      - { value: '`$this->assertEquals(5, $crawler->filter(''div'')->length);`', correct: false }
      - { value: '`$crawler->assertCount(5);`', correct: false }
    help: |
      The `Crawler` object's `filter()` method returns a new `Crawler` instance, which can be used with `assertCount()` or by checking its `count()` method.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      What is the purpose of `#[CodeCoverageIgnore]` in PHPUnit?
    answers:
      - { value: 'To exclude a specific method or class from code coverage analysis.', correct: true }
      - { value: 'To prevent the test from running.', correct: false }
      - { value: 'To mark a test as incomplete.', correct: false }
      - { value: 'To generate a separate code coverage report for the marked code.', correct: false }
    help: |
      The `@codeCoverageIgnore` annotation (or `#[CodeCoverageIgnore]` attribute) tells PHPUnit's code coverage analysis to ignore the annotated code.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.codeCoverageIgnore

  -
    question: |
      When inspecting the Profiler data, how can you access the data collected by the `router` data collector?
    answers:
      - { value: '`$profile->getCollector(''router'')`', correct: true }
      - { value: '`$profile->getRouterData();`', correct: false }
      - { value: '`$profile->get(''routing'');`', correct: false }
      - { value: '`$profile->collectors->router;`', correct: false }
    help: |
      The `Profile` object provides the `getCollector()` method to retrieve a specific data collector by its name.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      Which of the following is a valid way to assert that a specific form field exists on the page?
    answers:
      - { value: '`$this->assertCount(1, $crawler->filter(''#form_field_id''));`', correct: true }
      - { value: '`$crawler->filter(''#form_field_id'')->count() > 0;`', correct: true }
      - { value: '`$this->assertNotNull($crawler->filter(''#form_field_id'')->getNode(0));`', correct: true }
      - { value: '`$crawler->hasFormField(''form_field_id'');`', correct: false }
    help: |
      You can assert the count of elements found by the `Crawler` or check if the first node exists.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      What is the purpose of `#[BackupStaticProperties(false)]` in PHPUnit?
    answers:
      - { value: 'To prevent PHPUnit from backing up and restoring static properties of classes, which can improve performance but requires careful handling of static state in tests.', correct: true }
      - { value: 'To ensure static properties are reset to their initial values before each test.', correct: false }
      - { value: 'To disable the use of static properties in tests.', correct: false }
      - { value: 'To run tests in a separate process.', correct: false }
    help: |
      The `@backupStaticProperties` annotation (or `#[BackupStaticProperties]` attribute) controls whether PHPUnit attempts to back up and restore static properties. Setting it to `false` can improve performance but requires careful management of static state.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.backupStaticProperties

  -
    question: |
      How can you assert that a specific service was *not* called during a functional test, using mocks?
    answers:
      - { value: 'Mock the service and configure its methods with `->expects($this->never())`.', correct: true }
      - { value: 'There is no direct way to assert that a service was not called.', correct: false }
      - { value: 'Check the Profiler for any logs related to the service.', correct: false }
      - { value: 'Remove the service from the container before the request.', correct: false }
    help: |
      By mocking a service and setting `->expects($this->never())` on its methods, you can assert that those methods were not invoked.
      https://phpunit.de/manual/current/en/test-doubles.html

  -
    question: |
      Which of the following is a valid way to assert that the response content is empty?
    answers:
      - { value: '`$this->assertEmpty($client->getResponse()->getContent());`', correct: true }
      - { value: '`$this->assertEquals('', $client->getResponse()->getContent());`', correct: true }
      - { value: '`$client->getResponse()->isEmpty();`', correct: false }
      - { value: '`$this->assertNull($client->getResponse()->getContent());`', correct: false }
    help: |
      You can use `assertEmpty()` or `assertEquals('')` to check if the response content is empty.
      https://phpunit.de/manual/current/en/assertions.html#assertions.assertEmpty

  -
    question: |
      What is the purpose of `#[PostCondition]` in PHPUnit?
    answers:
      - { value: 'To mark a method that should be run after each test method, regardless of whether the test passed or failed, for cleanup or state verification.', correct: true }
      - { value: 'To define a condition that must be met for the test to pass.', correct: false }
      - { value: 'To specify a method that runs after all tests in a class.', correct: false }
      - { value: 'To assert the final state of the application after a test.', correct: false }
    help: |
      The `@postCondition` annotation (or `#[PostCondition]` attribute) marks a method to be run after each test method, similar to `tearDown()`, but specifically for checking post-conditions.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.postCondition

  -
    question: |
      How can you simulate a `HEAD` request in a functional test?
    answers:
      - { value: '`$client->request(''HEAD'', ''/resource'');`', correct: true }
      - { value: '`$client->headRequest(''/resource'');`', correct: false }
      - { value: '`$client->request(''GET'', ''/resource'', [], [], [''REQUEST_METHOD'' => ''HEAD'']);`', correct: false }
      - { value: '`$client->submit(''HEAD'', ''/resource'');`', correct: false }
    help: |
      The `request()` method of the `KernelBrowser` (client) allows you to specify the HTTP method as the first argument.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the purpose of `#[PreCondition]` in PHPUnit?
    answers:
      - { value: 'To mark a method that should be run before each test method to set up specific conditions, similar to `setUp()`.', correct: true }
      - { value: 'To define a condition that must be met before a test can run.', correct: false }
      - { value: 'To specify a method that runs before all tests in a class.', correct: false }
      - { value: 'To assert the initial state of the application before a test.', correct: false }
    help: |
      The `@preCondition` annotation (or `#[PreCondition]` attribute) marks a method to be run before each test method, similar to `setUp()`, but specifically for setting up pre-conditions.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.preCondition

  -
    question: |
      When writing a functional test, how can you assert that a specific route was matched for the last request?
    answers:
      - { value: 'Access the `router` data collector from the Profiler and check the `route` property.', correct: true }
      - { value: '`$this->assertRouteSame(''app_homepage'');`', correct: false }
      - { value: 'Check `$client->getRequest()->attributes->get(''_route'')`.', correct: true }
      - { value: '`$client->assertCurrentRoute(''app_homepage'');`', correct: false }
    help: |
      The matched route name is stored in the request attributes. You can also inspect the router data collector in the profiler.
      https://symfony.com/doc/current/testing.html#accessing-profiler-data

  -
    question: |
      What is the purpose of `#[TestWith([1, 2, 3])]` in PHPUnit?
    answers:
      - { value: 'To provide inline data for a test method, similar to a data provider but defined directly on the test method.', correct: true }
      - { value: 'To define a test suite with specific parameters.', correct: false }
      - { value: 'To run the test method with a specific set of arguments only once.', correct: false }
      - { value: 'To specify test dependencies with arguments.', correct: false }
    help: |
      The `#[TestWith]` attribute (PHP 8+) allows you to define inline data sets for a test method, making it run multiple times with different arguments.
      https://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.test-with-attribute

  -
    question: |
      How can you assert that a specific exception was thrown during a unit test?
    answers:
      - { value: '`$this->expectException(MyException::class);`', correct: true }
      - { value: '`$this->expectExceptionMessage(''Expected message'');`', correct: true }
      - { value: 'Use a `try-catch` block and then assert on the caught exception.', correct: true }
      - { value: '`$this->assertThrows(MyException::class, function() { /* code */ });`', correct: false }
    help: |
      PHPUnit provides `expectException()` and `expectExceptionMessage()` for asserting exceptions. You can also use a `try-catch` block for more complex assertions.
      https://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.exceptions

  -
    question: |
      When using the `Crawler` object, how can you get the value of an attribute from a selected HTML element?
    answers:
      - { value: '`$crawler->filter(''a'')->attr(''href'')`', correct: true }
      - { value: '`$crawler->filter(''a'')->getAttribute(''href'')`', correct: false }
      - { value: '`$crawler->filter(''a'')->href`', correct: false }
      - { value: '`$crawler->filter(''a'')->value(''href'')`', correct: false }
    help: |
      The `attr()` method on a `Crawler` node allows you to retrieve the value of a specified HTML attribute.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      What is the primary purpose of `#[Ignore]` in PHPUnit?
    answers:
      - { value: 'To exclude a test class or method from being executed by PHPUnit.', correct: true }
      - { value: 'To mark a test as incomplete.', correct: false }
      - { value: 'To prevent code coverage analysis for a test.', correct: false }
      - { value: 'To skip a test if a certain condition is not met.', correct: false }
    help: |
      The `@ignore` annotation (or `#[Ignore]` attribute) tells PHPUnit to skip the annotated test class or method.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.ignore

  -
    question: |
      How can you assert that a specific service was instantiated during a functional test, using the Profiler?
    answers:
      - { value: 'Access the `container` data collector from the Profiler and check the list of instantiated services.', correct: true }
      - { value: 'There is no direct way to assert service instantiation via the Profiler.', correct: false }
      - { value: 'Use `$client->assertServiceInstantiated(''service_id'');`', correct: false }
      - { value: 'Check the container''s debug logs for service instantiation events.', correct: false }
    help: |
      The `container` data collector in the Profiler can provide information about which services were instantiated during a request.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      What is the purpose of `#[Small]`, `#[Medium]`, `#[Large]` in PHPUnit?
    answers:
      - { value: 'To categorize tests by their estimated execution time or resource consumption, allowing for selective execution.', correct: true }
      - { value: 'To define the priority of tests.', correct: false }
      - { value: 'To specify the number of assertions in a test.', correct: false }
      - { value: 'To indicate the complexity of the test logic.', correct: false }
    help: |
      These annotations/attributes are used to categorize tests by size, which can be used to run subsets of tests (e.g., only "small" tests for quick feedback).
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.group

  -
    question: |
      When writing a functional test, how can you simulate a `GET` request with query parameters?
    answers:
      - { value: 'Append query parameters directly to the URL string.', correct: true }
      - { value: 'Pass an array of query parameters as the third argument to `request()`.', correct: true }
      - { value: 'Use `$client->get('/path', ['param' => 'value']);`', correct: false }
      - { value: 'Set query parameters in the `$_GET` superglobal before the request.', correct: false }
    help: |
      You can include query parameters in the URL string or pass them as the third argument to the `request()` method.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the purpose of `#[CoversNothing]` in PHPUnit?
    answers:
      - { value: 'To indicate that a test class or method does not cover any production code, often used for integration or functional tests.', correct: true }
      - { value: 'To exclude a test from code coverage analysis.', correct: false }
      - { value: 'To mark a test that is not yet implemented.', correct: false }
      - { value: 'To prevent the test from affecting code coverage reports.', correct: false }
    help: |
      The `@coversNothing` annotation (or `#[CoversNothing]` attribute) is used to specify that a test does not cover any specific production code, which is common for higher-level tests like functional tests.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.coversNothing

  -
    question: |
      How can you assert that a specific number of database queries were executed during a functional test, using the Profiler?
    answers:
      - { value: 'Access the `doctrine` data collector from the Profiler and check its query count.', correct: true }
      - { value: 'Use `$this->assertQueryCount(5);`', correct: false }
      - { value: 'There is no direct way to assert query count via the Profiler.', correct: false }
      - { value: 'Enable SQL logging and count the entries.', correct: false }
    help: |
      The `doctrine` data collector in the Profiler provides the number of executed queries.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      What is the purpose of `#[ExcludeGlobalVariableFromBackup('myGlobal')]` in PHPUnit?
    answers:
      - { value: 'To prevent PHPUnit from backing up and restoring a specific global variable, which can be useful for performance or when a global variable is intentionally modified by a test.', correct: true }
      - { value: 'To make a global variable accessible only within a test.', correct: false }
      - { value: 'To define a global variable for all tests.', correct: false }
      - { value: 'To remove a global variable from the test environment.', correct: false }
    help: |
      The `@excludeGlobalVariableFromBackup` annotation (or `#[ExcludeGlobalVariableFromBackup]` attribute) allows you to exclude specific global variables from PHPUnit's backup and restore process.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.excludeGlobalVariableFromBackup

  -
    question: |
      When writing a functional test, how can you assert that the response is a JSON response?
    answers:
      - { value: '`$client->getResponse()->headers->contains(''Content-Type'', ''application/json'');`', correct: true }
      - { value: '`$client->getResponse()->isJson();`', correct: false }
      - { value: '`$this->assertResponseIsJson();`', correct: false }
      - { value: '`$this->assertStringContainsString(''application/json'', $client->getResponse()->headers->get(''Content-Type''));`', correct: true }
    help: |
      You can check the `Content-Type` header of the response to determine if it's a JSON response.
      https://symfony.com/doc/current/components/http_foundation.html#response-headers

  -
    question: |
      What is the purpose of `#[WithoutErrorHandler]` in PHPUnit?
    answers:
      - { value: 'To disable PHPUnit''s error handler for a specific test, allowing native PHP errors and warnings to be reported directly.', correct: true }
      - { value: 'To prevent errors from stopping the test execution.', correct: false }
      - { value: 'To ignore all errors during the test.', correct: false }
      - { value: 'To use a custom error handler for the test.', correct: false }
    help: |
      The `@withoutErrorHandler` annotation (or `#[WithoutErrorHandler]` attribute) disables PHPUnit's error handler for the annotated test.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.withoutErrorHandler

  -
    question: |
      How can you simulate a `POST` request with JSON content in a functional test?
    answers:
      - { value: '`$client->request(''POST'', ''/api/resource'', [], [], [''CONTENT_TYPE'' => ''application/json''], json_encode($data));`', correct: true }
      - { value: '`$client->postJson(''/api/resource'', $data);`', correct: false }
      - { value: '`$client->request(''POST'', ''/api/resource'', $data, [], [''HTTP_CONTENT_TYPE'' => ''application/json'']);`', correct: false }
      - { value: '`$client->submitForm(''form_name'', $data, ''POST'', [''json'' => true]);`', correct: false }
    help: |
      You need to set the `CONTENT_TYPE` header to `application/json` and pass the JSON encoded data as the request body.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      What is the purpose of `#[DependsExternal('MyClass', 'myMethod')]` in PHPUnit?
    answers:
      - { value: 'To declare a dependency on a method in an external class, indicating that this test relies on the successful execution of that external method.', correct: true }
      - { value: 'To mock an external class method.', correct: false }
      - { value: 'To include an external method in the test suite.', correct: false }
      - { value: 'To run a test only if an external method exists.', correct: false }
    help: |
      The `@dependsExternal` annotation (or `#[DependsExternal]` attribute) is used to declare dependencies on methods in external classes.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.dependsExternal

  -
    question: |
      When writing a unit test, how can you assert that a specific method was called on a mock object a certain number of times?
    answers:
      - { value: '`$mock->expects($this->exactly(3))->method(''myMethod'');`', correct: true }
      - { value: '`$mock->myMethod()->times(3);`', correct: false }
      - { value: '`$this->assertMethodCalled($mock, ''myMethod'', 3);`', correct: false }
      - { value: '`$mock->expects($this->atLeast(3))->method(''myMethod'');`', correct: true }
    help: |
      PHPUnit's mock object API allows you to set expectations on method calls, including the exact number of times a method should be called.
      https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.mock-objects.expectations

  -
    question: |
      What is the purpose of `#[RequiresPhp('8.2')]` in PHPUnit?
    answers:
      - { value: 'To indicate that a test requires a minimum PHP version to run, skipping the test if the requirement is not met.', correct: true }
      - { value: 'To force the test to run with a specific PHP version.', correct: false }
      - { value: 'To define the PHP version used for code coverage analysis.', correct: false }
      - { value: 'To ensure PHP 8.2 features are available in the test.', correct: false }
    help: |
      The `@requires PHP` annotation (or `#[RequiresPhp]` attribute) allows you to specify a minimum required PHP version for a test.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.requires

  -
    question: |
      How can you assert that a specific form field is disabled in a functional test?
    answers:
      - { value: '`$this->assertCount(1, $crawler->filter(''input[name="field_name"][disabled]''));`', correct: true }
      - { value: '`$crawler->filter(''input[name="field_name"]'')->attr(''disabled'') !== null;`', correct: true }
      - { value: '`$crawler->filter(''input[name="field_name"]'')->isDisabled();`', correct: false }
      - { value: '`$client->assertFormFieldDisabled(''field_name'');`', correct: false }
    help: |
      You can use the `Crawler` to select the input field with the `disabled` attribute and assert its presence.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      What is the purpose of `#[UsesFunction('my_function')]` in PHPUnit?
    answers:
      - { value: 'To indicate that a test uses a specific global function, which can be useful for documentation and static analysis.', correct: true }
      - { value: 'To automatically include a global function in the test environment.', correct: false }
      - { value: 'To mock a global function.', correct: false }
      - { value: 'To ensure a global function is available during test execution.', correct: false }
    help: |
      The `@uses` annotation (or `#[UsesFunction]` attribute) indicates that a test uses a specific global function.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.uses

  -
    question: |
      How can you assert that a specific element does *not* exist on the page in a functional test?
    answers:
      - { value: '`$this->assertCount(0, $crawler->filter(''.non-existent-class''));`', correct: true }
      - { value: '`$crawler->filter(''.non-existent-class'')->count() === 0;`', correct: true }
      - { value: '`$this->assertEmpty($crawler->filter(''.non-existent-class''));`', correct: true }
      - { value: '`$crawler->doesNotHave(''.non-existent-class'');`', correct: false }
    help: |
      You can assert that the count of elements found by the `Crawler` is zero, or that the `Crawler` object is empty.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: |
      What is the purpose of `#[TestIsolation(true)]` in PHPUnit?
    answers:
      - { value: 'To force a test to run in a separate PHP process, ensuring complete isolation from other tests and preventing side effects.', correct: true }
      - { value: 'To prevent the test from accessing global variables.', correct: false }
      - { value: 'To ensure the test environment is reset after each test method.', correct: false }
      - { value: 'To run tests in parallel.', correct: false }
    help: |
      The `@testIsolation` annotation (or `#[TestIsolation]` attribute) forces a test to run in a separate process, providing strong isolation.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.testIsolation

  -
    question: |
      When inspecting the Profiler data, how can you access the data collected by the `security` data collector?
    answers:
      - { value: '`$profile->getCollector(''security'')`', correct: true }
      - { value: '`$profile->getSecurityData();`', correct: false }
      - { value: '`$profile->get(''auth'');`', correct: false }
      - { value: '`$profile->collectors->security;`', correct: false }
    help: |
      The `Profile` object provides the `getCollector()` method to retrieve a specific data collector by its name.
      https://symfony.com/doc/current/testing/profiling.html#accessing-profiler-data

  -
    question: |
      What is the purpose of `#[BackupGlobals(false)]` in PHPUnit?
    answers:
      - { value: 'To prevent PHPUnit from backing up and restoring global and superglobal variables, which can improve performance but requires careful handling of global state in tests.', correct: true }
      - { value: 'To ensure global variables are reset before each test.', correct: false }
      - { value: 'To disable the use of global variables in tests.', correct: false }
      - { value: 'To run tests in a separate process.', correct: false }
    help: |
      The `@backupGlobals` annotation (or `#[BackupGlobals]` attribute) controls whether PHPUnit attempts to back up and restore global and superglobal variables. Setting it to `false` can improve performance but requires careful management of global state.
      https://phpunit.de/manual/current/en/appendixes.annotations.html#appendixes.annotations.backupGlobals

  -
    question: |
      How can you assert that a specific HTTP header is *not* present in the response of a functional test?
    answers:
      - { value: '`$client->getResponse()->headers->has(''X-Non-Existent-Header'') === false;`', correct: true }
      - { value: '`$this->assertResponseNotHasHeader(''X-Non-Existent-Header'');`', correct: false }
      - { value: '`$this->assertNull($client->getResponse()->headers->get(''X-Non-Existent-Header''));`', correct: true }
      - { value: '`$client->getResponse()->headers->get(''X-Non-Existent-Header'') === null;`', correct: true }
    help: |
      You can check if the `HeaderBag` does not contain the header, or if retrieving the header returns `null`.
      https://symfony.com/doc/current/components/http_foundation.html#response-headers