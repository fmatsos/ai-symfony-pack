category: Automated Tests
questions:
  - question: Which PHPUnit test class is recommended for writing functional tests
      that interact with the Symfony application's HTTP layer?
    answers:
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`"
        correct: true
      - value: "`PHPUnit\\Framework\\TestCase`"
        correct: false
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`"
        correct: false
      - value: "`Symfony\\Component\\BrowserKit\\HttpBrowser`"
        correct: false
    help: For functional tests that simulate HTTP requests and interact with the
      full application stack, `WebTestCase` is the appropriate base class.
  - question: In a `KernelTestCase`, what is the correct way to boot the Symfony
      kernel before accessing services?
    answers:
      - value: "`self::bootKernel();`"
        correct: true
      - value: "`$this->bootKernel();`"
        correct: false
      - value: "`static::getKernel()->boot();`"
        correct: false
      - value: "`$this->kernel->boot();`"
        correct: false
    help: The `bootKernel()` method is a static method of `KernelTestCase` and
      should be called using `self::bootKernel()`.
  - question: How can you retrieve a service from the Symfony container within a
      `KernelTestCase` after the kernel has been booted?
    answers:
      - value: "`static::getContainer()->get(MyService::class);`"
        correct: true
      - value: "`$this->container->get(MyService::class);`"
        correct: false
      - value: "`self::getService(MyService::class);`"
        correct: false
      - value: "`$this->get(MyService::class);`"
        correct: false
    help: After booting the kernel with `self::bootKernel()`, the service container
      can be accessed via `static::getContainer()`.
  - question: Which Composer command is used to install the `symfony/test-pack` for
      testing Symfony applications?
    answers:
      - value: "`composer require --dev symfony/test-pack`"
        correct: true
      - value: "`composer install symfony/test-pack --dev`"
        correct: false
      - value: "`composer add symfony/test-pack --dev`"
        correct: false
      - value: "`composer test-pack install`"
        correct: false
    help: The `symfony/test-pack` is installed as a development dependency using
      `composer require --dev symfony/test-pack`.
  - question: What is the primary purpose of `dama/doctrine-test-bundle` in Symfony
      functional tests?
    answers:
      - value: To automatically reset the database state before each test using Doctrine
          transactions.
        correct: true
      - value: To generate dummy data (fixtures) for tests.
        correct: false
      - value: To provide assertions for Doctrine entities.
        correct: false
      - value: To run database migrations in the test environment.
        correct: false
    help: The `dama/doctrine-test-bundle` is used to ensure test isolation by
      resetting the database state for each test via Doctrine transactions.
  - question: How can you configure a dedicated test database URL in Symfony?
    answers:
      - value: By defining `DATABASE_URL` in `.env.test.local`.
        correct: true
      - value: By setting `DATABASE_URL` in `config/packages/test/doctrine.yaml`.
        correct: false
      - value: By using the `SYMFONY_ENV=test` environment variable.
        correct: false
      - value: By modifying `config/services.yaml`.
        correct: false
    help: A dedicated test database URL can be configured in `.env.test.local` to
      ensure tests run against their own database.
  - question: Which command is used to create the database schema for the test
      environment in Symfony?
    answers:
      - value: "`php bin/console --env=test doctrine:schema:create`"
        correct: true
      - value: "`php bin/console doctrine:migrations:migrate --env=test`"
        correct: false
      - value: "`php bin/console doctrine:database:create --env=test`"
        correct: false
      - value: "`php bin/console doctrine:fixtures:load --env=test`"
        correct: false
    help: The `doctrine:schema:create` command, run with `--env=test`, creates the
      tables and columns in the test database.
  - question: What is the purpose of `php bin/console make:test`?
    answers:
      - value: To interactively create a new test class, prompting for test type and
          name.
        correct: true
      - value: To run all existing tests in the application.
        correct: false
      - value: To generate test fixtures for the database.
        correct: false
      - value: To create a new PHPUnit configuration file.
        correct: false
    help: The `make:test` command from SymfonyMakerBundle helps in quickly
      scaffolding new test classes.
  - question: When performing functional tests, why might you call
      `$client->catchExceptions(false);`?
    answers:
      - value: To allow PHPUnit to report exceptions directly, aiding in debugging.
        correct: true
      - value: To prevent the application from throwing any exceptions during the test.
        correct: false
      - value: To automatically catch all exceptions and convert them into 500
          responses.
        correct: false
      - value: To disable the Symfony error handler completely.
        correct: false
    help: By default, the Symfony test client catches exceptions. Disabling this
      allows PHPUnit to report them, which is essential for debugging test
      failures caused by exceptions.
  - question: Which method of the Symfony test client is used to simulate an AJAX
      request?
    answers:
      - value: "`$client->xmlHttpRequest('POST', '/submit');`"
        correct: true
      - value: "`$client->ajaxRequest('POST', '/submit');`"
        correct: false
      - value: "`$client->request('POST', '/submit', [], [], ['HTTP_X_REQUESTED_WITH' =>
          'XMLHttpRequest']);`"
        correct: false
      - value: "`$client->jsonRequest('POST', '/submit');`"
        correct: false
    help: The `xmlHttpRequest()` method automatically adds the
      `HTTP_X_REQUESTED_WITH` header, simplifying AJAX testing.
  - question: |-
      Consider the following code snippet:

      ```php
      $client = static::createClient();
      $crawler = $client->request('GET', '/post/hello-world');
      $this->assertCount(4, $crawler->filter('.comment'));
      ```

      What does the `assertCount` assertion verify in this context?
    answers:
      - value: That there are exactly 4 elements with the CSS class `comment` in the
          response.
        correct: true
      - value: That the response contains the text '4' within an element with the class
          `comment`.
        correct: false
      - value: That the request was made 4 times.
        correct: false
      - value: That there are at least 4 elements with the CSS class `comment`.
        correct: false
    help: The `assertCount` method, when used with the Crawler's `filter()` method,
      asserts that the number of matched elements is exactly the expected count.
  - question: Which of the following assertions can be used to check if a specific
      CSS selector exists in the response content?
    answers:
      - value: "`assertSelectorExists(string $selector, string $message = '')`"
        correct: true
      - value: "`assertHtmlContains(string $selector, string $message = '')`"
        correct: false
      - value: "`assertElementPresent(string $selector, string $message = '')`"
        correct: false
      - value: "`assertNodeExists(string $selector, string $message = '')`"
        correct: false
    help: The `assertSelectorExists` method is part of Symfony's crawler assertions
      to verify the presence of elements matching a CSS selector.
  - question: How can you assert that the HTML body of an email contains a specific
      text string?
    answers:
      - value: "`assertEmailHtmlBodyContains(RawMessage $email, string $text, string
          $message = '')`"
        correct: true
      - value: "`assertEmailBodyContains(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertEmailContains(RawMessage $email, string $text, string $message =
          '')`"
        correct: false
      - value: "`assertEmailHtmlContains(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
    help: Symfony provides specific assertions for email content, including
      `assertEmailHtmlBodyContains` for HTML bodies.
  - question: To enable the Symfony Profiler for a specific test request, what
      method should be called on the client *before* making the request?
    answers:
      - value: "`$client->enableProfiler();`"
        correct: true
      - value: "`$client->collectProfile();`"
        correct: false
      - value: "`$client->setProfilerEnabled(true);`"
        correct: false
      - value: "`$client->getProfile()->enable();`"
        correct: false
    help: Calling `$client->enableProfiler()` before a request ensures that profiler
      data is collected for that specific request.
  - question: After enabling the profiler and making a request, how do you retrieve
      the collected profile data?
    answers:
      - value: "`$profile = $client->getProfile();`"
        correct: true
      - value: "`$profile = $client->getProfilerData();`"
        correct: false
      - value: "`$profile = $client->getContainer()->get('profiler');`"
        correct: false
      - value: "`$profile = $client->getLatestProfile();`"
        correct: false
    help: The `getProfile()` method on the test client returns the collected profile
      object for the last request.
  - question: Which of the following configuration options for the Symfony profiler
      in `framework.yaml` is recommended for the `test` environment to avoid
      performance overhead, while still allowing individual enabling?
    answers:
      - value: "`profiler: { enabled: true, collect: false }`"
        correct: true
      - value: "`profiler: { enabled: false, collect: true }`"
        correct: false
      - value: "`profiler: { enabled: true, collect: true }`"
        correct: false
      - value: "`profiler: { enabled: false, collect: false }`"
        correct: false
    help: "Setting `enabled: true` and `collect: false` allows the profiler to be
      enabled programmatically for specific requests without collecting data for
      all requests by default."
  - question: What is the purpose of the `@group time-sensitive` annotation in a
      PHPUnit test class?
    answers:
      - value: It enables `ClockMock` functionality to mock time-related functions like
          `sleep()`.
        correct: true
      - value: It marks the test as taking a long time to execute.
        correct: false
      - value: It groups tests that depend on external time services.
        correct: false
      - value: It ensures the test runs at a specific time of day.
        correct: false
    help: The `@group time-sensitive` annotation, provided by
      `symfony/phpunit-bridge`, activates `ClockMock` for the test, allowing
      time-sensitive functions to be mocked.
  - question: When unit testing a Symfony form type that is registered as a service
      and has dependencies, which PHPUnit extension is typically used to
      register the form type instance?
    answers:
      - value: "`Symfony\\Component\\Form\\PreloadedExtension`"
        correct: true
      - value: "`Symfony\\Component\\Form\\Extension\\Core\\CoreExtension`"
        correct: false
      - value: "`Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension`"
        correct: false
      - value: "`Symfony\\Component\\Form\\Test\\TypeTestCase`"
        correct: false
    help: "`PreloadedExtension` is used to register pre-instantiated form type
      instances, which is useful when testing service-based form types with
      mocked dependencies."
  - question: Which assertion is used to verify that the current request matches a
      specific route and optionally its parameters?
    answers:
      - value: "`assertRouteSame($expectedRoute, array $parameters = [], string $message
          = '')`"
        correct: true
      - value: "`assertCurrentRoute($expectedRoute, array $parameters = [], string
          $message = '')`"
        correct: false
      - value: "`assertPathSame($expectedRoute, array $parameters = [], string $message
          = '')`"
        correct: false
      - value: "`assertUrlSame($expectedRoute, array $parameters = [], string $message =
          '')`"
        correct: false
    help: The `assertRouteSame` assertion verifies that the current request's route
      and parameters match the expected values.
  - question: How can you assert that a specific number of HTTP client requests have
      been made during a test?
    answers:
      - value: "`assertHttpClientRequestCount(int $count, string $httpClientId =
          'http_client')`"
        correct: true
      - value: "`assertHttpRequestCount(int $count, string $httpClientId =
          'http_client')`"
        correct: false
      - value: "`assertClientRequestCount(int $count, string $httpClientId =
          'http_client')`"
        correct: false
      - value: "`assertTotalRequests(int $count, string $httpClientId = 'http_client')`"
        correct: false
    help: The `assertHttpClientRequestCount` assertion is used to verify the total
      number of HTTP client requests made. Remember to enable the profiler
      first.
  - question: What is the purpose of the `urlProvider()` method in a functional test
      class like `ApplicationAvailabilityFunctionalTest`?
    answers:
      - value: It provides a list of URLs to be tested, allowing for data-driven smoke
          testing.
        correct: true
      - value: It defines the base URL for all requests in the test class.
        correct: false
      - value: It generates random URLs for fuzz testing.
        correct: false
      - value: It configures the routing for the test environment.
        correct: false
    help: The `urlProvider()` method, used with `@dataProvider`, supplies a set of
      URLs to the test method, enabling efficient smoke testing of multiple
      endpoints.
  - question: Which of the following is the correct way to simulate a logged-in user
      in a Symfony functional test?
    answers:
      - value: "`$client->loginUser($testUser);`"
        correct: true
      - value: "`$client->setLoggedInUser($testUser);`"
        correct: false
      - value: "`$client->request('POST', '/login', ['_username' => ..., '_password' =>
          ...]);`"
        correct: false
      - value: "`$client->getContainer()->get('security.token_storage')->setToken(...);\
          `"
        correct: false
    help: The `loginUser()` method on the test client is the recommended and most
      efficient way to simulate a logged-in user without a full login process.
  - question: When performing functional tests, what is the effect of calling
      `$client->followRedirects();`?
    answers:
      - value: The client will automatically follow all subsequent HTTP redirects.
        correct: true
      - value: The client will follow only the next HTTP redirect.
        correct: false
      - value: The client will stop following redirects.
        correct: false
      - value: The client will throw an exception if a redirect occurs.
        correct: false
    help: Calling `followRedirects()` without arguments sets the client to
      automatically follow all redirects until explicitly disabled with
      `followRedirects(false)`.
  - question: Which assertion is used to check if a checkbox with a given name is
      checked in the response?
    answers:
      - value: "`assertCheckboxChecked(string $fieldName, string $message = '')`"
        correct: true
      - value: "`assertInputChecked(string $fieldName, string $message = '')`"
        correct: false
      - value: "`assertFieldChecked(string $fieldName, string $message = '')`"
        correct: false
      - value: "`assertChecked(string $fieldName, string $message = '')`"
        correct: false
    help: The `assertCheckboxChecked` assertion verifies the checked state of a
      checkbox input field by its `name` attribute.
  - question: What is the purpose of `Symfony\Component\Form\Test\TypeTestCase`?
    answers:
      - value: It is the base class for unit testing Symfony form types.
        correct: true
      - value: It is used for functional testing of forms within a web application.
        correct: false
      - value: It provides utilities for testing form themes with Twig.
        correct: false
      - value: It is a base class for integration testing of Symfony forms.
        correct: false
    help: "`TypeTestCase` is specifically designed for isolated unit testing of
      individual Symfony form types."
  - question: When unit testing a form type, how do you verify that there are no
      data transformation failures after form submission?
    answers:
      - value: "`$this->assertTrue($form->isSynchronized());`"
        correct: true
      - value: "`$this->assertTrue($form->isValid());`"
        correct: false
      - value: "`$this->assertFalse($form->isSubmitted());`"
        correct: false
      - value: "`$this->assertEmpty($form->getErrors());`"
        correct: false
    help: The `isSynchronized()` method on a form indicates whether the submitted
      data was successfully transformed and synchronized with the form's
      underlying data.
  - question: Which command would you use to run all PHPUnit tests in a Symfony
      application?
    answers:
      - value: "`php bin/phpunit`"
        correct: true
      - value: "`./vendor/bin/phpunit`"
        correct: true
      - value: "`symfony console phpunit`"
        correct: false
      - value: "`composer run-test`"
        correct: false
    help: Both `php bin/phpunit` and `./vendor/bin/phpunit` are common ways to
      execute the PHPUnit test suite in a Symfony project.
  - question: How can you generate an HTML code coverage report after running
      PHPUnit tests?
    answers:
      - value: "`./vendor/bin/phpunit --coverage-html=cov/`"
        correct: true
      - value: "`./vendor/bin/phpunit --coverage-text`"
        correct: false
      - value: "`./vendor/bin/phpunit --report-html=cov/`"
        correct: false
      - value: "`./vendor/bin/phpunit --generate-coverage=html`"
        correct: false
    help: The `--coverage-html` option tells PHPUnit to generate an HTML report in
      the specified directory.
  - question: When testing a Doctrine repository functionally, why is it recommended
      to set `$this->entityManager = null;` in the `tearDown()` method?
    answers:
      - value: To avoid memory leaks by explicitly closing and nullifying the
          `EntityManager`.
        correct: true
      - value: To ensure the database connection is closed after each test.
        correct: false
      - value: To reset the entity manager's state for the next test.
        correct: false
      - value: To prevent accidental database writes in subsequent tests.
        correct: false
    help: Explicitly closing and nullifying the `EntityManager` in `tearDown()` is a
      best practice to prevent memory leaks, especially in tests that boot the
      kernel multiple times.
  - question: Which assertion is used to check if the value of a form input field
      (identified by its `name` attribute) is equal to an expected value?
    answers:
      - value: "`assertInputValueSame(string $fieldName, string $expectedValue, string
          $message = '')`"
        correct: true
      - value: "`assertFieldValueSame(string $fieldName, string $expectedValue, string
          $message = '')`"
        correct: false
      - value: "`assertFormInputSame(string $fieldName, string $expectedValue, string
          $message = '')`"
        correct: false
      - value: "`assertInputEquals(string $fieldName, string $expectedValue, string
          $message = '')`"
        correct: false
    help: The `assertInputValueSame` assertion is specifically designed for
      verifying the value of an input field.
  - question: What is the primary benefit of using `simple-phpunit` to run tests in
      parallel?
    answers:
      - value: It significantly reduces the total execution time of the test suite.
        correct: true
      - value: It provides a more detailed code coverage report.
        correct: false
      - value: It automatically fixes failing tests.
        correct: false
      - value: It allows running tests on different PHP versions simultaneously.
        correct: false
    help: "`simple-phpunit` is part of the PHPUnit Bridge and enables parallel test
      execution, which can drastically speed up large test suites."
  - question: When testing multi-domain applications with Symfony Panther, which
      PHPUnit annotation and client option are typically used to ensure each
      test targets a different domain in isolation?
    answers:
      - value: "`@runInSeparateProcess` and `external_base_uri`"
        correct: true
      - value: "`@runIsolated` and `base_uri`"
        correct: false
      - value: "`@separateProcess` and `domain_uri`"
        correct: false
      - value: "`@pantherProcess` and `target_uri`"
        correct: false
    help: The `@runInSeparateProcess` annotation combined with the
      `external_base_uri` option in `createPantherClient()` allows for isolated
      testing of different domains.
  - question: Which assertion is used to verify that the page's `<title>` element
      contains a specific string?
    answers:
      - value: "`assertPageTitleContains(string $expectedTitle, string $message = '')`"
        correct: true
      - value: "`assertTitleContains(string $expectedTitle, string $message = '')`"
        correct: false
      - value: "`assertHtmlTitleContains(string $expectedTitle, string $message = '')`"
        correct: false
      - value: "`assertSelectorTextContains('title', string $expectedTitle, string
          $message = '')`"
        correct: false
    help: The `assertPageTitleContains` assertion specifically targets the content
      of the HTML `<title>` tag.
  - question: What is the purpose of
      `Symfony\Component\Form\Extension\Validator\ValidatorExtension` in form
      testing?
    answers:
      - value: It integrates the Symfony Validator component with the Form component,
          enabling validation options.
        correct: true
      - value: It provides a way to mock the validator service in form tests.
        correct: false
      - value: It defines custom validation constraints for form types.
        correct: false
      - value: It is a base class for writing custom form validators.
        correct: false
    help: The `ValidatorExtension` is crucial for testing form types that rely on
      Symfony's validation component.
  - question: When writing unit tests for a class that uses time-sensitive functions
      (e.g., `time()`, `sleep()`), how can you explicitly register `ClockMock`
      for that external class?
    answers:
      - value: "`ClockMock::register(MyClass::class);`"
        correct: true
      - value: "`ClockMock::mock(MyClass::class);`"
        correct: false
      - value: "`MyClass::enableClockMock();`"
        correct: false
      - value: "`$this->mockTime(MyClass::class);`"
        correct: false
    help: The `ClockMock::register()` method allows you to explicitly register
      classes for time mocking, ensuring consistent test results for
      dependencies.
  - question: Which assertion is used to check if a specific email header exists in
      a `RawMessage` object?
    answers:
      - value: "`assertEmailHasHeader(RawMessage $email, string $headerName, string
          $message = '')`"
        correct: true
      - value: "`assertEmailHeaderExists(RawMessage $email, string $headerName, string
          $message = '')`"
        correct: false
      - value: "`assertEmailContainsHeader(RawMessage $email, string $headerName, string
          $message = '')`"
        correct: false
      - value: "`assertEmailHeaderPresent(RawMessage $email, string $headerName, string
          $message = '')`"
        correct: false
    help: The `assertEmailHasHeader` assertion verifies the presence of a specific
      header in an email message.
  - question: What is the primary benefit of using `KernelTestCase` for testing
      services that interact with the Symfony container?
    answers:
      - value: It allows direct access to the service container and real services,
          enabling integration tests.
        correct: true
      - value: It provides a fully isolated environment without booting the kernel.
        correct: false
      - value: It automatically mocks all services for unit testing.
        correct: false
      - value: It is only suitable for testing controllers.
        correct: false
    help: "`KernelTestCase` is designed for integration tests where you need to
      interact with the actual Symfony container and its services."
  - question: How can you assert that the text body of an email does NOT contain a
      specific string?
    answers:
      - value: "`assertEmailTextBodyNotContains(RawMessage $email, string $text, string
          $message = '')`"
        correct: true
      - value: "`assertEmailTextBodyExcludes(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertEmailBodyDoesNotContain(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertEmailNotContainsText(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
    help: The `assertEmailTextBodyNotContains` assertion is used to verify the
      absence of text in the email's plain text body.
  - question: Which assertion is used to check if a specific URL has been called by
      the HTTP client during a test?
    answers:
      - value: "`assertHttpClientRequest(string $expectedUrl, string $expectedMethod =
          'GET', string|array|null $expectedBody = null, array $expectedHeaders
          = [], string $httpClientId = 'http_client')`"
        correct: true
      - value: "`assertHttpRequestMade(string $expectedUrl, string $expectedMethod =
          'GET', string $httpClientId = 'http_client')`"
        correct: false
      - value: "`assertClientCalled(string $expectedUrl, string $expectedMethod = 'GET',
          string $httpClientId = 'http_client')`"
        correct: false
      - value: "`assertUrlRequested(string $expectedUrl, string $expectedMethod = 'GET',
          string $httpClientId = 'http_client')`"
        correct: false
    help: The `assertHttpClientRequest` assertion verifies that a specific URL was
      requested by the HTTP client. Remember to enable the profiler first.
  - question: What is the purpose of the `PHPUnit / Tests (high-deps)` job in
      Symfony's continuous integration?
    answers:
      - value: It checks individual packages by running `composer update` and `phpunit`
          inside each, including 'flipped' tests for backward compatibility.
        correct: true
      - value: It runs the main test suite on Ubuntu across multiple PHP versions.
        correct: false
      - value: It checks individual packages using `composer update --prefer-lowest`
          before running tests.
        correct: false
      - value: It runs tests that require external services.
        correct: false
    help: The `high-deps` job specifically tests with the latest possible
      dependencies and includes backward compatibility checks.
  - question: How can you manually clear the Symfony cache in the test environment
      programmatically?
    answers:
      - value: "` (new
          \\Symfony\\Component\\Filesystem\\Filesystem())->remove(__DIR__.'/../\
          var/cache/test');`"
        correct: true
      - value: "`self::bootKernel(['environment' => 'test', 'debug' => false]);
          self::getContainer()->get('cache.app')->clear();`"
        correct: false
      - value: "`php bin/console cache:clear --env=test`"
        correct: false
      - value: "`$client->clearCache();`"
        correct: false
    help: Manually removing the cache directory for the test environment ensures a
      fresh cache state, especially when debug mode is disabled.
  - question: Which of the following is the correct way to click a link by its text
      using the Symfony test client?
    answers:
      - value: "`$client->clickLink('Click here');`"
        correct: true
      - value: "`$client->click('Click here');`"
        correct: false
      - value: "`$crawler->selectLink('Click here')->click();`"
        correct: false
      - value: "`$client->findLink('Click here')->click();`"
        correct: false
    help: The `clickLink()` method on the client directly allows clicking a link
      based on its visible text.
  - question: What is the purpose of `Symfony\Bridge\Twig\Test\FormLayoutTestCase`?
    answers:
      - value: It is a base class for testing form themes with Twig.
        correct: true
      - value: It is used for unit testing individual Twig extensions.
        correct: false
      - value: It provides assertions for Twig template rendering.
        correct: false
      - value: It is a base class for integration testing of Twig forms.
        correct: false
    help: "`FormLayoutTestCase` extends `FormIntegrationTestCase` and adds specific
      methods for testing Twig-based form themes."
  - question: When unit testing a class that depends on Doctrine's `EntityManager`
      and its repositories, how should you typically handle these dependencies
      to isolate the class under test?
    answers:
      - value: Mock both the `EntityRepository` and the `EntityManager` to control their
          behavior.
        correct: true
      - value: Use a real in-memory SQLite database for all unit tests.
        correct: false
      - value: Inject a dummy `EntityManager` that does nothing.
        correct: false
      - value: Avoid unit testing classes with Doctrine dependencies; only functional
          test them.
        correct: false
    help: For true unit testing, dependencies like `EntityManager` and
      `EntityRepository` should be mocked to prevent actual database interaction
      and isolate the class being tested.
  - question: Which assertion is used to check if the subject of an email contains a
      specific string?
    answers:
      - value: "`assertEmailSubjectContains(RawMessage $email, string $expectedValue,
          string $message = '')`"
        correct: true
      - value: "`assertEmailSubjectSame(RawMessage $email, string $expectedValue, string
          $message = '')`"
        correct: false
      - value: "`assertEmailHeaderSame(RawMessage $email, 'Subject', string
          $expectedValue, string $message = '')`"
        correct: false
      - value: "`assertEmailSubjectMatches(RawMessage $email, string $expectedValue,
          string $message = '')`"
        correct: false
    help: The `assertEmailSubjectContains` assertion specifically targets the
      subject line of an email.
  - question: What is the purpose of the `PHPUnit / Tests (low-deps)` job in
      Symfony's continuous integration?
    answers:
      - value: It checks individual packages using `composer update --prefer-lowest`
          before running tests.
        correct: true
      - value: It runs tests that require external services.
        correct: false
      - value: It runs the main test suite on Ubuntu across multiple PHP versions.
        correct: false
      - value: It checks individual packages by running `composer update` and `phpunit`
          inside each.
        correct: false
    help: The `low-deps` job ensures compatibility with the lowest supported
      versions of dependencies by using `composer update --prefer-lowest`.
  - question: Which assertion verifies that the first element matching a given CSS
      selector contains a specific text?
    answers:
      - value: "`assertSelectorTextContains(string $selector, string $text, string
          $message = '')`"
        correct: true
      - value: "`assertAnySelectorTextContains(string $selector, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertElementTextContains(string $selector, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertTextContains(string $selector, string $text, string $message =
          '')`"
        correct: false
    help: "`assertSelectorTextContains` checks the text content of the *first*
      element found by the selector."
  - question: What is the primary role of
      `Symfony\Component\BrowserKit\AbstractBrowser::xmlHttpRequest()`?
    answers:
      - value: To make AJAX requests, automatically adding the `HTTP_X_REQUESTED_WITH`
          header.
        correct: true
      - value: To send XML-RPC requests to a server.
        correct: false
      - value: To parse XML responses from a server.
        correct: false
      - value: To simulate a browser's XMLHttpRequest object directly.
        correct: false
    help: This method simplifies testing AJAX interactions by handling the necessary
      request headers.
  - question: How can you assert that a specific request attribute has an expected value?
    answers:
      - value: "`assertRequestAttributeValueSame(string $name, string $expectedValue,
          string $message = '')`"
        correct: true
      - value: "`assertRequestAttributeEquals(string $name, string $expectedValue,
          string $message = '')`"
        correct: false
      - value: "`assertAttributeSame(string $name, string $expectedValue, string
          $message = '')`"
        correct: false
      - value: "`assertRequestHasAttribute(string $name, string $expectedValue, string
          $message = '')`"
        correct: false
    help: The `assertRequestAttributeValueSame` assertion is used to check the value
      of a specific attribute on the request object.
  - question: Which assertion is used to check the total number of emails sent
      during a test?
    answers:
      - value: "`assertEmailCount(int $count, ?string $transport = null, string $message
          = '')`"
        correct: true
      - value: "`assertEmailsSent(int $count, ?string $transport = null, string $message
          = '')`"
        correct: false
      - value: "`assertMailerCount(int $count, ?string $transport = null, string
          $message = '')`"
        correct: false
      - value: "`assertSentEmailCount(int $count, ?string $transport = null, string
          $message = '')`"
        correct: false
    help: The `assertEmailCount` assertion is part of Symfony's Mailer assertions
      for testing email sending behavior.
  - question: What is the purpose of the `PHPUnit / Tests (experimental)` job in
      Symfony's continuous integration?
    answers:
      - value: It is used by the core team to prepare for upcoming PHP versions and
          always passes, even with failing tests.
        correct: true
      - value: It runs tests that are still under development and might be unstable.
        correct: false
      - value: It runs tests with experimental features of Symfony.
        correct: false
      - value: It is a deprecated job that will be removed soon.
        correct: false
    help: The `experimental` job is a special CI job for internal use by the Symfony
      core team to test compatibility with future PHP versions without blocking
      pull requests.
  - question: How can you assert that any element matching a given CSS selector
      contains a specific text?
    answers:
      - value: "`assertAnySelectorTextContains(string $selector, string $text, string
          $message = '')`"
        correct: true
      - value: "`assertSelectorTextContains(string $selector, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertContainsInSelector(string $selector, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertTextInAnySelector(string $selector, string $text, string $message
          = '')`"
        correct: false
    help: Unlike `assertSelectorTextContains` which checks only the first match,
      `assertAnySelectorTextContains` checks if *any* element matching the
      selector contains the text.
  - question: Which command is used to load all Doctrine fixture classes, emptying
      the database first, typically in a test environment?
    answers:
      - value: "`php bin/console --env=test doctrine:fixtures:load`"
        correct: true
      - value: "`php bin/console doctrine:schema:update --force --env=test`"
        correct: false
      - value: "`php bin/console doctrine:database:drop --force --env=test && php
          bin/console doctrine:database:create --env=test`"
        correct: false
      - value: "`php bin/console doctrine:data:load --env=test`"
        correct: false
    help: The `doctrine:fixtures:load` command is used to populate the database with
      dummy data for testing, and by default, it purges existing data.
  - question: What is the purpose of `Symfony\Component\Form\PreloadedExtension` in
      form testing?
    answers:
      - value: To register preloaded form type instances with the FormRegistry.
        correct: true
      - value: To define custom form extensions for testing.
        correct: false
      - value: To load form data from a predefined set of values.
        correct: false
      - value: To enable form caching during tests.
        correct: false
    help: "`PreloadedExtension` is essential when you need to provide specific
      instances of form types or extensions to the form factory during testing,
      especially for service-based form types."
  - question: Which of the following is a valid way to run tests for a specific
      Symfony component, e.g., the Finder component?
    answers:
      - value: "`php ./phpunit src/Symfony/Component/Finder/`"
        correct: true
      - value: "`php bin/phpunit Symfony/Component/Finder/`"
        correct: false
      - value: "`php ./phpunit --component=Finder`"
        correct: false
      - value: "`php bin/console test:component Finder`"
        correct: false
    help: You can specify the path to the component's test directory when running
      `phpunit` from the Symfony root.
  - question: What is the primary function of
      `Symfony\Component\Form\Test\FormIntegrationTestCase`?
    answers:
      - value: It is a base class for integration testing of Symfony forms.
        correct: true
      - value: It is used for unit testing individual form fields.
        correct: false
      - value: It provides methods for testing form submission with real data.
        correct: false
      - value: It is a base class for end-to-end testing of forms.
        correct: false
    help: "`FormIntegrationTestCase` provides a more comprehensive testing
      environment for forms, allowing for testing with extensions and guessers."
  - question: Which assertion is used to check if a specific email has a certain
      number of attachments?
    answers:
      - value: "`assertEmailAttachmentCount(RawMessage $email, int $count, string
          $message = '')`"
        correct: true
      - value: "`assertEmailHasAttachments(RawMessage $email, int $count, string
          $message = '')`"
        correct: false
      - value: "`assertAttachmentCount(RawMessage $email, int $count, string $message =
          '')`"
        correct: false
      - value: "`assertEmailAttachments(RawMessage $email, int $count, string $message =
          '')`"
        correct: false
    help: The `assertEmailAttachmentCount` assertion verifies the number of
      attachments in a given email message.
  - question: What is the purpose of the `continuous-integration/appveyor/pr` job in
      Symfony's CI?
    answers:
      - value: It runs tests on Windows using x86 architecture and the lowest supported
          PHP version.
        correct: true
      - value: It runs tests on macOS with the latest PHP version.
        correct: false
      - value: It performs security vulnerability checks on the code.
        correct: false
      - value: It deploys the application to a staging environment.
        correct: false
    help: This job specifically targets Windows environments and minimal PHP
      configurations to ensure broad compatibility.
  - question: When writing a PHPUnit test for a Symfony application, what is the
      typical location for test files?
    answers:
      - value: In the `tests/` directory.
        correct: true
      - value: In the `src/Tests/` directory.
        correct: false
      - value: In the `var/tests/` directory.
        correct: false
      - value: In the `app/Tests/` directory.
        correct: false
    help: Symfony applications typically place their test files in the `tests/`
      directory at the project root.
  - question: Which of the following is a valid way to run PHPUnit tests for a
      specific directory, e.g., `tests/Form`?
    answers:
      - value: "`php bin/phpunit tests/Form`"
        correct: true
      - value: "`php bin/phpunit --dir=tests/Form`"
        correct: false
      - value: "`php bin/phpunit --path=tests/Form`"
        correct: false
      - value: "`php bin/console test:run tests/Form`"
        correct: false
    help: PHPUnit allows specifying a directory path to run tests only within that
      directory.
  - question: What is the purpose of the `bootstrap="vendor/autoload.php"` attribute
      in `phpunit.xml.dist`?
    answers:
      - value: It specifies the autoloader to be used by PHPUnit for loading test
          classes and application code.
        correct: true
      - value: It defines the entry point for the test application.
        correct: false
      - value: It includes a script to set up the test environment.
        correct: false
      - value: It configures the test database connection.
        correct: false
    help: The `bootstrap` attribute in `phpunit.xml.dist` tells PHPUnit which file
      to include before running tests, typically Composer's autoloader.
  - question: Which of the following is a valid way to run tests for a single test
      file, e.g., `tests/Form/UserTypeTest.php`?
    answers:
      - value: "`php bin/phpunit tests/Form/UserTypeTest.php`"
        correct: true
      - value: "`php bin/phpunit --file=tests/Form/UserTypeTest.php`"
        correct: false
      - value: "`php bin/phpunit UserTypeTest.php`"
        correct: false
      - value: "`php bin/console test:file tests/Form/UserTypeTest.php`"
        correct: false
    help: You can specify the exact path to a test file to run only the tests within
      that file.
  - question: What is the purpose of the `assertResponseIsSuccessful()` assertion in
      a functional test?
    answers:
      - value: To assert that the HTTP response status code is 2xx (successful).
        correct: true
      - value: To assert that the HTTP response status code is exactly 200 OK.
        correct: false
      - value: To assert that the response contains no errors.
        correct: false
      - value: To assert that the request was processed without exceptions.
        correct: false
    help: "`assertResponseIsSuccessful()` checks for any 2xx status code, indicating
      a successful HTTP response."
  - question: How can you assert that the number of queued emails is a specific count?
    answers:
      - value: "`assertQueuedEmailCount(int $count, ?string $transport = null, string
          $message = '')`"
        correct: true
      - value: "`assertEmailQueuedCount(int $count, ?string $transport = null, string
          $message = '')`"
        correct: false
      - value: "`assertEmailsQueued(int $count, ?string $transport = null, string
          $message = '')`"
        correct: false
      - value: "`assertMessengerEmailCount(int $count, ?string $transport = null, string
          $message = '')`"
        correct: false
    help: The `assertQueuedEmailCount` assertion is used to verify the number of
      emails that have been queued, typically via the Messenger component.
  - question: Which assertion is used to verify that the value of a field within the
      first form matching a given selector does NOT equal an expected value?
    answers:
      - value: "`assertNoFormValue(string $formSelector, string $fieldName, string
          $message = '')`"
        correct: true
      - value: "`assertFormValueNotSame(string $formSelector, string $fieldName, string
          $value, string $message = '')`"
        correct: false
      - value: "`assertFormValueNotEquals(string $formSelector, string $fieldName,
          string $value, string $message = '')`"
        correct: false
      - value: "`assertFormNotContainsValue(string $formSelector, string $fieldName,
          string $value, string $message = '')`"
        correct: false
    help: "`assertNoFormValue` checks that a specific form field does not have a
      given value. Note that `assertFormValue` is for positive checks."
  - question: What is the purpose of the `Integration / Tests` job in Symfony's
      continuous integration?
    answers:
      - value: It runs tests that require external services (e.g., Redis, RabbitMQ) by
          executing the `integration` PHPUnit group.
        correct: true
      - value: It performs tests on the integration of different Symfony components.
        correct: false
      - value: It runs tests for the application's API integrations.
        correct: false
      - value: It checks for integration issues with third-party bundles.
        correct: false
    help: The `Integration / Tests` job is specifically for tests that depend on
      external infrastructure or services.
  - question: When configuring `CoverageListener` in `phpunit.xml.dist`, what is the
      purpose of providing a custom SUT (System Under Test) solver as an
      argument?
    answers:
      - value: To customize the logic used by the listener to determine the code related
          to a given test.
        correct: true
      - value: To define which tests should be included in the code coverage report.
        correct: false
      - value: To specify the output format for the code coverage report.
        correct: false
      - value: To enable code coverage for external libraries.
        correct: false
    help: A custom SUT solver allows you to override the default behavior of
      `CoverageListener` in identifying the code under test, which is useful for
      complex project structures.
  - question: Which of the following describes the
      `Symfony\Component\Form\Extension\Core\CoreExtension`?
    answers:
      - value: The default core form extension, automatically registered in
          `TypeTestCase`.
        correct: true
      - value: A custom extension for adding core functionality to forms.
        correct: false
      - value: An extension for integrating third-party form libraries.
        correct: false
      - value: An extension that provides advanced form validation rules.
        correct: false
    help: The `CoreExtension` provides the fundamental form types and
      functionalities and is always present in `TypeTestCase`.
  - question: What is the purpose of
      `Symfony\Component\OptionsResolver\Exception\InvalidOptionsException` in
      the context of form testing?
    answers:
      - value: An exception thrown when an invalid option is passed to a form type or
          extension, often due to missing extensions.
        correct: true
      - value: An exception indicating that a required form option is missing.
        correct: false
      - value: An exception thrown when a form's data is invalid.
        correct: false
      - value: An exception indicating a problem with the form's data transformers.
        correct: false
    help: This exception helps diagnose issues where form types are configured with
      options they don't support, often a symptom of a missing form extension.
  - question: Which command would you use to generate a code coverage report
      directly to the console?
    answers:
      - value: "`./vendor/bin/phpunit --coverage-text`"
        correct: true
      - value: "`./vendor/bin/phpunit --coverage-console`"
        correct: false
      - value: "`./vendor/bin/phpunit --text-coverage`"
        correct: false
      - value: "`./vendor/bin/phpunit --report-text`"
        correct: false
    help: The `--coverage-text` option outputs a summary of code coverage directly
      to the terminal.
  - question: What is the primary purpose of `Symfony\Component\Form\PreloadedExtension`?
    answers:
      - value: Registers preloaded form type instances with the FormRegistry.
        correct: true
      - value: Allows for dynamic loading of form types based on configuration.
        correct: false
      - value: Provides a way to mock form type dependencies.
        correct: false
      - value: Enables lazy loading of form types to improve performance.
        correct: false
    help: This extension is crucial for unit testing form types that are defined as
      services and have dependencies, allowing you to inject mocked instances.
  - question: When testing a form type, how can you verify custom view variables
      that are passed to the form's template?
    answers:
      - value: By creating a form view and asserting against
          `$view->vars['custom_var']`.
        correct: true
      - value: By inspecting the form's configuration options.
        correct: false
      - value: By using `assertFormViewVarSame()`.
        correct: false
      - value: By checking the form's data object.
        correct: false
    help: The `createView()` method on a form returns a `FormView` object, which
      contains the variables passed to the template in its `vars` property.
  - question: Which of the following is a key purpose of the `PHPUnit / Tests` job
      in Symfony's CI?
    answers:
      - value: Runs the main test suite on Ubuntu across multiple PHP versions.
        correct: true
      - value: Checks individual packages by running `composer update`.
        correct: false
      - value: Runs tests that require external services.
        correct: false
      - value: Prepares for upcoming PHP versions.
        correct: false
    help: The `PHPUnit / Tests` job is the core test suite execution, covering
      various PHP versions on Ubuntu.
  - question: Which assertion is used to check if the value of a form input with the
      given name does NOT equal the expected value?
    answers:
      - value: "`assertInputValueNotSame(string $fieldName, string $expectedValue,
          string $message = '')`"
        correct: true
      - value: "`assertInputValueNotEquals(string $fieldName, string $expectedValue,
          string $message = '')`"
        correct: false
      - value: "`assertNoInputValue(string $fieldName, string $expectedValue, string
          $message = '')`"
        correct: false
      - value: "`assertInputNotSame(string $fieldName, string $expectedValue, string
          $message = '')`"
        correct: false
    help: The `assertInputValueNotSame` assertion is the correct way to verify that
      an input field's value is different from an expected value.
  - question: What is the purpose of
      `Symfony\Component\Validator\Validation::createValidatorBuilder()`?
    answers:
      - value: To create a builder for more complex validator configurations.
        correct: true
      - value: To create a basic validator instance directly.
        correct: false
      - value: To register custom validation constraints.
        correct: false
      - value: To enable validation for a specific form type.
        correct: false
    help: The `ValidatorBuilder` allows for more granular control over validator
      creation, such as enabling attribute mapping.
  - question: How can you assert that a checkbox with a given name is NOT checked?
    answers:
      - value: "`assertCheckboxNotChecked(string $fieldName, string $message = '')`"
        correct: true
      - value: "`assertCheckboxUnchecked(string $fieldName, string $message = '')`"
        correct: false
      - value: "`assertInputNotChecked(string $fieldName, string $message = '')`"
        correct: false
      - value: "`assertNotChecked(string $fieldName, string $message = '')`"
        correct: false
    help: The `assertCheckboxNotChecked` assertion is used to verify that a checkbox
      input field is not in a checked state.
  - question: What is the purpose of the `assertEmailIsQueued` assertion?
    answers:
      - value: Asserts that the given mailer event is queued (e.g., using the Messenger
          component).
        correct: true
      - value: Asserts that an email has been successfully sent.
        correct: false
      - value: Asserts that an email is ready to be sent.
        correct: false
      - value: Asserts that an email has been consumed from the queue.
        correct: false
    help: This assertion is specifically for verifying that an email dispatch event
      has been placed into a queue, typically when using Symfony Messenger for
      async mail.
  - question: Which of the following is the correct way to configure Composer's
      `autoload-dev` to include application-specific test directories like
      `apps/api/tests/`?
    answers:
      - value: |-
          ```json
          {
              "autoload-dev": {
                  "psr-4": {
                      "Api\\Tests\\": "apps/api/tests/"
                  }
              }
          }
          ```
        correct: true
      - value: |-
          ```json
          {
              "autoload": {
                  "psr-4": {
                      "Api\\Tests\\": "apps/api/tests/"
                  }
              }
          }
          ```
        correct: false
      - value: |-
          ```json
          {
              "test-autoload": {
                  "psr-4": {
                      "Api\\Tests\\": "apps/api/tests/"
                  }
              }
          }
          ```
        correct: false
      - value: |-
          ```json
          {
              "require-dev": {
                  "autoload": {
                      "Api\\Tests\\": "apps/api/tests/"
                  }
              }
          }
          ```
        correct: false
    help: The `autoload-dev` section in `composer.json` is used for
      development-specific autoloading, including test directories.
  - question: What is the purpose of
      `Symfony\Component\Form\Test\FormIntegrationTestCase::getTypes()`?
    answers:
      - value: Returns a list of custom form types to register for the test.
        correct: true
      - value: Returns a list of all form types available in the application.
        correct: false
      - value: Returns the data types expected by the form.
        correct: false
      - value: Returns the form types that are currently being tested.
        correct: false
    help: This method allows you to provide custom form types that should be
      available to the form factory during integration tests.
  - question: Which assertion is used to check if an email's subject does NOT
      contain a specific value?
    answers:
      - value: "`assertEmailSubjectNotContains(RawMessage $email, string $expectedValue,
          string $message = '')`"
        correct: true
      - value: "`assertEmailSubjectExcludes(RawMessage $email, string $expectedValue,
          string $message = '')`"
        correct: false
      - value: "`assertEmailSubjectDoesNotContain(RawMessage $email, string
          $expectedValue, string $message = '')`"
        correct: false
      - value: "`assertEmailNotSubjectContains(RawMessage $email, string $expectedValue,
          string $message = '')`"
        correct: false
    help: The `assertEmailSubjectNotContains` assertion is used to verify that the
      subject of an email does not include a particular string.
  - question: What is the purpose of
      `Symfony\Component\Form\Test\TypeTestCase::getExtensions()`?
    answers:
      - value: Returns a list of form extensions to register for the test.
        correct: true
      - value: Returns all available form extensions in the application.
        correct: false
      - value: Returns the file extensions supported by form types.
        correct: false
      - value: Returns the Twig extensions used for form rendering.
        correct: false
    help: This method allows you to add custom form extensions, such as
      `ValidatorExtension` or `PreloadedExtension`, to the test environment.
  - question: Which assertion is used to verify that a specific HTTP client request
      has NOT been made?
    answers:
      - value: "`assertNotHttpClientRequest(string $unexpectedUrl, string
          $expectedMethod = 'GET', string $httpClientId = 'http_client')`"
        correct: true
      - value: "`assertHttpClientRequestNotMade(string $unexpectedUrl, string
          $expectedMethod = 'GET', string $httpClientId = 'http_client')`"
        correct: false
      - value: "`assertNoHttpClientRequest(string $unexpectedUrl, string $expectedMethod
          = 'GET', string $httpClientId = 'http_client')`"
        correct: false
      - value: "`assertHttpClientRequestAbsent(string $unexpectedUrl, string
          $expectedMethod = 'GET', string $httpClientId = 'http_client')`"
        correct: false
    help: The `assertNotHttpClientRequest` assertion is used to confirm that a
      particular HTTP request was not initiated by the client during the test.
  - question: What is the purpose of
      `Symfony\Component\Form\Test\FormIntegrationTestCase::getTypeExtensions()`?
    answers:
      - value: Returns a list of custom form type extensions to register.
        correct: true
      - value: Returns all available form type extensions.
        correct: false
      - value: Returns the extensions of the form type being tested.
        correct: false
      - value: Returns the file extensions associated with form types.
        correct: false
    help: This method allows you to register custom form type extensions that modify
      the behavior of existing form types.
  - question: Which assertion is used to verify that the HTML body of an email does
      NOT contain a specific text string?
    answers:
      - value: "`assertEmailHtmlBodyNotContains(RawMessage $email, string $text, string
          $message = '')`"
        correct: true
      - value: "`assertEmailHtmlBodyExcludes(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertEmailHtmlDoesNotContain(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
      - value: "`assertEmailNotHtmlContains(RawMessage $email, string $text, string
          $message = '')`"
        correct: false
    help: The `assertEmailHtmlBodyNotContains` assertion is used to confirm the
      absence of specific text within the HTML content of an email.
  - question: What is the purpose of
      `Symfony\Component\Form\Test\FormIntegrationTestCase::getTypeGuessers()`?
    answers:
      - value: Returns a list of custom type guessers to register.
        correct: true
      - value: Returns all available type guessers.
        correct: false
      - value: Returns the guessed type of a form field.
        correct: false
      - value: Returns the type guessers used for validation.
        correct: false
    help: This method allows you to register custom type guessers that help Symfony
      determine the appropriate form type for a given property based on its
      metadata.
  - question: Which assertion is used to verify that an email does NOT have a
      specific header set?
    answers:
      - value: "`assertEmailNotHasHeader(RawMessage $email, string $headerName, string
          $message = '')`"
        correct: true
      - value: "`assertEmailHeaderNotExists(RawMessage $email, string $headerName,
          string $message = '')`"
        correct: false
      - value: "`assertEmailDoesNotHaveHeader(RawMessage $email, string $headerName,
          string $message = '')`"
        correct: false
      - value: "`assertEmailHeaderAbsent(RawMessage $email, string $headerName, string
          $message = '')`"
        correct: false
    help: The `assertEmailNotHasHeader` assertion is used to confirm that a
      particular header is not present in an email message.
  - question: What is the purpose of
      `Symfony\Bridge\Twig\Test\FormLayoutTestCase::getTemplatePaths()`?
    answers:
      - value: Returns an array of paths where Twig templates for form themes are
          located.
        correct: true
      - value: Returns the path to the main Twig layout file.
        correct: false
      - value: Returns the paths to Twig cache directories.
        correct: false
      - value: Returns the paths to Twig extensions.
        correct: false
    help: This method is used in form layout testing to tell Twig where to find the
      form theme templates.
  - question: Which assertion is used to verify that a specific email header is NOT
      set to an expected value?
    answers:
      - value: "`assertEmailHeaderNotSame(RawMessage $email, string $headerName, string
          $expectedValue, string $message = '')`"
        correct: true
      - value: "`assertEmailHeaderDoesNotMatch(RawMessage $email, string $headerName,
          string $expectedValue, string $message = '')`"
        correct: false
      - value: "`assertEmailHeaderNotEquals(RawMessage $email, string $headerName,
          string $expectedValue, string $message = '')`"
        correct: false
      - value: "`assertEmailHeaderDifferent(RawMessage $email, string $headerName,
          string $expectedValue, string $message = '')`"
        correct: false
    help: The `assertEmailHeaderNotSame` assertion is used to confirm that a
      specific email header's value is not identical to the expected value.
  - question: What is the purpose of
      `Symfony\Bridge\Twig\Test\FormLayoutTestCase::getTwigExtensions()`?
    answers:
      - value: Returns an array of Twig extensions to register for the test environment.
        correct: true
      - value: Returns all available Twig extensions.
        correct: false
      - value: Returns the Twig extensions used for form rendering.
        correct: false
      - value: Returns the Twig extensions that are currently enabled.
        correct: false
    help: This method allows you to register any custom Twig extensions required for
      testing your form themes.
  - question: Which assertion is used to verify that a given address header in an
      email equals the expected e-mail address, normalizing formats like 'Jane
      Smith <jane@example.com>'?
    answers:
      - value: "`assertEmailAddressContains(RawMessage $email, string $headerName,
          string $expectedValue, string $message = '')`"
        correct: true
      - value: "`assertEmailAddressSame(RawMessage $email, string $headerName, string
          $expectedValue, string $message = '')`"
        correct: false
      - value: "`assertEmailHeaderAddressSame(RawMessage $email, string $headerName,
          string $expectedValue, string $message = '')`"
        correct: false
      - value: "`assertEmailRecipientSame(RawMessage $email, string $headerName, string
          $expectedValue, string $message = '')`"
        correct: false
    help: The `assertEmailAddressContains` assertion is specifically designed to
      normalize and compare email addresses in headers.
  - question: What is the purpose of
      `Symfony\Bridge\Twig\Test\FormLayoutTestCase::getThemes()`?
    answers:
      - value: Returns an array of form themes to apply during the test.
        correct: true
      - value: Returns all available form themes.
        correct: false
      - value: Returns the default form themes.
        correct: false
      - value: Returns the Twig themes used for rendering.
        correct: false
    help: This method allows you to specify which form themes should be applied when
      testing form layouts.
