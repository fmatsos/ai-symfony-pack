category: Automated Tests

questions:
  -
    question: >
      Which PHPUnit test class is typically used for unit testing individual components or services in isolation, without booting the full Symfony kernel?
    answers:
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`
        correct: false
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: true
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Panther\\PantherTestCase`
        correct: false
    help: |
      `PHPUnit\\Framework\\TestCase` is the standard base class for unit tests, allowing you to test code in isolation, often with mocked dependencies.
      https://symfony.com/doc/current/create_framework/unit_testing.html

  -
    question: |
      Given the following PHPUnit test for a `SalaryCalculator` service, what is the primary purpose of mocking `EntityManager` and `EntityRepository`?

      ```php
      // tests/Salary/SalaryCalculatorTest.php
      namespace App\\Tests\\Salary;

      use App\\Entity\\Employee;
      use App\\Salary\\SalaryCalculator;
      use Doctrine\\ORM\\EntityManager;
      use Doctrine\\ORM\\EntityRepository;
      use PHPUnit\\Framework\\TestCase;

      class SalaryCalculatorTest extends TestCase
      {
          public function testCalculateTotalSalary(): void
          {
              $employee = new Employee();
              $employee->setSalary(1000);
              $employee->setBonus(1100);

              $employeeRepository = $this->createMock(EntityRepository::class);
              $employeeRepository->expects($this->any())
                  ->method('find')
                  ->willReturn($employee);

              $entityManager = $this->createMock(EntityManager::class);
              $entityManager->expects($this->any())
                  ->method('getRepository')
                  ->willReturn($employeeRepository);

              $salaryCalculator = new SalaryCalculator($entityManager);
              $this->assertEquals(2100, $salaryCalculator->calculateTotalSalary(1));
          }
      }
      ```
    answers:
      -
        value: >
          To ensure the test interacts with a real database for accurate results.
        correct: false
      -
        value: >
          To test the `EntityManager` and `EntityRepository` classes themselves.
        correct: false
      -
        value: >
          To isolate the `SalaryCalculator` logic from database interactions, making it a true unit test.
        correct: true
      -
        value: >
          To speed up the test by bypassing the Symfony kernel boot process.
        correct: true
    help: |
      Mocking dependencies like `EntityManager` and `EntityRepository` in unit tests allows you to test the `SalaryCalculator` in isolation, without needing a real database connection or booting the full Symfony kernel. This makes the test faster and more focused on the unit's logic.
      https://symfony.com/doc/current/testing/database.html#unit-tests

  -
    question: >
      Which command is used to run all PHPUnit tests in a Symfony application?
    answers:
      -
        value: >
          `php bin/console test:run`
        correct: false
      -
        value: >
          `php bin/phpunit`
        correct: true
      -
        value: >
          `composer run-tests`
        correct: false
      -
        value: >
          `symfony run-tests`
        correct: false
    help: |
      The `php bin/phpunit` command, when executed from the project root, will run all tests configured in `phpunit.xml.dist`.
      https://symfony.com/doc/current/testing.html#running-tests

  -
    question: >
      Which Symfony test class should you extend for functional tests that require booting the Symfony kernel and interacting with the application as a whole, including making HTTP requests?
    answers:
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`
        correct: true
      -
        value: >
          `Symfony\\Component\\Panther\\PantherTestCase`
        correct: false
    help: |
      `WebTestCase` is the recommended base class for functional tests in Symfony, as it provides methods to create a test client and interact with the application's HTTP layer.
      https://symfony.com/doc/current/testing.html#functional-tests

  -
    question: >
      What is the purpose of the `static::createClient()` method in a `WebTestCase`?
    answers:
      -
        value: >
          To create a new instance of the Symfony kernel.
        correct: false
      -
        value: >
          To create a test browser client that acts like a real browser, allowing you to make HTTP requests.
        correct: true
      -
        value: >
          To establish a direct database connection for testing.
        correct: false
      -
        value: >
          To generate a unique test user for authentication.
        correct: false
    help: |
      `static::createClient()` initializes a `KernelBrowser` (the test client) that simulates HTTP requests to your application, allowing you to test controllers and the full request-response cycle.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      After making a request with `$client->request('GET', '/some-url');`, which object is returned that allows you to traverse the HTML document and make assertions on its content?
    answers:
      -
        value: >
          `Symfony\\Component\\HttpFoundation\\Response`
        correct: false
      -
        value: >
          `Symfony\\Component\\BrowserKit\\Response`
        correct: false
      -
        value: >
          `Symfony\\Component\\DomCrawler\\Crawler`
        correct: true
      -
        value: >
          `Symfony\\Component\\HttpFoundation\\Request`
        correct: false
    help: |
      The `request()` method of the test client returns a `Crawler` object, which is used to select HTML elements and extract data from the response.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      Which of the following assertions can be used with the Symfony test client's response to check if the HTTP status code is in the 2xx range?
    answers:
      -
        value: >
          `$this->assertResponseStatusCode(200);`
        correct: false
      -
        value: >
          `$this->assertResponseIsSuccessful();`
        correct: true
      -
        value: >
          `$this->assertStatusCodeIsSuccessful();`
        correct: false
      -
        value: >
          `$this->assertResponseCode(2xx);`
        correct: false
    help: |
      The `assertResponseIsSuccessful()` method checks if the HTTP response status code is between 200 and 299 (inclusive).
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      To access services from the Dependency Injection Container within a `KernelTestCase` or `WebTestCase`, which static method should you use after booting the kernel?
    answers:
      -
        value: >
          `$this->getContainer()`
        correct: false
      -
        value: >
          `static::getContainer()`
        correct: true
      -
        value: >
          `$this->container()`
        correct: false
      -
        value: >
          `self::get('service_id')`
        correct: false
    help: |
      After calling `self::bootKernel()`, you can access the service container using `static::getContainer()` to retrieve services for testing.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      You want to simulate a logged-in user for a functional test without going through the login form. Which method of the test client allows you to achieve this?
    answers:
      -
        value: >
          `$client->setLoggedInUser($user);`
        correct: false
      -
        value: >
          `$client->authenticate($user);`
        correct: false
      -
        value: >
          `$client->loginUser($user);`
        correct: true
      -
        value: >
          `$client->setUser($user);`
        correct: false
    help: |
      The `loginUser()` method on the test client allows you to simulate a user being logged in for the current request, bypassing the need to submit a login form.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      By default, the Symfony Profiler is disabled in the `test` environment to speed up tests. How can you enable it for a specific functional test to inspect collected data?
    answers:
      -
        value: >
          Set `framework.profiler.enabled: true` in `config/packages/test/framework.yaml`.
        correct: false
      -
        value: >
          Call `$client->enableProfiler();` before making the request.
        correct: true
      -
        value: >
          Add `#[EnableProfiler]` attribute to the test method.
        correct: false
      -
        value: >
          Set `APP_ENV=dev` for the test run.
        correct: false
    help: |
      While the profiler is enabled in the `test` environment (with `collect: false`), you need to call `$client->enableProfiler()` before a request to collect data for that specific request.
      https://symfony.com/doc/current/testing.html#the-profiler

  -
    question: >
      What is the primary benefit of using `dama/doctrine-test-bundle` in Symfony functional tests involving a database?
    answers:
      -
        value: >
          It automatically generates Doctrine entities from your database schema.
        correct: false
      -
        value: >
          It provides a graphical interface for inspecting database changes during tests.
        correct: false
      -
        value: >
          It automatically rolls back database transactions after each test, ensuring a clean state.
        correct: true
      -
        value: >
          It replaces your real database with an in-memory SQLite database.
        correct: false
    help: |
      The `dama/doctrine-test-bundle` is crucial for database-heavy functional tests as it ensures each test runs with a clean database state by wrapping each test in a transaction and rolling it back.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      When performing functional tests, how can you ensure that your tests use a separate database from your development or production environments?
    answers:
      -
        value: >
          By setting the `DATABASE_URL` environment variable in your `.env.test.local` file.
        correct: true
      -
        value: >
          By configuring a different database connection in `config/packages/doctrine.yaml`.
        correct: false
      -
        value: >
          By using an in-memory SQLite database by default.
        correct: false
      -
        value: >
          By manually creating a new database for each test run.
        correct: false
    help: |
      It's a best practice to configure a dedicated test database by overriding the `DATABASE_URL` in `.env.test.local` to prevent test data from affecting other environments.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      Which of the following commands is used to generate an HTML code coverage report after running PHPUnit tests?
    answers:
      -
        value: >
          `php bin/phpunit --coverage-html=report/`
        correct: true
      -
        value: >
          `php bin/phpunit --html-coverage=report/`
        correct: false
      -
        value: >
          `php bin/console coverage:generate --format=html`
        correct: false
      -
        value: >
          `php bin/phpunit --report=html`
        correct: false
    help: |
      The `--coverage-html` option with `php bin/phpunit` generates an HTML report of your code coverage, which can be viewed in a web browser. XDebug or PCOV is required.
      https://symfony.com/doc/current/create_framework/unit_testing.html#code-coverage

  -
    question: >
      What is the primary role of the `Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener`?
    answers:
      -
        value: >
          To provide additional assertions for Symfony-specific testing.
        correct: false
      -
        value: >
          To integrate Symfony's PHPUnit bridge functionalities, such as `ClockMock` and deprecation handling.
        correct: true
      -
        value: >
          To automatically generate test classes for Symfony entities.
        correct: false
      -
        value: >
          To manage the Symfony test client's lifecycle.
        correct: false
    help: |
      The `SymfonyTestsListener` is a key component of the PHPUnit bridge, enabling features like `ClockMock` and the deprecation helper by integrating with PHPUnit's event system.
      https://symfony.com/doc/current/components/phpunit_bridge.html#clockmock

  -
    question: |
      You have a time-sensitive test that uses `sleep()` and `Stopwatch`. How can you make this test reliable and prevent transient failures due to real-time variations when using the Symfony PHPUnit bridge?
    answers:
      -
        value: >
          By increasing the `sleep()` duration to a very large number.
        correct: false
      -
        value: >
          By adding the `@group time-sensitive` annotation to the test class or method.
        correct: true
      -
        value: >
          By disabling `ClockMock` in `phpunit.xml.dist`.
        correct: false
      -
        value: >
          By using `usleep()` instead of `sleep()`.
        correct: false
    help: |
      The `@group time-sensitive` annotation, when `SymfonyTestsListener` is enabled, automatically activates `ClockMock` for the test, ensuring time-based functions behave predictably.
      https://symfony.com/doc/current/components/phpunit_bridge.html#clockmock

  -
    question: >
      When using the Symfony Deprecations Helper, how can you execute tests while ignoring deprecations listed in a specific baseline file?
    answers:
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='ignoreFile=./tests/baseline.json' php bin/phpunit`
        correct: false
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='baselineFile=./tests/allowed.json' ./vendor/bin/simple-phpunit`
        correct: true
      -
        value: >
          `PHPUNIT_IGNORE_DEPRECATIONS=./tests/baseline.json php bin/phpunit`
        correct: false
      -
        value: >
          `php bin/phpunit --ignore-deprecations=./tests/allowed.json`
        correct: false
    help: |
      The `SYMFONY_DEPRECATIONS_HELPER` environment variable with `baselineFile` allows you to specify a file containing known deprecations to be ignored during the test run.
      https://symfony.com/doc/current/components/phpunit_bridge.html#excluding-deprecations-from-the-output

  -
    question: >
      What is the primary purpose of `Symfony\\Component\\Clock\\MockClock`?
    answers:
      -
        value: >
          To measure the execution time of code blocks.
        correct: false
      -
        value: >
          To provide a mock implementation of a physical clock for testing time-sensitive logic.
        correct: true
      -
        value: >
          To synchronize time across distributed test environments.
        correct: false
      -
        value: >
          To generate random timestamps for test data.
        correct: false
    help: |
      `MockClock` allows you to control the current time in your tests, enabling reliable testing of time-sensitive logic without actual delays.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      Which of the following is a correct way to assert that an HTML element with a specific selector exists in the response using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertSelectorExists('.my-class');`
        correct: true
      -
        value: >
          `$crawler->filter('.my-class')->count() > 0;`
        correct: true
      -
        value: >
          `$this->assertElementExists('.my-class');`
        correct: false
      -
        value: >
          `$crawler->hasSelector('.my-class');`
        correct: false
    help: |
      The `assertSelectorExists()` method is a convenient assertion provided by `WebTestCase` to check for the presence of elements matching a CSS selector. You can also use the Crawler's `filter()` method and check the count.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When submitting a form in a functional test using the Crawler, which method should you use to get the form object from a button or input element?
    answers:
      -
        value: >
          `$crawler->selectButton('Submit')->form();`
        correct: true
      -
        value: >
          `$crawler->filter('button[type="submit"]')->getForm();`
        correct: false
      -
        value: >
          `$crawler->form('submit_button_id');`
        correct: false
      -
        value: >
          `$crawler->getFormByButton('Submit');`
        correct: false
    help: |
      You can obtain a `Form` object from a button or input element using the `form()` method on the `Crawler` node.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\PantherTestCase`?
    answers:
      -
        value: >
          To run unit tests in a separate process.
        correct: false
      -
        value: >
          To enable end-to-end testing of JavaScript-heavy applications using a real browser.
        correct: true
      -
        value: >
          To provide a simplified `WebTestCase` for API testing.
        correct: false
      -
        value: >
          To mock HTTP requests for external APIs.
        correct: false
    help: |
      `PantherTestCase` extends `WebTestCase` and provides a client that controls a real browser (like Chrome or Firefox) for end-to-end testing, including JavaScript execution.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      Which PHPUnit annotation is often used with Symfony Panther tests, especially when testing multi-domain applications, to ensure test isolation?
    answers:
      -
        value: >
          `@isolated`
        correct: false
      -
        value: >
          `@runInSeparateProcess`
        correct: true
      -
        value: >
          `@separateProcess`
        correct: false
      -
        value: >
          `@threadSafe`
        correct: false
    help: |
      The `@runInSeparateProcess` annotation ensures that each test runs in its own PHP process, which is crucial for isolating tests that might interfere with each other, such as those involving different domains in Panther.
      https://symfony.com/doc/current/testing/end_to_end.html#testing-multi-domain-applications

  -
    question: >
      When using Symfony Panther, what is the purpose of "future assertions" like `assertSelectorWillExist()`?
    answers:
      -
        value: >
          To assert conditions that are expected to be true immediately.
        correct: false
      -
        value: >
          To assert conditions that will eventually become true after asynchronous operations.
        correct: true
      -
        value: >
          To assert conditions that were true in a previous state of the application.
        correct: false
      -
        value: >
          To assert conditions that are expected to fail in the future.
        correct: false
    help: |
      Future assertions in Panther are designed for testing dynamic UIs and AJAX-driven content, allowing the test to wait until a condition (e.g., an element appearing) is met within a timeout.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      How can you enable interactive debug mode for Symfony Panther tests, pausing on failure to allow manual browser inspection?
    answers:
      -
        value: >
          `PANTHER_DEBUG=1 php bin/phpunit`
        correct: false
      -
        value: >
          `PANTHER_NO_HEADLESS=1 bin/phpunit --debug`
        correct: true
      -
        value: >
          `php bin/phpunit --panther-interactive`
        correct: false
      -
        value: >
          `$client->debug();` in the test.
        correct: false
    help: |
      Setting `PANTHER_NO_HEADLESS=1` and running PHPUnit with `--debug` will open a visible browser window and pause on test failures, allowing for interactive debugging.
      https://symfony.com/doc/current/testing/end_to_end.html#interactive-debug-mode

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid way to assert that the response is a redirect to a specific location using the Symfony test client?
    answers:
      -
        value: >
          `$this->assertResponseRedirects('/login');`
        correct: true
      -
        value: >
          `$this->assertRedirectTo('/login');`
        correct: false
      -
        value: >
          `$this->assertResponseStatusCodeSame(302, '/login');`
        correct: false
      -
        value: >
          `$this->assertRedirectsTo('/login');`
        correct: false
    help: |
      The `assertResponseRedirects()` method allows you to assert that the response is a redirect and optionally check the target location and status code.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the default behavior of the Symfony test client regarding redirects after a request?
    answers:
      -
        value: >
          It automatically follows all redirects.
        correct: false
      -
        value: >
          It does not follow redirects by default; you must explicitly follow them.
        correct: true
      -
        value: >
          It asks for user confirmation before following redirects.
        correct: false
      -
        value: >
          It only follows redirects with a 301 status code.
        correct: false
    help: |
      By default, the test client does not automatically follow redirects. You need to use `$client->followRedirect()` or `$client->followRedirects()` to handle them.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      When writing functional tests, how can you obtain the `Request` object that was sent during the last client request?
    answers:
      -
        value: >
          `$client->getLastRequest();`
        correct: true
      -
        value: >
          `$client->getRequest();`
        correct: false
      -
        value: >
          `$client->getContainer()->get('request_stack')->getCurrentRequest();`
        correct: false
      -
        value: >
          `$client->getResponse()->getRequest();`
        correct: false
    help: |
      The `getLastRequest()` method on the test client returns the `Request` object from the last interaction.
      https://symfony.com/doc/current/testing.html#request-and-response-objects

  -
    question: >
      What is the purpose of `Symfony\\Bridge\\PhpUnit\\CoverageListener`?
    answers:
      -
        value: >
          To provide a graphical interface for code coverage reports.
        correct: false
      -
        value: >
          To automatically add `@covers` annotations to test classes for accurate code coverage reporting.
        correct: true
      -
        value: >
          To optimize the performance of code coverage generation.
        correct: false
      -
        value: >
          To integrate code coverage with continuous integration platforms.
        correct: false
    help: |
      The `CoverageListener` helps in generating more accurate code coverage reports by automatically inferring and adding `@covers` annotations based on the test class and method names.
      https://symfony.com/doc/current/components/phpunit_bridge.html#coverage-listener

  -
    question: >
      When configuring the Symfony Profiler for the `test` environment, what does setting `collect: false` under `framework.profiler` achieve?
    answers:
      -
        value: >
          It completely disables the profiler, preventing any data collection.
        correct: false
      -
        value: >
          It enables the profiler but prevents it from collecting data by default, requiring explicit enabling per test.
        correct: true
      -
        value: >
          It collects only summary data, not detailed profiling information.
        correct: false
      -
        value: >
          It forces the profiler to collect data for all requests, regardless of test settings.
        correct: false
    help: |
      Setting `collect: false` means the profiler is enabled but won't collect data unless `client->enableProfiler()` is called for a specific request, which is useful for performance in tests.
      https://symfony.com/doc/current/testing/profiling.html#enabling-the-profiler

  -
    question: >
      Which assertion should you use to check if a specific header is present in the HTTP response?
    answers:
      -
        value: >
          `$this->assertResponseHasHeader('Content-Type');`
        correct: true
      -
        value: >
          `$this->assertHasHeader('Content-Type');`
        correct: false
      -
        value: >
          `$this->assertResponseHeaderExists('Content-Type');`
        correct: false
      -
        value: >
          `$this->assertHeaderPresent('Content-Type');`
        correct: false
    help: |
      The `assertResponseHasHeader()` method is used to verify the presence of a specific header in the HTTP response.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the primary purpose of the `make:test` command from SymfonyMakerBundle?
    answers:
      -
        value: >
          To run existing tests.
        correct: false
      -
        value: >
          To generate boilerplate code for new test classes, including `WebTestCase` and `KernelTestCase` types.
        correct: true
      -
        value: >
          To analyze test coverage.
        correct: false
      -
        value: >
          To install testing dependencies.
        correct: false
    help: |
      The `make:test` command is a convenient way to quickly generate a new test class with the correct boilerplate, saving time and ensuring adherence to Symfony's testing conventions.
      https://symfony.com/doc/current/testing.html#creating-a-test-class

  -
    question: >
      When performing a "smoke test" on your application's URLs, what is the main goal?
    answers:
      -
        value: >
          To verify the functionality of all forms on every page.
        correct: false
      -
        value: >
          To check if all public URLs load successfully and return a 2xx status code.
        correct: true
      -
        value: >
          To test the performance of database queries on all pages.
        correct: false
      -
        value: >
          To ensure all JavaScript on the page is executing correctly.
        correct: false
    help: |
      A smoke test quickly verifies that the most critical functions of an application are working, typically by checking if key URLs are accessible and return successful responses.
      https://symfony.com/doc/current/best_practices.html#smoke-tests

  -
    question: >
      Which of the following is the correct way to assert that a specific text is contained within an element matching a CSS selector using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertSelectorTextContains('h1', 'Hello World');`
        correct: true
      -
        value: >
          `$crawler->filter('h1')->text()->contains('Hello World');`
        correct: false
      -
        value: >
          `$this->assertTextContains('h1', 'Hello World');`
        correct: false
      -
        value: >
          `$crawler->textContains('h1', 'Hello World');`
        correct: false
    help: |
      `assertSelectorTextContains()` is a convenient assertion provided by `WebTestCase` to check if the text content of an element matches a given string.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the primary benefit of using `doctrine/doctrine-fixtures-bundle` in Symfony tests?
    answers:
      -
        value: >
          It allows you to define and load dummy data into your database for testing.
        correct: true
      -
        value: >
          It provides a way to mock Doctrine entities without a database.
        correct: false
      -
        value: >
          It automatically generates migrations for your database schema.
        correct: false
      -
        value: >
          It helps in analyzing the performance of Doctrine queries.
        correct: false
    help: |
      Doctrine Fixtures Bundle allows you to easily create and load consistent test data into your database, ensuring reproducible test environments.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      When testing a console command, what method should you call on the `Application` object to ensure you can retrieve the command's output and exit code for assertions?
    answers:
      -
        value: >
          `$application->runInBackground(true);`
        correct: false
      -
        value: >
          `$application->setAutoExit(false);`
        correct: true
      -
        value: >
          `$application->disableExit();`
        correct: false
      -
        value: >
          `$application->setInteractive(false);`
        correct: false
    help: |
      Setting `setAutoExit(false)` on the `Application` instance prevents the application from exiting immediately after running a command, allowing the `ApplicationTester` to capture output and exit code.
      https://symfony.com/doc/current/console.html#testing-commands

  -
    question: >
      Which class is created by the `loginUser()` method and stored in the session of the test client during functional tests?
    answers:
      -
        value: >
          `Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\TestBrowserToken`
        correct: true
      -
        value: >
          `Symfony\\Component\\Security\\Core\\User\\UserInterface`
        correct: false
      -
        value: >
          `Symfony\\Component\\HttpFoundation\\Session\\Session`
        correct: false
    help: |
      The `loginUser()` method creates a special `TestBrowserToken` and stores it in the test client's session to simulate a logged-in user.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      What is the purpose of `Symfony\\Component\\HttpClient\\Response\\MockResponse` and `Symfony\\Component\\HttpClient\\MockHttpClient` when testing HTTP clients in Symfony?
    answers:
      -
        value: >
          To make real HTTP requests to external services during tests.
        correct: false
      -
        value: >
          To record and replay HTTP interactions for integration tests.
        correct: false
      -
        value: >
          To simulate HTTP responses without making actual network calls, enabling isolated and fast tests.
        correct: true
      -
        value: >
          To optimize the performance of HTTP client calls in production.
        correct: false
    help: |
      `MockHttpClient` and `MockResponse` (or `HarFileResponseFactory`) allow you to mock HTTP client responses, making tests faster, more reliable, and independent of external services.
      https://symfony.com/doc/current/http_client.html#testing

  -
    question: >
      When writing a unit test for a custom Symfony Validator constraint, which base class should you extend?
    answers:
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`
        correct: true
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase`
        correct: true
    help: |
      For single constraints, extend `ConstraintValidatorTestCase`. For compound constraints (constraints composed of other constraints), extend `CompoundConstraintTestCase`.
      https://symfony.com/doc/current/validation/custom_constraint.html#testing-the-constraint

  -
    question: >
      How can you configure a less resource-intensive password hasher specifically for the `test` environment to speed up test execution?
    answers:
      -
        value: >
          By setting `security.password_hashers.App\\Entity\\User.algorithm: plaintext` in `config/packages/test/security.yaml`.
        correct: false
      -
        value: >
          By overriding the `password_hashers` configuration under `when@test` in `config/packages/security.yaml`.
        correct: true
      -
        value: >
          By using a custom password encoder service only for tests.
        correct: false
      -
        value: >
          Symfony automatically uses a faster hasher in the test environment.
        correct: false
    help: |
      You can define environment-specific configurations in Symfony. For the test environment, you can override the password hasher configuration to use a faster algorithm.
      https://symfony.com/doc/current/security/passwords.html#configuring-password-hashers

  -
    question: >
      What is the main purpose of `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      -
        value: >
          To test individual PHP functions in isolation.
        correct: false
      -
        value: >
          To provide a base class for integration tests that need to boot the Symfony kernel and access its services.
        correct: true
      -
        value: >
          To simulate HTTP requests and responses.
        correct: false
      -
        value: >
          To manage database connections for all tests.
        correct: false
    help: |
      `KernelTestCase` is used for integration tests where you need to interact with Symfony services and the kernel, but not necessarily simulate full HTTP requests.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      Which of the following commands would you use to install the `symfony/test-pack` Composer package, which includes PHPUnit and other testing dependencies?
    answers:
      -
        value: >
          `composer install symfony/test-pack`
        correct: false
      -
        value: >
          `composer require symfony/test-pack`
        correct: false
      -
        value: >
          `composer require --dev symfony/test-pack`
        correct: true
      -
        value: >
          `symfony install:test-pack`
        correct: false
    help: |
      The `symfony/test-pack` should be installed as a development dependency using `composer require --dev`.
      https://symfony.com/doc/current/testing.html#installation

  -
    question: >
      When running PHPUnit tests, what is the effect of the `--coverage-text` option?
    answers:
      -
        value: >
          It generates a detailed HTML report of code coverage.
        correct: false
      -
        value: >
          It outputs a summary of code coverage directly to the console.
        correct: true
      -
        value: >
          It creates a text file with all covered lines of code.
        correct: false
      -
        value: >
          It only shows coverage for files that have 100% coverage.
        correct: false
    help: |
      The `--coverage-text` option provides a quick, console-based overview of your code coverage.
      https://symfony.com/doc/current/create_framework/unit_testing.html#code-coverage

  -
    question: >
      You are testing a form and want to assert that a checkbox with a specific name is checked. Which assertion method should you use with the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertCheckboxChecked('my_checkbox_name');`
        correct: true
      -
        value: >
          `$this->assertInputValueSame('my_checkbox_name', 'on');`
        correct: false
      -
        value: >
          `$crawler->filter('#my_checkbox_name')->isChecked();`
        correct: false
      -
        value: >
          `$this->assertSelectorAttributeContains('input[name="my_checkbox_name"]', 'checked', 'checked');`
        correct: false
    help: |
      The `assertCheckboxChecked()` method is a dedicated assertion for checking the state of a checkbox by its name.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the recommended approach for clearing the Symfony cache specifically for the `test` environment, especially on CI servers where `debug` is `false`?
    answers:
      -
        value: >
          Manually delete the `var/cache/test` directory before each test run.
        correct: false
      -
        value: >
          Use `(new Filesystem())->remove(__DIR__.'/../var/cache/test');` in your `setUp()` method.
        correct: true
      -
        value: >
          Run `php bin/console cache:clear --env=test` before each test.
        correct: false
      -
        value: >
          Symfony automatically clears the test cache.
        correct: false
    help: |
      Programmatically clearing the test cache using the Filesystem component ensures a fresh state, particularly when debug mode is off and the cache isn't automatically invalidated.
      https://symfony.com/doc/current/testing.html#clearing-the-cache

  -
    question: >
      When testing a custom form type, which base class should you extend to benefit from Symfony's form testing utilities?
    answers:
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Form\\Test\\TypeTestCase`
        correct: true
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`
        correct: true
    help: |
      `TypeTestCase` is the base class for testing individual form types, while `FormIntegrationTestCase` is for more complex scenarios involving multiple types or extensions.
      https://symfony.com/doc/current/form/unit_testing.html

  -
    question: >
      What is the purpose of the `getProfile()` method on the Symfony test client after enabling the profiler?
    answers:
      -
        value: >
          To retrieve the user's security profile.
        correct: false
      -
        value: >
          To get the collected data from the Symfony Profiler for the last request.
        correct: true
      -
        value: >
          To access the current request's performance metrics.
        correct: false
      -
        value: >
          To generate a new profiler token.
        correct: false
    help: |
      After a request, if the profiler was enabled, `getProfile()` allows you to retrieve the `Profile` object containing all collected data.
      https://symfony.com/doc/current/testing.html#the-profiler

  -
    question: >
      Which method of the Symfony test client allows you to submit a form by providing the form's button and an array of form values?
    answers:
      -
        value: >
          `$client->submitForm('Submit', ['field' => 'value']);`
        correct: true
      -
        value: >
          `$client->sendForm('Submit', ['field' => 'value']);`
        correct: false
      -
        value: >
          `$client->postForm('Submit', ['field' => 'value']);`
        correct: false
      -
        value: >
          `$client->clickButton('Submit', ['field' => 'value']);`
        correct: false
    help: |
      The `submitForm()` method simplifies form submission in functional tests by allowing you to specify the button text and an array of form field values.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: >
      When running tests with the Symfony Deprecations Helper, how can you generate a baseline file that lists all currently reported deprecations, which can then be used to ignore them in future runs?
    answers:
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='generateBaseline=./tests/baseline.json' ./vendor/bin/simple-phpunit`
        correct: true
      -
        value: >
          `php bin/console deprecations:baseline:generate`
        correct: false
      -
        value: >
          `./vendor/bin/simple-phpunit --generate-baseline=./tests/baseline.json`
        correct: false
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='dumpFile=./tests/baseline.json' php bin/phpunit`
        correct: false
    help: |
      Setting `SYMFONY_DEPRECATIONS_HELPER` with `generateBaseline` will create a JSON file containing all deprecations encountered during the test run.
      https://symfony.com/doc/current/components/phpunit_bridge.html#excluding-deprecations-from-the-output

  -
    question: >
      What is the primary benefit of using `HarFileResponseFactory` with `MockHttpClient` for testing Symfony's HTTP Client?
    answers:
      -
        value: >
          It records new HTTP interactions into HAR files.
        correct: false
      -
        value: >
          It allows replaying recorded HTTP interactions, ensuring realistic and reproducible tests without external dependencies.
        correct: true
      -
        value: >
          It converts HAR files into PHPUnit test cases.
        correct: false
      -
        value: >
          It provides real-time monitoring of HTTP client requests.
        correct: false
    help: |
      `HarFileResponseFactory` enables "replay testing" by using pre-recorded HAR files to generate mock responses, making tests deterministic and fast.
      https://symfony.com/doc/current/http_client.html#testing

  -
    question: >
      Which of the following is a valid way to assert that the page title is exactly "My Page Title" using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertPageTitleSame('My Page Title');`
        correct: true
      -
        value: >
          `$this->assertSelectorTextSame('title', 'My Page Title');`
        correct: true
      -
        value: >
          `$this->assertTitleEquals('My Page Title');`
        correct: false
      -
        value: >
          `$crawler->filter('title')->text() === 'My Page Title';`
        correct: false
    help: |
      Both `assertPageTitleSame()` and `assertSelectorTextSame('title', ...)` can be used to assert the exact content of the page title.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Doctrine repository using `KernelTestCase`, what is the recommended way to get the `EntityManager` instance?
    answers:
      -
        value: >
          `$this->getContainer()->get('doctrine.orm.entity_manager');`
        correct: false
      -
        value: >
          `static::getContainer()->get('doctrine')->getManager();`
        correct: true
      -
        value: >
          `$this->getDoctrine()->getManager();`
        correct: false
      -
        value: >
          `$this->entityManager;` (assuming it's a property initialized in `setUp`)
        correct: true
    help: |
      After booting the kernel, you can access the `EntityManager` via the container. It's common to store it as a protected property and initialize it in `setUp()`.
      https://symfony.com/doc/current/testing/database.html#functional-tests-for-doctrine-repositories

  -
    question: >
      What is the purpose of the `tearDown()` method in a PHPUnit test class extending `KernelTestCase` when dealing with Doctrine `EntityManager`?
    answers:
      -
        value: >
          To commit any pending database transactions.
        correct: false
      -
        value: >
          To close the `EntityManager` and set it to `null` to prevent memory leaks.
        correct: true
      -
        value: >
          To reset the application's state for the next test.
        correct: false
      -
        value: >
          To clear the Symfony cache.
        correct: false
    help: |
      It's recommended to close the `EntityManager` and nullify its reference in `tearDown()` to avoid memory leaks, especially when running many tests.
      https://symfony.com/doc/current/testing/database.html#functional-tests-for-doctrine-repositories

  -
    question: >
      Which of the following is NOT a valid assertion method provided by the Symfony test client for checking response headers?
    answers:
      -
        value: >
          `assertResponseHasHeader()`
        correct: false
      -
        value: >
          `assertResponseHeaderSame()`
        correct: false
      -
        value: >
          `assertResponseHeaderEquals()`
        correct: true
      -
        value: >
          `assertResponseNotHasHeader()`
        correct: false
    help: |
      `assertResponseHeaderEquals()` is not a standard assertion method. The correct ones are `assertResponseHasHeader()`, `assertResponseNotHasHeader()`, `assertResponseHeaderSame()`, and `assertResponseHeaderNotSame()`.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      When writing end-to-end tests with Symfony Panther, what is the primary advantage of using client-side waiting methods like `waitFor()` or `waitForElementToContain()`?
    answers:
      -
        value: >
          They speed up test execution by skipping unnecessary waits.
        correct: false
      -
        value: >
          They ensure tests are reliable by waiting for asynchronous JavaScript operations to complete before making assertions.
        correct: true
      -
        value: >
          They allow tests to run without a real browser.
        correct: false
      -
        value: >
          They automatically generate screenshots on test failures.
        correct: false
    help: |
      Client-side waiting methods are essential for testing dynamic web applications, as they prevent assertions from failing due to elements not being immediately present or visible after an AJAX call or animation.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      Which of the following is a correct way to run only tests within a specific directory using PHPUnit?
    answers:
      -
        value: >
          `php bin/phpunit --dir tests/Controller`
        correct: false
      -
        value: >
          `php bin/phpunit tests/Controller`
        correct: true
      -
        value: >
          `php bin/phpunit --path tests/Controller`
        correct: false
      -
        value: >
          `php bin/console test:run --dir=tests/Controller`
        correct: false
    help: |
      You can specify a directory path as an argument to `php bin/phpunit` to run tests only within that directory.
      https://symfony.com/doc/current/testing.html#run-specific-tests

  -
    question: >
      What is the purpose of the `users_in_memory` configuration under `security` in `config/packages/test/security.yaml`?
    answers:
      -
        value: >
          To define users that can log in through the application's login form.
        correct: false
      -
        value: >
          To provide a simple, in-memory user provider for functional tests, avoiding database interaction for test users.
        correct: true
      -
        value: >
          To store user sessions in memory during testing.
        correct: false
      -
        value: >
          To encrypt user passwords for test environments.
        correct: false
    help: |
      `users_in_memory` is a convenient way to define simple test users directly in your security configuration, especially for the test environment, for use with `loginUser()`.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      When using `KernelTestCase`, what does `self::bootKernel()` achieve?
    answers:
      -
        value: >
          It starts a web server for the application.
        correct: false
      -
        value: >
          It initializes the Symfony application kernel, making services and bundles available.
        correct: true
      -
        value: >
          It clears the application's cache.
        correct: false
      -
        value: >
          It creates a new database connection.
        correct: false
    help: |
      `bootKernel()` is essential for `KernelTestCase` as it sets up the Symfony environment, allowing access to the container and services.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      Which of the following is a valid way to assert that an input field with a specific name has a particular value using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertInputValueSame('my_field_name', 'expected_value');`
        correct: true
      -
        value: >
          `$crawler->filter('input[name="my_field_name"]')->attr('value') === 'expected_value';`
        correct: false
      -
        value: >
          `$this->assertFormValue('form_selector', 'my_field_name', 'expected_value');`
        correct: true
      -
        value: >
          `$this->assertInputHasValue('my_field_name', 'expected_value');`
        correct: false
    help: |
      Both `assertInputValueSame()` and `assertFormValue()` are provided for asserting input field values.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the primary reason for running `php bin/console --env=test doctrine:database:create` and `php bin/console --env=test doctrine:schema:create` before running database-dependent functional tests?
    answers:
      -
        value: >
          To create and initialize a dedicated database for the test environment.
        correct: true
      -
        value: >
          To migrate the production database schema to the test environment.
        correct: false
      -
        value: >
          To clear all data from the existing test database.
        correct: false
      -
        value: >
          To generate Doctrine entities from the database.
        correct: false
    help: |
      These commands ensure that a clean test database exists and has the correct schema before tests that interact with the database are run.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      When using `WebTestCase`, what is the purpose of the `$client->followRedirects()` method?
    answers:
      -
        value: >
          To manually follow a single redirect after a response.
        correct: false
      -
        value: >
          To configure the client to automatically follow all subsequent redirects.
        correct: true
      -
        value: >
          To prevent the client from following any redirects.
        correct: false
      -
        value: >
          To get the URL of the redirect target.
        correct: false
    help: |
      Calling `$client->followRedirects()` without arguments enables automatic redirect following for all subsequent requests made by that client instance.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      What is the main advantage of using a data provider for functional tests, such as in a smoke test for URLs?
    answers:
      -
        value: >
          It allows running tests in parallel.
        correct: false
      -
        value: >
          It enables running the same test method multiple times with different sets of data, reducing code duplication.
        correct: true
      -
        value: >
          It automatically generates test data.
        correct: false
      -
        value: >
          It provides a mechanism for mocking external services.
        correct: false
    help: |
      Data providers are a PHPUnit feature that allows a single test method to be executed multiple times with different arguments, which is ideal for testing a list of URLs or various input combinations.
      https://symfony.com/doc/current/best_practices.html#smoke-tests

  -
    question: >
      Which of the following is a valid way to assert that the HTTP response status code is exactly 404?
    answers:
      -
        value: >
          `$this->assertResponseStatusCodeSame(404);`
        correct: true
      -
        value: >
          `$this->assertResponseCode(404);`
        correct: false
      -
        value: >
          `$this->assertStatusCode(404);`
        correct: false
      -
        value: >
          `$this->assertEquals(404, $client->getResponse()->getStatusCode());`
        correct: true
    help: |
      Both `assertResponseStatusCodeSame()` and directly asserting the status code from the response object are valid ways to check the HTTP status.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `getTemplatePaths()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To define the paths where Twig templates for form themes are located.
        correct: true
      -
        value: >
          To retrieve the paths of all Twig templates in the application.
        correct: false
      -
        value: >
          To specify the directory for cached Twig templates.
        correct: false
      -
        value: >
          To return the path to the main application template.
        correct: false
    help: |
      `getTemplatePaths()` is an overridable method in `FormLayoutTestCase` that allows you to specify where your form theme Twig templates are located for testing purposes.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      When testing a custom form type, which method in `TypeTestCase` allows you to register additional form extensions for the test case?
    answers:
      -
        value: >
          `getExtensions()`
        correct: true
      -
        value: >
          `registerExtensions()`
        correct: false
      -
        value: >
          `addExtensions()`
        correct: false
      -
        value: >
          `getFormExtensions()`
        correct: false
    help: |
      The `getExtensions()` method in `TypeTestCase` can be overridden to return an array of `FormExtensionInterface` instances that should be registered for the current test.
      https://symfony.com/doc/current/form/unit_testing.html#registering-form-extensions

  -
    question: >
      Which of the following is a valid way to run a single PHPUnit test file?
    answers:
      -
        value: >
          `php bin/phpunit tests/Controller/MyControllerTest.php`
        correct: true
      -
        value: >
          `php bin/phpunit --file tests/Controller/MyControllerTest.php`
        correct: false
      -
        value: >
          `php bin/console test:file tests/Controller/MyControllerTest.php`
        correct: false
      -
        value: >
          `php bin/phpunit --test tests/Controller/MyControllerTest.php`
        correct: false
    help: |
      You can specify the path to a single test file as an argument to `php bin/phpunit` to run only the tests within that file.
      https://symfony.com/doc/current/testing.html#run-specific-tests

  -
    question: >
      What is the purpose of `Symfony\\Component\\Security\\Core\\User\\InMemoryUser` in functional tests?
    answers:
      -
        value: >
          To persist user data to a database during tests.
        correct: false
      -
        value: >
          To create a simple, temporary user object for authentication in tests without needing a real user entity or database.
        correct: true
      -
        value: >
          To encrypt user passwords for testing.
        correct: false
      -
        value: >
          To manage user roles and permissions.
        correct: false
    help: |
      `InMemoryUser` is a convenient class for creating simple user objects on the fly for testing purposes, especially when used with `loginUser()`.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      When testing a custom framework's exception handling, how would you typically simulate a `ResourceNotFoundException` to verify a 404 response?
    answers:
      -
        value: >
          By making a request to a non-existent URL.
        correct: false
      -
        value: >
          By mocking the URL matcher to throw the `ResourceNotFoundException`.
        correct: true
      -
        value: >
          By throwing the exception directly in the test method.
        correct: false
      -
        value: >
          By configuring the test environment to return 404 for all requests.
        correct: false
    help: |
      For unit testing a framework's exception handling, mocking the component that would throw the exception (like the URL matcher) is the correct approach to isolate the test.
      https://symfony.com/doc/current/create_framework/unit_testing.html#not-found-handling

  -
    question: >
      What is the significance of the `test:` configuration setting under `framework` in `config/packages/test/framework.yaml`?
    answers:
      -
        value: >
          It enables the Symfony Profiler by default.
        correct: false
      -
        value: >
          It loads services related to testing, such as `test.client`.
        correct: true
      -
        value: >
          It configures the test database connection.
        correct: false
      -
        value: >
          It sets the application environment to `test`.
        correct: false
    help: |
      The `test:` configuration setting ensures that testing-specific services, like the test client, are loaded in the test environment.
      https://symfony.com/doc/current/reference/configuration/framework.html#test

  -
    question: >
      Which of the following is a valid way to assert that an element matching a given selector does NOT exist in the response using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertSelectorNotExists('.my-class');`
        correct: true
      -
        value: >
          `$crawler->filter('.my-class')->count() === 0;`
        correct: true
      -
        value: >
          `$this->assertNoSelector('.my-class');`
        correct: false
      -
        value: >
          `$crawler->doesNotHaveSelector('.my-class');`
        correct: false
    help: |
      Both `assertSelectorNotExists()` and checking the count of filtered elements are valid ways to assert that an element is not present.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Symfony console command, how can you execute the command and capture its output and exit code?
    answers:
      -
        value: >
          Use `ApplicationTester` and its `execute()` method.
        correct: true
      -
        value: >
          Call the command's `run()` method directly.
        correct: false
      -
        value: >
          Use `Symfony\\Component\\Console\\Tester\\CommandTester`.
        correct: true
      -
        value: >
          Redirect stdout to a file and read it.
        correct: false
    help: |
      `ApplicationTester` and `CommandTester` are specifically designed for testing console commands, providing methods to execute commands and retrieve their output and exit codes.
      https://symfony.com/doc/current/console.html#testing-commands

  -
    question: >
      What is the purpose of the `getTypes()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      -
        value: >
          To return a list of custom form types to be loaded for integration tests.
        correct: true
      -
        value: >
          To retrieve the data types of form fields.
        correct: false
      -
        value: >
          To define the expected form types in a test.
        correct: false
      -
        value: >
          To get the names of all registered form types.
        correct: false
    help: |
      `getTypes()` allows you to register custom form types that your integration tests depend on.
      https://symfony.com/doc/current/form/unit_testing.html#registering-custom-form-types

  -
    question: >
      Which of the following is a key advantage of using `PantherTestCase` over `WebTestCase` for certain types of functional tests?
    answers:
      -
        value: >
          `PantherTestCase` is significantly faster for all types of tests.
        correct: false
      -
        value: >
          `PantherTestCase` can execute JavaScript and interact with dynamic content.
        correct: true
      -
        value: >
          `PantherTestCase` does not require a web server.
        correct: false
      -
        value: >
          `PantherTestCase` provides direct database access.
        correct: false
    help: |
      `PantherTestCase` uses a real browser, allowing it to handle JavaScript, AJAX, and other client-side interactions that `WebTestCase` (which simulates HTTP requests) cannot.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      When using the Symfony Profiler in tests, how can you retrieve a specific data collector, such as the `logger` collector?
    answers:
      -
        value: >
          `$profile->getCollector('logger');`
        correct: true
      -
        value: >
          `$profile->get('logger');`
        correct: false
      -
        value: >
          `$profile->getCollectorByType(LoggerCollector::class);`
        correct: false
      -
        value: >
          `$profile->findCollector('logger');`
        correct: false
    help: |
      The `getCollector()` method on the `Profile` object allows you to retrieve a specific data collector by its name.
      https://symfony.com/doc/current/testing.html#the-profiler

  -
    question: >
      What is the purpose of the `getTwigExtensions()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To return an array of Twig extensions to be loaded for the test environment.
        correct: true
      -
        value: >
          To get the file paths of Twig extensions.
        correct: false
      -
        value: >
          To enable or disable Twig extensions for tests.
        correct: false
      -
        value: >
          To configure the Twig cache directory.
        correct: false
    help: |
      This method allows you to register any Twig extensions that are necessary for rendering your form themes during tests.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      Which of the following describes the correct setup for running Symfony tests in a GitHub Actions workflow?
    answers:
      -
        value: >
          Checkout repository, install Composer dependencies, then run `bin/phpunit`.
        correct: true
      -
        value: >
          Install Composer dependencies, then checkout repository, then run `bin/phpunit`.
        correct: false
      -
        value: >
          Run `composer test`, then install dependencies, then checkout repository.
        correct: false
      -
        value: >
          Only `bin/phpunit` is needed, as GitHub Actions handles dependencies.
        correct: false
    help: |
      A typical GitHub Actions workflow for Symfony tests involves checking out the code, installing PHP dependencies via Composer, and then executing PHPUnit.
      https://symfony.com/doc/current/testing/end_to_end.html#github-actions

  -
    question: >
      What is the primary difference between a "unit test" and a "functional test" in Symfony?
    answers:
      -
        value: >
          Unit tests are written in PHP, while functional tests are written in JavaScript.
        correct: false
      -
        value: >
          Unit tests focus on individual components in isolation, while functional tests verify the application's behavior through its HTTP layer.
        correct: true
      -
        value: >
          Unit tests require a database, while functional tests do not.
        correct: false
      -
        value: >
          Unit tests are slower than functional tests.
        correct: false
    help: |
      Unit tests isolate small pieces of code, often using mocks, while functional tests simulate user interaction with the full application stack via HTTP requests.
      https://symfony.com/doc/current/testing.html#unit-tests-vs-functional-tests

  -
    question: >
      When testing a custom framework's request handling, how would you typically simulate a successful request to verify a 200 OK response?
    answers:
      -
        value: >
          By mocking the URL matcher to return a valid route and a controller.
        correct: true
      -
        value: >
          By sending a real HTTP request to the application.
        correct: false
      -
        value: >
          By directly calling the controller method.
        correct: false
      -
        value: >
          By setting the response status code to 200 manually.
        correct: false
    help: |
      For unit testing the framework's core request handling, you would mock the components that the framework interacts with (like the URL matcher and controller resolver) to simulate a successful routing and controller execution.
      https://symfony.com/doc/current/create_framework/unit_testing.html

  -
    question: >
      What is the purpose of the `getThemes()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To return an array of form themes (e.g., Twig templates) to apply during the test.
        correct: true
      -
        value: >
          To define the default theme for all forms.
        correct: false
      -
        value: >
          To retrieve the currently active form themes.
        correct: false
      -
        value: >
          To register new Twig namespaces for themes.
        correct: false
    help: |
      This method allows you to specify which form themes should be loaded and applied when rendering forms within your Twig form layout tests.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      Which of the following is a valid way to assert that an input field with a specific name does NOT have a particular value using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertInputValueNotSame('my_field_name', 'unexpected_value');`
        correct: true
      -
        value: >
          `$this->assertInputValueDifferent('my_field_name', 'unexpected_value');`
        correct: false
      -
        value: >
          `$crawler->filter('input[name="my_field_name"]')->attr('value') !== 'unexpected_value';`
        correct: false
      -
        value: >
          `$this->assertNoFormValue('form_selector', 'my_field_name');`
        correct: false
    help: |
      `assertInputValueNotSame()` is the direct assertion for checking that an input's value is not equal to a given value. `assertNoFormValue()` checks if a field has *no* value.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When configuring `phpunit.xml.dist` for Symfony tests, what is the purpose of defining `<testsuites>`?
    answers:
      -
        value: >
          To specify the order in which tests should be executed.
        correct: false
      -
        value: >
          To group tests into logical sets and define directories where they are located.
        correct: true
      -
        value: >
          To enable or disable specific test environments.
        correct: false
      -
        value: >
          To configure the database connection for each test.
        correct: false
    help: |
      Test suites allow you to organize your tests into named groups, making it easier to run specific sets of tests (e.g., unit, functional, API).
      https://symfony.com/doc/current/configuration/multiple_kernels.html#test-suites

  -
    question: >
      What is the primary role of `Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException` in the context of form testing?
    answers:
      -
        value: >
          It indicates that a form field's submitted value is invalid.
        correct: false
      -
        value: >
          It is raised by the OptionsResolver component when an invalid or unsupported option is encountered during form configuration.
        correct: true
      -
        value: >
          It signifies a database constraint violation.
        correct: false
      -
        value: >
          It is thrown when a form type is not found.
        correct: false
    help: |
      This exception is part of the OptionsResolver component, which is used by Symfony Forms to validate and resolve options passed to form types.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      Which of the following is the correct way to assert that the `<title>` element of the HTML response contains a specific string?
    answers:
      -
        value: >
          `$this->assertPageTitleContains('Part of Title');`
        correct: true
      -
        value: >
          `$this->assertSelectorTextContains('title', 'Part of Title');`
        correct: true
      -
        value: >
          `$this->assertTitleContains('Part of Title');`
        correct: false
      -
        value: >
          `$crawler->filter('title')->text()->contains('Part of Title');`
        correct: false
    help: |
      Both `assertPageTitleContains()` and `assertSelectorTextContains('title', ...)` are valid ways to check if the page title contains a specific substring.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When writing unit tests for a custom constraint that is a "compound constraint" (composed of other constraints), which base class should you extend?
    answers:
      -
        value: >
          `Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase`
        correct: true
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
    help: |
      `CompoundConstraintTestCase` is specifically designed for testing compound constraints, providing utilities to assert violations from its inner constraints.
      https://symfony.com/doc/current/validation/custom_constraint.html#testing-the-constraint

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Form\\PreloadedExtension` class in form testing?
    answers:
      -
        value: >
          To register form type extensions that are loaded on demand.
        correct: false
      -
        value: >
          To register preloaded form type instances with the `FormRegistry`, ensuring specific instances are used during testing.
        correct: true
      -
        value: >
          To define global form options.
        correct: false
      -
        value: >
          To provide a way to mock form types.
        correct: false
    help: |
      `PreloadedExtension` allows you to explicitly provide form type instances to the form factory, which is useful in tests to ensure specific, pre-configured types are used.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      Which of the following is a valid way to assert that the first element matching a given selector does NOT contain a specific text?
    answers:
      -
        value: >
          `$this->assertSelectorTextNotContains('.my-element', 'Forbidden Text');`
        correct: true
      -
        value: >
          `$crawler->filter('.my-element')->text() !== 'Forbidden Text';`
        correct: false
      -
        value: >
          `$this->assertNoSelectorText('.my-element', 'Forbidden Text');`
        correct: false
      -
        value: >
          `$this->assertSelectorDoesNotContainText('.my-element', 'Forbidden Text');`
        correct: false
    help: |
      `assertSelectorTextNotContains()` is the dedicated assertion for checking that an element's text content does not include a specific string.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the primary purpose of the `Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension` in form testing?
    answers:
      -
        value: >
          To integrate the Symfony Validator component, enabling validation features for form fields.
        correct: true
      -
        value: >
          To provide custom validation rules for forms.
        correct: false
      -
        value: >
          To mock the validator service for unit tests.
        correct: false
      -
        value: >
          To define default validation groups for forms.
        correct: false
    help: |
      This extension is responsible for connecting the Form component with the Validator component, allowing you to test form validation.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      When running tests with `simple-phpunit`, what is the effect of setting `SYMFONY_DEPRECATIONS_HELPER='max[total]=0'`?
    answers:
      -
        value: >
          It ignores all deprecations during the test run.
        correct: false
      -
        value: >
          It forces the test run to fail if any deprecation is triggered.
        correct: true
      -
        value: >
          It limits the number of reported deprecations to zero.
        correct: false
      -
        value: >
          It only reports deprecations from Symfony components.
        correct: false
    help: |
      Setting `max[total]=0` makes the test suite fail if any deprecation is triggered, which is useful for ensuring a deprecation-free codebase.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      What is the purpose of `Symfony\\Component\\Form\\Extension\\Core\\CoreExtension` in form testing?
    answers:
      -
        value: >
          It provides advanced form types for complex scenarios.
        correct: false
      -
        value: >
          It is the default core form extension that provides basic form types and functionality, registered by default in `TypeTestCase`.
        correct: true
      -
        value: >
          It handles form data mapping.
        correct: false
      -
        value: >
          It integrates with external form libraries.
        correct: false
    help: |
      The `CoreExtension` provides fundamental form types like TextType, ChoiceType, etc., and is automatically included in `TypeTestCase` setups.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      Which of the following methods allows you to assert that a specific number of elements matching a given selector are present in the response?
    answers:
      -
        value: >
          `$this->assertSelectorCount(5, '.my-element');`
        correct: true
      -
        value: >
          `$crawler->filter('.my-element')->count() === 5;`
        correct: true
      -
        value: >
          `$this->assertCountOfSelector(5, '.my-element');`
        correct: false
      -
        value: >
          `$this->assertNumElements(5, '.my-element');`
        correct: false
    help: |
      Both `assertSelectorCount()` and directly checking the count of the Crawler's filter result are valid.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To test the Twig templating engine in isolation.
        correct: false
      -
        value: >
          A specialized test case for testing form themes with Twig, providing boilerplate setup for template paths, Twig extensions, and themes.
        correct: true
      -
        value: >
          To test the integration of Twig with Symfony controllers.
        correct: false
      -
        value: >
          To generate Twig templates from form definitions.
        correct: false
    help: |
      This test case simplifies the process of testing how your form themes are rendered using Twig, setting up the necessary Twig environment.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      When writing functional tests, how can you manually follow a single redirect after a client request?
    answers:
      -
        value: >
          `$client->followRedirect();`
        correct: true
      -
        value: >
          `$client->getRedirect();`
        correct: false
      -
        value: >
          `$client->handleRedirect();`
        correct: false
      -
        value: >
          `$client->request($client->getResponse()->getHeader('Location'));`
        correct: false
    help: |
      The `followRedirect()` method explicitly tells the client to follow the redirect from the last response.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      Which of the following is a valid way to assert that the value of a form input with a given name does NOT equal the expected value?
    answers:
      -
        value: >
          `$this->assertInputValueNotSame('username', 'admin');`
        correct: true
      -
        value: >
          `$this->assertInputValueDifferent('username', 'admin');`
        correct: false
      -
        value: >
          `$crawler->filter('input[name="username"]')->attr('value') !== 'admin';`
        correct: false
      -
        value: >
          `$this->assertNoInputValue('username', 'admin');`
        correct: false
    help: |
      `assertInputValueNotSame()` is the direct assertion for this purpose.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `getTypeExtensions()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      -
        value: >
          To return a list of custom form type extensions to be loaded for integration tests.
        correct: true
      -
        value: >
          To get the default form type extensions.
        correct: false
      -
        value: >
          To register new form type extensions globally.
        correct: false
      -
        value: >
          To disable specific form type extensions.
        correct: false
    help: |
      This method allows you to register custom form type extensions that modify the behavior of existing form types, enabling their testing within an integration context.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      Which of the following is the correct way to assert that the checkbox with the given name is NOT checked?
    answers:
      -
        value: >
          `$this->assertCheckboxNotChecked('newsletter_opt_in');`
        correct: true
      -
        value: >
          `$this->assertCheckboxUnchecked('newsletter_opt_in');`
        correct: false
      -
        value: >
          `$crawler->filter('#newsletter_opt_in')->isChecked() === false;`
        correct: false
      -
        value: >
          `$this->assertSelectorAttributeNotContains('input[name="newsletter_opt_in"]', 'checked', 'checked');`
        correct: true
    help: |
      Both `assertCheckboxNotChecked()` and checking for the absence of the 'checked' attribute are valid ways to assert that a checkbox is unchecked.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `getTypeGuessers()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      -
        value: >
          To return a list of custom form type guessers required for integration tests.
        correct: true
      -
        value: >
          To guess the type of a form field based on its data.
        correct: false
      -
        value: >
          To register new form type guessers globally.
        correct: false
      -
        value: >
          To disable specific form type guessers.
        correct: false
    help: |
      This method allows you to register custom form type guessers that help the form component determine the best form type for a given property, enabling their testing.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      When running tests with `simple-phpunit`, what does `SYMFONY_DEPRECATIONS_HELPER='weak_vendors'` achieve?
    answers:
      -
        value: >
          It ignores deprecations from all vendor packages.
        correct: false
      -
        value: >
          It only reports deprecations from your own code, ignoring those from vendor packages.
        correct: true
      -
        value: >
          It reports deprecations from vendor packages as warnings instead of errors.
        correct: false
      -
        value: >
          It enforces strict deprecation checks for vendor packages.
        correct: false
    help: |
      `weak_vendors` is a setting for the deprecation helper that allows you to focus on deprecations in your own codebase, ignoring those originating from third-party vendors.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      What is the main benefit of using `static::getContainer()` in `KernelTestCase` over `$this->getContainer()`?
    answers:
      -
        value: >
          `static::getContainer()` is faster.
        correct: false
      -
        value: >
          `static::getContainer()` ensures the container is always the same instance across all tests in the class.
        correct: false
      -
        value: >
          `static::getContainer()` is the correct way to access the container after `self::bootKernel()` as the container is static.
        correct: true
      -
        value: >
          `static::getContainer()` allows access to private services.
        correct: false
    help: |
      The container in `KernelTestCase` is managed statically, so `static::getContainer()` is the correct way to access it after the kernel has been booted.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: >
      When testing a Symfony application, what is the primary role of `Symfony\\Component\\BrowserKit\\HttpBrowser` (or `KernelBrowser` which extends it)?
    answers:
      -
        value: >
          To render HTML pages in a real browser.
        correct: false
      -
        value: >
          To simulate a web browser's behavior, sending HTTP requests and processing responses.
        correct: true
      -
        value: >
          To manage browser cookies and sessions.
        correct: false
      -
        value: >
          To interact with JavaScript on the client-side.
        correct: false
    help: |
      The `HttpBrowser` (or `KernelBrowser` in Symfony tests) acts as a headless browser, allowing you to programmatically make HTTP requests and inspect the responses.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: >
      Which of the following is the correct way to assert that the given header does NOT contain the expected value on the response?
    answers:
      -
        value: >
          `$this->assertResponseHeaderNotSame('Content-Type', 'text/html');`
        correct: true
      -
        value: >
          `$this->assertResponseHeaderDifferent('Content-Type', 'text/html');`
        correct: false
      -
        value: >
          `$this->assertResponseHeaderDoesNotContain('Content-Type', 'text/html');`
        correct: false
      -
        value: >
          `$client->getResponse()->headers->get('Content-Type') !== 'text/html';`
        correct: false
    help: |
      `assertResponseHeaderNotSame()` is the dedicated assertion for checking that a header's value is not exactly the expected value.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `bootKernel()` method in `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      -
        value: >
          To start the web server for functional tests.
        correct: false
      -
        value: >
          To initialize the Symfony application kernel for the current test, ensuring a clean state.
        correct: true
      -
        value: >
          To load all bundles defined in the application.
        correct: false
      -
        value: >
          To clear the cache and log files.
        correct: false
    help: |
      `bootKernel()` is crucial for `KernelTestCase` as it sets up the Symfony environment, making services and bundles available for testing in isolation.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      When using `Symfony\\Component\\Clock\\MockClock`, which method allows you to advance the mocked time by a specific duration, as if time had passed normally?
    answers:
      -
        value: >
          `$clock->advance(600);`
        correct: false
      -
        value: >
          `$clock->sleep(600);`
        correct: true
      -
        value: >
          `$clock->add(new DateInterval('PT10M'));`
        correct: false
      -
        value: >
          `$clock->forward(600);`
        correct: false
    help: |
      The `sleep()` method on `MockClock` instantly advances the mocked time by the specified number of seconds, simulating the passage of time.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      What is the main purpose of `Symfony\\Component\\DomCrawler\\Crawler` in functional tests?
    answers:
      -
        value: >
          To make HTTP requests to the application.
        correct: false
      -
        value: >
          To parse HTML and XML content, allowing navigation and selection of elements.
        correct: true
      -
        value: >
          To execute JavaScript on the client-side.
        correct: false
      -
        value: >
          To manage form submissions.
        correct: false
    help: |
      The `Crawler` object provides a powerful API for traversing and manipulating the DOM of an HTML or XML document obtained from a response.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      Which of the following is a valid way to assert that the first element matching a given selector does contain the expected text?
    answers:
      -
        value: >
          `$this->assertSelectorTextContains('div.message', 'Success');`
        correct: true
      -
        value: >
          `$crawler->filter('div.message')->text() === 'Success';`
        correct: false
      -
        value: >
          `$this->assertContainsText('div.message', 'Success');`
        correct: false
      -
        value: >
          `$this->assertSelectorTextSame('div.message', 'Success');`
        correct: false
    help: |
      `assertSelectorTextContains()` checks if the text content of the first matching element includes the specified text. `assertSelectorTextSame()` would require an exact match.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `SYMFONY_DEPRECATIONS_HELPER` environment variable?
    answers:
      -
        value: >
          To enable or disable deprecation notices in the Symfony application.
        correct: false
      -
        value: >
          To configure the behavior of the Symfony PHPUnit bridge's deprecation handling.
        correct: true
      -
        value: >
          To automatically fix deprecated code in your project.
        correct: false
      -
        value: >
          To generate a report of all deprecated services.
        correct: false
    help: |
      This environment variable allows fine-grained control over how deprecation notices are handled during test runs, including ignoring them, failing on them, or generating baselines.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      When testing a Symfony application, what is the primary purpose of the `Response` object returned by the test client?
    answers:
      -
        value: >
          To represent the HTTP request sent by the client.
        correct: false
      -
        value: >
          To provide access to the HTTP response received from the application, including status code, headers, and content.
        correct: true
      -
        value: >
          To store session data.
        correct: false
      -
        value: >
          To interact with the database.
        correct: false
    help: |
      The `Response` object encapsulates all information about the HTTP response, which is crucial for making assertions about the application's output.
      https://symfony.com/doc/current/testing.html#request-and-response-objects

  -
    question: >
      Which of the following is a valid way to assert that the given header does contain the expected value on the response?
    answers:
      -
        value: >
          `$this->assertResponseHeaderSame('Content-Type', 'application/json');`
        correct: true
      -
        value: >
          `$this->assertResponseHeaderContains('Content-Type', 'application/json');`
        correct: false
      -
        value: >
          `$client->getResponse()->headers->get('Content-Type') === 'application/json';`
        correct: true
      -
        value: >
          `$this->assertHeaderEquals('Content-Type', 'application/json');`
        correct: false
    help: |
      Both `assertResponseHeaderSame()` and directly comparing the header value from the response object are valid ways to check a header's exact value.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `Symfony\\Bridge\\PhpUnit\\CoverageListener` when configured with a custom SUT (System Under Test) solver?
    answers:
      -
        value: >
          To automatically generate unit tests for the specified SUT.
        correct: false
      -
        value: >
          To provide a custom logic for associating test methods with the specific code they cover, improving coverage accuracy.
        correct: true
      -
        value: >
          To exclude certain files from code coverage analysis.
        correct: false
      -
        value: >
          To integrate with external code coverage tools.
        correct: false
    help: |
      A custom SUT solver allows you to define how the `CoverageListener` determines which code is being tested by a particular test, which is useful for complex project structures where default logic might not suffice.
      https://symfony.com/doc/current/components/phpunit_bridge.html#coverage-listener

  -
    question: >
      When using `Symfony\\Component\\Clock\\MockClock`, which method allows you to change the mocked time to a specific `DateTimeImmutable` or string representation?
    answers:
      -
        value: >
          `$clock->setTime('2023-01-01 10:00:00');`
        correct: false
      -
        value: >
          `$clock->modify('2023-01-01 10:00:00');`
        correct: true
      -
        value: >
          `$clock->setDateTime('2023-01-01 10:00:00');`
        correct: false
      -
        value: >
          `$clock->jumpTo('2023-01-01 10:00:00');`
        correct: false
    help: |
      The `modify()` method allows you to set the mocked clock to a specific point in time, accepting any format supported by `DateTimeImmutable::modify()`.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      What is the primary benefit of using `Symfony\\Component\\Panther\\PantherTestCase` for testing a JavaScript-heavy single-page application (SPA)?
    answers:
      -
        value: >
          It allows direct manipulation of the database.
        correct: false
      -
        value: >
          It can execute JavaScript, interact with dynamic DOM elements, and simulate user actions in a real browser.
        correct: true
      -
        value: >
          It is significantly faster than traditional functional tests.
        correct: false
      -
        value: >
          It provides built-in API mocking capabilities.
        correct: false
    help: |
      Panther's ability to control a real browser makes it ideal for testing SPAs where client-side JavaScript heavily influences the user experience and application state.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      When writing functional tests, how can you obtain the `Response` object that was received from the last client request?
    answers:
      -
        value: >
          `$client->getLastResponse();`
        correct: true
      -
        value: >
          `$client->getResponse();`
        correct: false
      -
        value: >
          `$client->getContainer()->get('request_stack')->getMasterRequest()->getResponse();`
        correct: false
      -
        value: >
          `$client->request('GET', '/')->getResponse();`
        correct: false
    help: |
      The `getLastResponse()` method on the test client returns the `Response` object from the most recent interaction.
      https://symfony.com/doc/current/testing.html#request-and-response-objects

  -
    question: >
      What is the purpose of the `assertAnySelectorTextContains()` assertion in Symfony's Crawler?
    answers:
      -
        value: >
          Asserts that the first element matching the given selector contains the expected text.
        correct: false
      -
        value: >
          Asserts that *any* element matching the given selector contains the expected text.
        correct: true
      -
        value: >
          Asserts that all elements matching the given selector contain the expected text.
        correct: false
      -
        value: >
          Asserts that no element matching the given selector contains the expected text.
        correct: false
    help: |
      Unlike `assertSelectorTextContains()` which checks only the first match, `assertAnySelectorTextContains()` passes if at least one element matching the selector contains the text.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      Which of the following is the correct way to assert that the first element matching a given selector does equal the expected text content?
    answers:
      -
        value: >
          `$this->assertSelectorTextSame('p.greeting', 'Hello!');`
        correct: true
      -
        value: >
          `$this->assertSelectorTextEquals('p.greeting', 'Hello!');`
        correct: false
      -
        value: >
          `$crawler->filter('p.greeting')->text() === 'Hello!';`
        correct: false
      -
        value: >
          `$this->assertTextEquals('p.greeting', 'Hello!');`
        correct: false
    help: |
      `assertSelectorTextSame()` asserts an exact match for the text content of the first element found by the selector.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `assertAnySelectorTextSame()` assertion in Symfony's Crawler?
    answers:
      -
        value: >
          Asserts that the first element matching the given selector has the exact expected text.
        correct: false
      -
        value: >
          Asserts that *any* element matching the given selector has the exact expected text.
        correct: true
      -
        value: >
          Asserts that all elements matching the given selector have the exact expected text.
        correct: false
      -
        value: >
          Asserts that no element matching the given selector has the exact expected text.
        correct: false
    help: |
      `assertAnySelectorTextSame()` is useful when you need to confirm that at least one instance of an element has a precise text content.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Symfony application, what is the primary role of the `KernelBrowser` (the object returned by `static::createClient()`)?
    answers:
      -
        value: >
          To provide a direct interface to the Symfony kernel's internal services.
        correct: false
      -
        value: >
          To simulate a web browser's interactions with your application over HTTP.
        correct: true
      -
        value: >
          To manage database connections for functional tests.
        correct: false
      -
        value: >
          To execute JavaScript code within the test environment.
        correct: false
    help: |
      The `KernelBrowser` is the core component for functional testing, allowing you to send requests, submit forms, and navigate your application as a user would.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: >
      Which of the following is a valid assertion to check if an element's attribute contains a specific value using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorAttributeWillContain('.price', 'data-old-price', '€25');`
        correct: true
      -
        value: >
          `$this->assertAttributeWillContain('.price', 'data-old-price', '€25');`
        correct: false
      -
        value: >
          `$client->waitForAttributeToContain('.price', 'data-old-price', '€25');`
        correct: false
      -
        value: >
          `$this->assertSelectorAttributeContainsFuture('.price', 'data-old-price', '€25');`
        correct: false
    help: |
      `assertSelectorAttributeWillContain()` is a future assertion in Panther that waits for an element's attribute to contain a specific value.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist` for Panther tests?
    answers:
      -
        value: >
          It provides a built-in web server for serving static assets during tests.
        correct: false
      -
        value: >
          It automatically starts and stops a web server for your application during the test suite execution.
        correct: true
      -
        value: >
          It enables remote debugging of the Panther browser.
        correct: false
      -
        value: >
          It configures the port on which the Panther browser runs.
        correct: false
    help: |
      The `ServerExtension` simplifies Panther test setup by managing the lifecycle of the web server that serves your Symfony application to the Panther browser.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually become visible using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillBeVisible('.loader');`
        correct: true
      -
        value: >
          `$this->assertVisibleFuture('.loader');`
        correct: false
      -
        value: >
          `$client->waitForVisibility('.loader');`
        correct: false
      -
        value: >
          `$this->assertElementWillBeVisible('.loader');`
        correct: false
    help: |
      `assertSelectorWillBeVisible()` is a future assertion that waits for an element matching the selector to become visible within a timeout.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When running tests with `simple-phpunit`, what does `SYMFONY_DEPRECATIONS_HELPER='max[direct]=0'` achieve?
    answers:
      -
        value: >
          It ignores all deprecations that are directly triggered by your code.
        correct: false
      -
        value: >
          It fails the test if any deprecation is directly triggered by your code, ignoring indirect ones.
        correct: true
      -
        value: >
          It limits the number of direct deprecations reported to zero.
        correct: false
      -
        value: >
          It reports only direct deprecations.
        correct: false
    help: |
      `max[direct]=0` is a powerful setting for the deprecation helper that makes your test suite fail if your own code directly triggers any deprecation, encouraging immediate fixes.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually be removed from the DOM using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillNotExist('.popin');`
        correct: true
      -
        value: >
          `$this->assertElementWillDisappear('.popin');`
        correct: false
      -
        value: >
          `$client->waitForStaleness('.popin');`
        correct: false
      -
        value: >
          `$this->assertSelectorRemoved('.popin');`
        correct: false
    help: |
      `assertSelectorWillNotExist()` is a future assertion that waits for an element matching the selector to be removed from the DOM.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the primary purpose of the `Symfony\\Component\\Panther\\PantherTestCase` class?
    answers:
      -
        value: >
          To run unit tests in isolation.
        correct: false
      -
        value: >
          To enable end-to-end testing of web applications, including JavaScript execution, using a real browser.
        correct: true
      -
        value: >
          To provide a simplified way to test REST APIs.
        correct: false
      -
        value: >
          To generate screenshots of web pages for documentation.
        correct: false
    help: |
      `PantherTestCase` is designed for robust end-to-end testing, allowing you to interact with your web application as a real user would, including client-side scripting.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      When testing a multi-domain application with Symfony Panther, what is the purpose of the `external_base_uri` option in `createPantherClient()`?
    answers:
      -
        value: >
          To specify the base URL for external API calls.
        correct: false
      -
        value: >
          To define the URL of the primary domain for the application under test.
        correct: false
      -
        value: >
          To specify the base URL for a secondary domain being tested within the same application.
        correct: true
      -
        value: >
          To configure the URL of the Panther browser instance.
        correct: false
    help: |
      `external_base_uri` allows you to tell Panther to target a different domain for specific tests, which is essential for testing applications that span multiple domains.
      https://symfony.com/doc/current/testing/end_to_end.html#testing-multi-domain-applications

  -
    question: >
      Which of the following describes a key feature of `Symfony\\Component\\Panther\\ServerExtension`?
    answers:
      -
        value: >
          It automatically captures screenshots on test failures.
        correct: true
      -
        value: >
          It provides a built-in database server for tests.
        correct: false
      -
        value: >
          It enables parallel execution of Panther tests.
        correct: false
      -
        value: >
          It integrates with external CI/CD pipelines.
        correct: false
    help: |
      Beyond managing the web server, the `ServerExtension` also automatically takes screenshots when a Panther test fails, which is invaluable for debugging.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      What is the primary benefit of using `Symfony\\Component\\Clock\\MockClock` for time-sensitive tests compared to relying on `ClockMock` from the PHPUnit bridge?
    answers:
      -
        value: >
          `MockClock` is a more modern and flexible API for controlling time.
        correct: true
      -
        value: >
          `MockClock` works without requiring any PHPUnit listener configuration.
        correct: true
      -
        value: >
          `MockClock` can only mock specific time functions, while `ClockMock` mocks all of them.
        correct: false
      -
        value: >
          `MockClock` is specifically designed for functional tests, while `ClockMock` is for unit tests.
        correct: false
    help: |
      `MockClock` provides a more explicit and object-oriented way to control time in your tests, offering greater flexibility and not relying on PHPUnit listeners.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      When using `Symfony\\Component\\Panther\\PantherTestCase`, what is the purpose of the `waitFor()` method?
    answers:
      -
        value: >
          To pause the test execution for a fixed amount of time.
        correct: false
      -
        value: >
          To wait for an element matching a given selector to be attached to the DOM.
        correct: true
      -
        value: >
          To wait for a specific network request to complete.
        correct: false
      -
        value: >
          To wait for the entire page to fully load.
        correct: false
    help: |
      `waitFor()` is a client-side waiting method that ensures an element is present in the DOM before proceeding with assertions, crucial for asynchronous content loading.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\PantherTestCase`?
    answers:
      -
        value: >
          To run unit tests in isolation.
        correct: false
      -
        value: >
          To enable end-to-end testing of web applications, including JavaScript execution, using a real browser.
        correct: true
      -
        value: >
          To provide a simplified way to test REST APIs.
        correct: false
      -
        value: >
          To generate screenshots of web pages for documentation.
        correct: false
    help: |
      `PantherTestCase` is designed for robust end-to-end testing, allowing you to interact with your web application as a real user would, including client-side scripting.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually be disabled using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillBeDisabled('[type="submit"]');`
        correct: true
      -
        value: >
          `$this->assertDisabledFuture('[type="submit"]');`
        correct: false
      -
        value: >
          `$client->waitForDisabled('[type="submit"]');`
        correct: false
      -
        value: >
          `$this->assertElementWillBeDisabled('[type="submit"]');`
        correct: false
    help: |
      `assertSelectorWillBeDisabled()` is a future assertion that waits for an element matching the selector to become disabled.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually be enabled using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillBeEnabled('[type="submit"]');`
        correct: true
      -
        value: >
          `$this->assertEnabledFuture('[type="submit"]');`
        correct: false
      -
        value: >
          `$client->waitForEnabled('[type="submit"]');`
        correct: false
      -
        value: >
          `$this->assertElementWillBeEnabled('[type="submit"]');`
        correct: false
    help: |
      `assertSelectorWillBeEnabled()` is a future assertion that waits for an element matching the selector to become enabled.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-servercategory: Automated Tests

questions:
  -
    question: >
      Which PHPUnit test class is typically used for unit testing individual components or services in isolation, without booting the full Symfony kernel?
    answers:
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`
        correct: false
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: true
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Panther\\PantherTestCase`
        correct: false
    help: |
      `PHPUnit\\Framework\\TestCase` is the standard base class for unit tests, allowing you to test code in isolation, often with mocked dependencies.
      https://symfony.com/doc/current/create_framework/unit_testing.html

  -
    question: |
      Given the following PHPUnit test for a `SalaryCalculator` service, what is the primary purpose of mocking `EntityManager` and `EntityRepository`?

      ```php
      // tests/Salary/SalaryCalculatorTest.php
      namespace App\\Tests\\Salary;

      use App\\Entity\\Employee;
      use App\\Salary\\SalaryCalculator;
      use Doctrine\\ORM\\EntityManager;
      use Doctrine\\ORM\\EntityRepository;
      use PHPUnit\\Framework\\TestCase;

      class SalaryCalculatorTest extends TestCase
      {
          public function testCalculateTotalSalary(): void
          {
              $employee = new Employee();
              $employee->setSalary(1000);
              $employee->setBonus(1100);

              $employeeRepository = $this->createMock(EntityRepository::class);
              $employeeRepository->expects($this->any())
                  ->method('find')
                  ->willReturn($employee);

              $entityManager = $this->createMock(EntityManager::class);
              $entityManager->expects($this->any())
                  ->method('getRepository')
                  ->willReturn($employeeRepository);

              $salaryCalculator = new SalaryCalculator($entityManager);
              $this->assertEquals(2100, $salaryCalculator->calculateTotalSalary(1));
          }
      }
      ```
    answers:
      -
        value: >
          To ensure the test interacts with a real database for accurate results.
        correct: false
      -
        value: >
          To test the `EntityManager` and `EntityRepository` classes themselves.
        correct: false
      -
        value: >
          To isolate the `SalaryCalculator` logic from database interactions, making it a true unit test.
        correct: true
      -
        value: >
          To speed up the test by bypassing the Symfony kernel boot process.
        correct: true
    help: |
      Mocking dependencies like `EntityManager` and `EntityRepository` in unit tests allows you to test the `SalaryCalculator` in isolation, without needing a real database connection or booting the full Symfony kernel. This makes the test faster and more focused on the unit's logic.
      https://symfony.com/doc/current/testing/database.html#unit-tests

  -
    question: >
      Which command is used to run all PHPUnit tests in a Symfony application?
    answers:
      -
        value: >
          `php bin/console test:run`
        correct: false
      -
        value: >
          `php bin/phpunit`
        correct: true
      -
        value: >
          `composer run-tests`
        correct: false
      -
        value: >
          `symfony run-tests`
        correct: false
    help: |
      The `php bin/phpunit` command, when executed from the project root, will run all tests configured in `phpunit.xml.dist`.
      https://symfony.com/doc/current/testing.html#running-tests

  -
    question: >
      Which Symfony test class should you extend for functional tests that require booting the Symfony kernel and interacting with the application as a whole, including making HTTP requests?
    answers:
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`
        correct: true
      -
        value: >
          `Symfony\\Component\\Panther\\PantherTestCase`
        correct: false
    help: |
      `WebTestCase` is the recommended base class for functional tests in Symfony, as it provides methods to create a test client and interact with the application's HTTP layer.
      https://symfony.com/doc/current/testing.html#functional-tests

  -
    question: >
      What is the purpose of the `static::createClient()` method in a `WebTestCase`?
    answers:
      -
        value: >
          To create a new instance of the Symfony kernel.
        correct: false
      -
        value: >
          To create a test browser client that acts like a real browser, allowing you to make HTTP requests.
        correct: true
      -
        value: >
          To establish a direct database connection for testing.
        correct: false
      -
        value: >
          To generate a unique test user for authentication.
        correct: false
    help: |
      `static::createClient()` initializes a `KernelBrowser` (the test client) that simulates HTTP requests to your application, allowing you to test controllers and the full request-response cycle.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: |
      After making a request with `$client->request('GET', '/some-url');`, which object is returned that allows you to traverse the HTML document and make assertions on its content?
    answers:
      -
        value: >
          `Symfony\\Component\\HttpFoundation\\Response`
        correct: false
      -
        value: >
          `Symfony\\Component\\BrowserKit\\Response`
        correct: false
      -
        value: >
          `Symfony\\Component\\DomCrawler\\Crawler`
        correct: true
      -
        value: >
          `Symfony\\Component\\HttpFoundation\\Request`
        correct: false
    help: |
      The `request()` method of the test client returns a `Crawler` object, which is used to select HTML elements and extract data from the response.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      Which of the following assertions can be used with the Symfony test client's response to check if the HTTP status code is in the 2xx range?
    answers:
      -
        value: >
          `$this->assertResponseStatusCode(200);`
        correct: false
      -
        value: >
          `$this->assertResponseIsSuccessful();`
        correct: true
      -
        value: >
          `$this->assertStatusCodeIsSuccessful();`
        correct: false
      -
        value: >
          `$this->assertResponseCode(2xx);`
        correct: false
    help: |
      The `assertResponseIsSuccessful()` method checks if the HTTP response status code is between 200 and 299 (inclusive).
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      To access services from the Dependency Injection Container within a `KernelTestCase` or `WebTestCase`, which static method should you use after booting the kernel?
    answers:
      -
        value: >
          `$this->getContainer()`
        correct: false
      -
        value: >
          `static::getContainer()`
        correct: true
      -
        value: >
          `$this->container()`
        correct: false
      -
        value: >
          `self::get('service_id')`
        correct: false
    help: |
      After calling `self::bootKernel()`, you can access the service container using `static::getContainer()` to retrieve services for testing.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: |
      You want to simulate a logged-in user for a functional test without going through the login form. Which method of the test client allows you to achieve this?
    answers:
      -
        value: >
          `$client->setLoggedInUser($user);`
        correct: false
      -
        value: >
          `$client->authenticate($user);`
        correct: false
      -
        value: >
          `$client->loginUser($user);`
        correct: true
      -
        value: >
          `$client->setUser($user);`
        correct: false
    help: |
      The `loginUser()` method on the test client allows you to simulate a user being logged in for the current request, bypassing the need to submit a login form.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      By default, the Symfony Profiler is disabled in the `test` environment to speed up tests. How can you enable it for a specific functional test to inspect collected data?
    answers:
      -
        value: >
          Set `framework.profiler.enabled: true` in `config/packages/test/framework.yaml`.
        correct: false
      -
        value: >
          Call `$client->enableProfiler();` before making the request.
        correct: true
      -
        value: >
          Add `#[EnableProfiler]` attribute to the test method.
        correct: false
      -
        value: >
          Set `APP_ENV=dev` for the test run.
        correct: false
    help: |
      While the profiler is enabled in the `test` environment (with `collect: false`), you need to call `$client->enableProfiler()` before a request to collect data for that specific request.
      https://symfony.com/doc/current/testing.html#the-profiler

  -
    question: >
      What is the primary benefit of using `dama/doctrine-test-bundle` in Symfony functional tests involving a database?
    answers:
      -
        value: >
          It automatically generates Doctrine entities from your database schema.
        correct: false
      -
        value: >
          It provides a graphical interface for inspecting database changes during tests.
        correct: false
      -
        value: >
          It automatically rolls back database transactions after each test, ensuring a clean state.
        correct: true
      -
        value: >
          It replaces your real database with an in-memory SQLite database.
        correct: false
    help: |
      The `dama/doctrine-test-bundle` is crucial for database-heavy functional tests as it ensures each test runs with a clean database state by wrapping each test in a transaction and rolling it back.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      When performing functional tests, how can you ensure that your tests use a separate database from your development or production environments?
    answers:
      -
        value: >
          By setting the `DATABASE_URL` environment variable in your `.env.test.local` file.
        correct: true
      -
        value: >
          By configuring a different database connection in `config/packages/doctrine.yaml`.
        correct: false
      -
        value: >
          By using an in-memory SQLite database by default.
        correct: false
      -
        value: >
          By manually creating a new database for each test run.
        correct: false
    help: |
      It's a best practice to configure a dedicated test database by overriding the `DATABASE_URL` in `.env.test.local` to prevent test data from affecting other environments.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      Which of the following commands is used to generate an HTML code coverage report after running PHPUnit tests?
    answers:
      -
        value: >
          `php bin/phpunit --coverage-html=report/`
        correct: true
      -
        value: >
          `php bin/phpunit --html-coverage=report/`
        correct: false
      -
        value: >
          `php bin/console coverage:generate --format=html`
        correct: false
      -
        value: >
          `php bin/phpunit --report=html`
        correct: false
    help: |
      The `--coverage-html` option with `php bin/phpunit` generates an HTML report of your code coverage, which can be viewed in a web browser. XDebug or PCOV is required.
      https://symfony.com/doc/current/create_framework/unit_testing.html#code-coverage

  -
    question: >
      What is the primary role of the `Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener`?
    answers:
      -
        value: >
          To provide additional assertions for Symfony-specific testing.
        correct: false
      -
        value: >
          To integrate Symfony's PHPUnit bridge functionalities, such as `ClockMock` and deprecation handling.
        correct: true
      -
        value: >
          To automatically generate test classes for Symfony entities.
        correct: false
      -
        value: >
          To manage the Symfony test client's lifecycle.
        correct: false
    help: |
      The `SymfonyTestsListener` is a key component of the PHPUnit bridge, enabling features like `ClockMock` and the deprecation helper by integrating with PHPUnit's event system.
      https://symfony.com/doc/current/components/phpunit_bridge.html#clockmock

  -
    question: |
      You have a time-sensitive test that uses `sleep()` and `Stopwatch`. How can you make this test reliable and prevent transient failures due to real-time variations when using the Symfony PHPUnit bridge?
    answers:
      -
        value: >
          By increasing the `sleep()` duration to a very large number.
        correct: false
      -
        value: >
          By adding the `@group time-sensitive` annotation to the test class or method.
        correct: true
      -
        value: >
          By disabling `ClockMock` in `phpunit.xml.dist`.
        correct: false
      -
        value: >
          By using `usleep()` instead of `sleep()`.
        correct: false
    help: |
      The `@group time-sensitive` annotation, when `SymfonyTestsListener` is enabled, automatically activates `ClockMock` for the test, ensuring time-based functions behave predictably.
      https://symfony.com/doc/current/components/phpunit_bridge.html#clockmock

  -
    question: >
      When running tests with the Symfony Deprecations Helper, how can you execute tests while ignoring deprecations listed in a specific baseline file?
    answers:
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='ignoreFile=./tests/baseline.json' php bin/phpunit`
        correct: false
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='baselineFile=./tests/allowed.json' ./vendor/bin/simple-phpunit`
        correct: true
      -
        value: >
          `PHPUNIT_IGNORE_DEPRECATIONS=./tests/baseline.json php bin/phpunit`
        correct: false
      -
        value: >
          `php bin/phpunit --ignore-deprecations=./tests/allowed.json`
        correct: false
    help: |
      The `SYMFONY_DEPRECATIONS_HELPER` environment variable with `baselineFile` allows you to specify a file containing known deprecations to be ignored during the test run.
      https://symfony.com/doc/current/components/phpunit_bridge.html#excluding-deprecations-from-the-output

  -
    question: >
      What is the primary purpose of `Symfony\\Component\\Clock\\MockClock`?
    answers:
      -
        value: >
          To measure the execution time of code blocks.
        correct: false
      -
        value: >
          To provide a mock implementation of a physical clock for testing time-sensitive logic.
        correct: true
      -
        value: >
          To synchronize time across distributed test environments.
        correct: false
      -
        value: >
          To generate random timestamps for test data.
        correct: false
    help: |
      `MockClock` allows you to control the current time in your tests, enabling reliable testing of time-sensitive logic without actual delays.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      Which of the following is a correct way to assert that an HTML element with a specific selector exists in the response using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertSelectorExists('.my-class');`
        correct: true
      -
        value: >
          `$crawler->filter('.my-class')->count() > 0;`
        correct: true
      -
        value: >
          `$this->assertElementExists('.my-class');`
        correct: false
      -
        value: >
          `$crawler->hasSelector('.my-class');`
        correct: false
    help: |
      The `assertSelectorExists()` method is a convenient assertion provided by `WebTestCase` to check for the presence of elements matching a CSS selector. You can also use the Crawler's `filter()` method and check the count.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When submitting a form in a functional test using the Crawler, which method should you use to get the form object from a button or input element?
    answers:
      -
        value: >
          `$crawler->selectButton('Submit')->form();`
        correct: true
      -
        value: >
          `$crawler->filter('button[type="submit"]')->getForm();`
        correct: false
      -
        value: >
          `$crawler->form('submit_button_id');`
        correct: false
      -
        value: >
          `$crawler->getFormByButton('Submit');`
        correct: false
    help: |
      You can obtain a `Form` object from a button or input element using the `form()` method on the `Crawler` node.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\PantherTestCase`?
    answers:
      -
        value: >
          To run unit tests in a separate process.
        correct: false
      -
        value: >
          To enable end-to-end testing of JavaScript-heavy applications using a real browser.
        correct: true
      -
        value: >
          To provide a simplified `WebTestCase` for API testing.
        correct: false
      -
        value: >
          To mock HTTP requests for external APIs.
        correct: false
    help: |
      `PantherTestCase` extends `WebTestCase` and provides a client that controls a real browser (like Chrome or Firefox) for end-to-end testing, including JavaScript execution.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      Which PHPUnit annotation is often used with Symfony Panther tests, especially when testing multi-domain applications, to ensure test isolation?
    answers:
      -
        value: >
          `@isolated`
        correct: false
      -
        value: >
          `@runInSeparateProcess`
        correct: true
      -
        value: >
          `@separateProcess`
        correct: false
      -
        value: >
          `@threadSafe`
        correct: false
    help: |
      The `@runInSeparateProcess` annotation ensures that each test runs in its own PHP process, which is crucial for isolating tests that might interfere with each other, such as those involving different domains in Panther.
      https://symfony.com/doc/current/testing/end_to_end.html#testing-multi-domain-applications

  -
    question: >
      When using Symfony Panther, what is the purpose of "future assertions" like `assertSelectorWillExist()`?
    answers:
      -
        value: >
          To assert conditions that are expected to be true immediately.
        correct: false
      -
        value: >
          To assert conditions that will eventually become true after asynchronous operations.
        correct: true
      -
        value: >
          To assert conditions that were true in a previous state of the application.
        correct: false
      -
        value: >
          To assert conditions that are expected to fail in the future.
        correct: false
    help: |
      Future assertions in Panther are designed for testing dynamic UIs and AJAX-driven content, allowing the test to wait until a condition (e.g., an element appearing) is met within a timeout.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      How can you enable interactive debug mode for Symfony Panther tests, pausing on failure to allow manual browser inspection?
    answers:
      -
        value: >
          `PANTHER_DEBUG=1 php bin/phpunit`
        correct: false
      -
        value: >
          `PANTHER_NO_HEADLESS=1 bin/phpunit --debug`
        correct: true
      -
        value: >
          `php bin/phpunit --panther-interactive`
        correct: false
      -
        value: >
          `$client->debug();` in the test.
        correct: false
    help: |
      Setting `PANTHER_NO_HEADLESS=1` and running PHPUnit with `--debug` will open a visible browser window and pause on test failures, allowing for interactive debugging.
      https://symfony.com/doc/current/testing/end_to_end.html#interactive-debug-mode

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid way to assert that the response is a redirect to a specific location using the Symfony test client?
    answers:
      -
        value: >
          `$this->assertResponseRedirects('/login');`
        correct: true
      -
        value: >
          `$this->assertRedirectTo('/login');`
        correct: false
      -
        value: >
          `$this->assertResponseStatusCodeSame(302, '/login');`
        correct: false
      -
        value: >
          `$this->assertRedirectsTo('/login');`
        correct: false
    help: |
      The `assertResponseRedirects()` method allows you to assert that the response is a redirect and optionally check the target location and status code.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the default behavior of the Symfony test client regarding redirects after a request?
    answers:
      -
        value: >
          It automatically follows all redirects.
        correct: false
      -
        value: >
          It does not follow redirects by default; you must explicitly follow them.
        correct: true
      -
        value: >
          It asks for user confirmation before following redirects.
        correct: false
      -
        value: >
          It only follows redirects with a 301 status code.
        correct: false
    help: |
      By default, the test client does not automatically follow redirects. You need to use `$client->followRedirect()` or `$client->followRedirects()` to handle them.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      When writing functional tests, how can you obtain the `Request` object that was sent during the last client request?
    answers:
      -
        value: >
          `$client->getLastRequest();`
        correct: true
      -
        value: >
          `$client->getRequest();`
        correct: false
      -
        value: >
          `$client->getContainer()->get('request_stack')->getCurrentRequest();`
        correct: false
      -
        value: >
          `$client->getResponse()->getRequest();`
        correct: false
    help: |
      The `getLastRequest()` method on the test client returns the `Request` object from the last interaction.
      https://symfony.com/doc/current/testing.html#request-and-response-objects

  -
    question: >
      What is the purpose of `Symfony\\Bridge\\PhpUnit\\CoverageListener`?
    answers:
      -
        value: >
          To provide a graphical interface for code coverage reports.
        correct: false
      -
        value: >
          To automatically add `@covers` annotations to test classes for accurate code coverage reporting.
        correct: true
      -
        value: >
          To optimize the performance of code coverage generation.
        correct: false
      -
        value: >
          To integrate code coverage with continuous integration platforms.
        correct: false
    help: |
      The `CoverageListener` helps in generating more accurate code coverage reports by automatically inferring and adding `@covers` annotations based on the test class and method names.
      https://symfony.com/doc/current/components/phpunit_bridge.html#coverage-listener

  -
    question: >
      When configuring the Symfony Profiler for the `test` environment, what does setting `collect: false` under `framework.profiler` achieve?
    answers:
      -
        value: >
          It completely disables the profiler, preventing any data collection.
        correct: false
      -
        value: >
          It enables the profiler but prevents it from collecting data by default, requiring explicit enabling per test.
        correct: true
      -
        value: >
          It collects only summary data, not detailed profiling information.
        correct: false
      -
        value: >
          It forces the profiler to collect data for all requests, regardless of test settings.
        correct: false
    help: |
      Setting `collect: false` means the profiler is enabled but won't collect data unless `client->enableProfiler()` is called for a specific request, which is useful for performance in tests.
      https://symfony.com/doc/current/testing/profiling.html#enabling-the-profiler

  -
    question: >
      Which assertion should you use to check if a specific header is present in the HTTP response?
    answers:
      -
        value: >
          `$this->assertResponseHasHeader('Content-Type');`
        correct: true
      -
        value: >
          `$this->assertHasHeader('Content-Type');`
        correct: false
      -
        value: >
          `$this->assertResponseHeaderExists('Content-Type');`
        correct: false
      -
        value: >
          `$this->assertHeaderPresent('Content-Type');`
        correct: false
    help: |
      The `assertResponseHasHeader()` method is used to verify the presence of a specific header in the HTTP response.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the primary purpose of the `make:test` command from SymfonyMakerBundle?
    answers:
      -
        value: >
          To run existing tests.
        correct: false
      -
        value: >
          To generate boilerplate code for new test classes, including `WebTestCase` and `KernelTestCase` types.
        correct: true
      -
        value: >
          To analyze test coverage.
        correct: false
      -
        value: >
          To install testing dependencies.
        correct: false
    help: |
      The `make:test` command is a convenient way to quickly generate a new test class with the correct boilerplate, saving time and ensuring adherence to Symfony's testing conventions.
      https://symfony.com/doc/current/testing.html#creating-a-test-class

  -
    question: >
      When performing a "smoke test" on your application's URLs, what is the main goal?
    answers:
      -
        value: >
          To verify the functionality of all forms on every page.
        correct: false
      -
        value: >
          To check if all public URLs load successfully and return a 2xx status code.
        correct: true
      -
        value: >
          To test the performance of database queries on all pages.
        correct: false
      -
        value: >
          To ensure all JavaScript on the page is executing correctly.
        correct: false
    help: |
      A smoke test quickly verifies that the most critical functions of an application are working, typically by checking if key URLs are accessible and return successful responses.
      https://symfony.com/doc/current/best_practices.html#smoke-tests

  -
    question: >
      Which of the following is the correct way to assert that a specific text is contained within an element matching a CSS selector using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertSelectorTextContains('h1', 'Hello World');`
        correct: true
      -
        value: >
          `$crawler->filter('h1')->text()->contains('Hello World');`
        correct: false
      -
        value: >
          `$this->assertTextContains('h1', 'Hello World');`
        correct: false
      -
        value: >
          `$crawler->textContains('h1', 'Hello World');`
        correct: false
    help: |
      `assertSelectorTextContains()` is a convenient assertion provided by `WebTestCase` to check if the text content of an element matches a given string.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the primary benefit of using `doctrine/doctrine-fixtures-bundle` in Symfony tests?
    answers:
      -
        value: >
          It allows you to define and load dummy data into your database for testing.
        correct: true
      -
        value: >
          It provides a way to mock Doctrine entities without a database.
        correct: false
      -
        value: >
          It automatically generates migrations for your database schema.
        correct: false
      -
        value: >
          It helps in analyzing the performance of Doctrine queries.
        correct: false
    help: |
      Doctrine Fixtures Bundle allows you to easily create and load consistent test data into your database, ensuring reproducible test environments.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      When testing a console command, what method should you call on the `Application` object to ensure you can retrieve the command's output and exit code for assertions?
    answers:
      -
        value: >
          `$application->runInBackground(true);`
        correct: false
      -
        value: >
          `$application->setAutoExit(false);`
        correct: true
      -
        value: >
          `$application->disableExit();`
        correct: false
      -
        value: >
          `$application->setInteractive(false);`
        correct: false
    help: |
      Setting `setAutoExit(false)` on the `Application` instance prevents the application from exiting immediately after running a command, allowing the `ApplicationTester` to capture output and exit code.
      https://symfony.com/doc/current/console.html#testing-commands

  -
    question: >
      Which class is created by the `loginUser()` method and stored in the session of the test client during functional tests?
    answers:
      -
        value: >
          `Symfony\\Component\\Security\\Core\\Authentication\\Token\\UsernamePasswordToken`
        correct: false
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\TestBrowserToken`
        correct: true
      -
        value: >
          `Symfony\\Component\\Security\\Core\\User\\UserInterface`
        correct: false
      -
        value: >
          `Symfony\\Component\\HttpFoundation\\Session\\Session`
        correct: false
    help: |
      The `loginUser()` method creates a special `TestBrowserToken` and stores it in the test client's session to simulate a logged-in user.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      What is the purpose of `Symfony\\Component\\HttpClient\\Response\\MockResponse` and `Symfony\\Component\\HttpClient\\MockHttpClient` when testing HTTP clients in Symfony?
    answers:
      -
        value: >
          To make real HTTP requests to external services during tests.
        correct: false
      -
        value: >
          To record and replay HTTP interactions for integration tests.
        correct: false
      -
        value: >
          To simulate HTTP responses without making actual network calls, enabling isolated and fast tests.
        correct: true
      -
        value: >
          To optimize the performance of HTTP client calls in production.
        correct: false
    help: |
      `MockHttpClient` and `MockResponse` (or `HarFileResponseFactory`) allow you to mock HTTP client responses, making tests faster, more reliable, and independent of external services.
      https://symfony.com/doc/current/http_client.html#testing

  -
    question: >
      When writing a unit test for a custom Symfony Validator constraint, which base class should you extend?
    answers:
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`
        correct: true
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase`
        correct: true
    help: |
      For single constraints, extend `ConstraintValidatorTestCase`. For compound constraints (constraints composed of other constraints), extend `CompoundConstraintTestCase`.
      https://symfony.com/doc/current/validation/custom_constraint.html#testing-the-constraint

  -
    question: >
      How can you configure a less resource-intensive password hasher specifically for the `test` environment to speed up test execution?
    answers:
      -
        value: >
          By setting `security.password_hashers.App\\Entity\\User.algorithm: plaintext` in `config/packages/test/security.yaml`.
        correct: false
      -
        value: >
          By overriding the `password_hashers` configuration under `when@test` in `config/packages/security.yaml`.
        correct: true
      -
        value: >
          By using a custom password encoder service only for tests.
        correct: false
      -
        value: >
          Symfony automatically uses a faster hasher in the test environment.
        correct: false
    help: |
      You can define environment-specific configurations in Symfony. For the test environment, you can override the password hasher configuration to use a faster algorithm.
      https://symfony.com/doc/current/security/passwords.html#configuring-password-hashers

  -
    question: >
      What is the primary purpose of `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      -
        value: >
          To test individual PHP functions in isolation.
        correct: false
      -
        value: >
          To provide a base class for integration tests that need to boot the Symfony kernel and access its services.
        correct: true
      -
        value: >
          To simulate HTTP requests and responses.
        correct: false
      -
        value: >
          To manage database connections for all tests.
        correct: false
    help: |
      `KernelTestCase` is used for integration tests where you need to interact with Symfony services and the kernel, but not necessarily simulate full HTTP requests.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      Which of the following commands would you use to install the `symfony/test-pack` Composer package, which includes PHPUnit and other testing dependencies?
    answers:
      -
        value: >
          `composer install symfony/test-pack`
        correct: false
      -
        value: >
          `composer require symfony/test-pack`
        correct: false
      -
        value: >
          `composer require --dev symfony/test-pack`
        correct: true
      -
        value: >
          `symfony install:test-pack`
        correct: false
    help: |
      The `symfony/test-pack` should be installed as a development dependency using `composer require --dev`.
      https://symfony.com/doc/current/testing.html#installation

  -
    question: >
      When running PHPUnit tests, what is the effect of the `--coverage-text` option?
    answers:
      -
        value: >
          It generates a detailed HTML report of code coverage.
        correct: false
      -
        value: >
          It outputs a summary of code coverage directly to the console.
        correct: true
      -
        value: >
          It creates a text file with all covered lines of code.
        correct: false
      -
        value: >
          It only shows coverage for files that have 100% coverage.
        correct: false
    help: |
      The `--coverage-text` option provides a quick, console-based overview of your code coverage.
      https://symfony.com/doc/current/create_framework/unit_testing.html#code-coverage

  -
    question: >
      You are testing a form and want to assert that a checkbox with a specific name is checked. Which assertion method should you use with the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertCheckboxChecked('my_checkbox_name');`
        correct: true
      -
        value: >
          `$this->assertInputValueSame('my_checkbox_name', 'on');`
        correct: false
      -
        value: >
          `$crawler->filter('#my_checkbox_name')->isChecked();`
        correct: false
      -
        value: >
          `$this->assertSelectorAttributeContains('input[name="my_checkbox_name"]', 'checked', 'checked');`
        correct: false
    help: |
      The `assertCheckboxChecked()` method is a dedicated assertion for checking the state of a checkbox by its name.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the recommended approach for clearing the Symfony cache specifically for the `test` environment, especially on CI servers where `debug` is `false`?
    answers:
      -
        value: >
          Manually delete the `var/cache/test` directory before each test run.
        correct: false
      -
        value: >
          Use `(new Filesystem())->remove(__DIR__.'/../var/cache/test');` in your `setUp()` method.
        correct: true
      -
        value: >
          Run `php bin/console cache:clear --env=test` before each test.
        correct: false
      -
        value: >
          Symfony automatically clears the test cache.
        correct: false
    help: |
      Programmatically clearing the test cache using the Filesystem component ensures a fresh state, particularly when debug mode is off and the cache isn't automatically invalidated.
      https://symfony.com/doc/current/testing.html#clearing-the-cache

  -
    question: >
      When testing a custom form type, which base class should you extend to benefit from Symfony's form testing utilities?
    answers:
      -
        value: >
          `PHPUnit\\Framework\\TestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Form\\Test\\TypeTestCase`
        correct: true
      -
        value: >
          `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`
        correct: false
      -
        value: >
          `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`
        correct: true
    help: |
      `TypeTestCase` is the base class for testing individual form types, while `FormIntegrationTestCase` is for more complex scenarios involving multiple types or extensions.
      https://symfony.com/doc/current/form/unit_testing.html

  -
    question: >
      What is the purpose of the `getProfile()` method on the Symfony test client after enabling the profiler?
    answers:
      -
        value: >
          To retrieve the user's security profile.
        correct: false
      -
        value: >
          To get the collected data from the Symfony Profiler for the last request.
        correct: true
      -
        value: >
          To access the current request's performance metrics.
        correct: false
      -
        value: >
          To generate a new profiler token.
        correct: false
    help: |
      After a request, if the profiler was enabled, `getProfile()` allows you to retrieve the `Profile` object containing all collected data.
      https://symfony.com/doc/current/testing.html#the-profiler

  -
    question: >
      Which method of the Symfony test client allows you to submit a form by providing the form's button and an array of form values?
    answers:
      -
        value: >
          `$client->submitForm('Submit', ['field' => 'value']);`
        correct: true
      -
        value: >
          `$client->sendForm('Submit', ['field' => 'value']);`
        correct: false
      -
        value: >
          `$client->postForm('Submit', ['field' => 'value']);`
        correct: false
      -
        value: >
          `$client->clickButton('Submit', ['field' => 'value']);`
        correct: false
    help: |
      The `submitForm()` method simplifies form submission in functional tests by allowing you to specify the button text and an array of form field values.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: >
      When running tests with the Symfony Deprecations Helper, how can you generate a baseline file that lists all currently reported deprecations, which can then be used to ignore them in future runs?
    answers:
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='generateBaseline=./tests/baseline.json' ./vendor/bin/simple-phpunit`
        correct: true
      -
        value: >
          `php bin/console deprecations:baseline:generate`
        correct: false
      -
        value: >
          `./vendor/bin/simple-phpunit --generate-baseline=./tests/baseline.json`
        correct: false
      -
        value: >
          `SYMFONY_DEPRECATIONS_HELPER='dumpFile=./tests/baseline.json' php bin/phpunit`
        correct: false
    help: |
      Setting `SYMFONY_DEPRECATIONS_HELPER` with `generateBaseline` will create a JSON file containing all deprecations encountered during the test run.
      https://symfony.com/doc/current/components/phpunit_bridge.html#excluding-deprecations-from-the-output

  -
    question: >
      What is the primary benefit of using `HarFileResponseFactory` with `MockHttpClient` for testing Symfony's HTTP Client?
    answers:
      -
        value: >
          It records new HTTP interactions into HAR files.
        correct: false
      -
        value: >
          It allows replaying recorded HTTP interactions, ensuring realistic and reproducible tests without external dependencies.
        correct: true
      -
        value: >
          It converts HAR files into PHPUnit test cases.
        correct: false
      -
        value: >
          It provides real-time monitoring of HTTP client requests.
        correct: false
    help: |
      `HarFileResponseFactory` enables "replay testing" by using pre-recorded HAR files to generate mock responses, making tests deterministic and fast.
      https://symfony.com/doc/current/http_client.html#testing

  -
    question: >
      Which of the following is a valid way to assert that the page title is exactly "My Page Title" using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertPageTitleSame('My Page Title');`
        correct: true
      -
        value: >
          `$this->assertSelectorTextSame('title', 'My Page Title');`
        correct: true
      -
        value: >
          `$this->assertTitleEquals('My Page Title');`
        correct: false
      -
        value: >
          `$crawler->filter('title')->text() === 'My Page Title';`
        correct: false
    help: |
      Both `assertPageTitleSame()` and `assertSelectorTextSame('title', ...)` can be used to assert the exact content of the page title.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Doctrine repository using `KernelTestCase`, what is the recommended way to get the `EntityManager` instance?
    answers:
      -
        value: >
          `$this->getContainer()->get('doctrine.orm.entity_manager');`
        correct: false
      -
        value: >
          `static::getContainer()->get('doctrine')->getManager();`
        correct: true
      -
        value: >
          `$this->getDoctrine()->getManager();`
        correct: false
      -
        value: >
          `$this->entityManager;` (assuming it's a property initialized in `setUp`)
        correct: true
    help: |
      After booting the kernel, you can access the `EntityManager` via the container. It's common to store it as a protected property and initialize it in `setUp()`.
      https://symfony.com/doc/current/testing/database.html#functional-tests-for-doctrine-repositories

  -
    question: >
      What is the purpose of the `tearDown()` method in a PHPUnit test class extending `KernelTestCase` when dealing with Doctrine `EntityManager`?
    answers:
      -
        value: >
          To commit any pending database transactions.
        correct: false
      -
        value: >
          To close the `EntityManager` and set it to `null` to prevent memory leaks.
        correct: true
      -
        value: >
          To reset the application's state for the next test.
        correct: false
      -
        value: >
          To clear the Symfony cache.
        correct: false
    help: |
      It's recommended to close the `EntityManager` and nullify its reference in `tearDown()` to avoid memory leaks, especially when running many tests.
      https://symfony.com/doc/current/testing/database.html#functional-tests-for-doctrine-repositories

  -
    question: >
      Which of the following is NOT a valid assertion method provided by the Symfony test client for checking response headers?
    answers:
      -
        value: >
          `assertResponseHasHeader()`
        correct: false
      -
        value: >
          `assertResponseHeaderSame()`
        correct: false
      -
        value: >
          `assertResponseHeaderEquals()`
        correct: true
      -
        value: >
          `assertResponseNotHasHeader()`
        correct: false
    help: |
      `assertResponseHeaderEquals()` is not a standard assertion method. The correct ones are `assertResponseHasHeader()`, `assertResponseNotHasHeader()`, `assertResponseHeaderSame()`, and `assertResponseHeaderNotSame()`.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      When writing end-to-end tests with Symfony Panther, what is the primary advantage of using client-side waiting methods like `waitFor()` or `waitForElementToContain()`?
    answers:
      -
        value: >
          They speed up test execution by skipping unnecessary waits.
        correct: false
      -
        value: >
          They ensure tests are reliable by waiting for asynchronous JavaScript operations to complete before making assertions.
        correct: true
      -
        value: >
          They allow tests to run without a real browser.
        correct: false
      -
        value: >
          They automatically generate screenshots on test failures.
        correct: false
    help: |
      Client-side waiting methods are essential for testing dynamic web applications, as they prevent assertions from failing due to elements not being immediately present or visible after an AJAX call or animation.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      Which of the following is a correct way to run only tests within a specific directory using PHPUnit?
    answers:
      -
        value: >
          `php bin/phpunit --dir tests/Controller`
        correct: false
      -
        value: >
          `php bin/phpunit tests/Controller`
        correct: true
      -
        value: >
          `php bin/phpunit --path tests/Controller`
        correct: false
      -
        value: >
          `php bin/console test:run --dir=tests/Controller`
        correct: false
    help: |
      You can specify a directory path as an argument to `php bin/phpunit` to run tests only within that directory.
      https://symfony.com/doc/current/testing.html#run-specific-tests

  -
    question: >
      What is the purpose of the `users_in_memory` configuration under `security` in `config/packages/test/security.yaml`?
    answers:
      -
        value: >
          To define users that can log in through the application's login form.
        correct: false
      -
        value: >
          To provide a simple, in-memory user provider for functional tests, avoiding database interaction for test users.
        correct: true
      -
        value: >
          To store user sessions in memory during testing.
        correct: false
      -
        value: >
          To encrypt user passwords for test environments.
        correct: false
    help: |
      `users_in_memory` is a convenient way to define simple test users directly in your security configuration, especially for the test environment, for use with `loginUser()`.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      When using `KernelTestCase`, what does `self::bootKernel()` achieve?
    answers:
      -
        value: >
          It starts a web server for the application.
        correct: false
      -
        value: >
          It initializes the Symfony application kernel, making services and bundles available.
        correct: true
      -
        value: >
          It clears the application's cache.
        correct: false
      -
        value: >
          It creates a new database connection.
        correct: false
    help: |
      `bootKernel()` is essential for `KernelTestCase` as it sets up the Symfony environment, allowing access to the container and services.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      Which of the following is a valid way to assert that an input field with a specific name has a particular value using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertInputValueSame('my_field_name', 'expected_value');`
        correct: true
      -
        value: >
          `$crawler->filter('input[name="my_field_name"]')->attr('value') === 'expected_value';`
        correct: false
      -
        value: >
          `$this->assertFormValue('form_selector', 'my_field_name', 'expected_value');`
        correct: true
      -
        value: >
          `$this->assertInputHasValue('my_field_name', 'expected_value');`
        correct: false
    help: |
      Both `assertInputValueSame()` and `assertFormValue()` are provided for asserting input field values.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the primary reason for running `php bin/console --env=test doctrine:database:create` and `php bin/console --env=test doctrine:schema:create` before running database-dependent functional tests?
    answers:
      -
        value: >
          To create and initialize a dedicated database for the test environment.
        correct: true
      -
        value: >
          To migrate the production database schema to the test environment.
        correct: false
      -
        value: >
          To clear all data from the existing test database.
        correct: false
      -
        value: >
          To generate Doctrine entities from the database.
        correct: false
    help: |
      These commands ensure that a clean test database exists and has the correct schema before tests that interact with the database are run.
      https://symfony.com/doc/current/testing.html#database-testing

  -
    question: >
      When using `WebTestCase`, what is the purpose of the `$client->followRedirects()` method?
    answers:
      -
        value: >
          To manually follow a single redirect after a response.
        correct: false
      -
        value: >
          To configure the client to automatically follow all subsequent redirects.
        correct: true
      -
        value: >
          To prevent the client from following any redirects.
        correct: false
      -
        value: >
          To get the URL of the redirect target.
        correct: false
    help: |
      Calling `$client->followRedirects()` without arguments enables automatic redirect following for all subsequent requests made by that client instance.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      What is the main advantage of using a data provider for functional tests, such as in a smoke test for URLs?
    answers:
      -
        value: >
          It allows running tests in parallel.
        correct: false
      -
        value: >
          It enables running the same test method multiple times with different sets of data, reducing code duplication.
        correct: true
      -
        value: >
          It automatically generates test data.
        correct: false
      -
        value: >
          It provides a mechanism for mocking external services.
        correct: false
    help: |
      Data providers are a PHPUnit feature that allows a single test method to be executed multiple times with different arguments, which is ideal for testing a list of URLs or various input combinations.
      https://symfony.com/doc/current/best_practices.html#smoke-tests

  -
    question: >
      Which of the following is a valid way to assert that the HTTP response status code is exactly 404?
    answers:
      -
        value: >
          `$this->assertResponseStatusCodeSame(404);`
        correct: true
      -
        value: >
          `$this->assertResponseCode(404);`
        correct: false
      -
        value: >
          `$this->assertStatusCode(404);`
        correct: false
      -
        value: >
          `$this->assertEquals(404, $client->getResponse()->getStatusCode());`
        correct: true
    help: |
      Both `assertResponseStatusCodeSame()` and directly asserting the status code from the response object are valid ways to check the HTTP status.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `getTemplatePaths()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To define the paths where Twig templates for form themes are located.
        correct: true
      -
        value: >
          To retrieve the paths of all Twig templates in the application.
        correct: false
      -
        value: >
          To specify the directory for cached Twig templates.
        correct: false
      -
        value: >
          To return the path to the main application template.
        correct: false
    help: |
      `getTemplatePaths()` is an overridable method in `FormLayoutTestCase` that allows you to specify where your form theme Twig templates are located for testing purposes.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      When testing a custom form type, which method in `TypeTestCase` allows you to register additional form extensions for the test case?
    answers:
      -
        value: >
          `getExtensions()`
        correct: true
      -
        value: >
          `registerExtensions()`
        correct: false
      -
        value: >
          `addExtensions()`
        correct: false
      -
        value: >
          `getFormExtensions()`
        correct: false
    help: |
      The `getExtensions()` method in `TypeTestCase` can be overridden to return an array of `FormExtensionInterface` instances that should be registered for the current test.
      https://symfony.com/doc/current/form/unit_testing.html#registering-form-extensions

  -
    question: >
      Which of the following is a valid way to run a single PHPUnit test file?
    answers:
      -
        value: >
          `php bin/phpunit tests/Controller/MyControllerTest.php`
        correct: true
      -
        value: >
          `php bin/phpunit --file tests/Controller/MyControllerTest.php`
        correct: false
      -
        value: >
          `php bin/console test:file tests/Controller/MyControllerTest.php`
        correct: false
      -
        value: >
          `php bin/phpunit --test tests/Controller/MyControllerTest.php`
        correct: false
    help: |
      You can specify the path to a single test file as an argument to `php bin/phpunit` to run only the tests within that file.
      https://symfony.com/doc/current/testing.html#run-specific-tests

  -
    question: >
      What is the purpose of `Symfony\\Component\\Security\\Core\\User\\InMemoryUser` in functional tests?
    answers:
      -
        value: >
          To persist user data to a database during tests.
        correct: false
      -
        value: >
          To create a simple, temporary user object for authentication in tests without needing a real user entity or database.
        correct: true
      -
        value: >
          To encrypt user passwords for testing.
        correct: false
      -
        value: >
          To manage user roles and permissions.
        correct: false
    help: |
      `InMemoryUser` is a convenient class for creating simple user objects on the fly for testing purposes, especially when used with `loginUser()`.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      When testing a custom framework's exception handling, how would you typically simulate a `ResourceNotFoundException` to verify a 404 response?
    answers:
      -
        value: >
          By making a request to a non-existent URL.
        correct: false
      -
        value: >
          By mocking the URL matcher to throw the `ResourceNotFoundException`.
        correct: true
      -
        value: >
          By throwing the exception directly in the test method.
        correct: false
      -
        value: >
          By configuring the test environment to return 404 for all requests.
        correct: false
    help: |
      For unit testing a framework's exception handling, mocking the component that would throw the exception (like the URL matcher) is the correct approach to isolate the test.
      https://symfony.com/doc/current/create_framework/unit_testing.html#not-found-handling

  -
    question: >
      What is the significance of the `test:` configuration setting under `framework` in `config/packages/test/framework.yaml`?
    answers:
      -
        value: >
          It enables the Symfony Profiler by default.
        correct: false
      -
        value: >
          It loads services related to testing, such as `test.client`.
        correct: true
      -
        value: >
          It configures the test database connection.
        correct: false
      -
        value: >
          It sets the application environment to `test`.
        correct: false
    help: |
      The `test:` configuration setting ensures that testing-specific services, like the test client, are loaded in the test environment.
      https://symfony.com/doc/current/reference/configuration/framework.html#test

  -
    question: >
      Which of the following is a valid way to assert that an element matching a given selector does NOT exist in the response using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertSelectorNotExists('.my-class');`
        correct: true
      -
        value: >
          `$crawler->filter('.my-class')->count() === 0;`
        correct: true
      -
        value: >
          `$this->assertNoSelector('.my-class');`
        correct: false
      -
        value: >
          `$crawler->doesNotHaveSelector('.my-class');`
        correct: false
    help: |
      Both `assertSelectorNotExists()` and checking the count of filtered elements are valid ways to assert that an element is not present.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Symfony console command, how can you execute the command and capture its output and exit code?
    answers:
      -
        value: >
          Use `ApplicationTester` and its `execute()` method.
        correct: true
      -
        value: >
          Call the command's `run()` method directly.
        correct: false
      -
        value: >
          Use `Symfony\\Component\\Console\\Tester\\CommandTester`.
        correct: true
      -
        value: >
          Redirect stdout to a file and read it.
        correct: false
    help: |
      `ApplicationTester` and `CommandTester` are specifically designed for testing console commands, providing methods to execute commands and retrieve their output and exit codes.
      https://symfony.com/doc/current/console.html#testing-commands

  -
    question: >
      What is the purpose of the `getTypes()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      -
        value: >
          To return a list of custom form types to be loaded for integration tests.
        correct: true
      -
        value: >
          To retrieve the data types of form fields.
        correct: false
      -
        value: >
          To define the expected form types in a test.
        correct: false
      -
        value: >
          To get the names of all registered form types.
        correct: false
    help: |
      `getTypes()` allows you to register custom form types that your integration tests depend on.
      https://symfony.com/doc/current/form/unit_testing.html#registering-custom-form-types

  -
    question: >
      Which of the following is a key advantage of using `PantherTestCase` over `WebTestCase` for certain types of functional tests?
    answers:
      -
        value: >
          `PantherTestCase` is significantly faster for all types of tests.
        correct: false
      -
        value: >
          `PantherTestCase` can execute JavaScript and interact with dynamic content.
        correct: true
      -
        value: >
          `PantherTestCase` does not require a web server.
        correct: false
      -
        value: >
          `PantherTestCase` provides direct database access.
        correct: false
    help: |
      `PantherTestCase` uses a real browser, allowing it to handle JavaScript, AJAX, and other client-side interactions that `WebTestCase` (which simulates HTTP requests) cannot.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      When using the Symfony Profiler in tests, how can you retrieve a specific data collector, such as the `logger` collector?
    answers:
      -
        value: >
          `$profile->getCollector('logger');`
        correct: true
      -
        value: >
          `$profile->get('logger');`
        correct: false
      -
        value: >
          `$profile->getCollectorByType(LoggerCollector::class);`
        correct: false
      -
        value: >
          `$profile->findCollector('logger');`
        correct: false
    help: |
      The `getCollector()` method on the `Profile` object allows you to retrieve a specific data collector by its name.
      https://symfony.com/doc/current/testing.html#the-profiler

  -
    question: >
      What is the purpose of the `getTwigExtensions()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To return an array of Twig extensions to be loaded for the test environment.
        correct: true
      -
        value: >
          To get the file paths of Twig extensions.
        correct: false
      -
        value: >
          To enable or disable Twig extensions for tests.
        correct: false
      -
        value: >
          To configure the Twig cache directory.
        correct: false
    help: |
      This method allows you to register any Twig extensions that are necessary for rendering your form themes during tests.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      Which of the following describes the correct setup for running Symfony tests in a GitHub Actions workflow?
    answers:
      -
        value: >
          Checkout repository, install Composer dependencies, then run `bin/phpunit`.
        correct: true
      -
        value: >
          Install Composer dependencies, then checkout repository, then run `bin/phpunit`.
        correct: false
      -
        value: >
          Run `composer test`, then install dependencies, then checkout repository.
        correct: false
      -
        value: >
          Only `bin/phpunit` is needed, as GitHub Actions handles dependencies.
        correct: false
    help: |
      A typical GitHub Actions workflow for Symfony tests involves checking out the code, installing PHP dependencies via Composer, and then executing PHPUnit.
      https://symfony.com/doc/current/testing/end_to_end.html#github-actions

  -
    question: >
      What is the primary difference between a "unit test" and a "functional test" in Symfony?
    answers:
      -
        value: >
          Unit tests are written in PHP, while functional tests are written in JavaScript.
        correct: false
      -
        value: >
          Unit tests focus on individual components in isolation, while functional tests verify the application's behavior through its HTTP layer.
        correct: true
      -
        value: >
          Unit tests require a database, while functional tests do not.
        correct: false
      -
        value: >
          Unit tests are slower than functional tests.
        correct: false
    help: |
      Unit tests isolate small pieces of code, often using mocks, while functional tests simulate user interaction with the full application stack via HTTP requests.
      https://symfony.com/doc/current/testing.html#unit-tests-vs-functional-tests

  -
    question: >
      When testing a custom framework's request handling, how would you typically simulate a successful request to verify a 200 OK response?
    answers:
      -
        value: >
          By mocking the URL matcher to return a valid route and a controller.
        correct: true
      -
        value: >
          By sending a real HTTP request to the application.
        correct: false
      -
        value: >
          By directly calling the controller method.
        correct: false
      -
        value: >
          By setting the response status code to 200 manually.
        correct: false
    help: |
      For unit testing the framework's core request handling, you would mock the components that the framework interacts with (like the URL matcher and controller resolver) to simulate a successful routing and controller execution.
      https://symfony.com/doc/current/create_framework/unit_testing.html

  -
    question: >
      What is the purpose of the `getThemes()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      -
        value: >
          To return an array of form themes (e.g., Twig templates) to apply during the test.
        correct: true
      -
        value: >
          To define the default theme for all forms.
        correct: false
      -
        value: >
          To retrieve the currently active form themes.
        correct: false
      -
        value: >
          To register new Twig namespaces for themes.
        correct: false
    help: |
      This method allows you to specify which form themes should be loaded and applied when rendering forms within your Twig form layout tests.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      Which of the following is a valid way to assert that an input field with a specific name does NOT have a particular value using the Symfony Crawler?
    answers:
      -
        value: >
          `$this->assertInputValueNotSame('my_field_name', 'unexpected_value');`
        correct: true
      -
        value: >
          `$this->assertInputValueDifferent('my_field_name', 'unexpected_value');`
        correct: false
      -
        value: >
          `$crawler->filter('input[name="my_field_name"]')->attr('value') !== 'unexpected_value';`
        correct: false
      -
        value: >
          `$this->assertNoFormValue('form_selector', 'my_field_name');`
        correct: false
    help: |
      `assertInputValueNotSame()` is the direct assertion for checking that an input's value is not equal to a given value. `assertNoFormValue()` checks if a field has *no* value.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `getTypeExtensions()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      -
        value: >
          To return a list of custom form type extensions to be loaded for integration tests.
        correct: true
      -
        value: >
          To get the default form type extensions.
        correct: false
      -
        value: >
          To register new form type extensions globally.
        correct: false
      -
        value: >
          To disable specific form type extensions.
        correct: false
    help: |
      This method allows you to register custom form type extensions that modify the behavior of existing form types, enabling their testing within an integration context.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      Which of the following is the correct way to assert that the checkbox with the given name is NOT checked?
    answers:
      -
        value: >
          `$this->assertCheckboxNotChecked('newsletter_opt_in');`
        correct: true
      -
        value: >
          `$this->assertCheckboxUnchecked('newsletter_opt_in');`
        correct: false
      -
        value: >
          `$crawler->filter('#newsletter_opt_in')->isChecked() === false;`
        correct: false
      -
        value: >
          `$this->assertSelectorAttributeNotContains('input[name="newsletter_opt_in"]', 'checked', 'checked');`
        correct: true
    help: |
      Both `assertCheckboxNotChecked()` and checking for the absence of the 'checked' attribute are valid ways to assert that a checkbox is unchecked.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `getTypeGuessers()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      -
        value: >
          To return a list of custom form type guessers required for integration tests.
        correct: true
      -
        value: >
          To guess the type of a form field based on its data.
        correct: false
      -
        value: >
          To register new form type guessers globally.
        correct: false
      -
        value: >
          To disable specific form type guessers.
        correct: false
    help: |
      This method allows you to register custom form type guessers that help the form component determine the best form type for a given property, enabling their testing.
      https://symfony.com/doc/current/form/unit_testing.html#api-references

  -
    question: >
      When running tests with `simple-phpunit`, what does `SYMFONY_DEPRECATIONS_HELPER='weak_vendors'` achieve?
    answers:
      -
        value: >
          It ignores deprecations from all vendor packages.
        correct: false
      -
        value: >
          It only reports deprecations from your own code, ignoring those from vendor packages.
        correct: true
      -
        value: >
          It reports deprecations from vendor packages as warnings instead of errors.
        correct: false
      -
        value: >
          It enforces strict deprecation checks for vendor packages.
        correct: false
    help: |
      `weak_vendors` is a setting for the deprecation helper that allows you to focus on deprecations in your own codebase, ignoring those originating from third-party vendors.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      What is the main benefit of using `static::getContainer()` in `KernelTestCase` over `$this->getContainer()`?
    answers:
      -
        value: >
          `static::getContainer()` is faster.
        correct: false
      -
        value: >
          `static::getContainer()` ensures the container is always the same instance across all tests in the class.
        correct: false
      -
        value: >
          `static::getContainer()` is the correct way to access the container after `self::bootKernel()` as the container is static.
        correct: true
      -
        value: >
          `static::getContainer()` allows access to private services.
        correct: false
    help: |
      The container in `KernelTestCase` is managed statically, so `static::getContainer()` is the correct way to access it after the kernel has been booted.
      https://symfony.com/doc/current/testing.html#accessing-the-container

  -
    question: >
      When testing a Symfony application, what is the primary role of `Symfony\\Component\\BrowserKit\\HttpBrowser` (or `KernelBrowser` which extends it)?
    answers:
      -
        value: >
          To render HTML pages in a real browser.
        correct: false
      -
        value: >
          To simulate a web browser's behavior, sending HTTP requests and processing responses.
        correct: true
      -
        value: >
          To manage browser cookies and sessions.
        correct: false
      -
        value: >
          To interact with JavaScript on the client-side.
        correct: false
    help: |
      The `HttpBrowser` (or `KernelBrowser` in Symfony tests) acts as a headless browser, allowing you to programmatically make HTTP requests and inspect the responses.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: >
      Which of the following is the correct way to assert that the given header does NOT contain the expected value on the response?
    answers:
      -
        value: >
          `$this->assertResponseHeaderNotSame('Content-Type', 'text/html');`
        correct: true
      -
        value: >
          `$this->assertResponseHeaderDifferent('Content-Type', 'text/html');`
        correct: false
      -
        value: >
          `$this->assertResponseHeaderDoesNotContain('Content-Type', 'text/html');`
        correct: false
      -
        value: >
          `$client->getResponse()->headers->get('Content-Type') !== 'text/html';`
        correct: false
    help: |
      `assertResponseHeaderNotSame()` is the dedicated assertion for checking that a header's value is not exactly the expected value.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `bootKernel()` method in `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      -
        value: >
          To start the web server for functional tests.
        correct: false
      -
        value: >
          To initialize the Symfony application kernel for the current test, ensuring a clean state.
        correct: true
      -
        value: >
          To load all bundles defined in the application.
        correct: false
      -
        value: >
          To clear the cache and log files.
        correct: false
    help: |
      `bootKernel()` is crucial for `KernelTestCase` as it sets up the Symfony environment, making services and bundles available for testing in isolation.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      When using `Symfony\\Component\\Clock\\MockClock`, which method allows you to advance the mocked time by a specific duration, as if time had passed normally?
    answers:
      -
        value: >
          `$clock->advance(600);`
        correct: false
      -
        value: >
          `$clock->sleep(600);`
        correct: true
      -
        value: >
          `$clock->add(new DateInterval('PT10M'));`
        correct: false
      -
        value: >
          `$clock->forward(600);`
        correct: false
    help: |
      The `sleep()` method on `MockClock` instantly advances the mocked time by the specified number of seconds, simulating the passage of time.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      What is the main purpose of `Symfony\\Component\\DomCrawler\\Crawler` in functional tests?
    answers:
      -
        value: >
          To make HTTP requests to the application.
        correct: false
      -
        value: >
          To parse HTML and XML content, allowing navigation and selection of elements.
        correct: true
      -
        value: >
          To execute JavaScript on the client-side.
        correct: false
      -
        value: >
          To manage form submissions.
        correct: false
    help: |
      The `Crawler` object provides a powerful API for traversing and manipulating the DOM of an HTML or XML document obtained from a response.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      Which of the following is a valid way to assert that the first element matching a given selector does contain the expected text?
    answers:
      -
        value: >
          `$this->assertSelectorTextContains('div.message', 'Success');`
        correct: true
      -
        value: >
          `$crawler->filter('div.message')->text() === 'Success';`
        correct: false
      -
        value: >
          `$this->assertContainsText('div.message', 'Success');`
        correct: false
      -
        value: >
          `$this->assertSelectorTextSame('div.message', 'Success');`
        correct: false
    help: |
      `assertSelectorTextContains()` checks if the text content of the first matching element includes the specified text. `assertSelectorTextSame()` would require an exact match.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `SYMFONY_DEPRECATIONS_HELPER` environment variable?
    answers:
      -
        value: >
          To enable or disable deprecation notices in the Symfony application.
        correct: false
      -
        value: >
          To configure the behavior of the Symfony PHPUnit bridge's deprecation handling.
        correct: true
      -
        value: >
          To automatically fix deprecated code in your project.
        correct: false
      -
        value: >
          To generate a report of all deprecated services.
        correct: false
    help: |
      This environment variable allows fine-grained control over how deprecation notices are handled during test runs, including ignoring them, failing on them, or generating baselines.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      When testing a Symfony application, what is the primary purpose of the `Response` object returned by the test client?
    answers:
      -
        value: >
          To represent the HTTP request sent by the client.
        correct: false
      -
        value: >
          To provide access to the HTTP response received from the application, including status code, headers, and content.
        correct: true
      -
        value: >
          To store session data.
        correct: false
      -
        value: >
          To interact with the database.
        correct: false
    help: |
      The `Response` object encapsulates all information about the HTTP response, which is crucial for making assertions about the application's output.
      https://symfony.com/doc/current/testing.html#request-and-response-objects

  -
    question: >
      Which of the following is a valid way to assert that the given header does contain the expected value on the response?
    answers:
      -
        value: >
          `$this->assertResponseHeaderSame('Content-Type', 'application/json');`
        correct: true
      -
        value: >
          `$this->assertResponseHeaderContains('Content-Type', 'application/json');`
        correct: false
      -
        value: >
          `$client->getResponse()->headers->get('Content-Type') === 'application/json';`
        correct: true
      -
        value: >
          `$this->assertHeaderEquals('Content-Type', 'application/json');`
        correct: false
    help: |
      Both `assertResponseHeaderSame()` and directly comparing the header value from the response object are valid ways to check a header's exact value.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `Symfony\\Bridge\\PhpUnit\\CoverageListener` when configured with a custom SUT (System Under Test) solver?
    answers:
      -
        value: >
          To automatically generate unit tests for the specified SUT.
        correct: false
      -
        value: >
          To provide a custom logic for associating test methods with the specific code they cover, improving coverage accuracy.
        correct: true
      -
        value: >
          To exclude certain files from code coverage analysis.
        correct: false
      -
        value: >
          To integrate with external code coverage tools.
        correct: false
    help: |
      A custom SUT solver allows you to define how the `CoverageListener` determines which code is being tested by a particular test, which is useful for complex project structures where default logic might not suffice.
      https://symfony.com/doc/current/components/phpunit_bridge.html#coverage-listener

  -
    question: >
      When using `Symfony\\Component\\Clock\\MockClock`, which method allows you to change the mocked time to a specific `DateTimeImmutable` or string representation?
    answers:
      -
        value: >
          `$clock->setTime('2023-01-01 10:00:00');`
        correct: false
      -
        value: >
          `$clock->modify('2023-01-01 10:00:00');`
        correct: true
      -
        value: >
          `$clock->setDateTime('2023-01-01 10:00:00');`
        correct: false
      -
        value: >
          `$clock->jumpTo('2023-01-01 10:00:00');`
        correct: false
    help: |
      The `modify()` method allows you to set the mocked clock to a specific point in time, accepting any format supported by `DateTimeImmutable::modify()`.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      What is the primary benefit of using `Symfony\\Component\\Panther\\PantherTestCase` for testing a JavaScript-heavy single-page application (SPA)?
    answers:
      -
        value: >
          It allows direct manipulation of the database.
        correct: false
      -
        value: >
          It can execute JavaScript, interact with dynamic DOM elements, and simulate user actions in a real browser.
        correct: true
      -
        value: >
          It is significantly faster than traditional functional tests.
        correct: false
      -
        value: >
          It provides built-in API mocking capabilities.
        correct: false
    help: |
      Panther's ability to control a real browser makes it ideal for testing SPAs where client-side JavaScript heavily influences the user experience and application state.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      When writing functional tests, how can you obtain the `Response` object that was received from the last client request?
    answers:
      -
        value: >
          `$client->getLastResponse();`
        correct: true
      -
        value: >
          `$client->getResponse();`
        correct: false
      -
        value: >
          `$client->getContainer()->get('request_stack')->getMasterRequest()->getResponse();`
        correct: false
      -
        value: >
          `$client->request('GET', '/')->getResponse();`
        correct: false
    help: |
      The `getLastResponse()` method on the test client returns the `Response` object from the most recent interaction.
      https://symfony.com/doc/current/testing.html#request-and-response-objects

  -
    question: >
      What is the purpose of the `assertAnySelectorTextContains()` assertion in Symfony's Crawler?
    answers:
      -
        value: >
          Asserts that the first element matching the given selector contains the expected text.
        correct: false
      -
        value: >
          Asserts that *any* element matching the given selector contains the expected text.
        correct: true
      -
        value: >
          Asserts that all elements matching the given selector contain the expected text.
        correct: false
      -
        value: >
          Asserts that no element matching the given selector contains the expected text.
        correct: false
    help: |
      Unlike `assertSelectorTextContains()` which checks only the first match, `assertAnySelectorTextContains()` passes if at least one element matching the selector contains the text.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      Which of the following is the correct way to assert that the first element matching a given selector does equal the expected text content?
    answers:
      -
        value: >
          `$this->assertSelectorTextSame('p.greeting', 'Hello!');`
        correct: true
      -
        value: >
          `$this->assertSelectorTextEquals('p.greeting', 'Hello!');`
        correct: false
      -
        value: >
          `$crawler->filter('p.greeting')->text() === 'Hello!';`
        correct: false
      -
        value: >
          `$this->assertTextEquals('p.greeting', 'Hello!');`
        correct: false
    help: |
      `assertSelectorTextSame()` asserts an exact match for the text content of the first element found by the selector.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `assertAnySelectorTextSame()` assertion in Symfony's Crawler?
    answers:
      -
        value: >
          Asserts that the first element matching the given selector has the exact expected text.
        correct: false
      -
        value: >
          Asserts that *any* element matching the given selector has the exact expected text.
        correct: true
      -
        value: >
          Asserts that all elements matching the given selector have the exact expected text.
        correct: false
      -
        value: >
          Asserts that no element matching the given selector has the exact expected text.
        correct: false
    help: |
      `assertAnySelectorTextSame()` is useful when you need to confirm that at least one instance of an element has a precise text content.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Symfony application, what is the primary role of the `KernelBrowser` (the object returned by `static::createClient()`)?
    answers:
      -
        value: >
          To provide a direct interface to the Symfony kernel's internal services.
        correct: false
      -
        value: >
          To simulate a web browser's interactions with your application over HTTP.
        correct: true
      -
        value: >
          To manage database connections for functional tests.
        correct: false
      -
        value: >
          To execute JavaScript code within the test environment.
        correct: false
    help: |
      The `KernelBrowser` is the core component for functional testing, allowing you to send requests, submit forms, and navigate your application as a user would.
      https://symfony.com/doc/current/testing.html#making-requests

  -
    question: >
      Which of the following is a valid assertion to check if an element's attribute contains a specific value using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorAttributeWillContain('.price', 'data-old-price', '€25');`
        correct: true
      -
        value: >
          `$this->assertAttributeWillContain('.price', 'data-old-price', '€25');`
        correct: false
      -
        value: >
          `$client->waitForAttributeToContain('.price', 'data-old-price', '€25');`
        correct: false
      -
        value: >
          `$this->assertSelectorAttributeContainsFuture('.price', 'data-old-price', '€25');`
        correct: false
    help: |
      `assertSelectorAttributeWillContain()` is a future assertion in Panther that waits for an element's attribute to contain a specific value.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist` for Panther tests?
    answers:
      -
        value: >
          It provides a built-in web server for serving static assets during tests.
        correct: false
      -
        value: >
          It automatically starts and stops a web server for your application during the test suite execution.
        correct: true
      -
        value: >
          It enables remote debugging of the Panther browser.
        correct: false
      -
        value: >
          It configures the port on which the Panther browser runs.
        correct: false
    help: |
      The `ServerExtension` simplifies Panther test setup by managing the lifecycle of the web server that serves your Symfony application to the Panther browser.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually become visible using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillBeVisible('.loader');`
        correct: true
      -
        value: >
          `$this->assertVisibleFuture('.loader');`
        correct: false
      -
        value: >
          `$client->waitForVisibility('.loader');`
        correct: false
      -
        value: >
          `$this->assertElementWillBeVisible('.loader');`
        correct: false
    help: |
      `assertSelectorWillBeVisible()` is a future assertion that waits for an element matching the selector to become visible within a timeout.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When running tests with `simple-phpunit`, what does `SYMFONY_DEPRECATIONS_HELPER='max[direct]=0'` achieve?
    answers:
      -
        value: >
          It ignores all deprecations that are directly triggered by your code.
        correct: false
      -
        value: >
          It fails the test if any deprecation is directly triggered by your code, ignoring indirect ones.
        correct: true
      -
        value: >
          It limits the number of direct deprecations reported to zero.
        correct: false
      -
        value: >
          It reports only direct deprecations.
        correct: false
    help: |
      `max[direct]=0` is a powerful setting for the deprecation helper that makes your test suite fail if your own code directly triggers any deprecation, encouraging immediate fixes.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-deprecation-helper

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually be removed from the DOM using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillNotExist('.popin');`
        correct: true
      -
        value: >
          `$this->assertElementWillDisappear('.popin');`
        correct: false
      -
        value: >
          `$client->waitForStaleness('.popin');`
        correct: false
      -
        value: >
          `$this->assertSelectorRemoved('.popin');`
        correct: false
    help: |
      `assertSelectorWillNotExist()` is a future assertion that waits for an element matching the selector to be removed from the DOM.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the primary purpose of the `Symfony\\Component\\Panther\\PantherTestCase` class?
    answers:
      -
        value: >
          To run unit tests in isolation.
        correct: false
      -
        value: >
          To enable end-to-end testing of web applications, including JavaScript execution, using a real browser.
        correct: true
      -
        value: >
          To provide a simplified way to test REST APIs.
        correct: false
      -
        value: >
          To generate screenshots of web pages for documentation.
        correct: false
    help: |
      `PantherTestCase` is designed for robust end-to-end testing, allowing you to interact with your web application as a real user would, including client-side scripting.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      When testing a multi-domain application with Symfony Panther, what is the purpose of the `external_base_uri` option in `createPantherClient()`?
    answers:
      -
        value: >
          To specify the base URL for external API calls.
        correct: false
      -
        value: >
          To define the URL of the primary domain for the application under test.
        correct: false
      -
        value: >
          To specify the base URL for a secondary domain being tested within the same application.
        correct: true
      -
        value: >
          To configure the URL of the Panther browser instance.
        correct: false
    help: |
      `external_base_uri` allows you to tell Panther to target a different domain for specific tests, which is essential for testing applications that span multiple domains.
      https://symfony.com/doc/current/testing/end_to_end.html#testing-multi-domain-applications

  -
    question: >
      Which of the following describes a key feature of `Symfony\\Component\\Panther\\ServerExtension`?
    answers:
      -
        value: >
          It automatically captures screenshots on test failures.
        correct: true
      -
        value: >
          It provides a built-in database server for tests.
        correct: false
      -
        value: >
          It enables parallel execution of Panther tests.
        correct: false
      -
        value: >
          It integrates with external CI/CD pipelines.
        correct: false
    help: |
      Beyond managing the web server, the `ServerExtension` also automatically takes screenshots when a Panther test fails, which is invaluable for debugging.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      What is the primary benefit of using `Symfony\\Component\\Clock\\MockClock` for time-sensitive tests compared to relying on `ClockMock` from the PHPUnit bridge?
    answers:
      -
        value: >
          `MockClock` is a more modern and flexible API for controlling time.
        correct: true
      -
        value: >
          `MockClock` works without requiring any PHPUnit listener configuration.
        correct: true
      -
        value: >
          `MockClock` can only mock specific time functions, while `ClockMock` mocks all of them.
        correct: false
      -
        value: >
          `MockClock` is specifically designed for functional tests, while `ClockMock` is for unit tests.
        correct: false
    help: |
      `MockClock` provides a more explicit and object-oriented way to control time in your tests, offering greater flexibility and not relying on PHPUnit listeners.
      https://symfony.com/doc/current/components/clock.html#mockclock

  -
    question: >
      When using `Symfony\\Component\\Panther\\PantherTestCase`, what is the purpose of the `waitFor()` method?
    answers:
      -
        value: >
          To pause the test execution for a fixed amount of time.
        correct: false
      -
        value: >
          To wait for an element matching a given selector to be attached to the DOM.
        correct: true
      -
        value: >
          To wait for a specific network request to complete.
        correct: false
      -
        value: >
          To wait for the entire page to fully load.
        correct: false
    help: |
      `waitFor()` is a client-side waiting method that ensures an element is present in the DOM before proceeding with assertions, crucial for asynchronous content loading.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\PantherTestCase`?
    answers:
      -
        value: >
          To run unit tests in isolation.
        correct: false
      -
        value: >
          To enable end-to-end testing of web applications, including JavaScript execution, using a real browser.
        correct: true
      -
        value: >
          To provide a simplified way to test REST APIs.
        correct: false
      -
        value: >
          To generate screenshots of web pages for documentation.
        correct: false
    help: |
      `PantherTestCase` is designed for robust end-to-end testing, allowing you to interact with your web application as a real user would, including client-side scripting.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually be disabled using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillBeDisabled('[type="submit"]');`
        correct: true
      -
        value: >
          `$this->assertDisabledFuture('[type="submit"]');`
        correct: false
      -
        value: >
          `$client->waitForDisabled('[type="submit"]');`
        correct: false
      -
        value: >
          `$this->assertElementWillBeDisabled('[type="submit"]');`
        correct: false
    help: |
      `assertSelectorWillBeDisabled()` is a future assertion that waits for an element matching the selector to become disabled.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      What is the purpose of `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      -
        value: >
          To start a built-in PHP web server for functional tests.
        correct: true
      -
        value: >
          To manage the database connection for Panther tests.
        correct: false
      -
        value: >
          To provide additional assertions for Panther.
        correct: false
      -
        value: >
          To configure the browser used by Panther.
        correct: false
    help: |
      The `ServerExtension` automatically starts and stops a web server for your application during Panther tests, simplifying the setup and ensuring a clean environment.
      https://symfony.com/doc/current/testing/end_to_end.html#configure-the-server

  -
    question: >
      Which of the following is a valid assertion to check if an element will eventually be enabled using Panther's future assertions?
    answers:
      -
        value: >
          `$this->assertSelectorWillBeEnabled('[type="submit"]');`
        correct: true
      -
        value: >
          `$this->assertEnabledFuture('[type="submit"]');`
        correct: false
      -
        value: >
          `$client->waitForEnabled('[type="submit"]');`
        correct: false
      -
        value: >
          `$this->assertElementWillBeEnabled('[type="submit"]');`
        correct: false
    help: |
      `assertSelectorWillBeEnabled()` is a future assertion that waits for an element matching the selector to become enabled.
      https://symfony.com/doc/current/testing.html#future-assertions