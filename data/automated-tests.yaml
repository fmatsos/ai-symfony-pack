category: Automated Tests
questions:
  - question: Which PHPUnit base class should you extend for unit tests that do NOT
      require the Symfony kernel to be booted?
    answers:
      - value: "`PHPUnit\\Framework\\TestCase`"
        correct: true
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`"
        correct: false
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`"
        correct: false
      - value: "`Symfony\\Component\\Panther\\PantherTestCase`"
        correct: false
    help: For pure unit tests that do not interact with the Symfony container or
      request/response cycle, `PHPUnit\Framework\TestCase` is the appropriate
      base class. It ensures the test runs in isolation without the overhead of
      booting the kernel.
  - question: Which command is used to run all tests in a Symfony application?
    answers:
      - value: "`php bin/phpunit`"
        correct: true
      - value: "`composer test`"
        correct: false
      - value: "`symfony console test`"
        correct: false
      - value: "`./vendor/bin/phpunit all`"
        correct: false
    help: The standard command to execute all tests configured in `phpunit.xml.dist`
      is `php bin/phpunit`.
  - question: When writing a functional test for a Symfony application, which base
      class should your test extend to gain access to the `Client` object and
      boot the kernel?
    answers:
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`"
        correct: true
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`"
        correct: false
      - value: "`PHPUnit\\Framework\\TestCase`"
        correct: false
      - value: "`Symfony\\Component\\BrowserKit\\HttpBrowser`"
        correct: false
    help: "`WebTestCase` extends `KernelTestCase` and provides additional utilities
      for functional web testing, including the `createClient()` method."
  - question: Which method is used to create a test client in a functional test?
    answers:
      - value: "`static::createClient()`"
        correct: true
      - value: "`$this->getClient()`"
        correct: false
      - value: "`new Client()`"
        correct: false
      - value: "`$this->bootClient()`"
        correct: false
    help: The `createClient()` static method, available in `WebTestCase`,
      initializes a test client that acts as a browser.
  - question: After making a request with the test client (e.g.,
      `$client->request('GET', '/')`), which method on the client object allows
      you to access the `Crawler` object for DOM navigation and assertions?
    answers:
      - value: The `request()` method itself returns the `Crawler` object.
        correct: true
      - value: "`$client->getCrawler()`"
        correct: false
      - value: "`$client->getDomCrawler()`"
        correct: false
      - value: "`$client->getHtmlCrawler()`"
        correct: false
    help: The `request()` method of the `Client` object returns a `Crawler`
      instance, which can then be used to traverse the DOM and make assertions.
  - question: Which assertion method is used to check if a response was successful
      (HTTP status 2xx)?
    answers:
      - value: "`$this->assertResponseIsSuccessful()`"
        correct: true
      - value: "`$this->assertStatusCodeIsSuccessful()`"
        correct: false
      - value: "`$this->assertResponseOk()`"
        correct: false
      - value: "`$this->assertHttpSuccess()`"
        correct: false
    help: The `assertResponseIsSuccessful()` method is provided by `WebTestCase` to
      verify that the HTTP response status code is in the 2xx range.
  - question: How can you assert that a specific HTML element exists in the response
      using the `Crawler` object?
    answers:
      - value: "`$this->assertSelectorExists('h1');`"
        correct: true
      - value: "`$crawler->filter('h1')->count() > 0;`"
        correct: false
      - value: "`$this->assertElementExists('h1');`"
        correct: false
      - value: "`$crawler->exists('h1');`"
        correct: false
    help: The `assertSelectorExists()` method, available in `WebTestCase`, is used
      to assert the presence of an element matching a CSS selector.
  - question: To simulate a logged-in user in a functional test, which method of the
      `Client` object should you use?
    answers:
      - value: "`$client->loginUser($user);`"
        correct: true
      - value: "`$client->setAuthenticatedUser($user);`"
        correct: false
      - value: "`$client->authenticate($user);`"
        correct: false
      - value: "`$client->setUser($user);`"
        correct: false
    help: The `loginUser()` method on the `Client` object allows you to simulate a
      user being logged in for the duration of the test. It requires a
      `UserInterface` object.
  - question: When performing integration tests that require access to Symfony
      services from the container, which base class should your test extend, and
      how do you access the container?
    answers:
      - value: Extend `KernelTestCase` and use `static::getContainer()`.
        correct: true
      - value: Extend `WebTestCase` and use `$this->getContainer()`.
        correct: false
      - value: Extend `PHPUnit\Framework\TestCase` and use
          `self::bootKernel()->getContainer()`.
        correct: false
      - value: Extend `KernelTestCase` and use `$this->container`.
        correct: false
    help: "`KernelTestCase` is designed for integration tests that need to boot the
      kernel and access services. After calling `self::bootKernel()`, you can
      access the container via `static::getContainer()`."
  - question: By default, the Symfony Profiler is disabled in the `test` environment
      to speed up tests. How can you enable it for specific functional tests
      while keeping it disabled for collection by default?
    answers:
      - value: "Set `framework.profiler.enabled: true` and `framework.profiler.collect:
          false` in `config/packages/test/web_profiler.yaml`, then call
          `$client->enableProfiler()` in your test."
        correct: true
      - value: "Set `framework.profiler.enabled: true` in
          `config/packages/test/framework.yaml`."
        correct: false
      - value: Call `$client->enableProfiler()` without any specific configuration.
        correct: false
      - value: "Set `kernel.debug: true` in the test environment."
        correct: false
    help: "To enable the profiler on demand, you configure it to be enabled but not
      collect data by default (`collect: false`). Then, within your test, call
      `$client->enableProfiler()` before the request to collect data for that
      specific request."
  - question: Which of the following is the correct way to assert that a response
      has a specific HTTP status code?
    answers:
      - value: "`$this->assertResponseStatusCodeSame(200);`"
        correct: true
      - value: "`$this->assertStatusCode(200);`"
        correct: false
      - value: "`$this->assertEquals(200, $client->getResponse()->getStatusCode());`"
        correct: false
      - value: "`$this->assertResponseCode(200);`"
        correct: false
    help: The `assertResponseStatusCodeSame()` method is the recommended way to
      assert a specific HTTP status code on the response in Symfony functional
      tests.
  - question: What is the purpose of the `Dama\DoctrineTestBundle` in Symfony testing?
    answers:
      - value: To automatically roll back database transactions after each test,
          ensuring a clean database state.
        correct: true
      - value: To generate dummy data (fixtures) for tests.
        correct: false
      - value: To provide a test database connection.
        correct: false
      - value: To mock Doctrine entities and repositories.
        correct: false
    help: The `Dama\DoctrineTestBundle` is used to ensure test isolation by rolling
      back database changes after each test, preventing data leakage between
      tests.
  - question: How do you install `Dama\DoctrineTestBundle`?
    answers:
      - value: "`composer require --dev dama/doctrine-test-bundle`"
        correct: true
      - value: "`composer install dama/doctrine-test-bundle`"
        correct: false
      - value: "`php bin/console doctrine:install:test-bundle`"
        correct: false
      - value: "`symfony require --dev doctrine-test-bundle`"
        correct: false
    help: Like most Symfony bundles, `Dama\DoctrineTestBundle` is installed via
      Composer as a dev dependency.
  - question: Which of the following is a correct way to configure a separate
      database for the test environment?
    answers:
      - value: Define `DATABASE_URL` in `.env.test.local`.
        correct: true
      - value: Modify `config/packages/doctrine.yaml` directly.
        correct: false
      - value: Set the `DATABASE_URL` environment variable before running tests.
        correct: true
      - value: Use a different `doctrine.yaml` file for the test environment.
        correct: false
    help: Symfony's environment-specific configuration allows you to override
      parameters. For the test environment, defining `DATABASE_URL` in
      `.env.test.local` or as an environment variable is the standard approach.
  - question: What is the primary benefit of using
      `doctrine/doctrine-fixtures-bundle` in your Symfony tests?
    answers:
      - value: To load consistent, predefined data into the database for each test run.
        correct: true
      - value: To mock database interactions without a real database.
        correct: false
      - value: To manage database migrations in the test environment.
        correct: false
      - value: To speed up database queries during tests.
        correct: false
    help: Doctrine Fixtures Bundle provides a way to populate your database with
      test data, ensuring that your tests operate on a known and consistent
      dataset.
  - question: |-
      Consider the following code snippet from a functional test:

      ```php
      $client = static::createClient();
      $crawler = $client->request('GET', '/some-page');
      $this->assertResponseIsSuccessful();
      $this->assertSelectorTextContains('h1', 'Welcome');
      ```

      What does `$this->assertSelectorTextContains('h1', 'Welcome');` assert?
    answers:
      - value: That the first `<h1>` element found on the page contains the text
          'Welcome'.
        correct: true
      - value: That any `<h1>` element on the page contains the text 'Welcome'.
        correct: false
      - value: That the page title is 'Welcome'.
        correct: false
      - value: That there is exactly one `<h1>` element with the text 'Welcome'.
        correct: false
    help: "`assertSelectorTextContains()` checks if the *first* element matching the
      given selector contains the specified text."
  - question: Which of the following is true about `KernelTestCase` in Symfony testing?
    answers:
      - value: It boots the Symfony kernel for each test to ensure isolation.
        correct: true
      - value: It is primarily used for functional web tests.
        correct: false
      - value: It automatically provides a `Client` object for making HTTP requests.
        correct: false
      - value: It is suitable for pure unit tests that do not interact with the
          container.
        correct: false
    help: "`KernelTestCase` is the base for integration tests where you need to
      interact with the Symfony container and its services. It boots the kernel
      for each test to maintain a clean state."
  - question: When testing a console command using `ApplicationTester`, why is it
      important to call `$application->setAutoExit(false);`?
    answers:
      - value: To prevent the application from exiting immediately after the command
          runs, allowing you to retrieve the output and status code.
        correct: true
      - value: To enable interactive input for the command during testing.
        correct: false
      - value: To ensure the command runs in a separate process.
        correct: false
      - value: To disable Symfony's event listeners for the command.
        correct: false
    help: Setting `setAutoExit(false)` on the `Application` instance is crucial for
      testing console commands, as it prevents the script from terminating,
      allowing `ApplicationTester` to capture the command's output and exit
      code.
  - question: What is the purpose of the `Symfony\Bridge\PhpUnit\SymfonyTestsListener`?
    answers:
      - value: To integrate Symfony's PHPUnit Bridge functionalities, such as
          `ClockMock` and deprecation handling, into your test suite.
        correct: true
      - value: To automatically generate PHPUnit tests for your Symfony application.
        correct: false
      - value: To listen for Symfony events during tests and log them.
        correct: false
      - value: To provide custom assertions for Symfony components.
        correct: false
    help: The `SymfonyTestsListener` is a PHPUnit listener that enables various
      features of the Symfony PHPUnit Bridge, including `ClockMock` for
      time-sensitive tests and deprecation reporting.
  - question: How can you enable `ClockMock` for a specific PHPUnit test class in
      Symfony?
    answers:
      - value: Add the `@group time-sensitive` annotation to the test class and ensure
          `SymfonyTestsListener` is registered in `phpunit.xml.dist`.
        correct: true
      - value: Call `Symfony\Component\Clock\MockClock::freeze()` at the beginning of
          the test method.
        correct: false
      - value: "Configure `framework.clock_mock: true` in
          `config/packages/test/framework.yaml`."
        correct: false
      - value: Extend `Symfony\Component\Clock\Test\ClockTestCase`.
        correct: false
    help: The `@group time-sensitive` annotation, in conjunction with the
      `SymfonyTestsListener`, automatically enables `ClockMock` for the
      annotated test class, allowing you to control time-based functions.
  - question: Which environment variable is used to configure the Symfony
      Deprecations Helper for PHPUnit tests?
    answers:
      - value: "`SYMFONY_DEPRECATIONS_HELPER`"
        correct: true
      - value: "`PHPUNIT_DEPRECATIONS`"
        correct: false
      - value: "`SYMFONY_TEST_DEPRECATIONS`"
        correct: false
      - value: "`APP_DEPRECATIONS_HELPER`"
        correct: false
    help: The `SYMFONY_DEPRECATIONS_HELPER` environment variable is used to control
      the behavior of the Symfony Deprecations Helper, including ignoring
      deprecations or using a baseline file.
  - question: What is a 'deprecation baseline file' in the context of Symfony testing?
    answers:
      - value: A JSON file containing a list of deprecations that are currently allowed
          and should be ignored during test runs.
        correct: true
      - value: A file that defines the minimum PHPUnit version required for your tests.
        correct: false
      - value: A configuration file for ignoring specific test failures.
        correct: false
      - value: A report of all deprecations found in your application.
        correct: false
    help: A deprecation baseline file (typically `allowed.json`) allows you to
      acknowledge existing deprecations and ignore them, while still being
      notified of any *new* deprecations introduced.
  - question: How do you run PHPUnit tests while ignoring deprecations listed in a
      baseline file named `tests/allowed.json`?
    answers:
      - value: "`SYMFONY_DEPRECATIONS_HELPER='baselineFile=./tests/allowed.json'
          ./vendor/bin/simple-phpunit`"
        correct: true
      - value: "`./vendor/bin/simple-phpunit
          --ignore-deprecations=./tests/allowed.json`"
        correct: false
      - value: "`php bin/phpunit --env=test
          --deprecations-baseline=./tests/allowed.json`"
        correct: false
      - value: "`SYMFONY_DEPRECATIONS_HELPER='ignore=./tests/allowed.json' php
          bin/phpunit`"
        correct: false
    help: The `SYMFONY_DEPRECATIONS_HELPER` environment variable with the
      `baselineFile` option is used to specify a deprecation baseline file.
  - question: Which assertion method is used to check if the page title is exactly a
      specific string?
    answers:
      - value: "`$this->assertPageTitleSame('My Page Title');`"
        correct: true
      - value: "`$this->assertTitleEquals('My Page Title');`"
        correct: false
      - value: "`$crawler->filter('title')->text() === 'My Page Title';`"
        correct: false
      - value: "`$this->assertPageTitleContains('My Page Title');`"
        correct: false
    help: "`assertPageTitleSame()` is a convenient assertion provided by
      `WebTestCase` to check the exact content of the `<title>` element."
  - question: When testing a form, which assertion can be used to check the value of
      a specific input field?
    answers:
      - value: "`$this->assertInputValueSame('my_field_name', 'expected_value');`"
        correct: true
      - value: "`$crawler->filter('#my_field_id')->attr('value') === 'expected_value';`"
        correct: false
      - value: "`$this->assertFormFieldValue('my_field_name', 'expected_value');`"
        correct: false
      - value: "`$this->assertFormValue('form_selector', 'my_field_name',
          'expected_value');`"
        correct: true
    help: Both `assertInputValueSame()` (for a field by its name) and
      `assertFormValue()` (for a field within a specific form) can be used to
      assert input values.
  - question: What is the primary purpose of `Symfony\Component\Panther\PantherTestCase`?
    answers:
      - value: To enable end-to-end testing of JavaScript-heavy applications by
          controlling a real browser.
        correct: true
      - value: To provide advanced mocking capabilities for Symfony services.
        correct: false
      - value: To speed up functional tests by bypassing the web server.
        correct: false
      - value: To generate screenshots of web pages for visual regression testing.
        correct: false
    help: Panther is a browser testing and web scraping library for PHP, built on
      top of Symfony's BrowserKit and WebDriver. `PantherTestCase` allows you to
      write end-to-end tests that interact with a real browser.
  - question: Which PHPUnit extension should be registered in `phpunit.xml.dist` to
      improve Panther testing performance by managing the web server lifecycle
      and enabling automatic screenshot capture on test failures?
    answers:
      - value: "`Symfony\\Component\\Panther\\ServerExtension`"
        correct: true
      - value: "`Symfony\\Component\\Panther\\BrowserExtension`"
        correct: false
      - value: "`Symfony\\Component\\Panther\\ScreenshotExtension`"
        correct: false
      - value: "`Symfony\\Component\\Panther\\TestExtension`"
        correct: false
    help: The `ServerExtension` is crucial for Panther tests as it manages the
      built-in web server and provides features like automatic screenshots on
      failure.
  - question: When using Panther, what is the purpose of 'future assertions' like
      `assertSelectorWillExist()`?
    answers:
      - value: They pause the test execution until a specified condition (e.g., element
          existence) becomes true, useful for testing asynchronous UI changes.
        correct: true
      - value: They assert conditions that are expected to be true in a subsequent test
          case.
        correct: false
      - value: They predict future states of the DOM based on current actions.
        correct: false
      - value: They allow you to define assertions that will be re-evaluated if the
          initial check fails.
        correct: false
    help: Future assertions in Panther are designed for testing dynamic web pages.
      They wait for a condition to be met within a timeout period, making tests
      more robust against asynchronous operations.
  - question: To enable interactive debug mode in Panther, pausing tests on failure
      for manual browser inspection, which command should you use?
    answers:
      - value: "`PANTHER_NO_HEADLESS=1 bin/phpunit --debug`"
        correct: true
      - value: "`bin/phpunit --panther-debug`"
        correct: false
      - value: "`PANTHER_DEBUG=1 bin/phpunit`"
        correct: false
      - value: "`php bin/console panther:debug`"
        correct: false
    help: Setting `PANTHER_NO_HEADLESS=1` and running PHPUnit with `--debug` enables
      the interactive debug mode in Panther.
  - question: Which of the following is the correct way to assert that a response is
      a redirect to a specific location?
    answers:
      - value: "`$this->assertResponseRedirects('/new-location', 302);`"
        correct: true
      - value: "`$this->assertRedirectsTo('/new-location');`"
        correct: false
      - value: "`$this->assertResponseStatusCodeSame(302);
          $this->assertResponseHeaderSame('Location', '/new-location');`"
        correct: true
      - value: "`$client->followRedirect('/new-location');`"
        correct: false
    help: "`assertResponseRedirects()` is a dedicated assertion for checking
      redirects, optionally verifying the target location and status code. You
      can also manually check the status code and the `Location` header."
  - question: What is the purpose of `HarFileResponseFactory` in Symfony's HTTP
      Client testing?
    answers:
      - value: To create mock HTTP responses based on recorded HTTP Archive (HAR) files,
          enabling reproducible tests.
        correct: true
      - value: To generate HAR files from HTTP client requests during tests.
        correct: false
      - value: To analyze network performance of HTTP client requests.
        correct: false
      - value: To replay recorded HTTP requests against a live server.
        correct: false
    help: "`HarFileResponseFactory` allows you to use HAR files as a source for mock
      responses, making it easy to test HTTP client interactions with realistic,
      pre-recorded data."
  - question: When writing a unit test for a service that depends on Doctrine's
      `EntityManager`, how should you typically handle the `EntityManager`
      dependency to ensure the test remains a unit test?
    answers:
      - value: Mock the `EntityManager` and its `getRepository()` method to return a
          mocked repository.
        correct: true
      - value: Boot the Symfony kernel and retrieve the real `EntityManager` from the
          container.
        correct: false
      - value: Use an in-memory SQLite database for the test.
        correct: false
      - value: Pass a null `EntityManager` to the service's constructor.
        correct: false
    help: For a true unit test, you should mock external dependencies like
      `EntityManager` to isolate the class under test from its collaborators and
      avoid hitting a real database.
  - question: Which command can be used to generate a new application test class
      (e.g., `WebTestCase`) using Symfony MakerBundle?
    answers:
      - value: "`php bin/console make:test`"
        correct: true
      - value: "`php bin/console make:functional-test`"
        correct: false
      - value: "`php bin/console generate:test`"
        correct: false
      - value: "`symfony make:test`"
        correct: false
    help: The `make:test` command from Symfony MakerBundle provides an interactive
      way to generate various test types, including `WebTestCase`.
  - question: What is the purpose of the `TestBrowserToken` class in Symfony testing?
    answers:
      - value: It's a special security token created by `loginUser()` and stored in the
          test client's session to simulate a logged-in user.
        correct: true
      - value: It represents a browser's authentication token for external API calls.
        correct: false
      - value: It's used to manage CSRF tokens in functional tests.
        correct: false
      - value: It's a token used for authenticating the test client itself.
        correct: false
    help: When `loginUser()` is called, Symfony creates an instance of
      `TestBrowserToken` and places it in the test client's session, making the
      simulated user appear logged in.
  - question: How can you manually clear the Symfony cache directory for the test
      environment programmatically within a test or setup script?
    answers:
      - value: Use `(new
          \Symfony\Component\Filesystem\Filesystem())->remove(__DIR__.'/../var/cache/test');`
        correct: true
      - value: "`php bin/console cache:clear --env=test`"
        correct: false
      - value: "`$this->getContainer()->get('cache.app')->clear();`"
        correct: false
      - value: "`self::bootKernel(['environment' => 'test', 'debug' => false]);`"
        correct: false
    help: While `cache:clear` is a console command, you can programmatically remove
      the cache directory using the `Filesystem` component, which is useful for
      ensuring a fresh cache, especially when `debug` is `false`.
  - question: Which assertion method is used to check if a checkbox with a given
      name is checked?
    answers:
      - value: "`$this->assertCheckboxChecked('my_checkbox_name');`"
        correct: true
      - value: "`$this->assertInputValueSame('my_checkbox_name', 'on');`"
        correct: false
      - value: "`$crawler->filter('input[name=\"my_checkbox_name\"]')->attr('checked');\
          `"
        correct: false
      - value: "`$this->assertChecked('my_checkbox_name');`"
        correct: false
    help: "`assertCheckboxChecked()` provides a clear and concise way to assert the
      state of a checkbox by its name."
  - question: What is the primary purpose of `MockClock` in Symfony's Clock component?
    answers:
      - value: To control and manipulate time within tests, allowing for predictable
          testing of time-sensitive logic.
        correct: true
      - value: To measure the execution time of test methods.
        correct: false
      - value: To simulate different timezones during tests.
        correct: false
      - value: To automatically advance time during long-running tests.
        correct: false
    help: "`MockClock` allows you to 'freeze' time, 'sleep' (instantly advance
      time), or 'modify' time, which is invaluable for testing features like
      expirations, caching, or scheduled tasks without waiting for real time to
      pass."
  - question: When testing a custom Symfony form type, which base class should you
      extend, and what method can you override to register custom form
      extensions?
    answers:
      - value: Extend `Symfony\Component\Form\Test\TypeTestCase` and override
          `getExtensions()`.
        correct: true
      - value: Extend `Symfony\Bundle\FrameworkBundle\Test\WebTestCase` and override
          `getFormExtensions()`.
        correct: false
      - value: Extend `PHPUnit\Framework\TestCase` and manually register extensions.
        correct: false
      - value: Extend `Symfony\Component\Form\Test\FormIntegrationTestCase` and override
          `getExtensions()`.
        correct: true
    help: "`TypeTestCase` (which extends `FormIntegrationTestCase`) is specifically
      designed for testing form types. You can override `getExtensions()` to
      provide any necessary form extensions for your test."
  - question: Which of the following is NOT a valid assertion method for the
      `Crawler` object in Symfony's `WebTestCase`?
    answers:
      - value: "`assertElementVisible()`"
        correct: true
      - value: "`assertSelectorCount()`"
        correct: false
      - value: "`assertSelectorNotExists()`"
        correct: false
      - value: "`assertAnySelectorTextContains()`"
        correct: false
    help: While Panther provides `assertSelectorWillBeVisible()`, `WebTestCase`'s
      `Crawler` assertions do not directly include `assertElementVisible()`. You
      would typically check for existence or text content.
  - question: What is the purpose of the `test` configuration option under
      `framework` in `config/packages/test/framework.yaml`?
    answers:
      - value: If set to `true`, it loads services related to testing, such as
          `test.client`.
        correct: true
      - value: It enables the Symfony Profiler by default in the test environment.
        correct: false
      - value: It configures the test database connection.
        correct: false
      - value: It enables XDebug for code coverage generation.
        correct: false
    help: The `test` option under `framework` ensures that testing-specific
      services, like the test client, are loaded when running in the `test`
      environment.
  - question: How can you generate an HTML test coverage report using PHPUnit in Symfony?
    answers:
      - value: "`./vendor/bin/phpunit --coverage-html=cov/`"
        correct: true
      - value: "`php bin/phpunit --coverage-html`"
        correct: false
      - value: "`./vendor/bin/phpunit --coverage-report=html`"
        correct: false
      - value: "`php bin/console test:coverage --format=html`"
        correct: false
    help: The `--coverage-html` option with a directory path is used to generate an
      HTML code coverage report with PHPUnit. XDebug must be enabled for this to
      work.
  - question: When testing a multi-domain application with Symfony Panther, what
      PHPUnit annotation and client option are typically used to ensure isolated
      tests for different domains?
    answers:
      - value: "`@runInSeparateProcess` annotation and `external_base_uri` client
          option."
        correct: true
      - value: "`@preserveGlobalState false` annotation and `base_uri` client option."
        correct: false
      - value: "`@group isolated` annotation and `domain` client option."
        correct: false
      - value: "`@runTestsInSeparateProcesses` annotation and `app_url` client option."
        correct: false
    help: The `@runInSeparateProcess` annotation ensures that each test runs in its
      own PHP process, preventing state leakage. The `external_base_uri` option
      in `createPantherClient()` allows specifying the base URL for the domain
      under test.
  - question: What is the purpose of `Symfony\Bridge\PhpUnit\CoverageListener`?
    answers:
      - value: It automatically adds `@covers` annotations to test classes to accurately
          report code coverage.
        correct: true
      - value: It listens for code coverage events and generates reports.
        correct: false
      - value: It ensures that only covered code is executed during tests.
        correct: false
      - value: It provides a way to define custom code coverage rules.
        correct: false
    help: The `CoverageListener` helps improve the accuracy of code coverage reports
      by automatically inferring and adding `@covers` annotations, linking tests
      to the code they cover.
  - question: Which of the following is a valid way to retrieve the `Response`
      object from the `Client` after a request?
    answers:
      - value: "`$client->getResponse()`"
        correct: true
      - value: "`$client->response()`"
        correct: false
      - value: "`$client->getHttpResponse()`"
        correct: false
      - value: "`$client->getLastResponse()`"
        correct: false
    help: The `getResponse()` method on the `Client` object returns the last
      `Response` object received from the application.
  - question: When testing a custom validation constraint, which base class should
      you extend?
    answers:
      - value: "`Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase` for
          validator tests."
        correct: true
      - value: "`Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase` for
          compound constraint tests."
        correct: true
      - value: "`PHPUnit\\Framework\\TestCase` directly."
        correct: false
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`."
        correct: false
    help: Symfony provides dedicated test cases for validators
      (`ConstraintValidatorTestCase`) and compound constraints
      (`CompoundConstraintTestCase`) to simplify testing validation logic.
  - question: What is the primary benefit of using data providers in PHPUnit for
      functional tests, such as a smoke test of application URLs?
    answers:
      - value: To run the same test logic with multiple sets of input data (e.g.,
          different URLs) without writing repetitive test methods.
        correct: true
      - value: To parallelize test execution across multiple processes.
        correct: false
      - value: To dynamically generate test methods at runtime.
        correct: false
      - value: To mock external dependencies for the test.
        correct: false
    help: Data providers allow you to define a single test method and then feed it
      multiple sets of arguments, making it ideal for testing a list of URLs or
      different input scenarios.
  - question: To optimize functional tests in the `test` environment, how might you
      configure password hashers?
    answers:
      - value: Configure a less resource-intensive hasher (e.g., `plaintext` or `auto`
          with a low cost) for `App\Entity\User` in
          `config/packages/test/security.yaml`.
        correct: true
      - value: Disable password hashing entirely in the test environment.
        correct: false
      - value: Use a different algorithm like MD5 for faster hashing in tests.
        correct: false
      - value: Increase the hashing cost to ensure maximum security during tests.
        correct: false
    help: For faster test execution, it's common practice to use a quicker password
      hasher algorithm or a lower cost factor in the `test` environment, as
      strong security is not the primary concern during testing.
  - question: Which of the following is a correct way to run PHPUnit tests for a
      specific directory, e.g., `tests/Form`?
    answers:
      - value: "`php bin/phpunit tests/Form`"
        correct: true
      - value: "`php bin/phpunit --filter tests/Form`"
        correct: false
      - value: "`./vendor/bin/phpunit --dir tests/Form`"
        correct: false
      - value: "`php bin/console test:run tests/Form`"
        correct: false
    help: You can specify a directory or a specific test file as an argument to the
      `php bin/phpunit` command to run only those tests.
  - question: What is the purpose of
      `Symfony\Component\HttpClient\Response\MockResponse` when testing HTTP
      Clients?
    answers:
      - value: To create predefined, mock HTTP responses for the `MockHttpClient` to
          return, allowing you to control the client's behavior in tests.
        correct: true
      - value: To record actual HTTP responses for later playback.
        correct: false
      - value: To simulate network errors and timeouts.
        correct: false
      - value: To parse and validate HTTP responses.
        correct: false
    help: "`MockResponse` objects are used with `MockHttpClient` to define the
      responses that the HTTP client will return, enabling isolated and
      predictable testing of code that makes HTTP requests."
  - question: When writing a unit test for a custom form type, what is the role of
      `Symfony\Component\Form\PreloadedExtension`?
    answers:
      - value: It allows you to register specific form type instances with the
          `FormRegistry` for testing, ensuring your custom type is available.
        correct: true
      - value: It preloads all form types from your application for faster testing.
        correct: false
      - value: It provides a way to mock form extensions.
        correct: false
      - value: It's used to define default options for form types.
        correct: false
    help: "`PreloadedExtension` is useful in form unit tests to make specific form
      type instances available to the form factory, which is necessary when
      testing custom form types in isolation."
  - question: Which of the following is the correct way to get the `Request` object
      from the `Client` after a request has been made?
    answers:
      - value: "`$client->getRequest()`"
        correct: true
      - value: "`$client->getHistory()->current()->getRequest()`"
        correct: false
      - value: "`$client->getLastRequest()`"
        correct: false
      - value: "`$client->request()->getRequest()`"
        correct: false
    help: The `getRequest()` method on the `Client` object returns the `Request`
      object that was sent for the last interaction.
  - question: What does `$client->followRedirect();` do in a functional test?
    answers:
      - value: It follows the last redirect response, making a new request to the target
          URL and returning a new `Crawler`.
        correct: true
      - value: It configures the client to automatically follow all redirects for
          subsequent requests.
        correct: false
      - value: It asserts that the previous response was a redirect.
        correct: false
      - value: It prevents the client from following any redirects.
        correct: false
    help: "`followRedirect()` explicitly follows a single redirect. To automatically
      follow all redirects, you would use `$client->followRedirects()`."
  - question: To generate a console-based test coverage report with PHPUnit, which
      command option should you use?
    answers:
      - value: "`./vendor/bin/phpunit --coverage-text`"
        correct: true
      - value: "`./vendor/bin/phpunit --text-coverage`"
        correct: false
      - value: "`php bin/phpunit --coverage=text`"
        correct: false
      - value: "`php bin/console test:coverage --format=text`"
        correct: false
    help: The `--coverage-text` option outputs a summary of code coverage directly
      to the console.
  - question: Which of the following is true about the `bootKernel()` method in
      `KernelTestCase`?
    answers:
      - value: It boots the Symfony application kernel, ensuring a fresh kernel for each
          test.
        correct: true
      - value: It should only be called once per test suite.
        correct: false
      - value: It automatically creates a test client.
        correct: false
      - value: It is implicitly called when extending `WebTestCase`.
        correct: true
    help: "`bootKernel()` explicitly boots the kernel. `WebTestCase` calls it
      internally when `createClient()` is invoked. It's designed to be called
      for each test to provide isolation."
  - question: When testing a custom form theme with Twig, which specialized test
      case should you extend?
    answers:
      - value: "`Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`"
        correct: true
      - value: "`Symfony\\Component\\Form\\Test\\TypeTestCase`"
        correct: false
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`"
        correct: false
      - value: "`PHPUnit\\Framework\\TestCase`"
        correct: false
    help: "`FormLayoutTestCase` provides the necessary setup for testing Twig-based
      form themes, including methods to define template paths and Twig
      extensions."
  - question: "What is the effect of setting `framework.profiler.collect: false` in
      `config/packages/test/web_profiler.yaml`?"
    answers:
      - value: The profiler is enabled, but it will not collect data for every request
          unless explicitly enabled per test.
        correct: true
      - value: The profiler is completely disabled in the test environment.
        correct: false
      - value: The profiler will only collect data for requests that result in an error.
        correct: false
      - value: It forces the profiler to collect all data for every request.
        correct: false
    help: This configuration allows the profiler to be 'on' (enabled) but 'off' for
      collection by default, providing a performance benefit for tests while
      still allowing on-demand profiling.
  - question: Which method on the `Client` object allows you to retrieve the
      collected profiler data after a request?
    answers:
      - value: "`$client->getProfile()`"
        correct: true
      - value: "`$client->getProfilerData()`"
        correct: false
      - value: "`$client->getDebugProfile()`"
        correct: false
      - value: "`$client->retrieveProfile()`"
        correct: false
    help: After enabling the profiler and making a request, `getProfile()` returns
      the `Profile` object containing all collected data.
  - question: When writing a functional test for a Doctrine repository that
      interacts with a real database, which base class should you extend, and
      how do you get the `EntityManager`?
    answers:
      - value: Extend `KernelTestCase`, boot the kernel, and get the `EntityManager`
          from `static::getContainer()->get('doctrine')->getManager()`.
        correct: true
      - value: Extend `WebTestCase`, and the `EntityManager` is automatically injected.
        correct: false
      - value: Extend `PHPUnit\Framework\TestCase` and create a new `EntityManager`
          instance.
        correct: false
      - value: Extend `Doctrine\Bundle\DoctrineBundle\Test\RepositoryTestCase`.
        correct: false
    help: For repository tests requiring a real database, `KernelTestCase` is
      appropriate. You boot the kernel and then retrieve the `EntityManager`
      from the container.
  - question: What is the purpose of the `tearDown()` method in a PHPUnit test class
      extending `KernelTestCase` when dealing with Doctrine `EntityManager`?
    answers:
      - value: To close the `EntityManager` and set it to `null` to prevent memory
          leaks.
        correct: true
      - value: To roll back database transactions after each test.
        correct: false
      - value: To clear the Symfony cache after each test.
        correct: false
      - value: To reset the test client to its initial state.
        correct: false
    help: It's a best practice to close the `EntityManager` and nullify it in
      `tearDown()` to avoid memory leaks, especially when running many tests
      that interact with the database.
  - question: Which of the following is a valid way to assert that a response header
      does NOT contain a specific value?
    answers:
      - value: "`$this->assertResponseHeaderNotSame('Content-Type',
          'application/json');`"
        correct: true
      - value: "`$this->assertResponseHeaderDoesNotContain('Content-Type',
          'application/json');`"
        correct: false
      - value: "`$this->assertFalse($client->getResponse()->headers->contains('Content-\
          Type', 'application/json'));`"
        correct: false
      - value: "`$this->assertResponseHeaderNotPresent('Content-Type',
          'application/json');`"
        correct: false
    help: "`assertResponseHeaderNotSame()` is used to assert that a header's value
      is not exactly the expected value."
  - question: What is the primary reason for using `symfony/test-pack`?
    answers:
      - value: It installs `phpunit/phpunit` and other common testing dependencies for
          Symfony applications.
        correct: true
      - value: It provides a custom test runner for Symfony.
        correct: false
      - value: It's a collection of useful test fixtures.
        correct: false
      - value: It's required for running Panther tests.
        correct: false
    help: "`symfony/test-pack` is a Composer meta-package that simplifies the
      installation of standard testing tools for Symfony projects."
  - question: When testing a framework's exception handling, how can you simulate a
      `ResourceNotFoundException` to ensure a 404 response?
    answers:
      - value: Mock the URL matcher to throw a `ResourceNotFoundException` when
          `match()` is called.
        correct: true
      - value: Make a request to a non-existent URL.
        correct: false
      - value: Use `$this->expectException(ResourceNotFoundException::class);`.
        correct: false
      - value: Manually set the response status code to 404.
        correct: false
    help: To unit test exception handling, you mock the component that would
      typically throw the exception (e.g., the URL matcher) and configure it to
      throw the desired exception.
  - question: Which of the following is a correct way to run PHPUnit tests for a
      single test file, e.g., `tests/Form/UserTypeTest.php`?
    answers:
      - value: "`php bin/phpunit tests/Form/UserTypeTest.php`"
        correct: true
      - value: "`php bin/phpunit --file tests/Form/UserTypeTest.php`"
        correct: false
      - value: "`./vendor/bin/phpunit UserTypeTest`"
        correct: false
      - value: "`symfony test tests/Form/UserTypeTest.php`"
        correct: false
    help: You can specify the full path to a test file as an argument to the `php
      bin/phpunit` command.
  - question: What is the purpose of `Symfony\Component\Clock\MockClock::sleep(600)`
      in a test?
    answers:
      - value: It instantly advances the mocked time by 600 seconds (10 minutes) without
          actually pausing test execution.
        correct: true
      - value: It pauses the test execution for 600 seconds.
        correct: false
      - value: It sets the mocked time to 600 seconds from the current time.
        correct: false
      - value: It simulates a network delay of 600 milliseconds.
        correct: false
    help: "`MockClock::sleep()` is a powerful feature for testing time-sensitive
      logic, as it allows you to simulate the passage of time without
      introducing actual delays into your tests."
  - question: When using `Symfony\Bridge\PhpUnit\CoverageListener`, how can you
      provide a custom System Under Test (SUT) solver if the default logic for
      finding related code is insufficient?
    answers:
      - value: By providing a PHP callable (e.g., `My\Namespace\SutSolver::solve`) as an
          argument to the listener in `phpunit.xml.dist`.
        correct: true
      - value: By implementing a custom `CoverageListenerInterface`.
        correct: false
      - value: By configuring the SUT solver in `config/packages/test/framework.yaml`.
        correct: false
      - value: The SUT solver is not customizable.
        correct: false
    help: The `CoverageListener` allows you to specify a custom SUT solver, which is
      a callable that determines which code is covered by a given test.
  - question: Which of the following is NOT a valid method for the `Client` object
      to control redirect following?
    answers:
      - value: "`$client->disableRedirects()`"
        correct: true
      - value: "`$client->followRedirect()`"
        correct: false
      - value: "`$client->followRedirects()`"
        correct: false
      - value: "`$client->followRedirects(false)`"
        correct: false
    help: While `followRedirects(false)` disables automatic following, there isn't a
      `disableRedirects()` method. `followRedirect()` follows a single redirect,
      and `followRedirects()` (without arguments or with `true`) enables
      automatic following.
  - question: What is the purpose of `Symfony\Component\Stopwatch\Stopwatch` in the
      context of time-sensitive tests, and why can it lead to transient failures
      without `ClockMock`?
    answers:
      - value: It measures execution time. Without `ClockMock`, `sleep()` calls cause
          actual delays, making test durations unpredictable and prone to
          exceeding expected values due to system load.
        correct: true
      - value: It simulates time-based events. Without `ClockMock`, it cannot accurately
          simulate time changes.
        correct: false
      - value: It pauses test execution. Without `ClockMock`, it can only pause for
          fixed durations.
        correct: false
      - value: It tracks memory usage over time. Without `ClockMock`, it cannot
          accurately report memory consumption.
        correct: false
    help: The `Stopwatch` component measures real time. If a test uses `sleep()` or
      other time-dependent functions, the actual duration can vary, causing
      assertions to fail if not controlled by `ClockMock`.
  - question: What is the recommended way to create the test database and its schema
      for functional tests in Symfony?
    answers:
      - value: "`php bin/console --env=test doctrine:database:create` and `php
          bin/console --env=test doctrine:schema:create`"
        correct: true
      - value: "`php bin/console doctrine:fixtures:load --env=test`"
        correct: false
      - value: "`php bin/console doctrine:migrations:migrate --env=test`"
        correct: false
      - value: Manually create the database and run SQL scripts.
        correct: false
    help: Using the Doctrine console commands with `--env=test` ensures that the
      database operations are performed on the dedicated test database.
  - question: Which of the following is a valid assertion to check if an element
      matching a selector does NOT contain specific text?
    answers:
      - value: "`$this->assertSelectorTextNotContains('.my-class', 'Forbidden Text');`"
        correct: true
      - value: "`$this->assertSelectorNotTextContains('.my-class', 'Forbidden Text');`"
        correct: false
      - value: "`$this->assertFalse($crawler->filter('.my-class')->text()->contains('Fo\
          rbidden Text'));`"
        correct: false
      - value: "`$this->assertAnySelectorTextNotContains('.my-class', 'Forbidden
          Text');`"
        correct: true
    help: Both `assertSelectorTextNotContains()` (for the first matching element)
      and `assertAnySelectorTextNotContains()` (for any matching element) are
      valid assertions.
  - question: What is the primary purpose of a 'smoke test' in a Symfony
      application's test suite?
    answers:
      - value: To quickly verify that the most critical paths and URLs of the
          application load successfully and return a 2xx status code.
        correct: true
      - value: To test the performance of the application under heavy load.
        correct: false
      - value: To check for security vulnerabilities in the application.
        correct: false
      - value: To ensure all JavaScript functionalities are working correctly.
        correct: false
    help: A smoke test is a basic, quick test to ensure that the core
      functionalities of an application are working, often by checking if key
      pages return successful responses.
  - question: When should you use `PHPUnit\Framework\TestCase` instead of
      `Symfony\Bundle\FrameworkBundle\Test\KernelTestCase` or `WebTestCase`?
    answers:
      - value: When testing a single class or function in isolation, without needing the
          Symfony container, services, or HTTP request/response cycle.
        correct: true
      - value: When performing end-to-end browser tests.
        correct: false
      - value: When you need to interact with the database directly.
        correct: false
      - value: When testing a controller's full request lifecycle.
        correct: false
    help: "`PHPUnit\\Framework\\TestCase` is for true unit tests where you mock all
      external dependencies, ensuring the test focuses solely on the logic of
      the class under test."
  - question: How can you assert that a response does NOT have a specific header?
    answers:
      - value: "`$this->assertResponseNotHasHeader('X-Debug-Token');`"
        correct: true
      - value: "`$this->assertResponseHeaderMissing('X-Debug-Token');`"
        correct: false
      - value: "`$this->assertFalse($client->getResponse()->headers->has('X-Debug-Token\
          '));`"
        correct: false
      - value: "`$this->assertNoHeader('X-Debug-Token');`"
        correct: false
    help: "`assertResponseNotHasHeader()` is the dedicated assertion for checking
      the absence of a specific header."
  - question: What is the primary benefit of using
      `Symfony\Component\HttpClient\MockHttpClient` for testing code that makes
      HTTP requests?
    answers:
      - value: It allows you to simulate HTTP responses without making actual network
          calls, making tests faster, more reliable, and independent of external
          services.
        correct: true
      - value: It automatically records all outgoing HTTP requests for debugging
          purposes.
        correct: false
      - value: It provides a real HTTP client that can be used in tests.
        correct: false
      - value: It encrypts all HTTP traffic during tests for security.
        correct: false
    help: "`MockHttpClient` is essential for unit and integration testing of HTTP
      client usage, as it removes the dependency on external APIs and network
      connectivity."
  - question: When testing a Symfony console command, how do you execute the command
      and capture its output?
    answers:
      - value: Use `ApplicationTester` and its `execute()` method, then retrieve output
          with `getDisplay()`.
        correct: true
      - value: Call the command's `run()` method directly and capture `php://output`.
        correct: false
      - value: Use `Process` component to run the command and capture its output.
        correct: false
      - value: The `CommandTester` class is used for this purpose.
        correct: false
    help: "`ApplicationTester` (or `CommandTester` for a single command) provides a
      convenient way to execute console commands in tests and inspect their
      output and exit code."
  - question: Which of the following is true about the `Crawler` object's `filter()`
      method?
    answers:
      - value: It returns a new `Crawler` object containing elements that match the
          given CSS selector or XPath expression.
        correct: true
      - value: It modifies the current `Crawler` object to only include matching
          elements.
        correct: false
      - value: It returns an array of DOM elements.
        correct: false
      - value: It is used to assert the existence of elements.
        correct: false
    help: The `filter()` method is fundamental for navigating the DOM with the
      `Crawler`, allowing you to select specific elements based on CSS selectors
      or XPath.
  - question: What is the purpose of `static::getContainer()` in a `KernelTestCase`?
    answers:
      - value: To access the Symfony dependency injection container and retrieve public
          or non-removed private services.
        correct: true
      - value: To get the test client instance.
        correct: false
      - value: To retrieve the current request object.
        correct: false
      - value: To get the kernel instance itself.
        correct: false
    help: After booting the kernel, `static::getContainer()` provides access to the
      service container, allowing you to fetch and test your application's
      services.
  - question: When should you use `Symfony\Component\Panther\PantherTestCase` over
      `Symfony\Bundle\FrameworkBundle\Test\WebTestCase`?
    answers:
      - value: When your application heavily relies on JavaScript, AJAX, or needs real
          browser interaction for testing.
        correct: true
      - value: When you only need to test the HTTP layer of your application without
          JavaScript.
        correct: false
      - value: When you want to perform unit tests on your controllers.
        correct: false
      - value: When you need to mock external HTTP requests.
        correct: false
    help: Panther is designed for scenarios where `WebTestCase` (which simulates a
      browser without executing JavaScript) is insufficient, such as testing
      single-page applications or complex front-end interactions.
  - question: What is the primary advantage of using `MockClock` over `sleep()` for
      time-sensitive tests?
    answers:
      - value: "`MockClock` instantly advances time without actual delays, making tests
          faster and more reliable, while `sleep()` introduces real,
          unpredictable delays."
        correct: true
      - value: "`MockClock` allows testing in different timezones, which `sleep()` does
          not."
        correct: false
      - value: "`MockClock` can simulate past and future dates, unlike `sleep()`."
        correct: false
      - value: "`MockClock` integrates directly with PHPUnit, while `sleep()` requires
          manual setup."
        correct: false
    help: The key benefit of `MockClock` is its ability to manipulate time
      programmatically, eliminating the unpredictability and slowness associated
      with real-time delays in tests.
  - question: Which of the following is true about the `loginUser()` method in
      Symfony functional tests?
    answers:
      - value: It creates a `TestBrowserToken` and stores it in the test client's
          session.
        correct: true
      - value: It simulates a full login process, including form submission and
          authentication.
        correct: false
      - value: It requires a real user from the database to be passed as an argument.
        correct: false
      - value: It does not work with stateless firewalls.
        correct: true
    help: "`loginUser()` directly injects a security token, bypassing the actual
      login process. It's important to note its limitation with stateless
      firewalls, as it relies on session-based authentication."
  - question: How can you assert that a specific number of elements matching a
      selector exist in the response?
    answers:
      - value: "`$this->assertSelectorCount(5, '.my-item');`"
        correct: true
      - value: "`$crawler->filter('.my-item')->count() === 5;`"
        correct: false
      - value: "`$this->assertCount(5, $crawler->filter('.my-item'));`"
        correct: true
      - value: "`$this->assertSelectorExists('.my-item', 5);`"
        correct: false
    help: Both `assertSelectorCount()` and combining `assertCount()` with
      `Crawler::filter()` are valid ways to assert the number of matching
      elements.
  - question: What is the primary role of the `setUp()` method in a PHPUnit test class?
    answers:
      - value: To prepare the test environment before each test method is run.
        correct: true
      - value: To define the test methods.
        correct: false
      - value: To clean up the test environment after all tests in the class have run.
        correct: false
      - value: To initialize the PHPUnit test runner.
        correct: false
    help: "`setUp()` is a lifecycle method in PHPUnit that is executed before each
      test method. It's commonly used for initializing fixtures or setting up
      the test environment."
  - question: When performing a 'smoke test' on all application URLs using a data
      provider, why is it recommended to use raw URLs instead of generated URLs
      (e.g., from the router)?
    answers:
      - value: To ensure that the test fails if a public URL changes without proper
          redirection, catching broken links early.
        correct: true
      - value: To improve test performance by avoiding the routing component.
        correct: false
      - value: To make the tests independent of the routing configuration.
        correct: false
      - value: Raw URLs are easier to maintain.
        correct: false
    help: Using raw URLs in smoke tests helps identify issues where the public URL
      structure changes, which might not be caught if you rely on the router to
      generate URLs that might still be valid internally but lead to broken
      external links.
  - question: Which assertion method would you use to check if a form input field
      with a given name does NOT have a specific value?
    answers:
      - value: "`$this->assertInputValueNotSame('username', 'admin');`"
        correct: true
      - value: "`$this->assertInputValueDifferent('username', 'admin');`"
        correct: false
      - value: "`$this->assertNotInputValue('username', 'admin');`"
        correct: false
      - value: "`$this->assertFormValueNotSame('form_selector', 'username', 'admin');`"
        correct: true
    help: Both `assertInputValueNotSame()` and `assertFormValueNotSame()` are
      available for asserting that an input field's value is not equal to a
      specific value.
  - question: What is the significance of the `when@test` block in Symfony
      configuration files (e.g., `security.yaml`)?
    answers:
      - value: It allows you to apply specific configuration overrides only when the
          application is running in the `test` environment.
        correct: true
      - value: It defines configuration for all environments except `test`.
        correct: false
      - value: It's a deprecated way to configure the test environment.
        correct: false
      - value: It's used to enable or disable specific tests.
        correct: false
    help: The `when@env` syntax is a powerful feature for environment-specific
      configuration, allowing you to tailor settings (like security, profiler,
      or database) for different environments, including `test`.
  - question: When writing a unit test for a custom constraint, what is the purpose
      of the `validateValue()` method provided by `CompoundConstraintTestCase`?
    answers:
      - value: It executes the validation logic for the compound constraint against a
          given value and collects any violations.
        correct: true
      - value: It defines the value that the compound constraint will validate.
        correct: false
      - value: It asserts that a value is valid according to the constraint.
        correct: false
      - value: It generates random values for testing the constraint.
        correct: false
    help: "`validateValue()` is the entry point for testing a compound constraint.
      You pass the value to be validated, and the test case then allows you to
      assert against the generated violations."
  - question: Which of the following is a valid way to assert that a response header
      exists?
    answers:
      - value: "`$this->assertResponseHasHeader('Content-Type');`"
        correct: true
      - value: "`$this->assertHeaderExists('Content-Type');`"
        correct: false
      - value: "`$client->getResponse()->headers->has('Content-Type');`"
        correct: false
      - value: "`$this->assertResponseContainsHeader('Content-Type');`"
        correct: false
    help: "`assertResponseHasHeader()` is the dedicated assertion for checking the
      presence of a specific header in the response."
