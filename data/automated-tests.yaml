category: Automated Tests

questions:
  -
    question: >
      Which PHPUnit base class should be extended for unit tests in Symfony that do NOT require booting the Symfony kernel?
    answers:
      - { value: "`PHPUnit\\Framework\\TestCase`", correct: true }
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`", correct: false }
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`", correct: false }
      - { value: "`Symfony\\Component\\Panther\\PantherTestCase`", correct: false }
    help: |
      For pure unit tests that do not interact with the Symfony kernel or its services, `PHPUnit\\Framework\\TestCase` is the appropriate base class.
      https://symfony.com/doc/current/testing.html#unit-tests

  -
    question: >
      What is the primary purpose of the `static::createClient()` method in a Symfony `WebTestCase`?
    answers:
      - { value: "To create a new instance of the Symfony kernel.", correct: false }
      - { value: "To boot the Symfony kernel and return a test client that acts as a browser.", correct: true }
      - { value: "To establish a direct database connection for testing.", correct: false }
      - { value: "To generate a unique session ID for the test user.", correct: false }
    help: |
      `static::createClient()` boots the Symfony kernel and returns a `KernelBrowser` instance, which acts as a browser to make requests against your application.
      https://symfony.com/doc/current/testing.html#functional-tests

  -
    question: |
      Given a Symfony functional test extending `KernelTestCase`, how would you correctly access a service named `App\\Service\\NewsletterGenerator` from the dependency injection container?
    answers:
      - { value: "`$this->get('App\\Service\\NewsletterGenerator')`", correct: false }
      - { value: "`static::getContainer()->get(NewsletterGenerator::class)`", correct: true }
      - { value: "`$this->container->get(NewsletterGenerator::class)`", correct: false }
      - { value: "`self::get(NewsletterGenerator::class)`", correct: false }
    help: |
      After booting the kernel with `self::bootKernel()`, services can be accessed from the container using `static::getContainer()->get()`.
      https://symfony.com/doc/current/testing.html#accessing-the-service-container

  -
    question: >
      Which file is typically used to define a separate database connection specifically for the Symfony test environment, ensuring tests do not interfere with other environments?
    answers:
      - { value: "`.env`", correct: false }
      - { value: "`.env.local`", correct: false }
      - { value: "`.env.test`", correct: false }
      - { value: "`.env.test.local`", correct: true }
      - { value: "`config/packages/doctrine.yaml`", correct: false }
    help: |
      The `.env.test.local` file is the recommended place to override environment variables like `DATABASE_URL` for the test environment.
      https://symfony.com/doc/current/testing.html#database

  -
    question: >
      What is the primary benefit of installing and enabling `dama/doctrine-test-bundle` in a Symfony application's test suite?
    answers:
      - { value: "It automatically generates database migrations for test data.", correct: false }
      - { value: "It enables automatic database transaction rollback after each test, ensuring a clean state.", correct: true }
      - { value: "It provides a graphical interface for inspecting test database contents.", correct: false }
      - { value: "It allows running tests against multiple database types simultaneously.", correct: false }
    help: |
      `dama/doctrine-test-bundle` is used to wrap each test in a database transaction, which is then rolled back, ensuring test isolation and a clean database state.
      https://symfony.com/doc/current/testing.html#functional-tests-database

  -
    question: |
      You are writing a functional test and need to simulate a user being logged in without going through the login form. Which method of the test client should you use?
    answers:
      - { value: "`$client->submitForm('login', ['username' => 'test_user', 'password' => 'password']);`", correct: false }
      - { value: "`$client->setSession(['_security_main' => '...']);`", correct: false }
      - { value: "`$client->loginUser($userObject);`", correct: true }
      - { value: "`$client->request('POST', '/login', ['_username' => 'test_user', '_password' => 'password']);`", correct: false }
    help: |
      The `loginUser()` method on the test client allows you to simulate a user being logged in by setting the security token in the test client's session.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      Which of the following Symfony Crawler assertion methods correctly checks if an HTML element matching a given selector contains specific text?
    answers:
      - { value: "`$this->assertSelectorExists('.my-class', 'Expected Text');`", correct: false }
      - { value: "`$this->assertSelectorTextContains('h1', 'Welcome');`", correct: true }
      - { value: "`$this->assertContains('Welcome', $crawler->filter('h1')->text());`", correct: false }
      - { value: "`$this->assertSelectorValueSame('input[name=\"username\"]', 'admin');`", correct: false }
    help: |
      `assertSelectorTextContains()` is used to assert that the first element matching the given selector contains the expected text.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: |
      You want to inspect the Symfony Profiler data for a specific request in your functional test. How do you enable the profiler for the very next request and retrieve its data?
    answers:
      - { value: "`$client->enableProfiler(); $crawler = $client->request('GET', '/'); $profile = $client->getProfile();`", correct: true }
      - { value: "`$client->request('GET', '/', ['_profile' => true]); $profile = $client->getProfile();`", correct: false }
      - { value: "`$client->getProfile()->enable(); $crawler = $client->request('GET', '/');`", correct: false }
      - { value: "The profiler is always enabled in tests; just call `$client->getProfile();`", correct: false }
    help: |
      Call `enableProfiler()` on the client before making the request to enable it for the next request, then retrieve the profile using `getProfile()`.
      https://symfony.com/doc/current/testing.html#accessing-the-profiler

  -
    question: >
      To make a time-sensitive test reliable using the Symfony PHPUnit bridge's `ClockMock` functionality, which annotation should be applied to the test class?
    answers:
      - { value: "`@coversNothing`", correct: false }
      - { value: "`@group time-sensitive`", correct: true }
      - { value: "`@mockClock`", correct: false }
      - { value: "`@depends ClockMock`", correct: false }
    help: |
      The `@group time-sensitive` annotation, when used with the Symfony PHPUnit bridge, automatically enables `ClockMock` for the test, ensuring predictable time-based function behavior.
      https://symfony.com/doc/current/components/phpunit_bridge.html#making-time-sensitive-tests-reliable

  -
    question: >
      Which environment variable is used to configure the Symfony Deprecations Helper when running PHPUnit tests, for example, to ignore deprecations listed in a specific file?
    answers:
      - { value: "`SYMFONY_DEBUG`", correct: false }
      - { value: "`SYMFONY_TEST_ENV`", correct: false }
      - { value: "`SYMFONY_DEPRECATIONS_HELPER`", correct: true }
      - { value: "`PHPUNIT_DEPRECATIONS`", correct: false }
    help: |
      The `SYMFONY_DEPRECATIONS_HELPER` environment variable controls the behavior of the deprecations helper, allowing you to specify a baseline file or ignore certain deprecations.
      https://symfony.com/doc/current/components/phpunit_bridge.html#handling-legacy-deprecated-code

  -
    question: >
      When performing a functional test with `WebTestCase`, what is the default behavior of the test client regarding HTTP redirects after a request?
    answers:
      - { value: "It automatically follows all redirects by default.", correct: false }
      - { value: "It never follows redirects; you must manually handle them.", correct: false }
      - { value: "It does not follow redirects automatically unless explicitly configured to do so.", correct: true }
      - { value: "It prompts the user to confirm following each redirect.", correct: false }
    help: |
      By default, the Symfony test client does not automatically follow redirects. You need to call `$client->followRedirect()` or `$client->followRedirects()` to handle them.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: |
      Consider the following PHPUnit XML configuration snippet:

      ```xml
      <listeners>
          <listener class="Symfony\Bridge\PhpUnit\CoverageListener"/>
      </listeners>
      ```

      What is the primary purpose of adding the `Symfony\\Bridge\\PhpUnit\\CoverageListener`?
    answers:
      - { value: "To automatically generate `@depends` annotations for tests.", correct: false }
      - { value: "To enable XDebug for code coverage analysis.", correct: false }
      - { value: "To automatically add `@covers` annotations to test classes for accurate code coverage reporting.", correct: true }
      - { value: "To listen for test failures and send notifications.", correct: false }
    help: |
      The `CoverageListener` automatically adds the appropriate `@covers` annotation to test classes, ensuring that code coverage is accurately reported by linking tests to the specific code they are intended to cover.
      https://symfony.com/doc/current/components/phpunit_bridge.html#accurate-code-coverage

  -
    question: >
      When writing a unit test for a service that depends on Doctrine's `EntityManager`, what is the recommended approach to isolate the service from the database?
    answers:
      - { value: "Use a real database connection but clear it before each test.", correct: false }
      - { value: "Mock the `EntityManager` and its `getRepository()` method to return mock repositories.", correct: true }
      - { value: "Inject a `null` value for the `EntityManager` to skip database operations.", correct: false }
      - { value: "Extend `WebTestCase` and use a test database.", correct: false }
    help: |
      For unit tests, mocking dependencies like the `EntityManager` allows you to test the service in isolation without relying on a real database.
      https://symfony.com/doc/current/testing/database.html#unit-testing-a-doctrine-repository

  -
    question: >
      Which of the following commands is used to create the dedicated test database and its schema in a Symfony application?
    answers:
      - { value: "`php bin/console doctrine:database:create`", correct: false }
      - { value: "`php bin/console --env=test doctrine:database:create && php bin/console --env=test doctrine:schema:create`", correct: true }
      - { value: "`php bin/console doctrine:migrations:migrate --env=test`", correct: false }
      - { value: "`php bin/console --env=test doctrine:fixtures:load`", correct: false }
    help: |
      You must explicitly specify the `test` environment when creating the database and schema for tests.
      https://symfony.com/doc/current/testing.html#database

  -
    question: >
      What is the purpose of the `Symfony\\Bundle\\FrameworkBundle\\Test\\TestBrowserToken` class?
    answers:
      - { value: "It's a security token used for API authentication in tests.", correct: false }
      - { value: "It represents a mock browser for end-to-end testing.", correct: false }
      - { value: "It's a special token object created by `loginUser()` and stored in the test client's session.", correct: true }
      - { value: "It's used to track browser history during functional tests.", correct: false }
    help: |
      The `TestBrowserToken` is an internal class used by Symfony's test client to manage the logged-in user's security token within the test session.
      https://symfony.com/doc/current/testing.html#simulating-user-login

  -
    question: >
      When configuring the Symfony Profiler for the test environment, what is the effect of setting `collect: false` under `framework.profiler` in `config/packages/test/web_profiler.yaml`?
    answers:
      - { value: "The profiler is completely disabled and cannot be used in tests.", correct: false }
      - { value: "The profiler is enabled, but it does not collect data unless explicitly requested per test via `$client->enableProfiler()`.", correct: true }
      - { value: "The profiler collects data for all requests but does not display it in the web debug toolbar.", correct: false }
      - { value: "It forces the profiler to collect only critical errors, ignoring other data.", correct: false }
    help: |
      Setting `collect: false` means the profiler is enabled but won't collect data by default, improving test performance. Data collection can be triggered per test using `$client->enableProfiler()`.
      https://symfony.com/doc/current/testing/profiling.html

  -
    question: |
      You have a functional test that makes a request and expects a redirect. Which assertion should you use to verify that the response is a redirect to a specific location?
    answers:
      - { value: "`$this->assertResponseIsSuccessful();`", correct: false }
      - { value: "`$this->assertResponseStatusCodeSame(302);`", correct: false }
      - { value: "`$this->assertResponseRedirects('/expected-path', 302);`", correct: true }
      - { value: "`$this->assertResponseHasHeader('Location');`", correct: false }
    help: |
      The `assertResponseRedirects()` method allows you to assert that the response is a redirect and optionally check the target location and status code.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the primary benefit of using `Symfony\\Component\\Panther\\PantherTestCase` for end-to-end testing in Symfony?
    answers:
      - { value: "It allows running JavaScript and interacting with a real browser.", correct: true }
      - { value: "It provides faster test execution than `WebTestCase` by skipping the browser layer.", correct: false }
      - { value: "It automatically generates screenshots for every test step.", correct: false }
      - { value: "It integrates directly with API Platform for testing REST APIs.", correct: false }
    help: |
      Panther allows you to run tests in a real browser (headless Chrome or Firefox) to test JavaScript-heavy applications and simulate user interactions.
      https://symfony.com/doc/current/testing/end_to_end.html

  -
    question: |
      When using Symfony Panther, what is the purpose of the `waitForElementToContain()` method on the client?
    answers:
      - { value: "To assert that an element immediately contains specific text.", correct: false }
      - { value: "To pause test execution until a specified element is attached to the DOM.", correct: false }
      - { value: "To wait for a specific element's content to change and contain the expected text, useful for asynchronous updates.", correct: true }
      - { value: "To check if an element's attribute contains a certain value.", correct: false }
    help: |
      Panther's `waitForElementToContain()` method is a "future assertion" that waits for a condition to be met, specifically for an element to contain certain text, which is crucial for testing asynchronous UI updates.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      Which PHPUnit command would you use to generate an HTML test coverage report that can be viewed in a web browser?
    answers:
      - { value: "`./vendor/bin/phpunit --coverage-text`", correct: false }
      - { value: "`./vendor/bin/phpunit --coverage-html=cov/`", correct: true }
      - { value: "`./vendor/bin/phpunit --coverage-xml=coverage.xml`", correct: false }
      - { value: "`./vendor/bin/phpunit --generate-report`", correct: false }
    help: |
      The `--coverage-html` option generates an HTML report, which requires XDebug to be enabled.
      https://symfony.com/doc/current/create_framework/unit_testing.html#code-coverage

  -
    question: >
      What is the main reason to use `composer require --dev symfony/test-pack` when setting up a Symfony project?
    answers:
      - { value: "It installs all production dependencies for testing.", correct: false }
      - { value: "It includes `phpunit/phpunit` and other necessary development dependencies for testing.", correct: true }
      - { value: "It configures the web server for running tests.", correct: false }
      - { value: "It generates boilerplate code for all test types.", correct: false }
    help: |
      The `symfony/test-pack` is a Composer meta-package that pulls in common testing tools like PHPUnit and other Symfony Bridge components.
      https://symfony.com/doc/current/testing.html#installation

  -
    question: |
      Consider a Symfony functional test where you need to make a request to a URL that might return a 404 Not Found response. Which assertion should you use to verify this specific status code?
    answers:
      - { value: "`$this->assertResponseIsSuccessful();`", correct: false }
      - { value: "`$this->assertResponseStatusCodeSame(404);`", correct: true }
      - { value: "`$this->assertResponseRedirects();`", correct: false }
      - { value: "`$this->assertResponseHasHeader('Content-Type');`", correct: false }
    help: |
      `assertResponseStatusCodeSame()` allows you to assert that the HTTP response has a specific status code.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `bootKernel()` method in `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      - { value: "To start the web server for functional tests.", correct: false }
      - { value: "To initialize the database connection.", correct: false }
      - { value: "To boot the Symfony application kernel, ensuring test isolation by rebooting for each test.", correct: true }
      - { value: "To load all configured services into memory.", correct: false }
    help: |
      `bootKernel()` is essential for integration tests as it sets up the Symfony environment, including the service container, for each test run.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: >
      When writing a functional test, after making a request with `$client->request('GET', '/some-path');`, how do you typically access the HTML content of the response to perform assertions?
    answers:
      - { value: "By calling `$client->getResponse()->getContent();` directly.", correct: false }
      - { value: "The `request()` method returns a `Crawler` object, which provides methods for navigating and asserting on the DOM.", correct: true }
      - { value: "By using `$client->getBrowser()->getHtml();`", correct: false }
      - { value: "You must parse the response content manually using `DOMDocument`.", correct: false }
    help: |
      The `request()` method of the test client returns a `Crawler` object, which is the primary tool for inspecting and interacting with the HTML content of the response.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      Which of the following is a valid way to run only the tests located in the `tests/Form/` directory using PHPUnit in a Symfony project?
    answers:
      - { value: "`php bin/phpunit --filter tests/Form/`", correct: false }
      - { value: "`php bin/phpunit tests/Form`", correct: true }
      - { value: "`php bin/phpunit --dir=tests/Form`", correct: false }
      - { value: "`php bin/phpunit --suite=Form`", correct: false }
    help: |
      You can specify a directory path to `php bin/phpunit` to run tests only within that directory.
      https://symfony.com/doc/current/testing.html#running-tests

  -
    question: >
      What is the purpose of the `#[AsCommand]` attribute in a Symfony console command, as it relates to testing?
    answers:
      - { value: "It allows the command to be executed directly from a functional test client.", correct: false }
      - { value: "It defines the command's name and description, which can be used when testing the command via `ApplicationTester`.", correct: true }
      - { value: "It automatically registers the command as a service for dependency injection in tests.", correct: false }
      - { value: "It marks the command as a test-only command, preventing its use in production.", correct: false }
    help: |
      The `#[AsCommand]` attribute configures the command's metadata, which is relevant when testing console commands, typically with `ApplicationTester`.
      https://symfony.com/doc/current/console.html#configuring-the-command

  -
    question: |
      When testing a Symfony console command using `ApplicationTester`, what is a crucial step to ensure you can retrieve the command's output and exit code after execution?
    answers:
      - { value: "Set `$application->setCatchExceptions(false);`", correct: false }
      - { value: "Set `$application->setAutoExit(false);`", correct: true }
      - { value: "Call `$tester->run(['command' => 'my:command'], ['interactive' => false]);`", correct: false }
      - { value: "Ensure the command itself does not call `exit()`.", correct: false }
    help: |
      Setting `setAutoExit(false)` on the `Application` instance is crucial when testing with `ApplicationTester` to prevent the script from exiting prematurely, allowing you to inspect results.
      https://symfony.com/doc/current/console.html#testing-commands

  -
    question: >
      Which of the following describes a "smoke test" in the context of Symfony functional testing?
    answers:
      - { value: "A test that verifies the application's performance under heavy load.", correct: false }
      - { value: "A test that checks if all application URLs load successfully and return a 2xx response.", correct: true }
      - { value: "A test that simulates a user's complete journey through the application.", correct: false }
      - { value: "A test that verifies the security vulnerabilities of the application.", correct: false }
    help: |
      Smoke tests are quick, high-level tests to ensure the most critical functions of an application are working, often by checking if key pages return successful responses.
      https://symfony.com/doc/current/best_practices.html#smoke-test-all-your-urls

  -
    question: |
      You are writing a functional test and want to ensure that a specific HTTP header, like `Content-Type`, is present in the response. Which assertion should you use?
    answers:
      - { value: "`$this->assertResponseHeaderSame('Content-Type', 'application/json');`", correct: false }
      - { value: "`$this->assertResponseHasHeader('Content-Type');`", correct: true }
      - { value: "`$this->assertResponseNotHasHeader('Content-Type');`", correct: false }
      - { value: "`$this->assertResponseIsSuccessful();`", correct: false }
    help: |
      `assertResponseHasHeader()` is used to assert that a given header is present in the response.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the primary purpose of `doctrine/doctrine-fixtures-bundle` in the context of Symfony testing?
    answers:
      - { value: "To manage database migrations for the test environment.", correct: false }
      - { value: "To provide tools for creating and loading dummy data (fixtures) into the database for tests.", correct: true }
      - { value: "To automatically rollback database changes after each test.", correct: false }
      - { value: "To generate mock entities for unit testing.", correct: false }
    help: |
      The Doctrine Fixtures Bundle is essential for populating your test database with consistent, known data before running functional tests.
      https://symfony.com/doc/current/testing.html#functional-tests-database

  -
    question: >
      When testing a form in Symfony, which base class is typically used for unit testing custom form types?
    answers:
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase`", correct: false }
      - { value: "`PHPUnit\\Framework\\TestCase`", correct: false }
      - { value: "`Symfony\\Component\\Form\\Test\\TypeTestCase`", correct: true }
      - { value: "`Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`", correct: false }
    help: |
      `TypeTestCase` is specifically designed for unit testing individual form types, providing a pre-configured environment for form creation and submission.
      https://symfony.com/doc/current/form/unit_testing.html

  -
    question: |
      You've generated a deprecation baseline file named `tests/allowed.json`. How would you run your PHPUnit tests to ignore deprecations listed in this file but still report new ones?
    answers:
      - { value: "`SYMFONY_DEPRECATIONS_HELPER='ignoreFile=./tests/allowed.json' ./vendor/bin/simple-phpunit`", correct: false }
      - { value: "`SYMFONY_DEPRECATIONS_HELPER='baselineFile=./tests/allowed.json' ./vendor/bin/simple-phpunit`", correct: true }
      - { value: "`./vendor/bin/simple-phpunit --ignore-deprecations=./tests/allowed.json`", correct: false }
      - { value: "`./vendor/bin/simple-phpunit --baseline=./tests/allowed.json`", correct: false }
    help: |
      The `baselineFile` option for `SYMFONY_DEPRECATIONS_HELPER` allows you to specify a file containing known deprecations to ignore.
      https://symfony.com/doc/current/components/phpunit_bridge.html#running-tests-with-a-deprecation-baseline

  -
    question: >
      What is the primary purpose of `Symfony\\Component\\Clock\\MockClock` in testing?
    answers:
      - { value: "To measure the execution time of test methods.", correct: false }
      - { value: "To simulate network latency for time-sensitive operations.", correct: false }
      - { value: "To control and manipulate the current time during tests, making time-sensitive logic predictable.", correct: true }
      - { value: "To synchronize time across distributed test environments.", correct: false }
    help: |
      `MockClock` allows you to freeze, advance, or modify the perceived time within your tests, which is invaluable for testing features dependent on time (e.g., expirations, schedules).
      https://symfony.com/doc/current/components/clock.html#testing

  -
    question: |
      Which of the following `Crawler` assertion methods would you use to check if a checkbox with a specific name is currently checked?
    answers:
      - { value: "`$this->assertInputValueSame('my_checkbox', 'checked');`", correct: false }
      - { value: "`$this->assertCheckboxChecked('my_checkbox');`", correct: true }
      - { value: "`$this->assertSelectorExists('input[name="my_checkbox"]:checked');`", correct: false }
      - { value: "`$this->assertSelectorTextContains('input[name="my_checkbox"]', 'checked');`", correct: false }
    help: |
      `assertCheckboxChecked()` is a dedicated assertion for verifying the state of a checkbox.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When performing end-to-end tests with Symfony Panther, what is the effect of running PHPUnit with `PANTHER_NO_HEADLESS=1` and `--debug`?
    answers:
      - { value: "It disables all JavaScript execution in the browser.", correct: false }
      - { value: "It runs the browser in headless mode but provides more detailed logs.", correct: false }
      - { value: "It opens a visible browser window and pauses tests on failure for manual inspection.", correct: true }
      - { value: "It generates a video recording of the test execution.", correct: false }
    help: |
      `PANTHER_NO_HEADLESS=1` prevents the browser from running in headless mode, and `--debug` pauses the test on failure, allowing you to interact with the browser directly.
      https://symfony.com/doc/current/testing/end_to_end.html#interactive-debug-mode

  -
    question: >
      What is the primary reason to configure a less resource-intensive password hasher specifically for the `test` environment in Symfony's `security.yaml`?
    answers:
      - { value: "To improve the security of test user passwords.", correct: false }
      - { value: "To speed up test execution by reducing the CPU overhead of password hashing.", correct: true }
      - { value: "To prevent test passwords from being accidentally used in production.", correct: false }
      - { value: "To enable password hashing for in-memory users.", correct: false }
    help: |
      Using a faster hasher (e.g., `plain` or a very low cost `bcrypt`) in the test environment significantly reduces test suite execution time, as strong hashing is not needed for test data.
      https://symfony.com/doc/current/security/passwords.html#configuring-password-hashers

  -
    question: >
      Which of the following is the correct command to generate a new application test class (e.g., a `WebTestCase`) using Symfony MakerBundle?
    answers:
      - { value: "`php bin/console make:controller TestController`", correct: false }
      - { value: "`php bin/console make:test`", correct: true }
      - { value: "`php bin/console make:entity Test`", correct: false }
      - { value: "`php bin/console make:functional-test`", correct: false }
    help: |
      The `make:test` command is an interactive tool that helps you generate various types of test classes, including `WebTestCase`.
      https://symfony.com/doc/current/testing.html#generating-a-test-class

  -
    question: |
      You are writing a functional test and need to assert that the page title (`<title>`) of the response is exactly "My Application Title". Which assertion should you use?
    answers:
      - { value: "`$this->assertSelectorTextContains('title', 'My Application Title');`", correct: false }
      - { value: "`$this->assertPageTitleContains('My Application Title');`", correct: false }
      - { value: "`$this->assertPageTitleSame('My Application Title');`", correct: true }
      - { value: "`$this->assertSelectorExists('title', 'My Application Title');`", correct: false }
    help: |
      `assertPageTitleSame()` is specifically designed to assert that the `<title>` element's content exactly matches the expected string.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `@runInSeparateProcess` PHPUnit annotation when testing multi-domain applications with Symfony Panther?
    answers:
      - { value: "It ensures that each test runs in its own isolated browser instance.", correct: false }
      - { value: "It allows tests to run concurrently across multiple CPU cores.", correct: false }
      - { value: "It ensures that each test runs in a separate PHP process, preventing state leakage between tests and allowing `external_base_uri` to work correctly for different domains.", correct: true }
      - { value: "It enables parallel execution of tests on different domains.", correct: false }
    help: |
      The `@runInSeparateProcess` annotation is crucial for multi-domain Panther tests to ensure that the `external_base_uri` option correctly applies to each test's isolated environment.
      https://symfony.com/doc/current/testing/end_to_end.html#testing-multi-domain-applications

  -
    question: >
      Which of the following is NOT a valid assertion method provided by the Symfony `WebTestClient` for HTTP responses?
    answers:
      - { value: "`assertResponseIsSuccessful()`", correct: false }
      - { value: "`assertResponseStatusCodeSame()`", correct: false }
      - { value: "`assertResponseContentContains()`", correct: true }
      - { value: "`assertResponseHasHeader()`", correct: false }
    help: |
      There is no direct `assertResponseContentContains()` method. You would typically use the `Crawler` object's assertions (e.g., `assertSelectorTextContains()`) to check for content.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: |
      You are unit testing a class that uses `DateTimeImmutable::now()`. To ensure consistent test results regardless of when the test runs, which Symfony component or PHPUnit Bridge feature can you leverage?
    answers:
      - { value: "The `Stopwatch` component.", correct: false }
      - { value: "The `ClockMock` functionality provided by the PHPUnit Bridge.", correct: true }
      - { value: "Manually setting the system time before running tests.", correct: false }
      - { value: "Using `sleep()` to simulate time progression.", correct: false }
    help: |
      The `ClockMock` feature of the Symfony PHPUnit Bridge allows you to mock time-related functions like `time()`, `microtime()`, `sleep()`, and `DateTimeImmutable::now()`.
      https://symfony.com/doc/current/components/phpunit_bridge.html#making-time-sensitive-tests-reliable

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist`?
    answers:
      - { value: "It starts a built-in PHP web server for all functional tests.", correct: false }
      - { value: "It manages the web server lifecycle for Panther tests, improving performance and enabling automatic screenshot capture on failures.", correct: true }
      - { value: "It configures the database server for Panther tests.", correct: false }
      - { value: "It provides a mock HTTP server for testing external API calls.", correct: false }
    help: |
      The `ServerExtension` is crucial for Panther tests as it efficiently manages the web server, ensuring it's up and down as needed and providing features like automatic screenshots.
      https://symfony.com/doc/current/testing/end_to_end.html#server-extension

  -
    question: >
      When writing a unit test for a custom Symfony Validator constraint, which base class should you extend?
    answers:
      - { value: "`PHPUnit\\Framework\\TestCase`", correct: false }
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`", correct: false }
      - { value: "`Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`", correct: true }
      - { value: "`Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase`", correct: false }
    help: |
      `ConstraintValidatorTestCase` is the recommended base class for unit testing custom constraint validators, providing helper methods for setting up the validator and asserting violations.
      https://symfony.com/doc/current/validation/custom_constraint.html#testing-the-constraint

  -
    question: >
      What is the main advantage of using `HarFileResponseFactory` with `MockHttpClient` for testing Symfony's HTTP Client?
    answers:
      - { value: "It allows making real HTTP requests to external services during tests.", correct: false }
      - { value: "It records HTTP interactions into HAR files for later analysis.", correct: false }
      - { value: "It enables creating mock responses based on recorded HTTP interactions in HAR files, ensuring realistic and reproducible tests without external dependencies.", correct: true }
      - { value: "It automatically generates HTTP client configuration from HAR files.", correct: false }
    help: |
      `HarFileResponseFactory` allows you to replay recorded HTTP interactions, making tests for HTTP client usage highly reproducible and independent of external services.
      https://symfony.com/doc/current/http_client.html#testing

  -
    question: |
      You are writing a functional test and need to assert that an input field with the name "email" has a specific value "test@example.com". Which assertion should you use?
    answers:
      - { value: "`$this->assertSelectorTextContains('input[name="email"]', 'test@example.com');`", correct: false }
      - { value: "`$this->assertInputValueSame('email', 'test@example.com');`", correct: true }
      - { value: "`$this->assertFormValue('form', 'email', 'test@example.com');`", correct: false }
      - { value: "`$this->assertSelectorAttributeSame('input[name="email"]', 'value', 'test@example.com');`", correct: false }
    help: |
      `assertInputValueSame()` is specifically designed to assert the value of a form input field by its name.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the recommended way to clear the Symfony cache directory for the `test` environment programmatically within a test setup (e.g., `setUp()` method)?
    answers:
      - { value: "`exec('php bin/console cache:clear --env=test');`", correct: false }
      - { value: "`(new \\Symfony\\Component\\Filesystem\\Filesystem())->remove(__DIR__.'/../var/cache/test');`", correct: true }
      - { value: "`$this->getContainer()->get('cache.app')->clear();`", correct: false }
      - { value: "The cache is automatically cleared by `bootKernel()`.", correct: false }
    help: |
      Manually removing the cache directory for the test environment ensures a clean state, especially when debug mode is disabled.
      https://symfony.com/doc/current/testing.html#caching

  -
    question: >
      Which of the following describes a "future assertion" in Symfony Panther tests?
    answers:
      - { value: "An assertion that checks conditions on elements that will be present in the next page load.", correct: false }
      - { value: "An assertion that checks conditions on elements that are expected to occur in the future, useful for asynchronous UI changes.", correct: true }
      - { value: "An assertion that predicts the outcome of a user interaction before it happens.", correct: false }
      - { value: "An assertion that verifies the state of the browser after a specific time delay.", correct: false }
    help: |
      Future assertions (e.g., `assertSelectorWillExist`, `assertSelectorWillContain`) allow tests to wait for and assert on dynamic changes in the DOM that happen asynchronously.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When writing a unit test for a compound constraint in Symfony, which base class should you extend?
    answers:
      - { value: "`Symfony\\Component\\Validator\\Test\\ConstraintValidatorTestCase`", correct: false }
      - { value: "`Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase`", correct: true }
      - { value: "`PHPUnit\\Framework\\TestCase`", correct: false }
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`", correct: false }
    help: |
      `CompoundConstraintTestCase` is specifically designed for testing custom compound constraints, providing methods to validate values against the compound constraint and assert specific violations.
      https://symfony.com/doc/current/validation/custom_constraint.html#testing-the-constraint

  -
    question: >
      What is the purpose of the `test:` configuration setting under `framework` in `config/packages/test/framework.yaml`?
    answers:
      - { value: "It enables the web debug toolbar for the test environment.", correct: false }
      - { value: "It loads services related to testing, such as `test.client`, when set to `true`.", correct: true }
      - { value: "It configures the test database connection.", correct: false }
      - { value: "It enables XDebug for code coverage generation.", correct: false }
    help: |
      The `test` setting in the framework configuration ensures that testing-specific services are loaded in the test environment.
      https://symfony.com/doc/current/reference/configuration/framework.html#test

  -
    question: >
      When using the Symfony PHPUnit bridge, what is the effect of configuring `Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener` in `phpunit.xml.dist`?
    answers:
      - { value: "It enables automatic database transaction management for tests.", correct: false }
      - { value: "It provides a custom test runner for faster execution.", correct: false }
      - { value: "It integrates Symfony-specific functionalities like `ClockMock` and deprecation handling into PHPUnit.", correct: true }
      - { value: "It generates a report of all executed tests.", correct: false }
    help: |
      The `SymfonyTestsListener` is the entry point for many features provided by the Symfony PHPUnit bridge, including time mocking and deprecation reporting.
      https://symfony.com/doc/current/components/phpunit_bridge.html#configuring-the-listener

  -
    question: >
      Which of the following is the correct command to run all PHPUnit tests in a Symfony application from the project root directory?
    answers:
      - { value: "`phpunit`", correct: false }
      - { value: "`php bin/phpunit`", correct: true }
      - { value: "`symfony run tests`", correct: false }
      - { value: "`composer test`", correct: false }
    help: |
      The `php bin/phpunit` command is the standard way to execute your application's PHPUnit tests.
      https://symfony.com/doc/current/testing.html#running-tests

  -
    question: |
      You are debugging a functional test and want to see the full HTTP request and response details. Which method on the `KernelBrowser` (client) object can help you access the request object after a request has been made?
    answers:
      - { value: "`$client->getRequest();`", correct: true }
      - { value: "`$client->getResponse();`", correct: true }
      - { value: "`$client->getLastRequest();`", correct: false }
      - { value: "`$client->getCurrentRequest();`", correct: false }
    help: |
      After a request, you can access the `Request` and `Response` objects via `$client->getRequest()` and `$client->getResponse()` respectively for introspection.
      https://symfony.com/doc/current/testing.html#request-and-response-introspection

  -
    question: >
      What is the primary role of the `Crawler` object returned by `$client->request()` in a Symfony functional test?
    answers:
      - { value: "To simulate user interactions like clicking and submitting forms.", correct: true }
      - { value: "To store the HTTP response headers.", correct: false }
      - { value: "To manage the test client's session.", correct: false }
      - { value: "To log all requests made during the test.", correct: false }
    help: |
      The `Crawler` object allows you to navigate the DOM of the response, select elements, extract data, and simulate interactions.
      https://symfony.com/doc/current/testing.html#the-crawler

  -
    question: >
      When testing a Symfony application, what is the main advantage of using `KernelTestCase` over `WebTestCase` for integration tests that don't involve HTTP requests?
    answers:
      - { value: "`KernelTestCase` is faster because it doesn't boot the kernel.", correct: false }
      - { value: "`KernelTestCase` provides direct access to the database without Doctrine.", correct: false }
      - { value: "`KernelTestCase` is suitable for testing services or commands that require the Symfony container but not a full HTTP request/response cycle.", correct: true }
      - { value: "`WebTestCase` is deprecated for integration tests.", correct: false }
    help: |
      `KernelTestCase` is ideal for integration tests focusing on service logic where you need the Symfony container but don't need to simulate HTTP requests.
      https://symfony.com/doc/current/testing.html#kerneltestcase

  -
    question: |
      You need to test a scenario where a user submits a form. After submitting the form using the `Crawler`'s `submit()` method, how do you typically check for a successful response?
    answers:
      - { value: "`$this->assertResponseIsSuccessful();`", correct: true }
      - { value: "`$this->assertResponseStatusCodeSame(200);`", correct: true }
      - { value: "`$this->assertResponseRedirects();`", correct: false }
      - { value: "`$this->assertSelectorExists('.success-message');`", correct: true }
    help: |
      After form submission, you can use `assertResponseIsSuccessful()` to check for a 2xx status code, `assertResponseStatusCodeSame(200)` for a specific 200 OK, or `assertSelectorExists()` to check for success messages.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: >
      What is the purpose of the `assertSelectorWillExist()` method in Symfony Panther?
    answers:
      - { value: "It asserts that an element exists immediately after the call.", correct: false }
      - { value: "It waits for an element to be attached to the DOM and then asserts its existence.", correct: true }
      - { value: "It asserts that an element will be removed from the DOM.", correct: false }
      - { value: "It asserts that an element is visible on the page.", correct: false }
    help: |
      `assertSelectorWillExist()` is a future assertion that waits for the element to appear in the DOM before asserting its existence, handling asynchronous loading.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      Which PHPUnit command would you use to output the test coverage results directly to the console without generating an HTML report?
    answers:
      - { value: "`./vendor/bin/phpunit --coverage-console`", correct: false }
      - { value: "`./vendor/bin/phpunit --coverage-text`", correct: true }
      - { value: "`./vendor/bin/phpunit --coverage-summary`", correct: false }
      - { value: "`./vendor/bin/phpunit --report-text`", correct: false }
    help: |
      The `--coverage-text` option outputs a summary of code coverage directly to the terminal.
      https://symfony.com/doc/current/create_framework/unit_testing.html#code-coverage

  -
    question: >
      When writing a functional test, how can you make the test client automatically follow all redirects after a request?
    answers:
      - { value: "`$client->followRedirect();`", correct: false }
      - { value: "`$client->followRedirects(true);`", correct: true }
      - { value: "`$client->setMaxRedirects(10);`", correct: false }
      - { value: "`$client->request('GET', '/')->followRedirects();`", correct: false }
    help: |
      Calling `$client->followRedirects()` (or `$client->followRedirects(true)`) configures the client to automatically follow redirects for subsequent requests.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      What is the primary purpose of defining `testsuites` in `phpunit.xml.dist` for a Symfony application?
    answers:
      - { value: "To specify the order in which tests should be executed.", correct: false }
      - { value: "To group and organize tests into logical sets, allowing for targeted execution.", correct: true }
      - { value: "To define custom PHPUnit listeners for specific test types.", correct: false }
      - { value: "To configure the database connections for different test environments.", correct: false }
    help: |
      Test suites allow you to define collections of tests, which can then be run together (e.g., all functional tests, all unit tests for a specific bundle).
      https://symfony.com/doc/current/configuration/multiple_kernels.html#test-suites

  -
    question: |
      You have a functional test that needs to check if a specific element with the class `error-message` does NOT exist on the page. Which assertion should you use?
    answers:
      - { value: "`$this->assertSelectorExists('.error-message');`", correct: false }
      - { value: "`$this->assertSelectorNotExists('.error-message');`", correct: true }
      - { value: "`$this->assertCount(0, $crawler->filter('.error-message'));`", correct: false }
      - { value: "`$this->assertFalse($crawler->filter('.error-message')->count() > 0);`", correct: false }
    help: |
      `assertSelectorNotExists()` is the direct and semantic way to assert that no element matches the given selector.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When using `MockClock` in a PHPUnit test, how can you instantly advance the perceived time by a specific duration (e.g., 10 minutes)?
    answers:
      - { value: "`$clock->sleep(600);`", correct: true }
      - { value: "`$clock->advance(new DateInterval('PT10M'));`", correct: false }
      - { value: "`$clock->modify('+10 minutes');`", correct: true }
      - { value: "`$clock->setNow(new DateTimeImmutable('+10 minutes'));`", correct: false }
    help: |
      `MockClock::sleep()` instantly changes the time as if that duration has passed. `MockClock::modify()` also allows advancing time using `DateTimeImmutable::modify()` formats.
      https://symfony.com/doc/current/components/clock.html#testing

  -
    question: >
      What is the purpose of the `getTemplatePaths()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      - { value: "To define the paths where Twig templates for form themes are located.", correct: true }
      - { value: "To return the paths to the Twig cache directory.", correct: false }
      - { value: "To specify the Twig extensions to be loaded for the test environment.", correct: false }
      - { value: "To get the path to the main application templates.", correct: false }
    help: |
      `getTemplatePaths()` is an overridable method that allows you to tell the test case where to find your Twig form themes.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      Which of the following is a valid way to run tests for a specific file, for example, `tests/Form/UserTypeTest.php`?
    answers:
      - { value: "`php bin/phpunit --file tests/Form/UserTypeTest.php`", correct: false }
      - { value: "`php bin/phpunit tests/Form/UserTypeTest.php`", correct: true }
      - { value: "`php bin/phpunit --test=UserTypeTest`", correct: false }
      - { value: "`php bin/phpunit UserTypeTest.php`", correct: false }
    help: |
      You can specify the full path to a test file to run only the tests within that file.
      https://symfony.com/doc/current/testing.html#running-tests

  -
    question: |
      When writing a functional test, if your application redirects after a POST request, and you want to follow that redirect to assert on the redirected page, what method should you call on the client?
    answers:
      - { value: "`$client->followRedirect();`", correct: true }
      - { value: "`$client->request('GET', $client->getResponse()->headers->get('Location'));`", correct: false }
      - { value: "`$client->getHistory()->followRedirect();`", correct: false }
      - { value: "`$client->getResponse()->followRedirect();`", correct: false }
    help: |
      `$client->followRedirect()` makes a new request to the location specified in the `Location` header of the previous response.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Form\\PreloadedExtension` class in form testing?
    answers:
      - { value: "To register form type extensions that are loaded on demand.", correct: false }
      - { value: "To register preloaded form type instances with the `FormRegistry`, ensuring specific instances are used during testing.", correct: true }
      - { value: "To define custom form type guessers for the test environment.", correct: false }
      - { value: "To load all built-in Symfony form types for testing.", correct: false }
    help: |
      `PreloadedExtension` allows you to explicitly provide form type instances to the form factory, which is useful for testing specific form types in isolation.
      https://symfony.com/doc/current/form/unit_testing.html#form-extensions

  -
    question: >
      When should you use `Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase` instead of `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      - { value: "When you need to test individual services in isolation.", correct: false }
      - { value: "When you need to simulate HTTP requests and interact with the application through a client, like a browser.", correct: true }
      - { value: "When you are writing pure unit tests that do not involve the Symfony kernel.", correct: false }
      - { value: "When you need to test console commands.", correct: false }
    help: |
      `WebTestCase` extends `KernelTestCase` and adds the functionality to create a test client for making HTTP requests, making it suitable for functional tests.
      https://symfony.com/doc/current/testing.html#functional-tests

  -
    question: >
      What is the primary purpose of the `Symfony\\Component\\BrowserKit\\HttpBrowser` (or `KernelBrowser`) object in Symfony's testing framework?
    answers:
      - { value: "To render Twig templates in isolation.", correct: false }
      - { value: "To simulate a web browser, allowing you to make requests and interact with the application.", correct: true }
      - { value: "To manage the application's routing configuration.", correct: false }
      - { value: "To provide an interface for interacting with the database.", correct: false }
    help: |
      The `HttpBrowser` (or `KernelBrowser` in functional tests) acts as a virtual browser, enabling you to send requests and receive responses programmatically.
      https://symfony.com/doc/current/testing.html#the-test-client

  -
    question: |
      You are writing a functional test and need to check if a specific element, e.g., a `div` with ID `my-element`, exists on the page. Which assertion should you use?
    answers:
      - { value: "`$this->assertSelectorTextContains('#my-element', '');`", correct: false }
      - { value: "`$this->assertSelectorExists('#my-element');`", correct: true }
      - { value: "`$this->assertCount(1, $crawler->filter('#my-element'));`", correct: false }
      - { value: "`$this->assertPageContains('#my-element');`", correct: false }
    help: |
      `assertSelectorExists()` is the most direct way to assert the presence of an element matching a CSS selector.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      Which of the following describes a valid scenario for using `static::getContainer()->get()` in a Symfony functional test?
    answers:
      - { value: "To create a new instance of a service that is not registered in the container.", correct: false }
      - { value: "To retrieve a private service that has been explicitly marked as `public` or is not `removed` for testing purposes.", correct: true }
      - { value: "To directly access database entities without using a repository.", correct: false }
      - { value: "To boot the Symfony kernel before making any requests.", correct: false }
    help: |
      `static::getContainer()->get()` allows access to services from the dependency injection container after the kernel has been booted, including private services if they are not removed.
      https://symfony.com/doc/current/testing.html#accessing-the-service-container

  -
    question: >
      What is the purpose of the `getExtensions()` method in `Symfony\\Component\\Form\\Test\\TypeTestCase`?
    answers:
      - { value: "To return a list of form extensions to register for the current test case.", correct: true }
      - { value: "To get the file extensions of form templates.", correct: false }
      - { value: "To retrieve the Twig extensions used for form rendering.", correct: false }
      - { value: "To define custom form types that extend existing ones.", correct: false }
    help: |
      `getExtensions()` is an overridable method that allows you to register additional form extensions needed for your specific form type tests.
      https://symfony.com/doc/current/form/unit_testing.html#form-extensions

  -
    question: >
      When testing a Symfony application, what is the primary reason to use a separate test database (e.g., defined in `.env.test.local`) instead of the development database?
    answers:
      - { value: "To improve the performance of the development database.", correct: false }
      - { value: "To prevent test data from polluting the development or production databases and ensure test isolation.", correct: true }
      - { value: "To allow parallel execution of tests and development work.", correct: false }
      - { value: "To enable different database drivers for testing.", correct: false }
    help: |
      Using a separate test database is crucial for ensuring that tests are isolated and repeatable, as they won't affect or be affected by data in other environments.
      https://symfony.com/doc/current/testing.html#database

  -
    question: >
      Which of the following is a valid way to run all tests of the application using PHPUnit?
    answers:
      - { value: "`$ php bin/phpunit`", correct: true }
      - { value: "`$ phpunit --all`", correct: false }
      - { value: "`$ composer test`", correct: false }
      - { value: "`$ symfony run tests:all`", correct: false }
    help: |
      Running `php bin/phpunit` without any arguments will execute all tests configured in `phpunit.xml.dist`.
      https://symfony.com/doc/current/testing.html#running-tests

  -
    question: >
      What is the purpose of the `assertAnySelectorTextContains()` method in the Symfony Crawler?
    answers:
      - { value: "Asserts that the first element matching the selector contains the text.", correct: false }
      - { value: "Asserts that at least one element matching the given selector contains the expected text.", correct: true }
      - { value: "Asserts that all elements matching the selector contain the text.", correct: false }
      - { value: "Asserts that no element matching the selector contains the text.", correct: false }
    help: |
      `assertAnySelectorTextContains()` is useful when you need to confirm that at least one instance of an element contains specific text, without caring which specific instance it is.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When testing a Symfony application with GitHub Actions, which action is commonly used to install Composer dependencies?
    answers:
      - { value: "`actions/setup-php@v2`", correct: false }
      - { value: "`ramsey/composer-install@v2`", correct: true }
      - { value: "`php-actions/composer@v1`", correct: false }
      - { value: "`shivammathur/setup-php@v2`", correct: false }
    help: |
      The `ramsey/composer-install` action is a popular choice for efficiently installing Composer dependencies in GitHub Actions workflows.
      https://symfony.com/doc/current/testing/end_to_end.html#github-actions

  -
    question: >
      What is the primary difference between `assertResponseIsSuccessful()` and `assertResponseStatusCodeSame(200)` in Symfony functional tests?
    answers:
      - { value: "`assertResponseIsSuccessful()` checks for any 2xx status code, while `assertResponseStatusCodeSame(200)` specifically checks for a 200 OK status.", correct: true }
      - { value: "`assertResponseIsSuccessful()` is for GET requests, and `assertResponseStatusCodeSame(200)` is for POST requests.", correct: false }
      - { value: "There is no functional difference; they are interchangeable.", correct: false }
      - { value: "`assertResponseIsSuccessful()` is deprecated.", correct: false }
    help: |
      `assertResponseIsSuccessful()` provides a broader check for any successful HTTP status code (200-299), whereas `assertResponseStatusCodeSame(200)` is more specific.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the purpose of the `getProfile()` method on the Symfony test client after enabling the profiler?
    answers:
      - { value: "To get the current user's security profile.", correct: false }
      - { value: "To retrieve the collected data from the Symfony Profiler for the last request.", correct: true }
      - { value: "To get the memory usage profile of the test run.", correct: false }
      - { value: "To access the database query log.", correct: false }
    help: |
      After enabling the profiler and making a request, `getProfile()` provides access to the `Profile` object, which contains all collected data for that request.
      https://symfony.com/doc/current/testing.html#accessing-the-profiler

  -
    question: >
      When performing a functional test, how can you manually follow a redirect after a response has been received?
    answers:
      - { value: "`$client->request('GET', $client->getResponse()->headers->get('Location'));`", correct: false }
      - { value: "`$crawler = $client->followRedirect();`", correct: true }
      - { value: "`$client->getResponse()->sendRedirect();`", correct: false }
      - { value: "`$client->followRedirects(true);`", correct: false }
    help: |
      The `followRedirect()` method on the client explicitly follows the redirect indicated by the last response's `Location` header.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      Which of the following is NOT a valid `Crawler` assertion method for checking text content?
    answers:
      - { value: "`assertSelectorTextContains()`", correct: false }
      - { value: "`assertSelectorTextNotContains()`", correct: false }
      - { value: "`assertSelectorTextEquals()`", correct: true }
      - { value: "`assertSelectorTextSame()`", correct: false }
    help: |
      The correct assertion for exact text equality is `assertSelectorTextSame()`, not `assertSelectorTextEquals()`.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `getTypes()` method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase`?
    answers:
      - { value: "To return a list of custom form types required for integration tests.", correct: true }
      - { value: "To retrieve the default form types provided by Symfony.", correct: false }
      - { value: "To define the data types used in form fields.", correct: false }
      - { value: "To get the number of form types registered in the application.", correct: false }
    help: |
      `getTypes()` allows you to register any custom form types your integration test needs to use.
      https://symfony.com/doc/current/form/unit_testing.html#form-integration-tests

  -
    question: >
      When testing a Symfony application, what is the role of the `tearDown()` method in a PHPUnit test class (e.g., `KernelTestCase`)?
    answers:
      - { value: "To initialize the test environment before each test.", correct: false }
      - { value: "To clean up resources (e.g., close EntityManager, reset static properties) after each test to prevent memory leaks or side effects.", correct: true }
      - { value: "To log test results to a file.", correct: false }
      - { value: "To skip tests that are no longer relevant.", correct: false }
    help: |
      The `tearDown()` method is part of PHPUnit's lifecycle and is used to perform cleanup operations after each test method has run.
      https://symfony.com/doc/current/testing/database.html#functional-testing-a-doctrine-repository

  -
    question: >
      What is the main reason to use `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase` when testing forms?
    answers:
      - { value: "To test the data transformation of form types.", correct: false }
      - { value: "To test the validation rules applied to form fields.", correct: false }
      - { value: "To test custom form themes and their rendering with Twig.", correct: true }
      - { value: "To test the submission of forms with different HTTP methods.", correct: false }
    help: |
      `FormLayoutTestCase` provides the necessary setup for testing how your form types are rendered using Twig templates and custom form themes.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      What is the purpose of the `assertSelectorWillNotBeVisible()` method in Symfony Panther?
    answers:
      - { value: "It asserts that an element is currently hidden.", correct: false }
      - { value: "It waits for an element to become hidden (invisible) and then asserts its state.", correct: true }
      - { value: "It asserts that an element will be removed from the DOM.", correct: false }
      - { value: "It asserts that an element will not contain specific text.", correct: false }
    help: |
      `assertSelectorWillNotBeVisible()` is a future assertion that waits for an element to become invisible before asserting its hidden state, useful for dynamic UI.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When writing a functional test, how can you pass specific server parameters (e.g., HTTP headers) to the test client's request?
    answers:
      - { value: "By using the `setServerParameter()` method on the client.", correct: false }
      - { value: "By passing an array of `server` parameters as the second argument to `createClient()`.", correct: true }
      - { value: "By setting environment variables before running the test.", correct: false }
      - { value: "By modifying the `$_SERVER` superglobal directly in the test.", correct: false }
    help: |
      The `createClient()` method accepts an optional array of server parameters that will be passed to the kernel's request.
      https://symfony.com/doc/current/testing.html#the-test-client

  -
    question: >
      What is the purpose of `Symfony\\Component\\HttpClient\\MockHttpClient` in the context of testing Symfony's HTTP Client?
    answers:
      - { value: "To make real HTTP requests to external APIs during tests.", correct: false }
      - { value: "To simulate HTTP requests and provide predefined responses without making actual network calls.", correct: true }
      - { value: "To measure the performance of HTTP requests.", correct: false }
      - { value: "To automatically generate HTTP client configurations.", correct: false }
    help: |
      `MockHttpClient` allows you to mock HTTP responses, enabling you to test code that uses the HTTP Client without relying on external services or network connectivity.
      https://symfony.com/doc/current/http_client.html#testing

  -
    question: >
      Which of the following is a valid way to run all tests within a specific test suite named "api" as defined in `phpunit.xml.dist`?
    answers:
      - { value: "`php bin/phpunit --testsuite api`", correct: true }
      - { value: "`php bin/phpunit --group api`", correct: false }
      - { value: "`php bin/phpunit tests/api`", correct: false }
      - { value: "`php bin/phpunit --suite=api`", correct: false }
    help: |
      The `--testsuite` option allows you to run tests belonging to a specifically defined test suite in your PHPUnit configuration.
      https://symfony.com/doc/current/configuration/multiple_kernels.html#test-suites

  -
    question: >
      When writing a unit test for a custom form type, which method of `TypeTestCase` should you override to provide custom form extensions?
    answers:
      - { value: "`getTypes()`", correct: false }
      - { value: "`getExtensions()`", correct: true }
      - { value: "`getTypeExtensions()`", correct: false }
      - { value: "`getFormFactory()`", correct: false }
    help: |
      `getExtensions()` is the method to override in `TypeTestCase` to register any additional form extensions required for your test.
      https://symfony.com/doc/current/form/unit_testing.html#form-extensions

  -
    question: >
      What is the main purpose of `Symfony\\Component\\HttpKernel\\KernelBrowser` in Symfony's testing framework?
    answers:
      - { value: "It's a specialized browser for end-to-end testing with JavaScript.", correct: false }
      - { value: "It's the test client returned by `WebTestCase::createClient()`, acting as a browser to make requests against the Symfony kernel.", correct: true }
      - { value: "It's a tool for debugging HTTP requests and responses.", correct: false }
      - { value: "It's a class for mocking HTTP client responses.", correct: false }
    help: |
      `KernelBrowser` is the concrete class used by `WebTestCase` to simulate HTTP requests and interact with the application's kernel.
      https://symfony.com/doc/current/testing.html#the-test-client

  -
    question: >
      Which of the following is the correct way to assert that a specific HTTP header, e.g., `Content-Type`, has an exact value "application/json" in a functional test?
    answers:
      - { value: "`$this->assertResponseHasHeader('Content-Type');`", correct: false }
      - { value: "`$this->assertResponseHeaderSame('Content-Type', 'application/json');`", correct: true }
      - { value: "`$this->assertResponseHeaderContains('Content-Type', 'json');`", correct: false }
      - { value: "`$this->assertResponseHeaderEquals('Content-Type', 'application/json');`", correct: false }
    help: |
      `assertResponseHeaderSame()` is used to assert that a specific header's value exactly matches the expected string.
      https://symfony.com/doc/current/testing.html#response-assertions

  -
    question: >
      What is the main benefit of using data providers in PHPUnit for functional tests (e.g., for smoke testing URLs)?
    answers:
      - { value: "To run tests in parallel, speeding up execution.", correct: false }
      - { value: "To define multiple sets of test data, allowing a single test method to be executed with different inputs.", correct: true }
      - { value: "To generate test data dynamically from a database.", correct: false }
      - { value: "To skip tests based on certain conditions.", correct: false }
    help: |
      Data providers allow you to write a single test method and run it multiple times with different sets of data, which is perfect for scenarios like smoke testing multiple URLs.
      https://symfony.com/doc/current/best_practices.html#smoke-test-all-your-urls

  -
    question: >
      When testing a Symfony console command, what is the purpose of the `ApplicationTester` class?
    answers:
      - { value: "To simulate user input during command execution.", correct: true }
      - { value: "To run console commands in a separate process.", correct: false }
      - { value: "To inspect the command's internal state during execution.", correct: false }
      - { value: "To generate mock console commands for testing.", correct: false }
    help: |
      `ApplicationTester` provides a way to run console commands programmatically and inspect their output, exit code, and interactions.
      https://symfony.com/doc/current/console.html#testing-commands

  -
    question: >
      What is the purpose of the `waitForStaleness()` method in Symfony Panther?
    answers:
      - { value: "To wait for an element to become visible.", correct: false }
      - { value: "To wait for an element to be removed from the DOM.", correct: true }
      - { value: "To wait for an element's content to change.", correct: false }
      - { value: "To wait for a network request to complete.", correct: false }
    help: |
      `waitForStaleness()` is a waiting method that pauses test execution until a specified element is no longer present in the DOM, useful for testing dynamic removals.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      Which of the following is the correct way to assert that the `<title>` element of the response contains the text "Dashboard"?
    answers:
      - { value: "`$this->assertPageTitleSame('Dashboard');`", correct: false }
      - { value: "`$this->assertPageTitleContains('Dashboard');`", correct: true }
      - { value: "`$this->assertSelectorTextContains('title', 'Dashboard');`", correct: false }
      - { value: "`$this->assertTitleContains('Dashboard');`", correct: false }
    help: |
      `assertPageTitleContains()` is specifically designed to check if the page title contains a given substring.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the primary purpose of the `SYMFONY_DEPRECATIONS_HELPER='ignoreFile=./tests/baseline-ignore'` environment variable when running PHPUnit tests?
    answers:
      - { value: "To generate a new deprecation baseline file.", correct: false }
      - { value: "To ignore all deprecations during the test run.", correct: false }
      - { value: "To ignore deprecations that are listed in the specified file.", correct: true }
      - { value: "To report deprecations as errors.", correct: false }
    help: |
      The `ignoreFile` option allows you to specify a file containing a list of deprecations that should be ignored by the deprecations helper.
      https://symfony.com/doc/current/components/phpunit_bridge.html#running-tests-ignoring-defined-deprecations

  -
    question: >
      When writing a functional test, how can you access the `Request` object that was sent by the test client to the application?
    answers:
      - { value: "`$client->getRequest();`", correct: true }
      - { value: "`$client->getContainer()->get('request_stack')->getCurrentRequest();`", correct: false }
      - { value: "`$client->getResponse()->getRequest();`", correct: false }
      - { value: "`$client->getHistory()->current()->getRequest();`", correct: false }
    help: |
      The `getRequest()` method on the `KernelBrowser` (client) returns the `Request` object that was used for the last request.
      https://symfony.com/doc/current/testing.html#request-and-response-introspection

  -
    question: >
      What is the purpose of the `Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension` in form testing?
    answers:
      - { value: "To integrate the Symfony Validator component, enabling validation features for form fields.", correct: true }
      - { value: "To provide a mock validator for unit tests.", correct: false }
      - { value: "To define custom validation constraints for forms.", correct: false }
      - { value: "To assert that form submissions are valid.", correct: false }
    help: |
      This extension is crucial for testing forms that rely on Symfony's validation component.
      https://symfony.com/doc/current/form/unit_testing.html#form-extensions

  -
    question: >
      When using Symfony Panther, what is the purpose of the `waitForVisibility()` method on the client?
    answers:
      - { value: "To assert that an element is currently visible.", correct: false }
      - { value: "To wait for an element to become visible on the page.", correct: true }
      - { value: "To wait for an element to be attached to the DOM.", correct: false }
      - { value: "To wait for an element's text content to change.", correct: false }
    help: |
      `waitForVisibility()` is a waiting method that pauses test execution until a specified element becomes visible, useful for testing dynamically appearing elements.
      https://symfony.com/doc/current/testing/end_to_end.html#waiting-for-elements

  -
    question: >
      What is the primary benefit of using `InMemoryUser` with `loginUser()` for testing authenticated routes in Symfony?
    answers:
      - { value: "It creates a persistent user in the test database.", correct: false }
      - { value: "It allows testing authentication without needing a real user database or a full registration process.", correct: true }
      - { value: "It encrypts user credentials for secure testing.", correct: false }
      - { value: "It automatically generates roles and permissions for the test user.", correct: false }
    help: |
      `InMemoryUser` provides a simple way to create a user object on the fly for testing purposes, avoiding the overhead of database interactions for user management.
      https://symfony.com/doc/current/testing.html#authenticating-users-in-tests

  -
    question: >
      When performing a functional test, how can you disable the automatic following of redirects by the test client?
    answers:
      - { value: "`$client->followRedirects(false);`", correct: true }
      - { value: "`$client->disableRedirects();`", correct: false }
      - { value: "`$client->request('GET', '/')->disableRedirects();`", correct: false }
      - { value: "Redirects are always followed automatically; you cannot disable it.", correct: false }
    help: |
      Calling `$client->followRedirects(false)` will prevent the client from automatically following redirects for subsequent requests.
      https://symfony.com/doc/current/testing.html#handling-redirects

  -
    question: >
      What is the purpose of the `getTwigExtensions()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      - { value: "To return an array of Twig extensions to be loaded for the test environment.", correct: true }
      - { value: "To get the path to the Twig cache directory.", correct: false }
      - { value: "To define custom Twig functions for form rendering.", correct: false }
      - { value: "To retrieve the Twig environment configuration.", correct: false }
    help: |
      This method allows you to register any custom Twig extensions that your form themes might rely on during testing.
      https://symfony.com/doc/current/form/unit_testing.html#testing-form-themes

  -
    question: >
      Which of the following describes a scenario where `assertSelectorCount()` would be most appropriate?
    answers:
      - { value: "To check if at least one element matches a selector.", correct: false }
      - { value: "To verify that a specific number of elements (e.g., 3 list items) match a given selector.", correct: true }
      - { value: "To assert that no elements match a selector.", correct: false }
      - { value: "To count the total number of HTML elements on the page.", correct: false }
    help: |
      `assertSelectorCount()` is used when you need to verify that an exact number of elements matching a selector are present in the response.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      When performing functional tests, what is the primary role of the `Profiler` object obtained via `$client->getProfile()`?
    answers:
      - { value: "To measure the execution time of the entire test suite.", correct: false }
      - { value: "To collect and analyze detailed data about a specific HTTP request, including performance, database queries, and events.", correct: true }
      - { value: "To generate a visual representation of the application's call stack.", correct: false }
      - { value: "To manage the test client's browser history.", correct: false }
    help: |
      The `Profiler` object provides access to all the data collected by the Symfony Web Profiler for a given request, allowing for deep introspection during tests.
      https://symfony.com/doc/current/testing.html#accessing-the-profiler

  -
    question: >
      What is the purpose of the `assertSelectorAttributeWillContain()` method in Symfony Panther?
    answers:
      - { value: "It asserts that an element's attribute immediately contains specific content.", correct: false }
      - { value: "It waits for an element's attribute to contain specific content and then asserts it.", correct: true }
      - { value: "It asserts that an element's attribute will be removed.", correct: false }
      - { value: "It asserts that an element's text content will contain specific text.", correct: false }
    help: |
      `assertSelectorAttributeWillContain()` is a future assertion that waits for a specific attribute of an element to contain certain content, useful for dynamic attribute changes.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When writing a unit test for a custom form type, which method of `FormIntegrationTestCase` should you override to provide custom form type guessers?
    answers:
      - { value: "`getTypes()`", correct: false }
      - { value: "`getTypeExtensions()`", correct: false }
      - { value: "`getTypeGuessers()`", correct: true }
      - { value: "`getExtensions()`", correct: false }
    help: |
      `getTypeGuessers()` allows you to register custom form type guessers that your form types might rely on for automatic type inference.
      https://symfony.com/doc/current/form/unit_testing.html#form-integration-tests

  -
    question: >
      What is the main reason to use `Symfony\\Component\\Filesystem\\Filesystem` to clear the cache in a test's `setUp()` or `tearDown()` method?
    answers:
      - { value: "It's faster than using `php bin/console cache:clear`.", correct: true }
      - { value: "It ensures that the cache is cleared even if the console command fails.", correct: false }
      - { value: "It's the only way to clear the cache in the test environment.", correct: false }
      - { value: "It prevents the cache from being cleared in other environments.", correct: false }
    help: |
      Programmatically clearing the cache using `Filesystem` is often preferred in tests for performance reasons, especially when `debug` is `false`.
      https://symfony.com/doc/current/testing.html#caching

  -
    question: >
      Which of the following is NOT a valid `Crawler` assertion method for checking input values?
    answers:
      - { value: "`assertInputValueSame()`", correct: false }
      - { value: "`assertInputValueNotSame()`", correct: false }
      - { value: "`assertFormValue()`", correct: false }
      - { value: "`assertInputChecked()`", correct: true }
    help: |
      There is no `assertInputChecked()` method; instead, `assertCheckboxChecked()` is used for checkboxes.
      https://symfony.com/doc/current/testing.html#crawler-assertions

  -
    question: >
      What is the purpose of the `assertSelectorWillNotContain()` method in Symfony Panther?
    answers:
      - { value: "It asserts that an element's text content immediately does not contain specific text.", correct: false }
      - { value: "It waits for an element's text content to no longer contain specific text and then asserts it.", correct: true }
      - { value: "It asserts that an element will be removed from the DOM.", correct: false }
      - { value: "It asserts that an element will not be visible.", correct: false }
    help: |
      `assertSelectorWillNotContain()` is a future assertion that waits for a specific text to be removed from an element's content, useful for dynamic updates.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When writing a functional test, how can you simulate a user submitting a form with specific data?
    answers:
      - { value: "`$client->request('POST', '/submit', ['form_data' => ['field' => 'value']]);`", correct: false }
      - { value: "`$crawler->filter('form')->submit(['field_name' => 'value']);`", correct: true }
      - { value: "`$client->submitForm('submit_button_text', ['field_name' => 'value']);`", correct: true }
      - { value: "`$client->clickLink('Submit');`", correct: false }
    help: |
      You can use the `submit()` method on a `Crawler` object filtered to a form, or the `submitForm()` method on the client with the button's text.
      https://symfony.com/doc/current/testing.html#submitting-forms

  -
    question: >
      What is the main purpose of `Symfony\\Component\\Form\\Extension\\Core\\CoreExtension` in form testing?
    answers:
      - { value: "It provides basic form types and functionality, registered by default in `TypeTestCase`.", correct: true }
      - { value: "It handles the integration with Doctrine ORM for forms.", correct: false }
      - { value: "It allows for custom form field rendering.", correct: false }
      - { value: "It provides advanced form validation rules.", correct: false }
    help: |
      The `CoreExtension` provides the fundamental form types (e.g., `TextType`, `ChoiceType`) and is usually registered by default when testing forms.
      https://symfony.com/doc/current/form/unit_testing.html#form-extensions

  -
    question: >
      When using `SYMFONY_DEPRECATIONS_HELPER`, what is the difference between `baselineFile` and `ignoreFile`?
    answers:
      - { value: "`baselineFile` reports new deprecations while ignoring those in the file; `ignoreFile` ignores all deprecations listed in the file, regardless of whether they are new or not.", correct: true }
      - { value: "`baselineFile` is for production, `ignoreFile` is for development.", correct: false }
      - { value: "`baselineFile` is used for PHPUnit, `ignoreFile` is for Panther.", correct: false }
      - { value: "There is no difference; they are aliases.", correct: false }
    help: |
      `baselineFile` is used to create a "baseline" of acceptable deprecations, reporting only new ones. `ignoreFile` simply suppresses reporting for all listed deprecations.
      https://symfony.com/doc/current/components/phpunit_bridge.html#running-tests-with-a-deprecation-baseline

  -
    question: >
      What is the purpose of the `assertSelectorWillBeEnabled()` method in Symfony Panther?
    answers:
      - { value: "It asserts that an element is currently enabled.", correct: false }
      - { value: "It waits for an element to become enabled and then asserts its state.", correct: true }
      - { value: "It asserts that an element will be disabled.", correct: false }
      - { value: "It asserts that an element will be visible.", correct: false }
    help: |
      `assertSelectorWillBeEnabled()` is a future assertion that waits for an element (e.g., a button) to transition to an enabled state, useful for testing dynamic UI.
      https://symfony.com/doc/current/testing/end_to_end.html#future-assertions

  -
    question: >
      When writing a functional test, how can you access the `Response` object received from the application after a request has been made?
    answers:
      - { value: "`$client->getResponse();`", correct: true }
      - { value: "`$client->getContainer()->get('request_stack')->getCurrentResponse();`", correct: false }
      - { value: "`$client->getRequest()->getResponse();`", correct: false }
      - { value: "`$client->getHistory()->current()->getResponse();`", correct: false }
    help: |
      The `getResponse()` method on the `KernelBrowser` (client) returns the `Response` object received from the application for the last request.
      https://symfony.com/doc/current/testing.html#request-and-response-introspection