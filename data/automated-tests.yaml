category: Automated Tests

questions:
  -
    question: >
      What is the recommended command to run all PHPUnit tests in a Symfony application?
    answers:
      - { value: "php bin/phpunit", correct: true }
      - { value: "composer test", correct: false }
      - { value: "symfony run tests", correct: false }
      - { value: "php vendor/bin/phpunit all", correct: false }
    help: |
      The `php bin/phpunit` command executes all tests configured in `phpunit.xml.dist`.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_1

  -
    question: >
      Which base class should you extend for writing functional tests in Symfony that involve HTTP requests and responses?
    answers:
      - { value: "PHPUnit\\Framework\\TestCase", correct: false }
      - { value: "Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase", correct: true }
      - { value: "Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase", correct: false }
      - { value: "Symfony\\Component\\BrowserKit\\HttpBrowser", correct: false }
    help: |
      `WebTestCase` is the base class for functional tests that simulate a web browser and interact with the application via HTTP requests.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_22

  -
    question: >
      After calling `static::createClient()` in a `WebTestCase`, what does the returned object primarily represent?
    answers:
      - { value: "A real web browser instance.", correct: false }
      - { value: "A simulated browser for making requests.", correct: true }
      - { value: "An HTTP client for external API calls.", correct: false }
      - { value: "A direct database connection.", correct: false }
    help: |
      The client returned by `createClient()` acts as a simulated browser, allowing you to make requests and inspect responses.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_22

  -
    question: >
      Which assertion method is used in Symfony functional tests to verify that an HTTP response was successful (HTTP status is 2xx)?
    answers:
      - { value: "assertResponseStatusCode(200)", correct: false }
      - { value: "assertResponseIsSuccessful()", correct: true }
      - { value: "assertSuccessfulResponse()", correct: false }
      - { value: "assertStatusCodeIs2xx()", correct: false }
    help: |
      The `assertResponseIsSuccessful()` method checks if the HTTP status code is in the 2xx range.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_45

  -
    question: >
      How can you access services from the Dependency Injection Container within a `KernelTestCase` after booting the kernel?
    answers:
      - { value: "$this->get('service_id')", correct: false }
      - { value: "self::getContainer()->get(ServiceClass::class)", correct: true }
      - { value: "static::get('service_id')", correct: false }
      - { value: "Kernel::getService('service_id')", correct: false }
    help: |
      After calling `self::bootKernel()`, you can retrieve services using `static::getContainer()->get()`.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_10

  -
    question: >
      What is the primary purpose of the `Crawler` object returned by `$client->request()` in a functional test?
    answers:
      - { value: "To send subsequent HTTP requests.", correct: false }
      - { value: "To interact directly with the database.", correct: false }
      - { value: "To navigate and query the HTML content of the response.", correct: true }
      - { value: "To manage the test client's session data.", correct: false }
    help: |
      The `Crawler` object provides methods to traverse the DOM and make assertions on the content of the HTML response.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      Which `Crawler` assertion method verifies that an element matching a given CSS selector contains specific text?
    answers:
      - { value: "assertSelectorContainsText()", correct: false }
      - { value: "assertTextContains()", correct: false }
      - { value: "assertSelectorTextContains()", correct: true }
      - { value: "assertElementTextContains()", correct: false }
    help: |
      `assertSelectorTextContains()` is used to check if the first element matching the selector includes the specified text.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      How can you configure the Symfony test client to automatically follow all redirects before a request is made?
    answers:
      - { value: "$client->followRedirects(true);", correct: true }
      - { value: "$client->enableAutoRedirect();", correct: false }
      - { value: "$client->request('GET', '/', [], [], [], [], true);", correct: false }
      - { value: "$client->followRedirect();", correct: false }
    help: |
      Calling `$client->followRedirects()` (or `$client->followRedirects(true)`) enables automatic redirect following.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_27

  -
    question: >
      To enable the Symfony Profiler for a specific request during a functional test, which method of the client object should be called *before* the request?
    answers:
      - { value: "$client->collectProfilerData()", correct: false }
      - { value: "$client->enableProfiler()", correct: true }
      - { value: "$client->startProfiling()", correct: false }
      - { value: "$client->getProfile()->enable()", correct: false }
    help: |
      The `enableProfiler()` method ensures that the profiler collects data for the very next request.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_39

  -
    question: >
      After enabling the profiler and making a request with the test client, how do you retrieve the collected profile data?
    answers:
      - { value: "$client->getProfilerData()", correct: false }
      - { value: "$client->getProfile()", correct: true }
      - { value: "$client->fetchProfile()", correct: false }
      - { value: "$client->retrieveProfile()", correct: false }
    help: |
      The `getProfile()` method returns the `Profile` object containing the collected data for the last request.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_39

  -
    question: >
      Which PHPUnit annotation, when used with the Symfony PHPUnit bridge, automatically enables `ClockMock` for a time-sensitive test?
    answers:
      - { value: "@timeSensitive", correct: false }
      - { value: "@mockClock", correct: false }
      - { value: "@group time-sensitive", correct: true }
      - { value: "@usesClockMock", correct: false }
    help: |
      The `@group time-sensitive` annotation, combined with `SymfonyTestsListener`, activates `ClockMock` for the test.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_21

  -
    question: >
      What is the main purpose of registering `Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener` in `phpunit.xml.dist`?
    answers:
      - { value: "To speed up test execution by disabling certain features.", correct: false }
      - { value: "To enable `ClockMock` and other Symfony PHPUnit bridge functionalities.", correct: true }
      - { value: "To manage database transactions for functional tests.", correct: false }
      - { value: "To generate detailed code coverage reports.", correct: false }
    help: |
      This listener integrates Symfony's PHPUnit bridge features, such as `ClockMock`, into your test suite.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_20

  -
    question: >
      Which method of the Symfony test client allows you to simulate a user being logged in for functional tests without going through a login form?
    answers:
      - { value: "$client->login('username', 'password')", correct: false }
      - { value: "$client->authenticateUser($user)", correct: false }
      - { value: "$client->loginUser($user)", correct: true }
      - { value: "$client->setUser($user)", correct: false }
    help: |
      The `loginUser()` method injects a user object into the test client's session, simulating a logged-in state.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_28

  -
    question: >
      What is `Symfony\\Bundle\\FrameworkBundle\\Test\\TestBrowserToken`?
    answers:
      - { value: "A token for API authentication in tests.", correct: false }
      - { value: "A special token object created by `loginUser()` and stored in the test client's session.", correct: true }
      - { value: "A token used for CSRF protection in functional tests.", correct: false }
      - { value: "A mock object for the security context.", correct: false }
    help: |
      `TestBrowserToken` is the security token used internally by Symfony when `loginUser()` is called.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_32

  -
    question: >
      Where is the recommended place to define a separate `DATABASE_URL` for the test environment in a Symfony application?
    answers:
      - { value: "config/services.yaml", correct: false }
      - { value: ".env", correct: false }
      - { value: ".env.test.local", correct: true }
      - { value: "config/packages/doctrine.yaml", correct: false }
    help: |
      The `.env.test.local` file is used to override environment variables specifically for the test environment.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_12

  -
    question: >
      What is the primary benefit of installing and enabling `dama/doctrine-test-bundle` for Symfony functional tests?
    answers:
      - { value: "It provides a custom database connection for tests.", correct: false }
      - { value: "It enables automatic database transaction rollback after each test.", correct: true }
      - { value: "It generates database fixtures automatically.", correct: false }
      - { value: "It speeds up Doctrine queries in tests.", correct: false }
    help: |
      This bundle ensures a clean database state for every test by rolling back transactions.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_14

  -
    question: >
      How is `DAMA\\DoctrineTestBundle\\PHPUnit\\PHPUnitExtension` enabled in PHPUnit for transactional tests?
    answers:
      - { value: "By adding it as a service in `services.yaml`.", correct: false }
      - { value: "By configuring it in `config/packages/test/doctrine.yaml`.", correct: false }
      - { value: "By adding an `<extension>` tag in `phpunit.xml.dist`.", correct: true }
      - { value: "By calling a method on the test client.", correct: false }
    help: |
      The bundle is enabled as a PHPUnit extension in the `phpunit.xml.dist` file.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_15

  -
    question: >
      Which Composer package is used to create and load dummy data (fixtures) into the database for testing purposes in Symfony?
    answers:
      - { value: "doctrine/orm", correct: false }
      - { value: "doctrine/data-fixtures", correct: false }
      - { value: "doctrine/doctrine-fixtures-bundle", correct: true }
      - { value: "symfony/maker-bundle", correct: false }
    help: |
      The `doctrine/doctrine-fixtures-bundle` provides the tools for managing test data.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_16

  -
    question: >
      What is the purpose of `KernelTestCase::bootKernel()`?
    answers:
      - { value: "To start the built-in web server for tests.", correct: false }
      - { value: "To initialize the database connection for the test.", correct: false }
      - { value: "To boot the Symfony application kernel, ensuring test isolation.", correct: true }
      - { value: "To clear the application cache before each test.", correct: false }
    help: |
      `bootKernel()` ensures that the Symfony kernel is booted and rebooted for each test to maintain isolation.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_4

  -
    question: >
      When unit testing a service that depends on Doctrine's `EntityManager`, how would you typically isolate the service from the real database?
    answers:
      - { value: "By using an in-memory SQLite database.", correct: false }
      - { value: "By mocking the `EntityManager` and its `EntityRepository` instances.", correct: true }
      - { value: "By clearing the database before each test method.", correct: false }
      - { value: "By using a separate test database configured in `.env.test.local`.", correct: false }
    help: |
      Mocking dependencies like `EntityManager` allows you to test the service in isolation without actual database interaction.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/database.rst#_snippet_1

  -
    question: >
      Which class from the `Symfony\\Component\\Filesystem` component can be used to manually clear the Symfony cache directory for the test environment?
    answers:
      - { value: "Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter", correct: false }
      - { value: "Symfony\\Component\\Filesystem\\Filesystem", correct: true }
      - { value: "Symfony\\Component\\HttpKernel\\CacheClearer\\CacheClearer", correct: false }
      - { value: "Symfony\\Component\\Finder\\Finder", correct: false }
    help: |
      The `Filesystem` component provides utilities for file system operations, including removing directories.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_8

  -
    question: >
      Which Symfony MakerBundle command can be used to generate a new application test class, prompting for the test type (e.g., WebTestCase)?
    answers:
      - { value: "php bin/console make:entity", correct: false }
      - { value: "php bin/console make:controller", correct: false }
      - { value: "php bin/console make:test", correct: true }
      - { value: "php bin/console make:functional-test", correct: false }
    help: |
      The `make:test` command is an interactive tool to scaffold new test classes.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_21

  -
    question: >
      When performing a smoke test on all application URLs using PHPUnit data providers, what is the primary assertion to check for successful page loads?
    answers:
      - { value: "$this->assertResponseStatusCodeSame(200);", correct: false }
      - { value: "$this->assertResponseIsSuccessful();", correct: true }
      - { value: "$this->assertPageExists();", correct: false }
      - { value: "$this->assertUrlLoads();", correct: false }
    help: |
      `assertResponseIsSuccessful()` is the most robust way to check for a 2xx status code, indicating success.
      https://github.com/symfony/symfony-docs/blob/7.3/best_practices.rst#_snippet_4

  -
    question: >
      What does the `assertSelectorExists(string $selector)` method of the Symfony Crawler assert?
    answers:
      - { value: "That the given selector does not match any element in the response.", correct: false }
      - { value: "That the given selector matches exactly one element in the response.", correct: false }
      - { value: "That the given selector does match at least one element in the response.", correct: true }
      - { value: "That the given selector matches a visible element in the response.", correct: false }
    help: |
      This assertion verifies the presence of at least one element matching the provided CSS selector.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      Which `Crawler` assertion method checks if the `<title>` element of the response is exactly equal to a given string?
    answers:
      - { value: "assertTitleEquals()", correct: false }
      - { value: "assertPageTitleContains()", correct: false }
      - { value: "assertPageTitleSame()", correct: true }
      - { value: "assertHtmlTitle()", correct: false }
    help: |
      `assertPageTitleSame()` performs an exact comparison of the page title.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      To assert that the value of a form input with a given name equals an expected value, which `Crawler` assertion method should be used?
    answers:
      - { value: "assertInputEquals(string $fieldName, string $expectedValue)", correct: false }
      - { value: "assertFormInput(string $fieldName, string $expectedValue)", correct: false }
      - { value: "assertInputValueSame(string $fieldName, string $expectedValue)", correct: true }
      - { value: "assertFieldValue(string $fieldName, string $expectedValue)", correct: false }
    help: |
      `assertInputValueSame()` specifically targets the value of an input field by its name.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      How do you assert that a checkbox with a specific name is checked in a functional test using the Symfony Crawler?
    answers:
      - { value: "assertCheckboxIsChecked('fieldName')", correct: false }
      - { value: "assertChecked('fieldName')", correct: false }
      - { value: "assertCheckboxChecked('fieldName')", correct: true }
      - { value: "assertInputChecked('fieldName')", correct: false }
    help: |
      `assertCheckboxChecked()` is the dedicated method for checking checkbox states.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      Which assertion method is used to verify that an HTTP response is a redirect, optionally checking the target location and status code?
    answers:
      - { value: "assertRedirect()", correct: false }
      - { value: "assertResponseIsRedirect()", correct: false }
      - { value: "assertResponseRedirects(?string $expectedLocation = null, ?int $expectedCode = null)", correct: true }
      - { value: "assertRedirectTo()", correct: false }
    help: |
      `assertResponseRedirects()` allows for flexible assertions on redirect responses.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_45

  -
    question: >
      How do you assert that a specific header (e.g., `Content-Type`) is present in the HTTP response using the Symfony test client?
    answers:
      - { value: "assertHeaderExists('headerName')", correct: false }
      - { value: "assertResponseHeaderExists('headerName')", correct: false }
      - { value: "assertResponseHasHeader('headerName')", correct: true }
      - { value: "assertHasHeader('headerName')", correct: false }
    help: |
      `assertResponseHasHeader()` checks for the existence of a given header in the response.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_45

  -
    question: >
      To assert that a specific HTTP response header has an exact expected value, which method should be used?
    answers:
      - { value: "assertHeaderValue(string $headerName, string $expectedValue)", correct: false }
      - { value: "assertResponseHeaderEquals(string $headerName, string $expectedValue)", correct: false }
      - { value: "assertResponseHeaderSame(string $headerName, string $expectedValue)", correct: true }
      - { value: "assertHeaderSame(string $headerName, string $expectedValue)", correct: false }
    help: |
      `assertResponseHeaderSame()` performs a strict comparison of the header's value.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_45

  -
    question: >
      When testing Symfony console commands using `ApplicationTester`, why is it important to call `$application->setAutoExit(false)`?
    answers:
      - { value: "To prevent the test process from exiting prematurely, allowing results to be retrieved.", correct: true }
      - { value: "To allow the command to run in the background without blocking the test.", correct: false }
      - { value: "To enable interactive input during the command execution in tests.", correct: false }
      - { value: "To capture the command's output in real-time.", correct: false }
    help: |
      Disabling auto-exit ensures that the `ApplicationTester` can properly capture and assert on the command's output and exit code.
      https://github.com/symfony/symfony-docs/blob/7.3/console.rst#_snippet_18

  -
    question: >
      When creating a Panther client for multi-domain testing, which option is used to specify the base URI for an external domain?
    answers:
      - { value: "`base_uri`", correct: false }
      - { value: "`domain_uri`", correct: false }
      - { value: "`external_base_uri`", correct: true }
      - { value: "`target_uri`", correct: false }
    help: |
      The `external_base_uri` option allows Panther to interact with different domains within the same test suite.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_19

  -
    question: >
      What is the purpose of the `PantherClient::waitFor('.selector')` method?
    answers:
      - { value: "To wait for an element to be removed from the DOM.", correct: false }
      - { value: "To wait for an element to become visible on the page.", correct: false }
      - { value: "To wait for an element to be attached to the DOM.", correct: true }
      - { value: "To wait for an element to contain specific text.", correct: false }
    help: |
      `waitFor()` is used to pause test execution until a specified element appears in the DOM.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_6

  -
    question: >
      Which Panther assertion is used to verify that an element matching a selector is expected to appear in the DOM in the future (asynchronously)?
    answers:
      - { value: "assertSelectorExistsEventually()", correct: false }
      - { value: "assertSelectorFutureExist()", correct: false }
      - { value: "assertSelectorWillExist()", correct: true }
      - { value: "assertElementWillExist()", correct: false }
    help: |
      `assertSelectorWillExist()` is a future assertion that waits for the element to appear within a timeout.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_7

  -
    question: >
      What is the main benefit of enabling `Symfony\\Bridge\\PhpUnit\\CoverageListener` in `phpunit.xml.dist`?
    answers:
      - { value: "It improves test execution speed by optimizing code loading.", correct: false }
      - { value: "It automatically adds `@covers` annotations for accurate code coverage reporting.", correct: true }
      - { value: "It provides detailed performance metrics for each test case.", correct: false }
      - { value: "It helps in debugging test failures by providing more context.", correct: false }
    help: |
      The `CoverageListener` helps PHPUnit correctly attribute code coverage to the tested classes.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_39

  -
    question: |
      How can you provide a custom System Under Test (SUT) solver to the `Symfony\\Bridge\\PhpUnit\\CoverageListener` if the default logic is insufficient?
    answers:
      - { value: "By extending the `CoverageListener` class and overriding a method.", correct: false }
      - { value: "By configuring a service with a `sut_solver` tag in `services.yaml`.", correct: false }
      - { value: "By passing a PHP callable as an argument to the listener in `phpunit.xml.dist`.", correct: true }
      - { value: "By using a dedicated annotation in the test class for the SUT.", correct: false }
    help: |
      A custom callable can be provided in the `phpunit.xml.dist` configuration to define how the SUT is determined.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_40

  -
    question: >
      What is `Symfony\\Component\\Clock\\MockClock` primarily used for in tests?
    answers:
      - { value: "To measure the execution time of code blocks.", correct: false }
      - { value: "To simulate network latency in HTTP client tests.", correct: false }
      - { value: "To control and manipulate time for testing time-sensitive logic.", correct: true }
      - { value: "To generate random timestamps for data seeding.", correct: false }
    help: |
      `MockClock` allows tests to precisely control the current time, making time-dependent assertions reliable.
      https://github.com/symfony/symfony-docs/blob/7.3/components/clock.rst#_snippet_5

  -
    question: >
      What is the key difference between `MockClock::sleep()` and PHP's built-in `sleep()` function when used in tests with `MockClock`?
    answers:
      - { value: "`MockClock::sleep()` pauses test execution, while `sleep()` does not.", correct: false }
      - { value: "`MockClock::sleep()` instantly changes the mock time, while `sleep()` introduces a real-time delay.", correct: true }
      - { value: "`MockClock::sleep()` is only for functional tests, `sleep()` for unit tests.", correct: false }
      - { value: "There is no functional difference; they are interchangeable.", correct: false }
    help: |
      `MockClock::sleep()` advances the mocked time without actually pausing the test process.
      https://github.com/symfony/symfony-docs/blob/7.3/components/clock.rst#_snippet_5

  -
    question: >
      Which command generates an HTML test coverage report that can be viewed in a web browser, assuming XDebug is enabled?
    answers:
      - { value: "./vendor/bin/phpunit --coverage-html=cov/", correct: true }
      - { value: "./vendor/bin/phpunit --report-coverage=html", correct: false }
      - { value: "./vendor/bin/phpunit --html-coverage-report", correct: false }
      - { value: "./vendor/bin/phpunit --generate-html-report", correct: false }
    help: |
      The `--coverage-html` option specifies the directory where the HTML report will be generated.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/unit_testing.rst#_snippet_8

  -
    question: >
      Which command outputs the test coverage results directly to the console?
    answers:
      - { value: "./vendor/bin/phpunit --coverage-console", correct: false }
      - { value: "./vendor/bin/phpunit --coverage-text", correct: true }
      - { value: "./vendor/bin/phpunit --text-coverage", correct: false }
      - { value: "./vendor/bin/phpunit --show-coverage", correct: false }
    help: |
      The `--coverage-text` option displays a summary of code coverage in the terminal.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/unit_testing.rst#_snippet_9

  -
    question: >
      In `config/packages/test/framework.yaml`, what does setting `framework.test` to `true` enable?
    answers:
      - { value: "Debug mode for tests, providing more verbose output.", correct: false }
      - { value: "Loading of services related to testing (e.g., `test.client`).", correct: true }
      - { value: "Automatic database migrations before each test run.", correct: false }
      - { value: "Profiler collection for all requests by default.", correct: false }
    help: |
      This configuration setting ensures that Symfony's testing-specific services are available in the test environment.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_156

  -
    question: >
      Why is it recommended to configure a less resource-intensive password hasher for the `test` environment in `security.yaml`?
    answers:
      - { value: "To improve the security of test user passwords.", correct: false }
      - { value: "To prevent password leaks from the test database.", correct: false }
      - { value: "To speed up test execution by reducing hashing overhead.", correct: true }
      - { value: "To simplify user management in the test environment.", correct: false }
    help: |
      Using a faster hasher like `plaintext` or a low-cost bcrypt in tests significantly reduces test run times.
      https://github.com/symfony/symfony-docs/blob/7.3/security/passwords.rst#_snippet_3

  -
    question: >
      Which environment variable is used with `simple-phpunit` to instruct the Symfony Deprecations Helper to ignore deprecations listed in a specified file?
    answers:
      - { value: "SYMFONY_IGNORE_DEPRECATIONS", correct: false }
      - { value: "SYMFONY_DEPRECATIONS_HELPER", correct: true }
      - { value: "PHPUNIT_DEPRECATIONS_FILTER", correct: false }
      - { value: "SYMFONY_TEST_MODE", correct: false }
    help: |
      The `SYMFONY_DEPRECATIONS_HELPER` environment variable is used to configure the deprecations helper, including ignoring specific files.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_9

  -
    question: >
      To run PHPUnit tests using a previously generated deprecation baseline file, which option is used with `SYMFONY_DEPRECATIONS_HELPER`?
    answers:
      - { value: "`ignoreFile`", correct: false }
      - { value: "`baselineFile`", correct: true }
      - { value: "`allowFile`", correct: false }
      - { value: "`deprecationsFile`", correct: false }
    help: |
      Setting `baselineFile` to the path of your baseline JSON file will ignore existing deprecations while reporting new ones.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_11

  -
    question: >
      What does `static::createClient()` in a `WebTestCase` implicitly do before creating the client instance?
    answers:
      - { value: "Clears the application cache.", correct: false }
      - { value: "Runs database migrations.", correct: false }
      - { value: "Boots the Symfony kernel.", correct: true }
      - { value: "Starts a built-in web server.", correct: false }
    help: |
      `createClient()` internally calls `KernelTestCase::bootKernel()` to prepare the application environment.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_22

  -
    question: >
      When writing a functional test for a Doctrine repository that interacts with a real database, which base class should the test extend?
    answers:
      - { value: "PHPUnit\\Framework\\TestCase", correct: false }
      - { value: "Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase", correct: false }
      - { value: "Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase", correct: true }
      - { value: "Doctrine\\ORM\\Tools\\SchemaTool", correct: false }
    help: |
      `KernelTestCase` is appropriate for tests that need access to the Symfony container and a real database connection.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/database.rst#_snippet_2

  -
    question: >
      In a `KernelTestCase` involving Doctrine's `EntityManager`, why is it recommended to call `$this->entityManager->close();` and `$this->entityManager = null;` in the `tearDown()` method?
    answers:
      - { value: "To commit any pending database transactions.", correct: false }
      - { value: "To reset the database schema for the next test.", correct: false }
      - { value: "To avoid memory leaks by properly closing the entity manager and nullifying the property.", correct: true }
      - { value: "To clear the Doctrine entity cache between tests.", correct: false }
    help: |
      Properly closing the `EntityManager` and nullifying the property prevents memory accumulation during long test runs.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/database.rst#_snippet_2

  -
    question: >
      What is the primary benefit of registering `Symfony\\Component\\Panther\\ServerExtension` in `phpunit.xml.dist` for Panther tests?
    answers:
      - { value: "It enables automatic screenshot capture on test failures.", correct: true }
      - { value: "It manages the web server lifecycle for improved testing performance.", correct: true }
      - { value: "It allows running tests in parallel for faster execution.", correct: false }
      - { value: "It provides additional assertions for browser interactions.", correct: false }
    help: |
      The `ServerExtension` automates the management of the web server and provides useful features like screenshot capture.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_3

  -
    question: >
      Which environment variable and PHPUnit flag are used to enable Panther's interactive debug mode, pausing tests on failure for manual browser inspection?
    answers:
      - { value: "PANTHER_DEBUG=1 --stop-on-failure", correct: false }
      - { value: "PANTHER_NO_HEADLESS=1 bin/phpunit --debug", correct: true }
      - { value: "PANTHER_INTERACTIVE=true --verbose", correct: false }
      - { value: "PANTHER_PAUSE_ON_FAIL=1 --testdox", correct: false }
    help: |
      `PANTHER_NO_HEADLESS=1` prevents the browser from running in headless mode, and `--debug` enables the interactive pause.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_25

  -
    question: >
      What is the purpose of `Symfony\\Component\\HttpClient\\Response\\HarFileResponseFactory` when testing Symfony's HTTP Client?
    answers:
      - { value: "To record HTTP interactions into HAR files for later analysis.", correct: false }
      - { value: "To create mock responses for the HTTP client based on recorded HAR files.", correct: true }
      - { value: "To send HTTP requests to a HAR file server for validation.", correct: false }
      - { value: "To validate the format and content of HAR files.", correct: false }
    help: |
      `HarFileResponseFactory` allows you to replay recorded HTTP interactions, making tests realistic and reproducible.
      https://github.com/symfony/symfony-docs/blob/7.3/http_client.rst#_snippet_100

  -
    question: >
      Which of the following is a valid method to run tests for a specific directory in a Symfony application using PHPUnit?
    answers:
      - { value: "$ php bin/phpunit tests/Form", correct: true }
      - { value: "$ php bin/phpunit --dir=tests/Form", correct: false }
      - { value: "$ php bin/phpunit run tests/Form", correct: false }
      - { value: "$ php bin/phpunit --path=tests/Form", correct: false }
    help: |
      You can specify a directory path directly after `php bin/phpunit` to run tests within that directory.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_2

  -
    question: >
      When configuring the Symfony profiler for the `test` environment, what does setting `collect: false` under `framework.profiler` achieve?
    answers:
      - { value: "It disables the profiler entirely.", correct: false }
      - { value: "It enables the profiler but prevents it from collecting data unless explicitly requested per test.", correct: true }
      - { value: "It collects profiler data but does not display it in the web profiler.", correct: false }
      - { value: "It only collects data for requests that result in an error.", correct: false }
    help: |
      `collect: false` allows the profiler to be enabled without automatically gathering data for every request, improving test performance. Data can then be collected on demand.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/profiling.rst#_snippet_0

  -
    question: >
      Which of the following describes a unit test in the context of Symfony applications?
    answers:
      - { value: "A test that simulates a full HTTP request and response cycle.", correct: false }
      - { value: "A test that verifies the interaction between multiple services and the database.", correct: false }
      - { value: "A test that focuses on a single component or class in isolation, often using mocks for dependencies.", correct: true }
      - { value: "A test that checks the entire application's functionality from end-to-end.", correct: false }
    help: |
      Unit tests are designed to test the smallest testable parts of an application, typically individual methods or classes, in isolation.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/database.rst#_snippet_1 (example of unit test with mocks)

  -
    question: >
      What is the primary characteristic of a functional test in Symfony?
    answers:
      - { value: "It tests individual functions or methods without external dependencies.", correct: false }
      - { value: "It verifies the integration between different parts of the application, often involving the full request/response stack.", correct: true }
      - { value: "It focuses on the user interface and browser interactions.", correct: false }
      - { value: "It ensures that the database schema is correctly applied.", correct: false }
    help: |
      Functional tests (also known as integration tests) verify that different components of the application work together as expected, often by simulating HTTP requests.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_22 (example of functional test)

  -
    question: >
      When writing a `WebTestCase`, what is the purpose of the `assertResponseStatusCodeSame(int $expectedCode)` method?
    answers:
      - { value: "To assert that the response body contains the expected status code.", correct: false }
      - { value: "To assert that the HTTP status code of the response is exactly the expected value.", correct: true }
      - { value: "To assert that the response is a redirect with the given status code.", correct: false }
      - { value: "To assert that the response is successful and has the given status code.", correct: false }
    help: |
      This method provides a precise way to check the HTTP status code of the response.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_45

  -
    question: >
      Which of the following is NOT a valid assertion method provided by the Symfony Crawler for checking HTML content?
    answers:
      - { value: "assertSelectorCount(int $expectedCount, string $selector)", correct: false }
      - { value: "assertElementExists(string $selector)", correct: true }
      - { value: "assertSelectorTextSame(string $selector, string $text)", correct: false }
      - { value: "assertPageTitleContains(string $expectedTitle)", correct: false }
    help: |
      The correct method to check if a selector exists is `assertSelectorExists()`, not `assertElementExists()`.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      What is the purpose of `Symfony\\Component\\Validator\\Test\\CompoundConstraintTestCase`?
    answers:
      - { value: "To test individual validation constraints in isolation.", correct: false }
      - { value: "To test custom form types that include validation.", correct: false }
      - { value: "To write unit tests for custom compound validation constraints.", correct: true }
      - { value: "To test the entire validation process of an entity.", correct: false }
    help: |
      This test case provides a structured way to test custom compound constraints, asserting violations raised by its inner constraints.
      https://github.com/symfony/symfony-docs/blob/7.3/validation/custom_constraint.rst#_snippet_17

  -
    question: >
      When performing a functional test and you need to manually follow a redirect after a response, which method of the client object should you use?
    answers:
      - { value: "$client->followRedirect();", correct: true }
      - { value: "$client->getRedirectResponse();", correct: false }
      - { value: "$client->requestRedirect();", correct: false }
      - { value: "$client->autoFollowRedirects(false);", correct: false }
    help: |
      `followRedirect()` explicitly makes a new request to the redirect target.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_27

  -
    question: >
      Which of the following is a key advantage of using `Symfony\\Component\\Panther\\PantherTestCase` for end-to-end testing?
    answers:
      - { value: "It runs tests directly in PHP without a browser.", correct: false }
      - { value: "It allows testing JavaScript-driven applications in a real browser environment.", correct: true }
      - { value: "It provides faster test execution than traditional functional tests.", correct: false }
      - { value: "It automatically generates screenshots for all test steps.", correct: false }
    help: |
      Panther enables testing of client-side JavaScript and dynamic content by controlling a real browser.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst

  -
    question: >
      What is the purpose of `PantherClient::waitForStaleness('.selector')`?
    answers:
      - { value: "To wait for an element to become visible.", correct: false }
      - { value: "To wait for an element to be removed from the DOM.", correct: true }
      - { value: "To wait for an element to change its content.", correct: false }
      - { value: "To wait for an element to become disabled.", correct: false }
    help: |
      `waitForStaleness()` is used when you expect an element to disappear from the page.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_6

  -
    question: >
      Which of the following is true about the `Symfony\\Bridge\\PhpUnit\\SymfonyTestsListener` and time-sensitive tests?
    answers:
      - { value: "It automatically mocks the system clock for all tests.", correct: false }
      - { value: "It requires explicit configuration in `phpunit.xml.dist` to enable `ClockMock` for specific namespaces or groups.", correct: true }
      - { value: "It only works with PHP's built-in `sleep()` function.", correct: false }
      - { value: "It is deprecated in Symfony 7.", correct: false }
    help: |
      The listener needs to be configured to know which tests or namespaces are time-sensitive to apply `ClockMock`.
      https://github.com/symfony/symfony-docs/blob/7.3/components/phpunit_bridge.rst#_snippet_33

  -
    question: >
      What is the primary goal of using a data provider (e.g., `urlProvider()`) in a functional test for application availability?
    answers:
      - { value: "To dynamically generate test users.", correct: false }
      - { value: "To run the same test method with different sets of input data (e.g., URLs).", correct: true }
      - { value: "To mock external API responses.", correct: false }
      - { value: "To parallelize test execution across multiple processes.", correct: false }
    help: |
      Data providers allow you to test multiple scenarios with a single test method, reducing code duplication.
      https://github.com/symfony/symfony-docs/blob/7.3/best_practices.rst#_snippet_4

  -
    question: >
      Which of the following is a valid way to create the dedicated test database and its schema using Doctrine commands in Symfony?
    answers:
      - { value: "$ php bin/console doctrine:database:create --env=test && php bin/console doctrine:schema:update --force --env=test", correct: false }
      - { value: "$ php bin/console --env=test doctrine:database:create && php bin/console --env=test doctrine:schema:create", correct: true }
      - { value: "$ php bin/console test:database:setup", correct: false }
      - { value: "$ php bin/console doctrine:fixtures:load --env=test", correct: false }
    help: |
      The `--env=test` flag is crucial to ensure these operations target the test database.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_13

  -
    question: >
      When unit testing a form type, which base class should you extend to get access to form-specific testing utilities like `factory`?
    answers:
      - { value: "PHPUnit\\Framework\\TestCase", correct: false }
      - { value: "Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase", correct: false }
      - { value: "Symfony\\Component\\Form\\Test\\TypeTestCase", correct: true }
      - { value: "Symfony\\Component\\Form\\Test\\FormIntegrationTestCase", correct: false }
    help: |
      `TypeTestCase` provides the necessary setup for testing individual form types.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst

  -
    question: >
      What is the purpose of the `getExtensions()` method in `Symfony\\Component\\Form\\Test\\TypeTestCase`?
    answers:
      - { value: "To return a list of Twig extensions to be loaded for form rendering tests.", correct: false }
      - { value: "To return a list of form extensions to register for the current test case.", correct: true }
      - { value: "To return a list of custom form types to be used in the test.", correct: false }
      - { value: "To return a list of PHPUnit extensions for the form tests.", correct: false }
    help: |
      This method allows you to register specific form extensions needed for your form type tests.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      Which of the following assertions would you use in a Panther test to verify that a button with `type="submit"` will eventually become enabled?
    answers:
      - { value: "$this->assertSelectorWillBeEnabled('[type=\"submit\"]');", correct: true }
      - { value: "$this->assertButtonWillBeEnabled('submit');", correct: false }
      - { value: "$this->assertElementWillBeEnabled('[type=\"submit\"]');", correct: false }
      - { value: "$this->assertEnabled('[type=\"submit\"]');", correct: false }
    help: |
      `assertSelectorWillBeEnabled()` is a future assertion specifically for checking element enablement.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_7

  -
    question: >
      What is the main advantage of using `MockHttpClient` with `HarFileResponseFactory` for testing HTTP clients in Symfony?
    answers:
      - { value: "It records new HTTP requests into HAR files automatically.", correct: false }
      - { value: "It allows for realistic and reproducible tests without relying on external services.", correct: true }
      - { value: "It performs real HTTP requests to a local server for integration testing.", correct: false }
      - { value: "It generates a report of all HTTP interactions during the test run.", correct: false }
    help: |
      This approach ensures consistent test results by replaying predefined HTTP responses from HAR files.
      https://github.com/symfony/symfony-docs/blob/7.3/http_client.rst#_snippet_100

  -
    question: >
      When writing a unit test for a framework's exception handling, how would you typically simulate a `ResourceNotFoundException` being thrown by the URL matcher?
    answers:
      - { value: "By configuring a route that does not exist.", correct: false }
      - { value: "By mocking the `UrlMatcherInterface` to throw the exception when `match()` is called.", correct: true }
      - { value: "By calling `throw new ResourceNotFoundException()` directly in the test.", correct: false }
      - { value: "By making a request to a non-existent URL with the test client.", correct: false }
    help: |
      Mocking the `UrlMatcherInterface` allows you to control its behavior and simulate specific exceptions.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/unit_testing.rst#_snippet_3

  -
    question: >
      Which of the following is true regarding `Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase`?
    answers:
      - { value: "It is primarily used for testing controllers and HTTP responses.", correct: false }
      - { value: "It reboots the Symfony kernel for each test to ensure isolation.", correct: true }
      - { value: "It does not provide access to the dependency injection container.", correct: false }
      - { value: "It is intended for end-to-end browser testing.", correct: false }
    help: |
      The kernel is rebooted for each test to prevent side effects between tests.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_4

  -
    question: >
      What is the purpose of `Symfony\\Component\\Form\\PreloadedExtension` in form testing?
    answers:
      - { value: "To register preloaded form type instances with the FormRegistry, ensuring specific instances are used during testing.", correct: true }
      - { value: "To define custom form type extensions for the test environment.", correct: false }
      - { value: "To load form data from a predefined fixture file.", correct: false }
      - { value: "To automatically resolve form options based on configured services.", correct: false }
    help: |
      `PreloadedExtension` allows you to inject specific form type instances for testing, rather than relying on autowiring or service location.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      When defining test suites in `phpunit.xml.dist` for a Symfony application, what does the `<directory>tests</directory>` element typically refer to?
    answers:
      - { value: "The directory containing all application source code.", correct: false }
      - { value: "The root directory where all PHPUnit test files are located.", correct: true }
      - { value: "A directory for storing test data fixtures.", correct: false }
      - { value: "A directory for generated test reports.", correct: false }
    help: |
      The `tests/` directory is the conventional location for all application tests in Symfony.
      https://github.com/symfony/symfony-docs/blob/7.3/configuration/multiple_kernels.rst#_snippet_13

  -
    question: >
      Which command is used to install the `symfony/test-pack` Composer package, which includes `phpunit/phpunit` and other necessary dependencies for testing Symfony applications?
    answers:
      - { value: "$ composer install symfony/test-pack", correct: false }
      - { value: "$ composer require symfony/test-pack", correct: false }
      - { value: "$ composer require --dev symfony/test-pack", correct: true }
      - { value: "$ composer update symfony/test-pack", correct: false }
    help: |
      The `--dev` flag ensures it's installed as a development dependency.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_0

  -
    question: >
      What is the primary purpose of `Symfony\\Component\\HttpClient\\MockHttpClient`?
    answers:
      - { value: "To make real HTTP requests to external services.", correct: false }
      - { value: "To mock HTTP client responses for isolated testing.", correct: true }
      - { value: "To record HTTP traffic for debugging purposes.", correct: false }
      - { value: "To manage HTTP client configurations.", correct: false }
    help: |
      `MockHttpClient` allows you to control the responses of HTTP requests, making tests deterministic.
      https://github.com/symfony/symfony-docs/blob/7.3/http_client.rst#_snippet_100

  -
    question: >
      Which of the following is an example of a "future assertion" in Symfony Panther?
    answers:
      - { value: "assertSelectorExists('.element')", correct: false }
      - { value: "assertSelectorWillExist('.element')", correct: true }
      - { value: "assertResponseIsSuccessful()", correct: false }
      - { value: "assertPageTitleSame('My Page')", correct: false }
    help: |
      Future assertions wait for a condition to become true within a given timeout, useful for asynchronous operations.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_7

  -
    question: >
      When using `Symfony\\Component\\Clock\\MockClock`, how can you instantly advance the mocked time to a specific point, accepting formats supported by `DateTimeImmutable::modify()`?
    answers:
      - { value: "$clock->sleep(seconds);", correct: false }
      - { value: "$clock->advance(string $modifier);", correct: false }
      - { value: "$clock->modify(string $modifier);", correct: true }
      - { value: "$clock->setTime(string $time);", correct: false }
    help: |
      The `modify()` method allows precise control over the mocked time.
      https://github.com/symfony/symfony-docs/blob/7.3/components/clock.rst#_snippet_5

  -
    question: >
      What is the primary benefit of using `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase` for form testing?
    answers:
      - { value: "It allows testing form data submission and validation.", correct: false }
      - { value: "It provides a specialized test case for testing form themes with Twig.", correct: true }
      - { value: "It enables mocking of Twig services for faster tests.", correct: false }
      - { value: "It ensures that all form types are correctly registered with Twig.", correct: false }
    help: |
      This test case simplifies the setup for testing how forms are rendered with Twig templates.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      Which of the following is true about the `Symfony\\Component\\OptionsResolver\\Exception\\InvalidOptionsException`?
    answers:
      - { value: "It is thrown when a required form option is missing.", correct: false }
      - { value: "It is raised by the OptionsResolver component when an invalid or unsupported option is encountered.", correct: true }
      - { value: "It indicates a validation error in a form field.", correct: false }
      - { value: "It is a generic exception for all form-related errors.", correct: false }
    help: |
      This exception specifically signals issues with options passed to components using the OptionsResolver.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      When configuring GitHub Actions for Symfony Panther tests, which action is commonly used to install Composer dependencies?
    answers:
      - { value: "actions/composer-install@v1", correct: false }
      - { value: "ramsey/composer-install@v2", correct: true }
      - { value: "php-actions/composer@v2", correct: false }
      - { value: "shivammathur/setup-php@v2", correct: false }
    help: |
      `ramsey/composer-install` is a popular action for installing Composer dependencies in GitHub Actions workflows.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_29

  -
    question: >
      What is the purpose of the `getTwigExtensions()` method in `Symfony\\Bridge\\Twig\\Test\\FormLayoutTestCase`?
    answers:
      - { value: "To return an array of Twig extensions to be loaded for the test environment.", correct: true }
      - { value: "To return an array of custom form types that use Twig.", correct: false }
      - { value: "To configure Twig's cache directory for tests.", correct: false }
      - { value: "To define global Twig variables for the tests.", correct: false }
    help: |
      This method allows you to register any Twig extensions (e.g., custom filters or functions) needed for your form layout tests.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      Which of the following describes the role of `Symfony\\Component\\Form\\Extension\\Validator\\ValidatorExtension` in form testing?
    answers:
      - { value: "It provides core form types and functionality.", correct: false }
      - { value: "It integrates the Symfony Validator component, enabling validation features for form fields.", correct: true }
      - { value: "It handles the rendering of form errors in Twig.", correct: false }
      - { value: "It is responsible for mapping form data to entities.", correct: false }
    help: |
      This extension is crucial for testing forms that rely on Symfony's validation component.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      What is the primary purpose of `Symfony\\Component\\Form\\Extension\\Core\\CoreExtension` in the context of form testing?
    answers:
      - { value: "It provides advanced form types for complex scenarios.", correct: false }
      - { value: "It is the default core form extension that provides basic form types and functionality, registered by default in `TypeTestCase`.", correct: true }
      - { value: "It handles the integration with external form libraries.", correct: false }
      - { value: "It manages form events and listeners.", correct: false }
    help: |
      The `CoreExtension` is fundamental for most form tests as it provides the basic building blocks.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      When testing a multi-domain application with Symfony Panther, why is the `@runInSeparateProcess` PHPUnit annotation often used?
    answers:
      - { value: "To speed up tests by running them in parallel.", correct: false }
      - { value: "To ensure test isolation between different domains by providing a clean environment for each test.", correct: true }
      - { value: "To allow the Panther client to access external networks.", correct: false }
      - { value: "To prevent memory leaks during long test runs.", correct: false }
    help: |
      Running tests in separate processes prevents state leakage between tests, which is crucial for multi-domain scenarios.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_19

  -
    question: >
      What is the purpose of `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase::getTypes()`?
    answers:
      - { value: "To return an array of custom form types required for integration tests.", correct: true }
      - { value: "To return an array of form type extensions.", correct: false }
      - { value: "To return an array of form type guessers.", correct: false }
      - { value: "To return an array of preloaded form type instances.", correct: false }
    help: |
      This method allows you to register custom form types that your integration tests will use.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      Which method in `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase` is used to load custom form type extensions required for integration tests?
    answers:
      - { value: "getTypes()", correct: false }
      - { value: "getTypeExtensions()", correct: true }
      - { value: "getTypeGuessers()", correct: false }
      - { value: "getExtensions()", correct: false }
    help: |
      `getTypeExtensions()` is specifically for registering form type extensions.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      What is the purpose of `Symfony\\Component\\Form\\Test\\FormIntegrationTestCase::getTypeGuessers()`?
    answers:
      - { value: "To return an array of form types that can be guessed.", correct: false }
      - { value: "To return an array of form type extensions that provide guessing capabilities.", correct: false }
      - { value: "To return an array of custom form type guessers required for integration tests.", correct: true }
      - { value: "To return an array of services that can guess form options.", correct: false }
    help: |
      This method allows you to register custom form type guessers for your integration tests.
      https://github.com/symfony/symfony-docs/blob/7.3/form/unit_testing.rst#_snippet_7

  -
    question: >
      When using Panther, which method allows you to wait for an element of the DOM to become visible?
    answers:
      - { value: "$client->waitFor('.selector');", correct: false }
      - { value: "$client->waitForVisibility('.selector');", correct: true }
      - { value: "$client->waitUntilVisible('.selector');", correct: false }
      - { value: "$client->assertSelectorWillBeVisible('.selector');", correct: false }
    help: |
      `waitForVisibility()` is a client-side waiting method that pauses execution until the element is visible.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_6

  -
    question: >
      Which Panther client method is used to wait for text to be inserted into an element's content?
    answers:
      - { value: "$client->waitForElementToContain('.selector', 'text');", correct: true }
      - { value: "$client->waitForText('.selector', 'text');", correct: false }
      - { value: "$client->assertSelectorWillContain('.selector', 'text');", correct: false }
      - { value: "$client->waitUntilTextPresent('.selector', 'text');", correct: false }
    help: |
      `waitForElementToContain()` waits for the specified text to appear within the element's content.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_6

  -
    question: >
      What is the purpose of `PantherClient::waitForAttributeToContain('.selector', 'attributeName', 'value')`?
    answers:
      - { value: "To assert that an attribute will contain a specific value in the future.", correct: false }
      - { value: "To wait for an element's attribute to contain specific content.", correct: true }
      - { value: "To wait for an element's attribute to be removed.", correct: false }
      - { value: "To set an attribute's value on an element.", correct: false }
    help: |
      This method is used to pause test execution until a specific attribute of an element contains the expected content.
      https://github.com/symfony/symfony-docs/blob/7.3/testing/end_to_end.rst#_snippet_6

  -
    question: >
      Which assertion method would you use in a Symfony functional test to verify that any element matching a given selector contains specific text?
    answers:
      - { value: "assertSelectorTextContains(string $selector, string $text)", correct: false }
      - { value: "assertAnySelectorTextContains(string $selector, string $text)", correct: true }
      - { value: "assertElementTextContains(string $selector, string $text)", correct: false }
      - { value: "assertTextInAnySelector(string $selector, string $text)", correct: false }
    help: |
      `assertAnySelectorTextContains()` checks if at least one element matching the selector contains the text.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50

  -
    question: >
      What is the purpose of `assertAnySelectorTextSame(string $selector, string $text)` in Symfony Crawler assertions?
    answers:
      - { value: "Asserts that the contents of the first element matching the given selector does equal the expected text.", correct: false }
      - { value: "Asserts that any element matching the given selector does equal the expected text.", correct: true }
      - { value: "Asserts that all elements matching the given selector contain the expected text.", correct: false }
      - { value: "Asserts that no element matching the given selector contains the expected text.", correct: false }
    help: |
      This assertion is useful when you need to confirm that at least one of the matched elements has the exact text.
      https://github.com/symfony/symfony-docs/blob/7.3/testing.rst#_snippet_50