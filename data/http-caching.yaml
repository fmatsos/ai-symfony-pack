category: HTTP Caching

questions:
  -
    question: >
      What is the primary purpose of a reverse proxy in the context of Symfony HTTP caching?
    answers:
      - { value: "To cache responses closer to the client, reducing load on the application server.", correct: true }
      - { value: "To encrypt all incoming and outgoing HTTP traffic.", correct: false }
      - { value: "To handle database connections for the Symfony application.", correct: false }
      - { value: "To manage user sessions and authentication.", correct: false }
    help: |
      A reverse proxy (like Symfony's HttpCache or Varnish) sits in front of the web server and caches responses, serving them directly to clients for subsequent requests, thus reducing the load on the backend application.
      https://symfony.com/doc/current/http_cache.html#reverse-proxy

  -
    question: |
      Given a Symfony controller action, which `#[Cache]` attribute configuration makes the response publicly cacheable for 10 minutes (600 seconds)?

      ```php
      use Symfony\Component\HttpKernel\Attribute\Cache;
      // ...

      class MyController extends AbstractController
      {
          #[Cache(/* ??? */)]
          public function index(): Response
          {
              // ...
          }
      }
      ```
    answers:
      - { value: "public: true, maxage: 600", correct: true }
      - { value: "private: false, ttl: 600", correct: false }
      - { value: "smaxage: 600", correct: false }
      - { value: "expires: '+600 seconds'", correct: false }
    help: |
      The `#[Cache]` attribute's `public` option makes the response cacheable by shared caches, and `maxage` sets the maximum age for both private and shared caches.
      https://symfony.com/doc/current/http_cache/expiration.html#configuring-cache-control-with-the-cache-attribute

  -
    question: >
      What HTTP header is typically used by a client to conditionally request a resource based on a previously received ETag, indicating that the client only wants the resource if it has changed?
    answers:
      - { value: "If-None-Match", correct: true }
      - { value: "If-Modified-Since", correct: false }
      - { value: "Cache-Control", correct: false }
      - { value: "ETag", correct: false }
      - { value: "Vary", correct: false }
    help: |
      The `If-None-Match` request header is used by a client to send an ETag back to the server. If the ETag matches the current resource's ETag, the server can respond with a 304 Not Modified status.
      https://symfony.com/doc/current/http_cache/validation.html#etag

  -
    question: |
      How can you enable the built-in Symfony HTTP cache reverse proxy in a production environment using YAML configuration?
    answers:
      - { value: "Set `framework.http_cache.enabled: true` in `config/packages/framework.yaml` under `when@prod`.", correct: true }
      - { value: "Set `framework.cache.http_cache: true` in `config/services.yaml`.", correct: false }
      - { value: "Install `symfony/http-cache-bundle` and enable it in `bundles.php`.", correct: false }
      - { value: "Add `HttpCache` to `public/index.php` manually.", correct: false }
    help: |
      The built-in Symfony HTTP cache can be enabled via the `http_cache` option under the `framework` configuration, typically within a `when@prod` block for production environments.
      https://symfony.com/doc/current/http_cache.html#enabling-the-symfony-http-cache-reverse-proxy

  -
    question: |
      How would you set the `Expires` header for a Symfony `Response` object to expire in 5 minutes (300 seconds) from now?
    answers:
      - { value: "$date = new DateTime(); $date->modify('+300 seconds'); $response->setExpires($date);", correct: true }
      - { value: "$response->setExpires(new DateTime('+5 minutes'));", correct: true }
      - { value: "$response->setExpires(300);", correct: false }
      - { value: "$response->headers->set('Expires', '+300 seconds');", correct: false }
    help: |
      The `Response::setExpires()` method expects a `DateTimeInterface` object. You can create a `DateTime` object and modify it to the desired expiration time.
      https://symfony.com/doc/current/http_cache/expiration.html#the-expires-header

  -
    question: >
      Which HTTP header is used to indicate the last modification date of a resource, often used for cache validation in conjunction with `If-Modified-Since`?
    answers:
      - { value: "Last-Modified", correct: true }
      - { value: "Date", correct: false }
      - { value: "ETag", correct: false }
      - { value: "Cache-Control", correct: false }
    help: |
      The `Last-Modified` header specifies the date and time the origin server believes the resource was last modified. Clients can use `If-Modified-Since` to check if the resource has changed since that date.
      https://symfony.com/doc/current/http_cache/validation.html#last-modified

  -
    question: >
      What does the `<esi:include>` tag allow in the context of Edge Side Includes (ESI)?
    answers:
      - { value: "To include content from a different domain via a server-side request.", correct: false }
      - { value: "To mark a specific region of a page as content to be fetched via a sub-request, enabling granular caching.", correct: true }
      - { value: "To embed JavaScript code that dynamically loads content on the client-side.", correct: false }
      - { value: "To define a section of the page that should never be cached.", correct: false }
    help: |
      ESI allows for "fragment caching" where parts of a page are fetched via separate HTTP sub-requests and can have their own caching rules, while the main page might be cached differently.
      https://symfony.com/doc/current/http_cache/esi.html#edge-side-includes

  -
    question: >
      Which type of cache is typically managed by the client's web browser and stores responses for individual users?
    answers:
      - { value: "Browser cache (private cache)", correct: true }
      - { value: "Reverse proxy cache (shared cache)", correct: false }
      - { value: "CDN cache (shared cache)", correct: false }
      - { value: "Application cache", correct: false }
    help: |
      Browser caches are private caches, meaning they store responses for a single user and are managed by the user's web browser.
      https://symfony.com/doc/current/http_cache.html#cache-types

  -
    question: |
      Which `Response` method in Symfony allows you to set multiple HTTP cache-related headers (like `max_age`, `public`, `etag`) in a single call using an associative array?
    answers:
      - { value: "`setCache()`", correct: true }
      - { value: "`configureCache()`", correct: false }
      - { value: "`addCacheHeaders()`", correct: false }
      - { value: "`setHttpCache()`", correct: false }
    help: |
      The `Response::setCache()` method provides a convenient way to configure various caching directives with a single array.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What Symfony component acts as a reverse proxy and handles HTTP caching when enabled, often by wrapping the main kernel?
    answers:
      - { value: "HttpCache", correct: true }
      - { value: "CacheBundle", correct: false }
      - { value: "ProxyComponent", correct: false }
      - { value: "HttpFoundation", correct: false }
    help: |
      The `Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache` class implements the reverse proxy functionality for Symfony applications.
      https://symfony.com/doc/current/http_cache.html#enabling-the-symfony-http-cache-reverse-proxy

  -
    question: |
      Consider a Symfony controller. If you have set an ETag on a `Response` object, what method should you call on the `Response` to check if the client's cached version is still valid and automatically return a 304 response if so?
    answers:
      - { value: "`isNotModified($request)`", correct: true }
      - { value: "`setNotModified()`", correct: false }
      - { value: "`validateCache($request)`", correct: false }
      - { value: "`checkFreshness()`", correct: false }
    help: |
      The `Response::isNotModified($request)` method compares the request's `If-None-Match` (or `If-Modified-Since`) header with the response's ETag (or Last-Modified) and sets the response to 304 if not modified.
      https://symfony.com/doc/current/http_cache/validation.html#checking-freshness-with-isnotmodified

  -
    question: >
      Which `Cache-Control` directive indicates that a response must not be served from a cache without revalidation with the origin server, even if it's considered fresh?
    answers:
      - { value: "`no-cache`", correct: true }
      - { value: "`no-store`", correct: false }
      - { value: "`must-revalidate`", correct: false }
      - { value: "`private`", correct: false }
    help: |
      The `no-cache` directive means that a cache must revalidate the response with the origin server before using a cached copy, even if the cached copy is not stale.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-cache

  -
    question: >
      To implement custom cache invalidation logic, such as handling `PURGE` requests for a Symfony application, which Symfony class would you typically extend and decorate?
    answers:
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\HttpCache\\HttpCache`", correct: true }
      - { value: "`Symfony\\Component\\HttpFoundation\\Response`", correct: false }
      - { value: "`Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Kernel`", correct: false }
    help: |
      To add custom logic like handling `PURGE` requests, you typically extend `Symfony\\Bundle\\FrameworkBundle\\HttpCache\\HttpCache` and register it as a decorated service for `http_cache`.
      https://symfony.com/doc/current/http_cache/cache_invalidation.html#custom-cache-invalidation

  -
    question: >
      When Symfony's `HttpCache` debug mode is enabled, what HTTP header is added to responses to provide cache-related debugging information, such as whether a response was `fresh` or `stale`?
    answers:
      - { value: "X-Symfony-Cache", correct: true }
      - { value: "X-Cache-Status", correct: false }
      - { value: "Cache-Debug", correct: false }
      - { value: "X-Debug-Token", correct: false }
    help: |
      The `X-Symfony-Cache` header provides detailed insights into the cache layer's actions when debug mode is enabled.
      https://symfony.com/doc/current/create_framework/http_kernel_httpkernelinterface.html#debugging-the-http-cache

  -
    question: >
      What is the purpose of the `Vary` HTTP header in caching?
    answers:
      - { value: "To indicate that the cached response should vary based on specific request headers, meaning different cached versions will be stored.", correct: true }
      - { value: "To specify the maximum age a cached response can be considered fresh.", correct: false }
      - { value: "To force a cache to revalidate with the origin server before serving a response.", correct: false }
      - { value: "To prevent any caching of the response.", correct: false }
    help: |
      The `Vary` header tells caches that the response content varies depending on the values of the specified request headers.
      https://symfony.com/doc/current/http_cache/cache_vary.html

  -
    question: |
      How can you set the `Vary` header to `Accept-Encoding` and `User-Agent` on a Symfony `Response` object programmatically?
    answers:
      - { value: "$response->setVary(['Accept-Encoding', 'User-Agent']);", correct: true }
      - { value: "$response->headers->set('Vary', 'Accept-Encoding, User-Agent');", correct: true }
      - { value: "$response->setVary('Accept-Encoding', 'User-Agent');", correct: false }
      - { value: "$response->addVary('Accept-Encoding', 'User-Agent');", correct: false }
    help: |
      The `Response::setVary()` method accepts either a string or an array of header names. You can also directly set the header via `headers->set()`.
      https://symfony.com/doc/current/http_cache/cache_vary.html#setting-the-vary-header

  -
    question: >
      To enable response caching for the Symfony HTTP Client, which class should you use as a decorator, requiring the `HttpKernel` component and a `Store` implementation?
    answers:
      - { value: "`Symfony\\Component\\HttpClient\\CachingHttpClient`", correct: true }
      - { value: "`Symfony\\Component\\HttpClient\\CacheClient`", correct: false }
      - { value: "`Symfony\\Component\\HttpClient\\HttpCacheClient`", correct: false }
      - { value: "`Symfony\\Component\\HttpClient\\CacheDecorator`", correct: false }
    help: |
      `CachingHttpClient` decorates an existing HTTP client to add caching capabilities, using a `Store` for cache storage.
      https://symfony.com/doc/current/http_client.html#caching-http-client-responses

  -
    question: >
      A CDN (Content Delivery Network) typically acts as which type of cache?
    answers:
      - { value: "Shared cache (reverse proxy)", correct: true }
      - { value: "Private cache (browser cache)", correct: false }
      - { value: "Application cache", correct: false }
      - { value: "Local disk cache", correct: false }
    help: |
      CDNs are distributed networks of servers that cache content closer to users, acting as shared caches.
      https://symfony.com/doc/current/http_cache.html#cache-types

  -
    question: >
      What is the purpose of the `s-maxage` directive in the `Cache-Control` header?
    answers:
      - { value: "It specifies the maximum amount of time (in seconds) a resource is considered fresh for shared caches only.", correct: true }
      - { value: "It sets the maximum age for private caches only.", correct: false }
      - { value: "It indicates that the response should be stored on the server-side for the specified duration.", correct: false }
      - { value: "It defines the time after which the cache must revalidate the resource.", correct: false }
    help: |
      `s-maxage` (shared-maxage) is similar to `max-age` but applies only to shared caches (like reverse proxies or CDNs).
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What does the `immutable` directive in the `Cache-Control` header signify?
    answers:
      - { value: "It indicates that the response will not change over time and can be cached indefinitely without revalidation.", correct: true }
      - { value: "It means the response content is encrypted and cannot be modified.", correct: false }
      - { value: "It prevents the response from being stored in any cache.", correct: false }
      - { value: "It forces the cache to revalidate the response on every request.", correct: false }
    help: |
      The `immutable` directive tells caches that the response will not change, allowing them to serve it without revalidation for its entire `max-age` or `expires` lifetime.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      When setting an ETag using `Response::setEtag()`, what is the purpose of the optional second argument `$weak`?
    answers:
      - { value: "If set to `true`, the ETag will be marked as weak (e.g., `W/\"etag_value\"`), indicating that two resources with weak ETags might be semantically equivalent but not byte-for-byte identical.", correct: true }
      - { value: "It makes the ETag less secure and easier to bypass.", correct: false }
      - { value: "It ensures the ETag is only used by private caches, not shared caches.", correct: false }
      - { value: "It forces the client to always revalidate the resource, ignoring the ETag.", correct: false }
    help: |
      Weak ETags are used when two representations are semantically equivalent but not byte-for-byte identical.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: |
      When initializing `HttpCache` in Symfony, what object needs to be passed to its constructor to enable ESI support?
    answers:
      - { value: "`Symfony\\Component\\HttpKernel\\HttpCache\\Esi`", correct: true }
      - { value: "`Symfony\\Component\\HttpKernel\\HttpCache\\Store`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Fragment\\FragmentHandler`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\HttpCache\\Surrogate`", correct: false }
    help: |
      To enable ESI processing, an instance of `HttpKernel\\HttpCache\\Esi` must be passed as the third argument to the `HttpCache` constructor.
      https://symfony.com/doc/current/http_cache/esi.html#enabling-esi

  -
    question: >
      By default, how does Symfony's session listener affect the cacheability of a response when a user session is started?
    answers:
      - { value: "It automatically makes the response uncacheable (e.g., by adding `Cache-Control: private, no-cache`).", correct: true }
      - { value: "It automatically makes the response publicly cacheable for a short duration.", correct: false }
      - { value: "It adds a `Vary: Cookie` header to the response.", correct: false }
      - { value: "It has no effect on the cacheability; caching must be configured manually.", correct: false }
    help: |
      Symfony's `AbstractSessionListener` by default adds `Cache-Control: private, no-cache` to responses when a session is active to prevent accidental caching of user-specific content.
      https://symfony.com/doc/current/http_cache.html#sessions

  -
    question: >
      Which constant from `AbstractSessionListener` can be set on a `Response` header to prevent Symfony from automatically making responses uncacheable when a session is active, allowing manual control over caching?
    answers:
      - { value: "`AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER`", correct: true }
      - { value: "`AbstractSessionListener::DISABLE_SESSION_CACHE`", correct: false }
      - { value: "`AbstractSessionListener::ALLOW_CACHE_WITH_SESSION`", correct: false }
      - { value: "`AbstractSessionListener::OVERRIDE_CACHE_CONTROL`", correct: false }
    help: |
      Setting the `AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER` to `true` on the response headers disables the automatic cache control modification by the session listener.
      https://symfony.com/doc/current/http_cache.html#sessions

  -
    question: >
      Which `Cache-Control` directive explicitly forbids any cache (private or shared) from storing any part of the request or response?
    answers:
      - { value: "`no-store`", correct: true }
      - { value: "`no-cache`", correct: false }
      - { value: "`private`", correct: false }
      - { value: "`must-revalidate`", correct: false }
    help: |
      The `no-store` directive ensures that no part of the request or response is stored in any cache.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-store

  -
    question: >
      What is the effect of the `must-revalidate` directive in the `Cache-Control` header?
    answers:
      - { value: "It indicates that once the response becomes stale, caches must revalidate it with the origin server before serving it.", correct: true }
      - { value: "It forces the client to always revalidate the resource, even if it's fresh.", correct: false }
      - { value: "It prevents the response from being cached by proxy servers.", correct: false }
      - { value: "It specifies that the response should be cached for a very short period.", correct: false }
    help: |
      `must-revalidate` means that a cache must not serve a stale response without successful revalidation with the origin server.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#must-revalidate

  -
    question: >
      What is the primary difference between `must-revalidate` and `proxy-revalidate` directives in `Cache-Control`?
    answers:
      - { value: "`must-revalidate` applies to both private and shared caches, while `proxy-revalidate` applies only to shared (proxy) caches.", correct: true }
      - { value: "`must-revalidate` is for client-side caches, and `proxy-revalidate` is for server-side caches.", correct: false }
      - { value: "`proxy-revalidate` forces revalidation only if an error occurs, while `must-revalidate` always forces it.", correct: false }
      - { value: "There is no functional difference; they are synonyms.", correct: false }
    help: |
      `must-revalidate` applies to all caches, whereas `proxy-revalidate` is specifically for shared caches.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#proxy-revalidate

  -
    question: >
      When enabling the Symfony HTTP cache, what component is responsible for storing the cached responses on the file system or another backend?
    answers:
      - { value: "`Symfony\\Component\\HttpKernel\\HttpCache\\Store`", correct: true }
      - { value: "`Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter`", correct: false }
      - { value: "`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeFileSessionHandler`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\CacheWarmer\\CacheWarmerInterface`", correct: false }
    help: |
      The `Store` class manages the actual storage of cached responses for the `HttpCache` component.
      https://symfony.com/doc/current/http_cache.html#enabling-the-symfony-http-cache-reverse-proxy

  -
    question: >
      In a custom `CacheKernel` designed for handling `PURGE` requests for cache invalidation, what method of the `Store` object is typically called to remove a specific URI from the cache?
    answers:
      - { value: "`purge($uri)`", correct: true }
      - { value: "`delete($uri)`", correct: false }
      - { value: "`remove($uri)`", correct: false }
      - { value: "`invalidate($uri)`", correct: false }
    help: |
      The `Store::purge()` method is used to remove a specific URI from the cache.
      https://symfony.com/doc/current/http_cache/cache_invalidation.html#custom-cache-invalidation

  -
    question: >
      What is the primary purpose of `Symfony\\Component\\Config\\ConfigCache`?
    answers:
      - { value: "To manage caching of configuration resources, regenerating cached files only when source resources are modified.", correct: true }
      - { value: "To store application-wide key-value pairs in a high-performance cache.", correct: false }
      - { value: "To cache database query results for faster retrieval.", correct: false }
      - { value: "To handle HTTP response caching for controllers.", correct: false }
    help: |
      `ConfigCache` is specifically designed for caching configuration files and ensuring they are regenerated only when their source resources change.
      https://symfony.com/doc/current/components/config/caching.html

  -
    question: >
      When using `ConfigCache`, what is the purpose of the second argument (`debug`) in its constructor, and how does it affect the `.meta` file?
    answers:
      - { value: "If `true`, debug mode is enabled, and a `.meta` file containing serialized resources is created for freshness checks. If `false`, the cache is considered fresh as soon as it exists, and no `.meta` file is generated.", correct: true }
      - { value: "If `true`, it enables verbose logging for cache operations; the `.meta` file stores these logs.", correct: false }
      - { value: "It determines if the cache should be cleared automatically in debug mode.", correct: false }
      - { value: "It controls whether the cache file is minified or human-readable.", correct: false }
    help: |
      The `debug` argument controls the creation and usage of the `.meta` file for freshness checking.
      https://symfony.com/doc/current/components/config/caching.html#configcache

  -
    question: >
      How does `ConfigCache::isFresh()` determine if a cached file is still fresh?
    answers:
      - { value: "By comparing the timestamps of the associated resources (e.g., configuration files) with the cache's last modification time.", correct: true }
      - { value: "By checking a flag in the cached file itself.", correct: false }
      - { value: "By performing a checksum comparison of the cached content.", correct: false }
      - { value: "It always returns `true` unless the cache file is explicitly deleted.", correct: false }
    help: |
      `isFresh()` relies on the modification timestamps of the resources listed in the `.meta` file to determine freshness.
      https://symfony.com/doc/current/components/config/caching.html#configcache

  -
    question: >
      When writing to `ConfigCache` using the `write()` method, what kind of objects should be passed in the `resources` array to ensure proper freshness checks?
    answers:
      - { value: "An array of `Symfony\\Component\\Config\\Resource\\ResourceInterface` objects (e.g., `FileResource`).", correct: true }
      - { value: "An array of strings representing file paths.", correct: false }
      - { value: "An array of `DateTime` objects indicating last modification times.", correct: false }
      - { value: "An array of cache keys.", correct: false }
    help: |
      The `write()` method expects an array of `ResourceInterface` objects, such as `FileResource`, to track dependencies for freshness.
      https://symfony.com/doc/current/components/config/caching.html#configcache

  -
    question: >
      What is the effect of calling `Response::setTtl(60)` on a Symfony `Response` object?
    answers:
      - { value: "It sets the Time-To-Live (TTL) for the response, which is converted to a `max-age` directive in the `Cache-Control` header.", correct: true }
      - { value: "It sets the `Expires` header to 60 seconds from now.", correct: false }
      - { value: "It forces the response to be revalidated every 60 seconds.", correct: false }
      - { value: "It makes the response private for 60 seconds.", correct: false }
    help: |
      `setTtl()` sets the `max-age` directive in the `Cache-Control` header, indicating how long the response can be considered fresh.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What does the `Response::expire()` method do?
    answers:
      - { value: "It marks the HTTP response as stale, indicating that it should be revalidated by caches before serving.", correct: true }
      - { value: "It immediately deletes the cached version of the response from all caches.", correct: false }
      - { value: "It sets the `Expires` header to a date in the past.", correct: true }
      - { value: "It sets the `max-age` directive to 0.", correct: false }
    help: |
      `Response::expire()` sets the `Cache-Control` header to `no-cache, must-revalidate` and the `Expires` header to a past date, effectively marking the response as stale.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What status code does `Response::setNotModified()` set on the response, and what other actions does it typically perform?
    answers:
      - { value: "It sets the status code to `304 Not Modified` and removes the content and certain headers that must not be present for 304 responses.", correct: true }
      - { value: "It sets the status code to `200 OK` and adds a `Cache-Control: no-cache` header.", correct: false }
      - { value: "It sets the status code to `404 Not Found` if the resource has not been modified.", correct: false }
      - { value: "It sets the status code to `204 No Content` and clears all cache headers.", correct: false }
    help: |
      `setNotModified()` is used to send a 304 response, indicating to the client that its cached version is still valid.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      In Symfony's HTTP Client configuration, what option allows you to pre-populate the DNS cache to avoid lookups for specific hosts, which can be useful for security or testing?
    answers:
      - { value: "`resolve`", correct: true }
      - { value: "`dns_cache`", correct: false }
      - { value: "`hosts`", correct: false }
      - { value: "`pre_resolve`", correct: false }
    help: |
      The `resolve` option in HTTP client configuration allows mapping hostnames to IP addresses to pre-populate the DNS cache.
      https://symfony.com/doc/current/reference/configuration/framework.html#resolve

  -
    question: >
      When using the Symfony Cache component (PSR-6), what method on `ItemInterface` is used to set the expiration time for a cache item?
    answers:
      - { value: "`expiresAfter(int $seconds)`", correct: true }
      - { value: "`setTtl(int $seconds)`", correct: false }
      - { value: "`setExpiration(DateTimeInterface $date)`", correct: false }
      - { value: "`lifetime(int $seconds)`", correct: false }
    help: |
      The `expiresAfter()` method on `ItemInterface` is used to define the item's lifetime.
      https://symfony.com/doc/current/cache.html#basic-cache-usage

  -
    question: >
      What is the purpose of the `$beta` parameter in `CacheInterface::get()` when using the Symfony Cache component?
    answers:
      - { value: "It enables probabilistic early expiration, recomputing cache values ahead of their expiration to prevent stampedes.", correct: true }
      - { value: "It defines the probability of a cache hit.", correct: false }
      - { value: "It specifies the maximum number of times a cache item can be accessed before revalidation.", correct: false }
      - { value: "It's a multiplier for the cache's default TTL.", correct: false }
    help: |
      The `beta` parameter helps prevent cache stampedes by allowing a small percentage of requests to recompute a cache item before it fully expires.
      https://symfony.com/doc/current/cache.html#probabilistic-early-expiration-to-prevent-cache-stampede

  -
    question: >
      To enable tag-aware caching for a Symfony cache pool, what configuration option needs to be set to `true` in `config/packages/cache.yaml`?
    answers:
      - { value: "`tags`", correct: true }
      - { value: "`tag_aware`", correct: false }
      - { value: "`enable_tags`", correct: false }
      - { value: "`supports_tags`", correct: false }
    help: |
      The `tags: true` option enables tag-aware caching for a specific cache pool.
      https://symfony.com/doc/current/cache.html#tag-aware-caching

  -
    question: >
      Which class is used with `RedisAdapter` to optimize caching for tag-based retrieval and invalidation?
    answers:
      - { value: "`Symfony\\Component\\Cache\\Marshaller\\TagAwareMarshaller`", correct: true }
      - { value: "`Symfony\\Component\\Cache\\Marshaller\\RedisMarshaller`", correct: false }
      - { value: "`Symfony\\Component\\Cache\\Tagging\\TagManager`", correct: false }
      - { value: "`Symfony\\Component\\Cache\\Adapter\\TaggingAdapter`", correct: false }
    help: |
      `TagAwareMarshaller` is used with adapters like `RedisAdapter` to handle the serialization and deserialization of tagged cache items.
      https://symfony.com/doc/current/components/cache/adapters/redis_adapter.html#tag-aware-caching

  -
    question: >
      What method of a cache pool can be used to implement cache versioning or create isolated cache segments, for example, per user or per application version?
    answers:
      - { value: "`withSubNamespace(string $subNamespace)`", correct: true }
      - { value: "`createVersionedPool(string $version)`", correct: false }
      - { value: "`getNamespace(string $namespace)`", correct: false }
      - { value: "`isolate(string $identifier)`", correct: false }
    help: |
      The `withSubNamespace()` method allows creating a new cache pool instance with an appended namespace, useful for versioning or isolating cache data.
      https://symfony.com/doc/current/cache.html#cache-versioning

  -
    question: >
      Which of the following is a valid strategy for cache versioning using `withSubNamespace`?
    answers:
      - { value: "Using a static incrementing version number (e.g., `v1-user-ID`).", correct: true }
      - { value: "Using a dynamic version based on the current date (e.g., `YYYYMM-user-ID`).", correct: true }
      - { value: "Using a checksum of the underlying data (e.g., `user-ID-CHECKSUM`) to invalidate when data changes.", correct: true }
      - { value: "Using the current timestamp as the sub-namespace for every request.", correct: false }
    help: |
      All listed strategies (static version, date-based, data checksum) are valid approaches for cache versioning with `withSubNamespace`.
      https://symfony.com/doc/current/cache.html#cache-versioning

  -
    question: >
      In the `framework.yaml` configuration for `http_cache`, what does the `default_ttl` option control?
    answers:
      - { value: "The number of seconds that a cache entry should be considered fresh when no explicit freshness information is provided in a response.", correct: true }
      - { value: "The default time-to-live for all cache items in the application.", correct: false }
      - { value: "The maximum age for client-side caches.", correct: false }
      - { value: "The duration for which stale content can be served during revalidation.", correct: false }
    help: |
      `default_ttl` sets a fallback freshness lifetime for responses that lack explicit `Cache-Control` or `Expires` headers.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What is the purpose of the `private_headers` option in Symfony's `http_cache` configuration?
    answers:
      - { value: "It defines a set of request headers that trigger \"private\" cache-control behavior on responses that don't explicitly state whether the response is public or private.", correct: true }
      - { value: "It lists headers that should be removed from responses before caching.", correct: false }
      - { value: "It specifies headers that are only visible to the application server, not to clients.", correct: false }
      - { value: "It forces all responses containing these headers to be marked as `private`.", correct: false }
    help: |
      `private_headers` helps ensure that responses containing sensitive information (like `Authorization` or `Cookie` headers) are not accidentally cached publicly.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      Which `http_cache` configuration option defines a set of response headers that will never be cached, even when the response is otherwise cacheable and public?
    answers:
      - { value: "`skip_response_headers`", correct: true }
      - { value: "`exclude_headers`", correct: false }
      - { value: "`uncacheable_headers`", correct: false }
      - { value: "`no_cache_headers`", correct: false }
    help: |
      `skip_response_headers` allows you to prevent specific headers (e.g., `Set-Cookie`) from being cached.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `stale_if_error` option in `http_cache` configuration specify?
    answers:
      - { value: "The default number of seconds during which the cache can serve a stale response when an error is encountered (e.g., origin server is down).", correct: true }
      - { value: "The time after which a cached response is considered an error.", correct: false }
      - { value: "The duration for which error responses themselves should be cached.", correct: false }
      - { value: "It forces the cache to revalidate on every error.", correct: false }
    help: |
      `stale_if_error` implements the `stale-if-error` Cache-Control extension, allowing caches to serve stale content during origin server failures.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `stale_while_revalidate` option in `http_cache` configuration specify?
    answers:
      - { value: "The default number of seconds during which the cache can immediately return a stale response while it revalidates it in the background.", correct: true }
      - { value: "The time allowed for revalidation before an error is thrown.", correct: false }
      - { value: "It forces the cache to revalidate all stale responses simultaneously.", correct: false }
      - { value: "It defines how long a revalidation request should wait for a response.", correct: false }
    help: |
      `stale_while_revalidate` implements the `stale-while-revalidate` Cache-Control extension, improving perceived performance by serving stale content instantly while fetching fresh content in the background.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `allow_reload` option in `http_cache` configuration control?
    answers:
      - { value: "Specifies whether the client can force a cache reload by including a `Cache-Control: \"no-cache\"` directive in the request.", correct: true }
      - { value: "Enables automatic cache reloading when a resource changes on the server.", correct: false }
      - { value: "Allows the application to bypass the cache for specific requests.", correct: false }
      - { value: "Determines if the cache should be cleared on application redeployments.", correct: false }
    help: |
      `allow_reload` controls whether the `no-cache` directive from the client is respected by the Symfony HttpCache.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `allow_revalidate` option in `http_cache` configuration control?
    answers:
      - { value: "Specifies whether the client can force a cache revalidate by including a `Cache-Control: \"max-age=0\"` directive in the request.", correct: true }
      - { value: "Enables automatic revalidation of all cached items at regular intervals.", correct: false }
      - { value: "Allows the cache to revalidate items without contacting the origin server.", correct: false }
      - { value: "Defines the maximum number of revalidation attempts before an item is removed from cache.", correct: false }
    help: |
      `allow_revalidate` controls whether the `max-age=0` directive from the client is respected by the Symfony HttpCache.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      Which of the following HTTP headers is used for **expiration caching**?
    answers:
      - { value: "Expires", correct: true }
      - { value: "Cache-Control", correct: true }
      - { value: "ETag", correct: false }
      - { value: "Last-Modified", correct: false }
      - { value: "Vary", correct: false }
    help: |
      `Expires` and `Cache-Control` are the primary headers used to define how long a response can be considered fresh before it needs to be revalidated or refetched.
      https://symfony.com/doc/current/http_cache/expiration.html

  -
    question: >
      Which of the following HTTP headers is used for **validation caching**?
    answers:
      - { value: "ETag", correct: true }
      - { value: "Last-Modified", correct: true }
      - { value: "Expires", correct: false }
      - { value: "Cache-Control", correct: false }
      - { value: "Content-Length", correct: false }
    help: |
      `ETag` and `Last-Modified` are used to validate a cached response with the origin server, typically in conjunction with `If-None-Match` and `If-Modified-Since` request headers.
      https://symfony.com/doc/current/http_cache/validation.html

  -
    question: >
      When a Symfony `Response` is marked as `private`, what does this imply about its cacheability?
    answers:
      - { value: "It can only be cached by a private cache (e.g., a browser cache) and not by shared caches (e.g., proxy servers).", correct: true }
      - { value: "It cannot be cached by any cache.", correct: false }
      - { value: "It can be cached by any cache, but only for a very short duration.", correct: false }
      - { value: "It requires user authentication before being served from cache.", correct: false }
    help: |
      The `private` directive in `Cache-Control` indicates that the response is intended for a single user and should not be stored by a shared cache.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What is the default behavior of Symfony's `HttpCache` regarding responses that do not explicitly set `public` or `private` directives, but contain `private_headers` (like `Authorization` or `Cookie`)?
    answers:
      - { value: "It treats them as `private` and makes them uncacheable by shared caches.", correct: true }
      - { value: "It treats them as `public` by default.", correct: false }
      - { value: "It throws an exception, requiring explicit cache control.", correct: false }
      - { value: "It caches them but logs a warning.", correct: false }
    help: |
      Symfony's `HttpCache` is configured with `private_headers` (e.g., `Authorization`, `Cookie`) to automatically mark responses containing these as private if no explicit `public` or `private` directive is set.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      Which of the following is NOT a type of HTTP cache?
    answers:
      - { value: "Database cache", correct: true }
      - { value: "Browser cache", correct: false }
      - { value: "Reverse proxy cache", correct: false }
      - { value: "CDN cache", correct: false }
    help: |
      Database caching is an application-level caching mechanism, not a type of HTTP cache. HTTP caches operate on HTTP responses.
      https://symfony.com/doc/current/http_cache.html#cache-types

  -
    question: >
      When implementing ESI, what is the role of the main request and sub-requests?
    answers:
      - { value: "The main request fetches the overall page, and sub-requests are made by the ESI processor (e.g., `HttpCache`) to fetch content for `<esi:include>` tags.", correct: true }
      - { value: "Sub-requests are made by the client's browser after the main page loads.", correct: false }
      - { value: "The main request and sub-requests are always handled by different servers.", correct: false }
      - { value: "ESI only involves a single request, with content being dynamically generated.", correct: false }
    help: |
      ESI works by having the main request return a page with ESI tags, which are then processed by a capable reverse proxy (like Symfony's HttpCache or Varnish) that makes internal sub-requests to fetch the included content.
      https://symfony.com/doc/current/http_cache/esi.html

  -
    question: >
      What is the benefit of using `Response::isNotModified($request)` early in a controller action when implementing cache validation?
    answers:
      - { value: "It allows short-circuiting the response generation process, returning a 304 Not Modified response immediately if the content hasn't changed, thus reducing server load.", correct: true }
      - { value: "It ensures that the response is always served from the cache, even if it's stale.", correct: false }
      - { value: "It automatically clears the cache for the current resource.", correct: false }
      - { value: "It adds additional debugging information to the response headers.", correct: false }
    help: |
      Calling `isNotModified()` early can prevent expensive computations and database queries if the client's cached version is still valid, leading to significant performance improvements.
      https://symfony.com/doc/current/http_cache/validation.html#checking-freshness-with-isnotmodified

  -
    question: >
      Which of the following is a valid way to set a `Cache-Control` directive `must-revalidate` on a Symfony `Response` object?
    answers:
      - { value: "$response->headers->addCacheControlDirective('must-revalidate', true);", correct: true }
      - { value: "$response->setCache(['must_revalidate' => true]);", correct: true }
      - { value: "$response->setMustRevalidate(true);", correct: false }
      - { value: "$response->setCacheControl('must-revalidate');", correct: false }
    help: |
      You can add custom cache control directives using `addCacheControlDirective` or include it in the `setCache` options array.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What is the purpose of the `trace_header` option in Symfony's `http_cache` configuration?
    answers:
      - { value: "It defines the name of the HTTP header used for cache traces (e.g., `X-Symfony-Cache`).", correct: true }
      - { value: "It specifies the header used to trace user requests through the application.", correct: false }
      - { value: "It enables tracing of cache invalidation events.", correct: false }
      - { value: "It sets the header for distributed tracing systems.", correct: false }
    help: |
      `trace_header` allows customizing the name of the debug header added by HttpCache.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What are the possible values for the `trace_level` option in Symfony's `http_cache` configuration?
    answers:
      - { value: "`none`", correct: true }
      - { value: "`short`", correct: true }
      - { value: "`full`", correct: true }
      - { value: "`basic`", correct: false }
      - { value: "`verbose`", correct: false }
    help: |
      The `trace_level` option controls the verbosity of the `X-Symfony-Cache` header.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      When configuring `HttpCache` with ESI support, what additional option can be passed to the `HttpCache` constructor to enable debug information in the `X-Symfony-Cache` header for ESI sub-requests?
    answers:
      - { value: "`['debug' => true]`", correct: true }
      - { value: "`['esi_debug' => true]`", correct: false }
      - { value: "`['trace' => 'full']`", correct: false }
      - { value: "`['enable_debug_headers' => true]`", correct: false }
    help: |
      The `debug` option in the HttpCache constructor's options array enables debug headers, including for ESI.
      https://symfony.com/doc/current/create_framework/http_kernel_httpkernelinterface.html#debugging-the-http-cache

  -
    question: >
      What is the main advantage of using ESI (Edge Side Includes) for caching?
    answers:
      - { value: "It allows different parts of a single HTML page to be cached with different rules and lifetimes.", correct: true }
      - { value: "It encrypts the entire HTML page for secure delivery.", correct: false }
      - { value: "It enables client-side JavaScript to manage caching decisions.", correct: false }
      - { value: "It automatically invalidates the entire page cache when any small part changes.", correct: false }
    help: |
      ESI provides granular caching control, allowing dynamic sections of a page to be fetched separately while the static parts remain cached.
      https://symfony.com/doc/current/http_cache/esi.html

  -
    question: >
      Which of the following describes a "shared cache" in HTTP caching?
    answers:
      - { value: "A cache that stores responses for multiple users, such as a reverse proxy or CDN.", correct: true }
      - { value: "A cache that is only accessible by the application server.", correct: false }
      - { value: "A cache that shares its storage with other applications on the same server.", correct: false }
      - { value: "A cache that stores private user data.", correct: false }
    help: |
      Shared caches are deployed by intermediaries (like proxies or CDNs) and can serve cached responses to multiple users.
      https://symfony.com/doc/current/http_cache.html#cache-types

  -
    question: >
      What is the primary role of the `HttpKernelInterface::handle()` method in Symfony's request-response lifecycle, especially relevant to caching?
    answers:
      - { value: "It processes an incoming `Request` and returns a `Response`, forming the core of how Symfony handles HTTP interactions, including cache processing.", correct: true }
      - { value: "It is responsible for rendering Twig templates and generating HTML content.", correct: false }
      - { value: "It manages database connections and ORM operations.", correct: false }
      - { value: "It dispatches events to various listeners in the application.", correct: false }
    help: |
      The `handle()` method is the entry point for processing an HTTP request and generating a response, and it's where the `HttpCache` component intercepts and manages caching.
      https://symfony.com/doc/current/create_framework/http_kernel_httpkernelinterface.html#the-httpkernelinterface

  -
    question: >
      When using `CachingHttpClient`, what is the purpose of the `Store` object passed to its constructor?
    answers:
      - { value: "It defines where the cached HTTP responses will be physically stored (e.g., filesystem, Redis).", correct: true }
      - { value: "It specifies the maximum number of requests that can be cached.", correct: false }
      - { value: "It configures the HTTP client's network timeout.", correct: false }
      - { value: "It handles authentication for cached requests.", correct: false }
    help: |
      The `Store` implementation provides the actual storage mechanism for `CachingHttpClient`.
      https://symfony.com/doc/current/http_client.html#caching-http-client-responses

  -
    question: >
      What is the main difference between expiration caching (using `Expires` or `Cache-Control: max-age`) and validation caching (using `ETag` or `Last-Modified`)?
    answers:
      - { value: "Expiration caching allows a cache to serve a response without contacting the origin server until it's stale, while validation caching requires contacting the origin server to check if the content has changed after it becomes stale.", correct: true }
      - { value: "Expiration caching is for private caches, and validation caching is for shared caches.", correct: false }
      - { value: "Expiration caching is more efficient as it never requires revalidation, while validation caching always does.", correct: false }
      - { value: "Expiration caching only works for static files, while validation caching works for dynamic content.", correct: false }
    help: |
      Expiration caching is about freshness, while validation caching is about checking if stale content is still valid.
      https://symfony.com/doc/current/http_cache.html#expiration-vs-validation

  -
    question: >
      Which of the following `Cache-Control` directives explicitly indicates that a response is intended for a single user and must not be stored by a shared cache?
    answers:
      - { value: "`private`", correct: true }
      - { value: "`no-store`", correct: false }
      - { value: "`no-cache`", correct: false }
      - { value: "`personal`", correct: false }
    help: |
      The `private` directive is used for responses that contain user-specific data and should not be cached by shared proxies.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What is a "cache stampede" in the context of caching, and how can it be mitigated?
    answers:
      - { value: "A cache stampede occurs when many clients simultaneously request an expired or missing cache item, leading to a thundering herd problem on the origin server. It can be mitigated by probabilistic early expiration (`beta` parameter) or by using a locking mechanism.", correct: true }
      - { value: "It's a security vulnerability where malicious users flood the cache with invalid data.", correct: false }
      - { value: "It refers to the cache filling up too quickly, leading to frequent evictions.", correct: false }
      - { value: "It's a problem where cache entries are never invalidated, leading to stale data.", correct: false }
    help: |
      Cache stampedes can overwhelm the backend when a popular item expires. Probabilistic early expiration is a Symfony Cache component feature to address this.
      https://symfony.com/doc/current/cache.html#probabilistic-early-expiration-to-prevent-cache-stampede

  -
    question: >
      What is the primary benefit of using `ConfigCache` over a simple file_put_contents for caching generated code or configurations?
    answers:
      - { value: "It automatically handles freshness checks based on resource modification times, ensuring the cached file is regenerated only when necessary.", correct: true }
      - { value: "It encrypts the cached content for security.", correct: false }
      - { value: "It provides a mechanism for distributed caching across multiple servers.", correct: false }
      - { value: "It automatically clears the cache when the application is deployed.", correct: false }
    help: |
      `ConfigCache` is designed to manage the lifecycle of cached configuration files, including their freshness.
      https://symfony.com/doc/current/components/config/caching.html

  -
    question: >
      When using the `#[Cache]` attribute, how can you specify that the response should be cached for shared caches only, for a duration of 5 minutes?
    answers:
      - { value: "`#[Cache(smaxage: 300)]`", correct: true }
      - { value: "`#[Cache(maxage: 300, public: true)]`", correct: false }
      - { value: "`#[Cache(private: false, ttl: 300)]`", correct: false }
      - { value: "`#[Cache(shared: true, duration: 300)]`", correct: false }
    help: |
      The `smaxage` option specifically sets the `s-maxage` directive for shared caches.
      https://symfony.com/doc/current/http_cache/expiration.html#configuring-cache-control-with-the-cache-attribute

  -
    question: >
      What happens if a client sends an `If-Modified-Since` header with a date that is newer than the `Last-Modified` header of the resource on the server?
    answers:
      - { value: "The server will typically respond with a `304 Not Modified` status code, indicating the client's cached version is still valid.", correct: true }
      - { value: "The server will respond with a `200 OK` and the full content.", correct: false }
      - { value: "The server will return a `412 Precondition Failed` error.", correct: false }
      - { value: "The server will update the `Last-Modified` header to the client's date.", correct: false }
    help: |
      If the resource has not been modified since the date specified in `If-Modified-Since`, a 304 response is returned.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since

  -
    question: >
      Which of the following is a valid way to disable Symfony's automatic session cache control for a specific response?
    answers:
      - { value: "$response->headers->set(AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER, 'true');", correct: true }
      - { value: "$response->setPrivate(false);", correct: false }
      - { value: "$response->setCacheControl('public');", correct: false }
      - { value: "$response->headers->remove('Cache-Control');", correct: false }
    help: |
      Setting the `NO_AUTO_CACHE_CONTROL_HEADER` explicitly overrides the session listener's default behavior.
      https://symfony.com/doc/current/http_cache.html#sessions

  -
    question: >
      What is the main purpose of the `Set-Cookie` header in the context of HTTP caching?
    answers:
      - { value: "It's generally considered a non-cacheable header, and its presence often makes a response private or uncacheable by shared caches to prevent leaking user-specific data.", correct: true }
      - { value: "It indicates that the response should be cached for the duration of the cookie's lifetime.", correct: false }
      - { value: "It's used to store cache validation tokens on the client-side.", correct: false }
      - { value: "It forces the client to revalidate the cache on every request.", correct: false }
    help: |
      Responses containing `Set-Cookie` headers are typically not cached by shared caches to avoid serving private user data to others. Symfony's `http_cache.private_headers` includes `Cookie` by default.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      If a Symfony application uses an external reverse proxy (e.g., Varnish) for caching, what is the typical role of Symfony's built-in `HttpCache`?
    answers:
      - { value: "Symfony's `HttpCache` can still be used in conjunction with an external proxy, acting as a second layer of cache or handling ESI processing before Varnish.", correct: true }
      - { value: "Symfony's `HttpCache` should be disabled entirely as it conflicts with external proxies.", correct: false }
      - { value: "Symfony's `HttpCache` takes over all caching responsibilities from Varnish.", correct: false }
      - { value: "Symfony's `HttpCache` is only for development environments, not production with Varnish.", correct: false }
    help: |
      Symfony's `HttpCache` can complement an external reverse proxy, handling internal caching logic like ESI or providing a fallback cache.
      https://symfony.com/doc/current/http_cache.html#using-an-external-reverse-proxy

  -
    question: >
      When configuring the Symfony HTTP cache, what is the purpose of the `allow_reload` and `allow_revalidate` options?
    answers:
      - { value: "They control whether the client can force a cache reload (`no-cache`) or revalidation (`max-age=0`) respectively.", correct: true }
      - { value: "They enable automatic cache clearing when the application is reloaded or revalidated.", correct: false }
      - { value: "They define the frequency at which the cache reloads its content from the origin.", correct: false }
      - { value: "They are related to hot-reloading of application code, not HTTP caching.", correct: false }
    help: |
      These options allow the application to decide whether to honor client requests to bypass or revalidate the cache.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What is the significance of the `HTTP/1.1` protocol in relation to modern web caching?
    answers:
      - { value: "HTTP/1.1 introduced robust caching mechanisms, including `Cache-Control`, `ETag`, `Last-Modified`, and `Vary` headers, which are fundamental to current web caching strategies.", correct: true }
      - { value: "HTTP/1.1 completely removed the need for manual cache control, making it fully automatic.", correct: false }
      - { value: "HTTP/1.1 deprecated all previous caching headers in favor of a single new header.", correct: false }
      - { value: "HTTP/1.1 only supports client-side caching, not server-side or proxy caching.", correct: false }
    help: |
      HTTP/1.1 significantly advanced caching capabilities compared to HTTP/1.0, establishing most of the headers used today.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching

  -
    question: >
      Which of the following is a common issue that HTTP caching helps to mitigate?
    answers:
      - { value: "Reducing server load by serving content from cache instead of regenerating it.", correct: true }
      - { value: "Improving page load times for end-users.", correct: true }
      - { value: "Decreasing bandwidth usage by avoiding redundant data transfers.", correct: true }
      - { value: "Preventing SQL injection attacks.", correct: false }
      - { value: "Ensuring data consistency across distributed databases.", correct: false }
    help: |
      Caching is a fundamental optimization technique that addresses performance, scalability, and bandwidth usage.
      https://symfony.com/doc/current/http_cache.html

  -
    question: >
      What is the purpose of the `no-transform` directive in the `Cache-Control` header?
    answers:
      - { value: "It prevents proxy servers from modifying the content of the response (e.g., converting image formats).", correct: true }
      - { value: "It ensures that the response is always delivered in its original format without compression.", correct: false }
      - { value: "It disables any client-side JavaScript transformations on the content.", correct: false }
      - { value: "It prevents the cache from applying any encoding to the stored response.", correct: false }
    help: |
      The `no-transform` directive tells intermediaries not to alter the payload of the response.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-transform

  -
    question: >
      If a response has both a `Cache-Control: max-age` directive and an `Expires` header, which one takes precedence according to HTTP/1.1?
    answers:
      - { value: "The `Cache-Control: max-age` directive takes precedence.", correct: true }
      - { value: "The `Expires` header takes precedence.", correct: false }
      - { value: "They are treated as equally important, and the shortest duration is chosen.", correct: false }
      - { value: "It depends on the type of cache (private vs. shared).", correct: false }
    help: |
      According to RFC 7234, `Cache-Control` takes precedence over `Expires` for HTTP/1.1 and later.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control

  -
    question: >
      What is the significance of the `Date` header in HTTP caching?
    answers:
      - { value: "It indicates the date and time at which the response was originated by the origin server.", correct: true }
      - { value: "It specifies the expiration date of the cached content.", correct: false }
      - { value: "It is used for cache validation in conjunction with `If-Modified-Since`.", correct: false }
      - { value: "It defines the last time the cache was updated.", correct: false }
    help: |
      The `Date` header indicates when the response was generated. It's used in conjunction with other headers like `Age` to determine freshness.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date

  -
    question: >
      When a Symfony controller returns a `Response` object without any explicit cache headers, what is its default cacheability behavior?
    answers:
      - { value: "It is considered uncacheable by default, especially by shared caches, unless `public` or `private` is explicitly set.", correct: true }
      - { value: "It is cached for a default duration defined by `framework.http_cache.default_ttl`.", correct: false }
      - { value: "It is cached indefinitely by all caches.", correct: false }
      - { value: "It is cached only by the client's browser.", correct: false }
    help: |
      Responses are generally uncacheable by shared caches unless explicitly marked as `public` or `private` with an expiration.
      https://symfony.com/doc/current/http_cache.html

  -
    question: >
      What is the purpose of the `Age` header in HTTP caching?
    answers:
      - { value: "It indicates the time in seconds that the object has been in a proxy cache.", correct: true }
      - { value: "It specifies the maximum age a cached response can be considered fresh.", correct: false }
      - { value: "It defines the age of the client's browser cache.", correct: false }
      - { value: "It is used to determine if a resource is older than a certain date.", correct: false }
    help: |
      The `Age` header provides information about the age of a cached response.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age

  -
    question: >
      Which of the following is a key characteristic of ESI (Edge Side Includes)?
    answers:
      - { value: "It requires a compatible ESI processor (e.g., a reverse proxy like Varnish or Symfony's HttpCache) to parse and execute the `esi:include` tags.", correct: true }
      - { value: "It is a client-side technology executed by the web browser.", correct: false }
      - { value: "It allows embedding dynamic content directly into static HTML files without server-side processing.", correct: false }
      - { value: "It is primarily used for database query caching.", correct: false }
    help: |
      ESI tags are processed server-side by an ESI-capable proxy.
      https://symfony.com/doc/current/http_cache/esi.html

  -
    question: >
      What is the role of the `HttpKernelInterface::MAIN_REQUEST` constant when handling requests in Symfony?
    answers:
      - { value: "It indicates that the request is the primary request being handled by the kernel, as opposed to a sub-request (e.g., for ESI).", correct: true }
      - { value: "It specifies that the request should be handled by the main controller.", correct: false }
      - { value: "It denotes a request that bypasses all caching mechanisms.", correct: false }
      - { value: "It's a flag for debugging purposes only.", correct: false }
    help: |
      The `type` argument in `handle()` distinguishes between a main request and sub-requests, which is crucial for ESI and internal requests.
      https://symfony.com/doc/current/create_framework/http_kernel_httpkernelinterface.html#the-httpkernelinterface

  -
    question: >
      When configuring a Symfony cache pool, what is the purpose of the `adapter` option?
    answers:
      - { value: "It specifies the underlying storage mechanism for the cache (e.g., `cache.adapter.filesystem`, `cache.adapter.redis`).", correct: true }
      - { value: "It defines the name of the cache pool.", correct: false }
      - { value: "It sets the default lifetime for cache items in the pool.", correct: false }
      - { value: "It determines the cache invalidation strategy.", correct: false }
    help: |
      The `adapter` option determines which cache backend (filesystem, Redis, Memcached, etc.) the pool will use.
      https://symfony.com/doc/current/cache.html#cache-pools

  -
    question: >
      What is the primary benefit of using `ETag` over `Last-Modified` for cache validation?
    answers:
      - { value: "ETags are more precise for detecting changes, especially for resources that might be modified without a change in their modification date (e.g., content changes without file system update), or for comparing semantically equivalent but not byte-for-byte identical resources (weak ETags).", correct: true }
      - { value: "ETags are simpler to implement and require less server-side logic.", correct: false }
      - { value: "ETags are always supported by all caches, unlike `Last-Modified`.", correct: false }
      - { value: "ETags allow for partial content updates, while `Last-Modified` does not.", correct: false }
    help: |
      ETags provide a more robust validation mechanism than `Last-Modified` alone.
      https://symfony.com/doc/current/http_cache/validation.html#etag

  -
    question: >
      What is the purpose of the `setSharedMaxAge()` method on a Symfony `Response` object?
    answers:
      - { value: "It sets the `s-maxage` directive of the `Cache-Control` header, specifically for shared caches.", correct: true }
      - { value: "It sets the `max-age` directive for both private and shared caches.", correct: false }
      - { value: "It defines the maximum age for client-side caches only.", correct: false }
      - { value: "It forces the response to be revalidated by shared caches after the specified time.", correct: false }
    help: |
      `setSharedMaxAge()` directly controls the `s-maxage` directive.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      Which of the following describes a "private cache" in HTTP caching?
    answers:
      - { value: "A cache that stores responses for a single user, such as a web browser's cache.", correct: true }
      - { value: "A cache that requires authentication to access its content.", correct: false }
      - { value: "A cache that is located on the application server.", correct: false }
      - { value: "A cache that is not accessible via HTTP.", correct: false }
    help: |
      Private caches are user-specific and typically reside on the client side.
      https://symfony.com/doc/current/http_cache.html#cache-types

  -
    question: >
      What is the impact of a `Cache-Control: no-cache` header on a cached response that also has an `ETag`?
    answers:
      - { value: "The cache must revalidate the response with the origin server using the `If-None-Match` header before serving it, even if the cached copy is not stale.", correct: true }
      - { value: "The cache will ignore the `ETag` and immediately serve the stale content.", correct: false }
      - { value: "The response will be removed from the cache immediately.", correct: false }
      - { value: "The `ETag` will be updated to a new value.", correct: false }
    help: |
      `no-cache` forces revalidation, even if the item is fresh, but it still allows the cache to store the item.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-cache

  -
    question: >
      When using Symfony's `HttpCache`, what is the purpose of the `invalidate` method in a custom `CacheKernel`?
    answers:
      - { value: "It provides a hook to handle cache invalidation requests, such as `PURGE` requests, allowing specific URIs to be removed from the cache.", correct: true }
      - { value: "It automatically invalidates all cache entries when the application is deployed.", correct: false }
      - { value: "It is used to mark a response as stale, forcing revalidation.", correct: false }
      - { value: "It is an internal method that should not be overridden.", correct: false }
    help: |
      Overriding `invalidate` allows implementing custom cache invalidation strategies, like handling `PURGE` requests.
      https://symfony.com/doc/current/http_cache/cache_invalidation.html#custom-cache-invalidation

  -
    question: >
      Which of the following is a correct way to make a Symfony `Response` publicly cacheable?
    answers:
      - { value: "$response->setPublic();", correct: true }
      - { value: "$response->setCache(['public' => true]);", correct: true }
      - { value: "$response->headers->set('Cache-Control', 'public');", correct: true }
      - { value: "$response->setPrivate(false);", correct: false }
    help: |
      The `setPublic()` method, the `public` option in `setCache()`, or directly setting the `Cache-Control` header are all valid ways to mark a response as public.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What is the purpose of the `setClientTtl()` method on a Symfony `Response` object?
    answers:
      - { value: "It sets the `max-age` directive of the `Cache-Control` header, specifically for client-side (private) caches.", correct: true }
      - { value: "It sets the `s-maxage` directive for shared caches.", correct: false }
      - { value: "It defines the total time the response should be cached by any cache.", correct: false }
      - { value: "It forces the client to revalidate the response after the specified time.", correct: false }
    help: |
      `setClientTtl()` is an alias for `setMaxAge()`, which controls the `max-age` directive.
      https://symfony.com/doc/current/components/http_foundation.html#response-cache-headers

  -
    question: >
      What is the typical HTTP status code returned by a server when a client's cached resource is still valid based on `ETag` or `Last-Modified` validation?
    answers:
      - { value: "304 Not Modified", correct: true }
      - { value: "200 OK", correct: false }
      - { value: "204 No Content", correct: false }
      - { value: "404 Not Found", correct: false }
    help: |
      A 304 Not Modified response indicates that the client's cached version is still fresh, avoiding unnecessary data transfer.
      https://symfony.com/doc/current/http_cache/validation.html#checking-freshness-with-isnotmodified

  -
    question: >
      Which of the following is true about the `Expires` header?
    answers:
      - { value: "It specifies an absolute date and time after which the response is considered stale.", correct: true }
      - { value: "It is relative to the time of the request.", correct: false }
      - { value: "It takes precedence over the `Cache-Control` header.", correct: false }
      - { value: "It is typically used for validation caching.", correct: false }
    help: |
      The `Expires` header defines a fixed point in time for expiration.
      https://symfony.com/doc/current/http_cache/expiration.html#the-expires-header

  -
    question: >
      What is the main role of the `Vary` header in preventing incorrect cache hits?
    answers:
      - { value: "It ensures that a cache stores different versions of a resource if certain request headers differ, preventing one client's cached content from being served to another client with different capabilities or preferences.", correct: true }
      - { value: "It forces the cache to revalidate the resource on every request.", correct: false }
      - { value: "It specifies that the resource should never be cached.", correct: false }
      - { value: "It indicates that the resource content is encrypted and cannot be varied.", correct: false }
    help: |
      The `Vary` header is crucial for ensuring that caches serve the correct representation of a resource based on request headers like `Accept-Encoding` or `User-Agent`.
      https://symfony.com/doc/current/http_cache/cache_vary.html