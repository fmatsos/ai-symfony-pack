category: HTTP Caching

questions:
  -
    question: >
      What is the primary role of Symfony's built-in `HttpCache`?
    answers:
      - { value: "To act as a reverse proxy, caching responses and serving them to clients.", correct: true }
      - { value: "To manage database query caching for Doctrine entities.", correct: false }
      - { value: "To provide a client-side JavaScript caching mechanism.", correct: false }
      - { value: "To handle session storage and invalidation.", correct: false }
    help: |
      Symfony's `HttpCache` component acts as a reverse proxy, sitting in front of your application to cache responses and improve performance.
      https://symfony.com/doc/current/http_cache.html

  -
    question: |
      How can you set a response to be publicly cacheable for 600 seconds using a Symfony attribute on a controller method?

      ```php
      namespace App\Controller;

      use Symfony\Component\HttpFoundation\Response;
      use Symfony\Component\HttpKernel\Attribute\Cache;

      class MyController
      {
          /* ??? */
          public function index(): Response
          {
              return new Response('Hello Cache!');
          }
      }
      ```
    answers:
      - { value: "`#[Cache(public: true, maxage: 600)]`", correct: true }
      - { value: "`#[Cache(private: false, ttl: 600)]`", correct: false }
      - { value: "`#[Cache(shared: true, expires: '+600 seconds')]`", correct: false }
      - { value: "`#[Cache(cacheable: true, duration: 600)]`", correct: false }
    help: |
      The `#[Cache]` attribute allows declarative configuration of HTTP cache headers directly on controller methods. `public: true` makes it cacheable by shared caches, and `maxage` sets the freshness lifetime.
      https://symfony.com/doc/current/http_cache/expiration.html#configuring-cache-control-with-the-cache-attribute

  -
    question: >
      Which `Response` methods would you use to make a response publicly cacheable for 3600 seconds and enforce revalidation by setting `must-revalidate`?
    answers:
      - { value: "`$response->setPublic(); $response->setMaxAge(3600); $response->headers->addCacheControlDirective('must-revalidate', true);`", correct: true }
      - { value: "`$response->setPrivate(); $response->setTtl(3600); $response->setRevalidate(true);`", correct: false }
      - { value: "`$response->setSharedMaxAge(3600); $response->setExpires('+3600 seconds');`", correct: false }
      - { value: "`$response->setCache(['public' => true, 'max_age' => 3600, 'must_revalidate' => true]);`", correct: true }
    help: |
      The `setPublic()` method sets the `Cache-Control: public` directive. `setMaxAge()` sets `max-age`. The `must-revalidate` directive can be added via `headers->addCacheControlDirective()`. Alternatively, `setCache()` can set multiple directives at once.
      https://symfony.com/doc/current/http_cache/expiration.html#configuring-cache-control-programmatically
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      What is the purpose of the `ETag` header in HTTP caching?
    answers:
      - { value: "To specify the maximum age a resource can be stored in a cache.", correct: false }
      - { value: "To provide a unique identifier for a specific version of a resource, used for validation.", correct: true }
      - { value: "To indicate the date and time after which the response is considered stale.", correct: false }
      - { value: "To define the content type of the response.", correct: false }
    help: |
      The `ETag` (Entity Tag) is an opaque identifier assigned by a web server to a specific version of a resource found at a URL. If the resource content changes, a new `ETag` is generated. It's used for cache validation with the `If-None-Match` request header.
      https://symfony.com/doc/current/http_cache/validation.html#etag

  -
    question: >
      Which HTTP header is typically used by a client with `If-Modified-Since` for cache validation based on time?
    answers:
      - { value: "`Expires`", correct: false }
      - { value: "`Cache-Control`", correct: false }
      - { value: "`Last-Modified`", correct: true }
      - { value: "`Date`", correct: false }
    help: |
      The `Last-Modified` response header indicates the date and time the origin server believes the resource was last modified. Clients can send an `If-Modified-Since` request header with this date to ask the server if the resource has changed.
      https://symfony.com/doc/current/http_cache/validation.html#last-modified

  -
    question: >
      When a browser receives a response with a `Cache-Control: max-age=3600` header, what does it typically do?
    answers:
      - { value: "It will always re-request the resource from the server after 3600 seconds.", correct: false }
      - { value: "It will store the response and consider it fresh for up to 3600 seconds without revalidating.", correct: true }
      - { value: "It will send a `PURGE` request to the server after 3600 seconds.", correct: false }
      - { value: "It will ignore the cache directive and always fetch fresh content.", correct: false }
    help: |
      The `max-age` directive specifies the maximum amount of time a resource is considered fresh. Browsers will typically serve the cached response without revalidation until this time expires.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age

  -
    question: |
      How do you enable Symfony's built-in HTTP cache reverse proxy in `framework.yaml` specifically for the `prod` environment?
    answers:
      - { value: "```yaml\nwhen@prod:\n    framework:\n        http_cache: true\n```", correct: true }
      - { value: "```yaml\nframework:\n    http_cache:\n        enabled: true\n```", correct: false }
      - { value: "```yaml\nprod:\n    framework:\n        cache_proxy: true\n```", correct: false }
      - { value: "```yaml\nhttp_cache:\n    enabled_environments: [prod]\n```", correct: false }
    help: |
      The `http_cache: true` option under the `framework` configuration enables the built-in HTTP cache reverse proxy. It's typically enabled only for production environments using `when@prod:`.
      https://symfony.com/doc/current/http_cache.html#enabling-the-symfony-reverse-proxy

  -
    question: >
      Which Symfony component allows you to cache responses from an external HTTP client, such as when making requests to an API?
    answers:
      - { value: "`Symfony\\Component\\Cache`", correct: false }
      - { value: "`Symfony\\Component\\HttpClient\\CachingHttpClient`", correct: true }
      - { value: "`Symfony\\Component\\HttpFoundation\\ResponseCache`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\HttpCache`", correct: false }
    help: |
      `CachingHttpClient` decorates an existing HTTP client and adds caching capabilities, storing responses in a specified `Store`.
      https://symfony.com/doc/current/http_client.html#caching-responses

  -
    question: >
      What HTML tag is used to mark a region of a page for Edge Side Includes (ESI) processing, allowing it to be fetched via a sub-request?
    answers:
      - { value: "`<esi:include src=\"/path/to/resource\"/>`", correct: true }
      - { value: "`<cache:fragment url=\"/path/to/resource\"/>`", correct: false }
      - { value: "`<symfony:esi path=\"/path/to/resource\"/>`", correct: false }
      - { value: "`<http:cache-include href=\"/path/to/resource\"/>`", correct: false }
    help: |
      The `<esi:include>` tag is the standard way to embed ESI fragments within an HTML document.
      https://symfony.com/doc/current/http_cache/esi.html#embedding-esi-in-html

  -
    question: |
      How do you enable ESI support when initializing Symfony's `HttpCache` programmatically in your front controller?
    answers:
      - { value: "By passing an instance of `HttpKernel\\HttpCache\\Esi` as the third argument to the `HttpCache` constructor.", correct: true }
      - { value: "By calling `$httpCache->enableEsi()` after instantiation.", correct: false }
      - { value: "By setting a `esi_enabled: true` option in the `HttpCache` constructor array.", correct: false }
      - { value: "ESI is enabled by default and requires no explicit configuration.", correct: false }
    help: |
      To enable ESI, you need to pass an instance of `HttpKernel\\HttpCache\\Esi` to the `HttpCache` constructor.
      https://symfony.com/doc/current/http_cache/esi.html#enabling-esi

  -
    question: |
      How can you set the `Expires` header for a response to be 600 seconds from now using the `#[Cache]` attribute?
    answers:
      - { value: "`#[Cache(expires: '+600 seconds')]`", correct: true }
      - { value: "`#[Cache(maxage: 600)]`", correct: false }
      - { value: "`#[Cache(ttl: 600)]`", correct: false }
      - { value: "`#[Cache(expiration_date: 'now + 600 seconds')]`", correct: false }
    help: |
      The `expires` option in the `#[Cache]` attribute accepts a string that can be parsed by `DateTime` to set the `Expires` header.
      https://symfony.com/doc/current/http_cache/expiration.html#expires-header

  -
    question: >
      What does calling `$response->expire()` do to an HTTP response?
    answers:
      - { value: "It sets the `Cache-Control` header to `no-cache, no-store`.", correct: false }
      - { value: "It forces caches to revalidate the content with the origin server before serving it again.", correct: true }
      - { value: "It immediately removes the response from all caches.", correct: false }
      - { value: "It sets the `Expires` header to a past date, making the response immediately stale.", correct: true }
    help: |
      The `expire()` method marks the response as stale, forcing caches to revalidate. It sets the `Expires` header to a past date and `Cache-Control` to `no-cache, must-revalidate`.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      What is the primary benefit of using `$response->isNotModified($request)` in a Symfony controller?
    answers:
      - { value: "It automatically generates `ETag` and `Last-Modified` headers for the response.", correct: false }
      - { value: "It prevents the client from caching the response.", correct: false }
      - { value: "It allows the application to short-circuit processing and return a 304 Not Modified response if the client's cached version is still valid.", correct: true }
      - { value: "It forces the client to always re-download the full content.", correct: false }
    help: |
      `isNotModified()` checks the request's `If-None-Match` and `If-Modified-Since` headers against the response's `ETag` and `Last-Modified` headers. If they match, it sets the response status to 304, avoiding unnecessary content generation and transfer.
      https://symfony.com/doc/current/http_cache/validation.html#checking-if-a-response-is-not-modified

  -
    question: |
      How do you set a weak ETag for a Symfony `Response` object?
    answers:
      - { value: "`$response->setEtag('my-etag-value', true);`", correct: true }
      - { value: "`$response->setEtag('W/\"my-etag-value\"');`", correct: false }
      - { value: "`$response->setWeakEtag('my-etag-value');`", correct: false }
      - { value: "`$response->headers->set('ETag', 'W/\"my-etag-value\"');`", correct: false }
    help: |
      The `setEtag()` method has an optional second boolean argument to specify if the ETag should be weak.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      What HTTP method is commonly used by reverse proxies like Varnish to explicitly remove a resource from their cache?
    answers:
      - { value: "DELETE", correct: false }
      - { value: "PURGE", correct: true }
      - { value: "FLUSH", correct: false }
      - { value: "INVALIDATE", correct: false }
    help: |
      While not a standard HTTP method, `PURGE` is a widely adopted convention by caching proxies like Varnish for explicit cache invalidation. Symfony's `HttpCache` can be configured to handle `PURGE` requests.
      https://symfony.com/doc/current/http_cache/cache_invalidation.html#invalidation

  -
    question: >
      When Symfony's `HttpCache` debug mode is enabled, which HTTP header provides information about the cache status (e.g., `fresh`, `stale`, `miss`)?
    answers:
      - { value: "`X-Cache-Status`", correct: false }
      - { value: "`X-Debug-Cache`", correct: false }
      - { value: "`X-Symfony-Cache`", correct: true }
      - { value: "`Cache-Debug`", correct: false }
    help: |
      The `X-Symfony-Cache` header is added to responses when `HttpCache` debug mode is active, providing insights into how the cache handled the request.
      https://symfony.com/doc/current/http_cache.html#debugging-the-cache

  -
    question: |
      How can you prevent Symfony from automatically making a response uncacheable when a user session is active?
    answers:
      - { value: "By setting the `AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER` to `'true'` on the response headers.", correct: true }
      - { value: "By calling `$response->setPublic()` after the session is started.", correct: false }
      - { value: "By configuring `session.auto_cache_control: false` in `framework.yaml`.", correct: false }
      - { value: "This behavior cannot be overridden; responses with active sessions are always private.", correct: false }
    help: |
      Symfony's `AbstractSessionListener` automatically adds cache-busting headers if a session is active. You can override this by setting the `NO_AUTO_CACHE_CONTROL_HEADER` on the response headers.
      https://symfony.com/doc/current/http_cache.html#avoiding-automatic-cache-busting

  -
    question: >
      What is the purpose of the `Vary` HTTP header?
    answers:
      - { value: "To indicate that the cached response should be different based on specific request headers.", correct: true }
      - { value: "To specify alternative URLs for a resource.", correct: false }
      - { value: "To define the character encoding of the response content.", correct: false }
      - { value: "To instruct the client to revalidate the cache after a certain period.", correct: false }
    help: |
      The `Vary` header informs caches that the response content varies based on the values of one or more specified request headers (e.g., `Accept-Encoding`, `User-Agent`).
      https://symfony.com/doc/current/http_cache/cache_vary.html

  -
    question: |
      How can you configure a Symfony controller action to vary its cached response based on the `Accept-Encoding` header using an attribute?
    answers:
      - { value: "`#[Cache(vary: ['Accept-Encoding'])]`", correct: true }
      - { value: "`#[Cache(headers: ['Accept-Encoding'])]`", correct: false }
      - { value: "`#[Cache(dependentOn: 'Accept-Encoding')]`", correct: false }
      - { value: "`#[Cache(vary_by_header: 'Accept-Encoding')]`", correct: false }
    help: |
      The `vary` option in the `#[Cache]` attribute accepts an array of header names that should influence the caching key.
      https://symfony.com/doc/current/http_cache/cache_vary.html#configuring-the-vary-header-with-the-cache-attribute

  -
    question: |
      How do you programmatically set the `Vary` header on a Symfony `Response` object to include `Accept-Encoding` and `User-Agent`?
    answers:
      - { value: "`$response->setVary(['Accept-Encoding', 'User-Agent']);`", correct: true }
      - { value: "`$response->headers->set('Vary', 'Accept-Encoding, User-Agent');`", correct: true }
      - { value: "`$response->addVaryHeader('Accept-Encoding', 'User-Agent');`", correct: false }
      - { value: "`$response->setVary('Accept-Encoding'); $response->setVary('User-Agent');`", correct: false }
    help: |
      The `setVary()` method accepts either a string or an array of header names. You can also directly set the header via `headers->set()`.
      https://symfony.com/doc/current/http_cache/cache_vary.html#configuring-the-vary-header-programmatically

  -
    question: >
      What is the main purpose of `Symfony\\Component\\Config\\ConfigCache`?
    answers:
      - { value: "To cache database queries for faster retrieval.", correct: false }
      - { value: "To manage cached files based on the freshness of their source configuration resources.", correct: true }
      - { value: "To store user session data in a persistent way.", correct: false }
      - { value: "To provide a simple key-value store for application data.", correct: false }
    help: |
      `ConfigCache` is designed to manage cached files that are generated from configuration resources (e.g., YAML files). It ensures the cached file is regenerated only when its source resources are modified.
      https://symfony.com/doc/current/components/config/caching.html

  -
    question: >
      When using `ConfigCache`, what is the purpose of setting the `debug` argument to `true` in the constructor?
    answers:
      - { value: "It enables verbose logging of cache operations to the console.", correct: false }
      - { value: "It creates a `.meta` file containing serialized resources for freshness checks, allowing the cache to be invalidated if resources change.", correct: true }
      - { value: "It prevents the cache from being written to disk, forcing regeneration on every request.", correct: false }
      - { value: "It automatically clears the cache on every application restart.", correct: false }
    help: |
      In debug mode, `ConfigCache` creates a `.meta` file to track the resources used to generate the cache. This allows `isFresh()` to accurately determine if the cache needs to be regenerated based on resource modifications.
      https://symfony.com/doc/current/components/config/caching.html#basic-usage

  -
    question: >
      Which Symfony component provides a cache adapter for storing cached data directly on the filesystem?
    answers:
      - { value: "`Symfony\\Component\\Cache\\Adapter\\RedisAdapter`", correct: false }
      - { value: "`Symfony\\Component\\Cache\\Adapter\\MemcachedAdapter`", correct: false }
      - { value: "`Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter`", correct: true }
      - { value: "`Symfony\\Component\\Cache\\Adapter\\PdoAdapter`", correct: false }
    help: |
      The `FilesystemAdapter` is a concrete implementation of a cache adapter that stores cache items as files on the local filesystem.
      https://symfony.com/doc/current/components/cache/adapters/filesystem_adapter.html

  -
    question: >
      What is the purpose of the `$beta` parameter when using `CacheInterface::get()` in Symfony's Cache component?
    answers:
      - { value: "It defines the cache item's priority for garbage collection.", correct: false }
      - { value: "It enables probabilistic early expiration to prevent cache stampedes by recomputing values before they fully expire.", correct: true }
      - { value: "It specifies the maximum number of times a cache item can be accessed before being invalidated.", correct: false }
      - { value: "It sets a multiplier for the cache item's expiration time.", correct: false }
    help: |
      The `beta` parameter enables probabilistic early expiration, a technique to recompute cache values ahead of their expiration. This helps prevent CPU spikes when the cache is cold by serving stale data to some users while recomputing for others.
      https://symfony.com/doc/current/components/cache.html#probabilistic-early-expiration-cache-stampede-prevention

  -
    question: >
      What does the `Response::setTtl(10)` method do?
    answers:
      - { value: "It sets the `max-age` directive of the `Cache-Control` header to 10 seconds.", correct: false }
      - { value: "It sets the `s-maxage` directive of the `Cache-Control` header to 10 seconds.", correct: false }
      - { value: "It sets the Time-To-Live (TTL) for the response, which is converted to `max-age` and `s-maxage`.", correct: true }
      - { value: "It sets the `Expires` header to 10 seconds from now.", correct: false }
    help: |
      The `setTtl()` method sets the Time-To-Live for the response, which is then used to calculate and set both `max-age` and `s-maxage` directives in the `Cache-Control` header.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      To implement custom cache invalidation logic (e.g., handling PURGE requests) with Symfony's built-in HTTP cache, which class should you extend?
    answers:
      - { value: "`Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache`", correct: false }
      - { value: "`Symfony\\Bundle\\FrameworkBundle\\HttpCache\\HttpCache`", correct: true }
      - { value: "`Symfony\\Component\\HttpKernel\\CacheKernel`", correct: false }
      - { value: "`Symfony\\Component\\HttpFoundation\\ResponseCache`", correct: false }
    help: |
      You should extend `Symfony\\Bundle\\FrameworkBundle\\HttpCache\\HttpCache` (or `App\\CacheKernel` if you've generated it) and override the `invalidate()` method to handle custom invalidation logic like PURGE requests.
      https://symfony.com/doc/current/http_cache/cache_invalidation.html#invalidation

  -
    question: >
      Which `Response` method allows you to set multiple HTTP cache-related headers (like `max_age`, `public`, `etag`) in a single call using an associative array?
    answers:
      - { value: "`$response->setHeaders(['Cache-Control' => 'public, max-age=600']);`", correct: false }
      - { value: "`$response->configureCache(['max_age' => 600, 'public' => true]);`", correct: false }
      - { value: "`$response->setCache(['max_age' => 600, 'public' => true, 'etag' => 'abcdef']);`", correct: true }
      - { value: "`$response->addCacheDirectives(['max_age' => 600]);`", correct: false }
    help: |
      The `setCache()` method provides a convenient way to set multiple cache-related headers at once using an array of options.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      Which `Response` method forces the response to return a 304 Not Modified status code with no content?
    answers:
      - { value: "`$response->setStatusCode(304);`", correct: false }
      - { value: "`$response->setNotModified();`", correct: true }
      - { value: "`$response->setEmpty();`", correct: false }
      - { value: "`$response->setNoContent();`", correct: false }
    help: |
      The `setNotModified()` method automatically sets the response status code to 304 and removes content and certain headers, signaling to the client that its cached version is still valid.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      What is a key difference between a browser cache and a reverse proxy cache?
    answers:
      - { value: "Browser caches are only for static files, while reverse proxies cache dynamic content.", correct: false }
      - { value: "Browser caches are private to a single user, while reverse proxy caches are shared among multiple users.", correct: true }
      - { value: "Browser caches are always enabled, while reverse proxy caches must be manually configured.", correct: false }
      - { value: "Browser caches only store responses from HTTPS, while reverse proxies only cache HTTP.", correct: false }
    help: |
      Browser caches are client-side and store responses for a single user. Reverse proxy caches (like Symfony's HttpCache or Varnish) sit in front of the server and serve cached responses to multiple clients, making them shared caches.
      https://symfony.com/doc/current/http_cache.html#http-cache-types

  -
    question: >
      What does the `Cache-Control: no-store` directive instruct caches to do?
    answers:
      - { value: "To revalidate the cached entry before serving it.", correct: false }
      - { value: "To store the response but not serve it without revalidation.", correct: false }
      - { value: "To not store any part of either the request or response in any cache.", correct: true }
      - { value: "To store the response only for a very short period.", correct: false }
    help: |
      The `no-store` directive explicitly forbids any cache from storing any part of the client's request or the server's response.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-store

  -
    question: >
      What does the `Cache-Control: no-cache` directive instruct caches to do?
    answers:
      - { value: "To never store the response.", correct: false }
      - { value: "To store the response but always revalidate it with the origin server before serving it.", correct: true }
      - { value: "To store the response only if it's a static file.", correct: false }
      - { value: "To ignore all other cache directives.", correct: false }
    help: |
      Despite its name, `no-cache` does not mean "do not cache". It means "cache, but revalidate before serving". The cache must send a request to the origin server to check if the cached response is still fresh.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-cache

  -
    question: >
      When generating an ETag, what is a common practice to ensure it changes when the content changes?
    answers:
      - { value: "Using a random string for each request.", correct: false }
      - { value: "Hashing the response content (e.g., MD5 or SHA1) or a unique identifier derived from the content.", correct: true }
      - { value: "Setting the ETag to the current timestamp.", correct: false }
      - { value: "Using a fixed string for all versions of the resource.", correct: false }
    help: |
      A common and effective way to generate an ETag is to create a hash (like MD5 or SHA1) of the response content. This ensures that if even a single byte of the content changes, the ETag will be different, signaling to caches that the resource has been modified.
      https://symfony.com/doc/current/http_cache/validation.html#etag

  -
    question: >
      How does ESI typically work in terms of HTTP requests when a page contains an `<esi:include>` tag?
    answers:
      - { value: "The browser makes a separate AJAX request for each ESI include.", correct: false }
      - { value: "The server-side ESI processor (e.g., Symfony's HttpCache or Varnish) makes a sub-request to fetch the content of the ESI include before sending the full page to the client.", correct: true }
      - { value: "The ESI include is replaced with a JavaScript snippet that dynamically loads the content.", correct: false }
      - { value: "The ESI include is ignored by default and only processed if JavaScript is enabled.", correct: false }
    help: |
      When a reverse proxy (like Symfony's HttpCache with ESI enabled) encounters an `<esi:include>` tag, it makes an internal sub-request to the specified URL, fetches the content, and then embeds it into the main response before sending it to the client.
      https://symfony.com/doc/current/http_cache/esi.html

  -
    question: >
      What is the `s-maxage` directive in `Cache-Control` specifically used for?
    answers:
      - { value: "The maximum age a resource can be stored in a private browser cache.", correct: false }
      - { value: "The maximum age a resource can be stored in a shared cache (e.g., a reverse proxy).", correct: true }
      - { value: "The minimum age a resource must be stored before revalidation.", correct: false }
      - { value: "The age after which the resource must be revalidated by the client.", correct: false }
    help: |
      `s-maxage` (shared-maxage) applies only to shared caches (like proxies). It overrides `max-age` for shared caches, allowing different caching durations for private and shared caches.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage

  -
    question: >
      What does the `immutable` directive in `Cache-Control` indicate?
    answers:
      - { value: "That the response content cannot be compressed.", correct: false }
      - { value: "That the response will not change over time and can be cached indefinitely without revalidation.", correct: true }
      - { value: "That the response must be revalidated on every request.", correct: false }
      - { value: "That the response is private and should not be stored by shared caches.", correct: false }
    help: |
      The `immutable` directive indicates that the response will not change over time. This allows caches to serve the response from their storage without revalidation for the duration of its freshness lifetime, even if the user navigates away and then returns.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#immutable

  -
    question: >
      If you are using an external reverse proxy like Varnish, how would you typically invalidate a specific cached URL from your Symfony application?
    answers:
      - { value: "By sending a standard `GET` request with a `Cache-Control: no-cache` header.", correct: false }
      - { value: "By calling `$response->expire()` on the response object.", correct: false }
      - { value: "By sending a custom HTTP method, such as `PURGE`, to the Varnish server for the specific URL.", correct: true }
      - { value: "By clearing the entire Symfony cache directory.", correct: false }
    help: |
      External reverse proxies like Varnish often support custom HTTP methods (like `PURGE`) or specific API endpoints for targeted cache invalidation.
      https://symfony.com/doc/current/http_cache/cache_invalidation.html#invalidation

  -
    question: >
      When using `CachingHttpClient`, what is required to store the cached responses?
    answers:
      - { value: "A database connection configured for caching.", correct: false }
      - { value: "An instance of `Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter`.", correct: false }
      - { value: "An instance of `Symfony\\Component\\HttpKernel\\HttpCache\\Store`.", correct: true }
      - { value: "The `cache.app` service from the Symfony container.", correct: false }
    help: |
      `CachingHttpClient` requires a `Store` implementation (e.g., `HttpKernel\\HttpCache\\Store`) to manage the actual storage of cached HTTP responses.
      https://symfony.com/doc/current/http_client.html#caching-responses

  -
    question: >
      In Symfony's `framework.yaml` under `http_cache`, what does the `default_ttl` option configure?
    answers:
      - { value: "The maximum age for client-side browser caches.", correct: false }
      - { value: "The default time-to-live (in seconds) for cache entries when no explicit freshness information is provided in a response.", correct: true }
      - { value: "The duration for which ESI includes are cached.", correct: false }
      - { value: "The time after which the entire HTTP cache is cleared.", correct: false }
    help: |
      `default_ttl` sets a fallback cache lifetime for responses that do not explicitly define their own freshness information via `Expires` or `Cache-Control` headers.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      Which configuration option under `framework.http_cache` defines request headers that trigger "private" cache-control behavior on responses that don't explicitly state whether the response is public or private?
    answers:
      - { value: "`public_headers`", correct: false }
      - { value: "`private_headers`", correct: true }
      - { value: "`sensitive_headers`", correct: false }
      - { value: "`session_headers`", correct: false }
    help: |
      The `private_headers` option lists request headers (like `Authorization` or `Cookie`) that, if present, will cause a response to be considered private by default, even if no explicit `Cache-Control` directive is set.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      Which configuration option under `framework.http_cache` defines response headers that will never be cached, even when the response is otherwise cacheable and public?
    answers:
      - { value: "`exclude_headers`", correct: false }
      - { value: "`no_cache_headers`", correct: false }
      - { value: "`skip_response_headers`", correct: true }
      - { value: "`uncacheable_headers`", correct: false }
    help: |
      The `skip_response_headers` option allows you to specify a list of response headers (e.g., `Set-Cookie`) that should always be excluded from caching, regardless of other cache directives.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: |
      How do you enable tag-aware caching for a Symfony cache pool in `config/packages/cache.yaml`?
    answers:
      - { value: "```yaml\nframework:\n    cache:\n        pools:\n            my_cache_pool:\n                adapter: cache.adapter.redis\n                tags_enabled: true\n```", correct: false }
      - { value: "```yaml\nframework:\n    cache:\n        pools:\n            my_cache_pool:\n                adapter: cache.adapter.redis_tag_aware\n                tags: true\n```", correct: true }
      - { value: "```yaml\nframework:\n    cache:\n        pools:\n            my_cache_pool:\n                tag_support: true\n```", correct: false }
      - { value: "```yaml\nframework:\n    cache:\n        pools:\n            my_cache_pool:\n                tag_adapter: redis\n```", correct: false }
    help: |
      To enable tag-aware caching, you need to use a tag-aware adapter (like `cache.adapter.redis_tag_aware`) and set the `tags` option to `true` for the specific cache pool.
      https://symfony.com/doc/current/cache.html#tag-aware-caching

  -
    question: >
      What is the primary benefit of using `TagAwareMarshaller` with a cache adapter like `RedisAdapter`?
    answers:
      - { value: "It encrypts cache data for security.", correct: false }
      - { value: "It allows efficient invalidation of multiple related cache items by purging them based on associated tags.", correct: true }
      - { value: "It automatically compresses cache data to save space.", correct: false }
      - { value: "It converts cache keys to a standardized format.", correct: false }
    help: |
      `TagAwareMarshaller` is crucial for implementing tag-based caching. It allows you to associate tags with cache items, enabling you to invalidate groups of related items efficiently by purging specific tags.
      https://symfony.com/doc/current/components/cache/adapters/redis_adapter.html#tag-aware-marshaller

  -
    question: |
      How can you implement cache versioning for specific user data using `withSubNamespace()` in Symfony's Cache component, ensuring the cache is invalidated when the user's `updatedAt` timestamp changes?
    answers:
      - { value: "`$userCache = $cache->withSubNamespace(sprintf('user-%d-%s', $user->getId(), $user->getUpdatedAt()->getTimestamp()));`", correct: false }
      - { value: "`$userCache = $cache->withSubNamespace(sprintf('user-%d-%s', $user->getId(), hash('xxh128', $user->getUpdatedAt()->format(DATE_ATOM))));`", correct: true }
      - { value: "`$userCache = $cache->withVersion(sprintf('user-%d-%s', $user->getId(), $user->getUpdatedAt()->format('YmdHis')));`", correct: false }
      - { value: "`$userCache = $cache->forUser($user->getId())->version($user->getUpdatedAt()->format(DATE_ATOM));`", correct: false }
    help: |
      Using a hash of the `updatedAt` timestamp in the sub-namespace ensures that the cache key changes whenever the user data is updated, effectively invalidating the old cache entry.
      https://symfony.com/doc/current/components/cache.html#cache-versioning

  -
    question: >
      Which technique helps prevent CPU spikes when a cache entry expires and multiple requests try to recompute the value simultaneously?
    answers:
      - { value: "Aggressive `max-age` settings.", correct: false }
      - { value: "Using a distributed cache system.", correct: false }
      - { value: "Probabilistic early expiration (using the `beta` parameter).", correct: true }
      - { value: "Disabling caching entirely during peak hours.", correct: false }
    help: |
      Probabilistic early expiration, enabled by the `beta` parameter in `CacheInterface::get()`, allows a small percentage of requests to recompute a cache value before it fully expires, preventing a "thundering herd" problem when the cache goes cold.
      https://symfony.com/doc/current/components/cache.html#probabilistic-early-expiration-cache-stampede-prevention

  -
    question: >
      What is the purpose of the `trace_header` option under `framework.http_cache`?
    answers:
      - { value: "To specify a custom header for tracking cache hits/misses in external monitoring tools.", correct: false }
      - { value: "To define the name of the HTTP header used by Symfony's HttpCache to provide debugging information.", correct: true }
      - { value: "To enable tracing of all HTTP requests through the cache layer.", correct: false }
      - { value: "To configure the header used for ESI sub-request identification.", correct: false }
    help: |
      The `trace_header` option allows you to customize the name of the `X-Symfony-Cache` header, which provides debugging details about the HttpCache's behavior.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `allow_reload` option under `framework.http_cache` control?
    answers:
      - { value: "Whether the cache can be reloaded from a backup.", correct: false }
      - { value: "Whether the client can force a cache reload by including a `Cache-Control: no-cache` directive in the request.", correct: true }
      - { value: "Whether the server can automatically reload stale cache entries.", correct: false }
      - { value: "Whether the cache can be reloaded without restarting the application.", correct: false }
    help: |
      `allow_reload` determines if the Symfony HttpCache should respect a client's `Cache-Control: no-cache` directive, which requests a fresh response from the origin server.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `allow_revalidate` option under `framework.http_cache` control?
    answers:
      - { value: "Whether the cache can revalidate entries automatically in the background.", correct: false }
      - { value: "Whether the client can force a cache revalidation by including a `Cache-Control: max-age=0` directive in the request.", correct: true }
      - { value: "Whether the server can revalidate its internal cache.", correct: false }
      - { value: "Whether the cache should always revalidate before serving a response.", correct: false }
    help: |
      `allow_revalidate` specifies if the Symfony HttpCache should honor a client's `Cache-Control: max-age=0` directive, which requests revalidation of the cached response.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What does the `stale-if-error` directive in `Cache-Control` (or corresponding Symfony config) allow a cache to do?
    answers:
      - { value: "To serve a stale response if the origin server returns an error, for a specified duration.", correct: true }
      - { value: "To revalidate the cache entry immediately if an error occurs.", correct: false }
      - { value: "To store error pages in the cache for a longer period.", correct: false }
      - { value: "To always serve fresh content, even if errors occur.", correct: false }
    help: |
      `stale-if-error` allows a cache to serve a stale response when the origin server encounters an error or is unreachable, improving user experience during outages. The specified duration indicates how long the stale response can be served.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error

  -
    question: >
      What does the `stale-while-revalidate` directive in `Cache-Control` (or corresponding Symfony config) allow a cache to do?
    answers:
      - { value: "To serve a stale response immediately while it revalidates the content in the background.", correct: true }
      - { value: "To always revalidate the cache entry before serving it.", correct: false }
      - { value: "To store responses that are currently being revalidated.", correct: false }
      - { value: "To prevent revalidation if the response is stale.", correct: false }
    help: |
      `stale-while-revalidate` allows a cache to immediately serve a stale response to the client while it asynchronously revalidates the content with the origin server. This improves perceived performance.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate

  -
    question: >
      What is the purpose of the `Response::setClientTtl()` method?
    answers:
      - { value: "It sets the `max-age` directive for shared caches only.", correct: false }
      - { value: "It sets the `max-age` directive for private (client-side) caches only.", correct: true }
      - { value: "It sets the `Expires` header for the response.", correct: false }
      - { value: "It forces the client to revalidate the cache after a specific time.", correct: false }
    help: |
      The `setClientTtl()` method specifically sets the `max-age` directive, which primarily affects private (browser) caches. It's distinct from `setTtl()` which sets both `max-age` and `s-maxage`.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      Which of the following `Cache-Control` directives indicates that a response is intended for a single user and must not be stored by a shared cache?
    answers:
      - { value: "`public`", correct: false }
      - { value: "`private`", correct: true }
      - { value: "`no-store`", correct: false }
      - { value: "`must-revalidate`", correct: false }
    help: |
      The `private` directive indicates that the response is intended for a single user and should not be stored by shared caches. It can be cached by a private browser cache.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#private

  -
    question: >
      When configuring HTTP caching, what is the main difference between `Expires` and `Cache-Control: max-age`?
    answers:
      - { value: "`Expires` is for private caches, `max-age` is for shared caches.", correct: false }
      - { value: "`Expires` uses an absolute date, `max-age` uses a relative time in seconds.", correct: true }
      - { value: "`Expires` is preferred for modern applications, `max-age` is deprecated.", correct: false }
      - { value: "They are interchangeable and serve the exact same purpose.", correct: false }
    help: |
      `Expires` specifies an absolute date and time after which the response is considered stale. `max-age` specifies a relative time in seconds from the time of the request, after which the response is considered stale. `max-age` is generally preferred as it is less susceptible to clock skew issues.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age

  -
    question: >
      What is the primary reason to use Edge Side Includes (ESI) in a Symfony application?
    answers:
      - { value: "To allow client-side JavaScript to dynamically load content.", correct: false }
      - { value: "To enable granular caching of different parts of a web page, allowing some sections to be dynamic while others are heavily cached.", correct: true }
      - { value: "To reduce the number of HTTP requests made by the browser.", correct: false }
      - { value: "To provide a fallback mechanism when a page fails to load.", correct: false }
    help: |
      ESI allows you to mark specific sections of a page as independently cacheable. This means a reverse proxy can cache the main page for a long time, while dynamic sections (e.g., a personalized greeting) are fetched via separate sub-requests and cached for shorter durations or not at all.
      https://symfony.com/doc/current/http_cache/esi.html

  -
    question: >
      Consider a Symfony application using `HttpCache` as a reverse proxy. If a response has `Cache-Control: public, max-age=0, must-revalidate`, what will the `HttpCache` typically do on subsequent requests for the same resource?
    answers:
      - { value: "Serve the cached response directly without revalidation.", correct: false }
      - { value: "Always forward the request to the backend application to generate a fresh response.", correct: false }
      - { value: "Revalidate the cached response with the backend application before serving it.", correct: true }
      - { value: "Remove the item from its cache immediately.", correct: false }
    help: |
      `max-age=0` means the response is immediately stale, and `must-revalidate` forces the cache to check with the origin server before serving it. Thus, the `HttpCache` will revalidate.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age

  -
    question: >
      Which of the following is NOT a standard HTTP cache type?
    answers:
      - { value: "Browser cache", correct: false }
      - { value: "Proxy cache", correct: false }
      - { value: "Database cache", correct: true }
      - { value: "Reverse proxy cache", correct: false }
    help: |
      Standard HTTP cache types refer to caches that operate at the HTTP layer, such as browser caches (client-side), proxy caches (forward proxies), and reverse proxy caches (server-side). Database caching is an application-level caching mechanism, not an HTTP cache type.
      https://symfony.com/doc/current/http_cache.html#http-cache-types

  -
    question: >
      If a Symfony `Response` object has both `setEtag()` and `setLastModified()` called, which header takes precedence for validation if both `If-None-Match` and `If-Modified-Since` are present in the request?
    answers:
      - { value: "`Last-Modified` always takes precedence.", correct: false }
      - { value: "`ETag` always takes precedence.", correct: true }
      - { value: "The one that was set last in the code takes precedence.", correct: false }
      - { value: "It depends on the client's browser implementation.", correct: false }
    help: |
      According to RFC 7232 (HTTP/1.1 Conditional Requests), if both `If-None-Match` and `If-Modified-Since` are present in a request, `If-None-Match` (and thus `ETag`) takes precedence. If `If-None-Match` fails, then `If-Modified-Since` is evaluated.
      https://www.rfc-editor.org/rfc/rfc7232#section-3.2

  -
    question: >
      What is the purpose of the `immutable` option when setting cache headers in Symfony?
    answers:
      - { value: "It prevents the response from being modified by proxies.", correct: false }
      - { value: "It indicates that the resource will not change over time, allowing caches to serve it without revalidation for its entire freshness lifetime.", correct: true }
      - { value: "It makes the response read-only in the cache.", correct: false }
      - { value: "It ensures the response is always served from the origin server.", correct: false }
    help: |
      The `immutable` directive in `Cache-Control` tells caches that the response body will not change. This is useful for resources like versioned assets (e.g., `/css/app.v123.css`), allowing caches to avoid revalidation checks for a longer period.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      Which of the following methods on `Symfony\\Component\\HttpFoundation\\Response` can be used to set the `Last-Modified` HTTP header?
    answers:
      - { value: "`setModificationDate()`", correct: false }
      - { value: "`setLastModified(new \\DateTime())`", correct: true }
      - { value: "`setModifiedAt()`", correct: false }
      - { value: "`setUpdateDate()`", correct: false }
    help: |
      The `setLastModified()` method is used to set the `Last-Modified` HTTP header, accepting a `DateTimeInterface` object.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      When using Symfony's `HttpCache`, if a request includes `Cache-Control: no-cache` and the `allow_reload` option is `false` in `framework.yaml`, what will happen?
    answers:
      - { value: "The `HttpCache` will ignore the `no-cache` directive and serve the cached response if fresh.", correct: true }
      - { value: "The `HttpCache` will always forward the request to the backend application.", correct: false }
      - { value: "An exception will be thrown, indicating a cache configuration error.", correct: false }
      - { value: "The `HttpCache` will clear its entire cache.", correct: false }
    help: |
      If `allow_reload` is `false`, the `HttpCache` will not honor the client's `Cache-Control: no-cache` directive and will serve the cached response if it's still fresh, rather than revalidating or reloading from the origin.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      What is the purpose of the `proxy-revalidate` directive in `Cache-Control`?
    answers:
      - { value: "It forces private caches to revalidate stale entries.", correct: false }
      - { value: "It forces shared caches to revalidate stale entries with the origin server before serving them.", correct: true }
      - { value: "It allows proxies to revalidate their own configuration.", correct: false }
      - { value: "It prevents proxies from caching the response.", correct: false }
    help: |
      `proxy-revalidate` is similar to `must-revalidate` but applies specifically to shared caches (proxies). It instructs shared caches to revalidate stale responses with the origin server before serving them.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#proxy-revalidate

  -
    question: >
      Which of the following is a valid way to disable Symfony's automatic session cache control in `config/services.yaml`?
    answers:
      - { value: "```yaml\nframework:\n    session:\n        cache_limiter: 0\n```", correct: false }
      - { value: "```yaml\nparameters:\n    session.storage.options:\n        cache_limiter: 0\n```", correct: true }
      - { value: "```yaml\nservices:\n    _defaults:\n        bind:\n            $sessionAutoCacheControl: false\n```", correct: false }
      - { value: "```yaml\nframework:\n    http_cache:\n        session_aware: false\n```", correct: false }
    help: |
      Setting the `session.storage.options.cache_limiter` parameter to `0` prevents Symfony from automatically adding cache-busting headers related to session management.
      https://symfony.com/doc/current/reference/configuration/framework.html#session-storage-options

  -
    question: >
      When debugging Symfony's `HttpCache`, what does the `X-Symfony-Cache: stale` entry in the header indicate?
    answers:
      - { value: "The response was served directly from the cache and is still fresh.", correct: false }
      - { value: "The response was not found in the cache and was fetched from the backend.", correct: false }
      - { value: "The response was served from the cache, but it was considered stale and might have been revalidated.", correct: true }
      - { value: "The cache is disabled for this request.", correct: false }
    help: |
      `stale` indicates that the cached entry's freshness lifetime has expired. The cache might still serve it if allowed (e.g., with `stale-while-revalidate`) or it might have triggered a revalidation.
      https://symfony.com/doc/current/http_cache.html#debugging-the-cache

  -
    question: >
      Which of the following scenarios would typically result in a `Cache-Control: private` header being sent by Symfony?
    answers:
      - { value: "A response from a static asset (e.g., CSS, JS file).", correct: false }
      - { value: "A response for a logged-in user with an active session, without explicit cache control.", correct: true }
      - { value: "A response from an API endpoint that is publicly accessible.", correct: false }
      - { value: "A response that explicitly sets `setMaxAge(3600)`.", correct: false }
    help: |
      By default, if a user session is active, Symfony's `AbstractSessionListener` will add `Cache-Control: private, no-cache="Set-Cookie"` to responses to prevent shared caches from storing personalized content.
      https://symfony.com/doc/current/http_cache.html#avoiding-automatic-cache-busting

  -
    question: >
      What is the primary purpose of the `Vary` header in the context of HTTP caching?
    answers:
      - { value: "To specify different versions of a resource for different content types.", correct: false }
      - { value: "To inform caches that the response content can differ based on specified request header fields.", correct: true }
      - { value: "To indicate that the response should be varied based on the server's load.", correct: false }
      - { value: "To define a random string for cache busting.", correct: false }
    help: |
      The `Vary` header is crucial for correct caching when a resource's representation can change based on certain request headers (e.g., `Accept-Encoding` for compression, `User-Agent` for mobile vs. desktop content).
      https://symfony.com/doc/current/http_cache/cache_vary.html

  -
    question: >
      If you are using Symfony's `HttpCache` and want to ensure that a specific response is never stored by any cache (neither private nor shared), which `Cache-Control` directive should you use?
    answers:
      - { value: "`no-cache`", correct: false }
      - { value: "`private`", correct: false }
      - { value: "`no-store`", correct: true }
      - { value: "`must-revalidate`", correct: false }
    help: |
      The `no-store` directive explicitly forbids any cache from storing any part of the request or response.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-store

  -
    question: >
      Which of the following is the correct way to configure `HttpCache` to enable debug mode and ESI support programmatically?
    answers:
      - { value: "`new HttpKernel\\HttpCache\\HttpCache($kernel, new HttpKernel\\HttpCache\\Store(), new HttpKernel\\HttpCache\\Esi(), ['debug' => true]);`", correct: true }
      - { value: "`new HttpKernel\\HttpCache\\HttpCache($kernel, new HttpKernel\\HttpCache\\Store(), ['esi' => true, 'debug' => true]);`", correct: false }
      - { value: "`new HttpKernel\\HttpCache\\HttpCache($kernel, new HttpKernel\\HttpCache\\Store(), true, true);`", correct: false }
      - { value: "`$kernel->enableHttpCache(true)->enableEsi(true)->enableDebug(true);`", correct: false }
    help: |
      The `HttpCache` constructor accepts the kernel, a store, an optional ESI instance, and an array of options, including `debug`.
      https://symfony.com/doc/current/http_cache/esi.html#enabling-esi
      https://symfony.com/doc/current/http_cache.html#debugging-the-cache

  -
    question: >
      In the context of HTTP caching, what does a "cache hit" signify?
    answers:
      - { value: "The requested resource was not found in the cache and had to be fetched from the origin server.", correct: false }
      - { value: "The requested resource was found in the cache and was served directly from it without contacting the origin server.", correct: true }
      - { value: "The cache entry was successfully invalidated.", correct: false }
      - { value: "The cache encountered an error while trying to retrieve the resource.", correct: false }
    help: |
      A cache hit occurs when a requested resource is found in the cache and is served from the cache without needing to contact the origin server, leading to faster response times.

  -
    question: >
      What is the primary benefit of using `Response::setNotModified()` in a Symfony controller when dealing with conditional requests?
    answers:
      - { value: "It reduces the amount of data transferred over the network by sending only headers.", correct: true }
      - { value: "It forces the client to always re-download the full content.", correct: false }
      - { value: "It encrypts the response content for security.", correct: false }
      - { value: "It ensures the response is always publicly cacheable.", correct: false }
    help: |
      When a resource has not been modified, returning a 304 Not Modified response (which `setNotModified()` facilitates) avoids sending the entire response body, saving bandwidth and improving performance.
      https://symfony.com/doc/current/components/http_foundation.html#http-cache-headers

  -
    question: >
      Which of the following `Cache-Control` directives indicates that the response should not be transformed by any intermediate proxy?
    answers:
      - { value: "`no-cache`", correct: false }
      - { value: "`no-store`", correct: false }
      - { value: "`no-transform`", correct: true }
      - { value: "`immutable`", correct: false }
    help: |
      The `no-transform` directive prevents intermediate caches and proxies from altering the payload of the response, such as converting image formats or compressing content.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-transform

  -
    question: >
      When using ESI, if an included fragment's controller throws an exception, what is the default behavior of Symfony's `HttpCache`?
    answers:
      - { value: "The entire page will fail to load.", correct: false }
      - { value: "The ESI include will be replaced with an empty string or a placeholder, and the main page will still render.", correct: true }
      - { value: "The exception will be logged, but the ESI include will be re-attempted automatically.", correct: false }
      - { value: "The ESI include will redirect to an error page.", correct: false }
    help: |
      By default, if an ESI sub-request fails or throws an exception, Symfony's `HttpCache` will gracefully handle it by replacing the ESI include with an empty string or a configured fallback, allowing the main page to render. This behavior can be configured.
      https://symfony.com/doc/current/http_cache/esi.html#error-handling

  -
    question: >
      What is the primary difference between `max-age` and `s-maxage` in the `Cache-Control` header?
    answers:
      - { value: "`max-age` applies to all caches, `s-maxage` only to private caches.", correct: false }
      - { value: "`max-age` applies to private caches, `s-maxage` applies to shared caches.", correct: true }
      - { value: "`max-age` is for static assets, `s-maxage` is for dynamic content.", correct: false }
      - { value: "`max-age` is deprecated, `s-maxage` is the modern equivalent.", correct: false }
    help: |
      `max-age` applies to both private (browser) and shared (proxy) caches. `s-maxage` (shared-maxage) specifically overrides `max-age` for shared caches, allowing different freshness durations for these two types of caches.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage

  -
    question: >
      Which of the following is a valid use case for `Cache-Control: stale-while-revalidate`?
    answers:
      - { value: "Ensuring that a resource is always fetched fresh from the origin server.", correct: false }
      - { value: "Allowing a cache to serve slightly outdated content immediately while fetching a fresh version in the background to improve perceived performance.", correct: true }
      - { value: "Preventing any caching of the response.", correct: false }
      - { value: "Forcing a cache to revalidate only when an error occurs on the origin server.", correct: false }
    help: |
      `stale-while-revalidate` is designed to improve user experience by serving a stale (but still usable) cached response immediately, while the cache asynchronously revalidates the content with the origin server.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate

  -
    question: >
      What is the main advantage of using a reverse proxy cache (like Varnish or Symfony's HttpCache) over just relying on browser caching?
    answers:
      - { value: "Reverse proxies can cache dynamic content, while browser caches cannot.", correct: false }
      - { value: "Reverse proxies reduce the load on the origin server for all users, not just individual clients.", correct: true }
      - { value: "Reverse proxies are easier to configure than browser caches.", correct: false }
      - { value: "Reverse proxies provide better security against XSS attacks.", correct: false }
    help: |
      A reverse proxy cache serves as a shared cache for all users, reducing the number of requests that hit the backend application. This significantly offloads the origin server and improves overall scalability and performance for all clients.
      https://symfony.com/doc/current/http_cache.html#http-cache-types

  -
    question: >
      If a response has `Cache-Control: public, max-age=3600`, and the client sends a request with `Cache-Control: max-age=0`, what will a compliant cache do?
    answers:
      - { value: "Serve the cached response without revalidation.", correct: false }
      - { value: "Always fetch a new response from the origin server.", correct: false }
      - { value: "Revalidate the cached response with the origin server before serving it.", correct: true }
      - { value: "Ignore the client's `max-age=0` and use its own `max-age=3600`.", correct: false }
    help: |
      `max-age=0` in a request implies a desire for revalidation. A compliant cache will revalidate its stored response with the origin server, even if its own `max-age` indicates the response is still fresh.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age

  -
    question: >
      What is the purpose of the `trace_level` option under `framework.http_cache` in Symfony?
    answers:
      - { value: "To define the verbosity of cache-related logs in the application.", correct: true }
      - { value: "To set the maximum depth for ESI includes.", correct: false }
      - { value: "To configure the level of detail for cache invalidation events.", correct: false }
      - { value: "To specify the number of cache layers to trace.", correct: false }
    help: |
      The `trace_level` option (e.g., `none`, `short`, `full`) controls the amount of detail provided in the `X-Symfony-Cache` header when debug mode is enabled, helping to diagnose cache behavior.
      https://symfony.com/doc/current/reference/configuration/framework.html#http-cache

  -
    question: >
      Which HTTP header is used by a client to send a previously received `ETag` to the server for validation?
    answers:
      - { value: "`If-Modified-Since`", correct: false }
      - { value: "`If-None-Match`", correct: true }
      - { value: "`If-Match`", correct: false }
      - { value: "`Cache-Request`", correct: false }
    help: |
      The `If-None-Match` request header is sent by the client with one or more ETags. If any of the ETags match the current ETag of the resource on the server, the server can respond with a 304 Not Modified status.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match

  -
    question: >
      What happens if an `ETag` is set on a Symfony `Response` but the response is marked as `private`?
    answers:
      - { value: "The `ETag` will be ignored by all caches.", correct: false }
      - { value: "The `ETag` will only be used by private (browser) caches for validation.", correct: true }
      - { value: "An error will be thrown because `ETag` cannot be used with private responses.", correct: false }
      - { value: "The response will automatically become public.", correct: false }
    help: |
      If a response is `private`, shared caches are not allowed to store it. However, private caches (like a browser's cache) can still store and validate the response using the `ETag`.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#private

  -
    question: >
      When using ESI, what is the purpose of the `alt` attribute in an `<esi:include>` tag?
    answers:
      - { value: "To provide alternative text for accessibility purposes.", correct: false }
      - { value: "To specify an alternative URL to fetch if the primary `src` URL fails.", correct: true }
      - { value: "To define an alternative caching strategy for the included fragment.", correct: false }
      - { value: "To indicate that the fragment should be loaded asynchronously.", correct: false }
    help: |
      The `alt` attribute in an `<esi:include>` tag provides a fallback URL. If the primary `src` URL cannot be fetched or results in an error, the ESI processor will attempt to fetch content from the `alt` URL instead.
      https://www.w3.org/TR/EDGE-arch#include-element

  -
    question: >
      Which of the following is a valid reason to use `Cache-Control: must-revalidate`?
    answers:
      - { value: "To allow caches to serve stale content without revalidation.", correct: false }
      - { value: "To ensure that caches always revalidate stale entries with the origin server before serving them.", correct: true }
      - { value: "To prevent any caching of the response.", correct: false }
      - { value: "To specify a maximum age for the cached resource.", correct: false }
    help: |
      `must-revalidate` explicitly tells caches that they must revalidate the cached entry with the origin server once it becomes stale. They are not allowed to serve a stale response without checking for updates.
      https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#must-revalidate

  -
    question: >
      What is the primary function of the `HttpKernelInterface` in Symfony's HttpKernel component?
    answers:
      - { value: "To manage the dependency injection container.", correct: false }
      - { value: "To handle HTTP requests and return HTTP responses.", correct: true }
      - { value: "To define routing rules for the application.", correct: false }
      - { value: "To provide a generic interface for console commands.", correct: false }
    help: |
      The `HttpKernelInterface` defines the contract for processing an HTTP request and returning an HTTP response, forming the core of Symfony's request-response lifecycle.
      https://symfony.com/doc/current/create_framework/http_kernel_httpkernelinterface.html#the-httpkernelinterface

  -
    question: >
      When using `CachingHttpClient`, how can you ensure that cached responses are stored in a specific directory?
    answers:
      - { value: "By passing the directory path to the `CachingHttpClient` constructor directly.", correct: false }
      - { value: "By configuring the `Store` instance with the desired directory path.", correct: true }
      - { value: "By setting a `cache_dir` option in the HTTP client configuration.", correct: false }
      - { value: "The storage location is automatically determined by Symfony.", correct: false }
    help: |
      The `Store` implementation (e.g., `HttpKernel\\HttpCache\\Store`) is responsible for managing the actual storage of cached responses, and its constructor typically accepts the path to the cache directory.
      https://symfony.com/doc/current/http_client.html#caching-responses