category: Symfony Architecture
questions:
  - question: What is the primary role of Symfony Flex in a Symfony 7 application?
    answers:
      - value: To automate the installation and configuration of Symfony packages and
          bundles.
        correct: true
      - value: To provide a graphical user interface for managing Symfony projects.
        correct: false
      - value: To replace Composer as the dependency manager.
        correct: false
      - value: To compile PHP code into optimized binaries.
        correct: false
    help: Symfony Flex is a Composer plugin that automates the installation and
      configuration of Symfony packages and bundles using 'recipes'.
  - question: When you run `composer require doctrine/orm` in a Symfony 7
      application, what mechanism is primarily responsible for automatically
      configuring the bundle and adding database-related environment variables
      to `.env`?
    answers:
      - value: Symfony Flex recipes.
        correct: true
      - value: The Symfony Kernel's `registerBundles()` method.
        correct: false
      - value: Composer's autoloader.
        correct: false
      - value: Manual configuration in `config/packages/doctrine.yaml`.
        correct: false
    help: Symfony Flex uses 'recipes' to automate common installation and
      configuration tasks, such as adding bundle configurations and environment
      variables for Doctrine ORM.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_11
  - question: Under which open-source license is the Symfony framework distributed?
    answers:
      - value: MIT License
        correct: true
      - value: GPLv3
        correct: false
      - value: Apache License 2.0
        correct: false
      - value: BSD License
        correct: false
    help: Symfony is released under the MIT license, which is a permissive free
      software license.
  - question: Which of the following best describes a Symfony Component?
    answers:
      - value: A standalone, decoupled PHP library that can be used independently of the
          full Symfony framework.
        correct: true
      - value: A full-stack framework for building web applications.
        correct: false
      - value: A plugin that extends the functionality of a Symfony Bundle.
        correct: false
      - value: A tool for generating boilerplate code in Symfony applications.
        correct: false
    help: Symfony Components are reusable, decoupled PHP libraries that solve common
      web development problems. They can be used independently or as part of the
      full Symfony framework.
  - question: >-
      Consider the following PHP code using the PropertyAccess component:

      ```php

      use Symfony\Component\PropertyAccess\PropertyAccess;


      class Person

      {
          public string $firstName;
          private array $children = [];

          public function setChildren($children): void
          {
              $this->children = $children;
          }

          public function getChildren(): array
          {
              return $this->children;
          }
      }


      $person = new Person();

      $propertyAccessor = PropertyAccess::createPropertyAccessor();

      $propertyAccessor->setValue($person, 'children[0].firstName', 'Alice');

      ```

      What will be the value of `$person->getChildren()[0]->firstName` after the
      `setValue` call?
    answers:
      - value: "'Alice'"
        correct: true
      - value: "null"
        correct: false
      - value: An exception will be thrown because `children` is private.
        correct: false
      - value: An empty string.
        correct: false
    help: The PropertyAccess component can access and modify properties through
      public methods (getters/setters) and public properties, including nested
      structures like arrays and objects.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_access.rst#_snippet_23
  - question: What is the main purpose of the Symfony PropertyInfo component?
    answers:
      - value: To extract information about class properties, such as their types,
          descriptions, and accessors.
        correct: true
      - value: To validate data against a set of rules.
        correct: false
      - value: To convert PHP objects to and from different formats (e.g., JSON, XML).
        correct: false
      - value: To manage database migrations.
        correct: false
    help: The PropertyInfo component provides an API to extract information about
      properties of a PHP class, including their types, descriptions, and
      whether they are readable or writable.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_info.rst#_snippet_3
  - question: "Which of the following extractors, when configured with
      `property_info.with_constructor_extractor: true` in `framework.yaml`
      (Symfony 7.3+), can extract type information directly from constructor
      arguments?"
    answers:
      - value: ConstructorExtractor
        correct: true
      - value: ReflectionExtractor
        correct: false
      - value: PhpDocExtractor
        correct: false
      - value: PhpStanExtractor
        correct: false
    help: The `ConstructorExtractor` (introduced in Symfony 7.3) is specifically
      designed to extract property information by analyzing constructor
      arguments, often leveraging `ReflectionExtractor` or `PhpStanExtractor`
      internally.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_111
  - question: In the Symfony Messenger component, what is the primary responsibility
      of a `Sender`?
    answers:
      - value: Serializing and sending messages to a message broker or third-party API.
        correct: true
      - value: Retrieving and deserializing messages from a message broker.
        correct: false
      - value: Executing the business logic associated with a message.
        correct: false
      - value: Adding metadata (stamps) to a message envelope.
        correct: false
    help: A Sender in Symfony Messenger is responsible for the outbound flow of
      messages, preparing them for transport and dispatching them to the
      configured message broker.
      https://github.com/symfony/symfony-docs/blob/7.3/components/messenger.rst#_snippet_1
  - question: What are `Envelope Stamps` in the context of Symfony Messenger?
    answers:
      - value: Pieces of information attached to a message, providing metadata for
          middleware or transport layers.
        correct: true
      - value: Unique identifiers for messages.
        correct: false
      - value: Error codes returned by message handlers.
        correct: false
      - value: Pre-defined message types.
        correct: false
    help: Envelope Stamps are a Messenger-specific concept that allows you to attach
      arbitrary metadata to a message, which can be processed by middleware or
      transport layers.
      https://github.com/symfony/symfony-docs/blob/7.3/components/messenger.rst#_snippet_1
  - question: The Symfony Config component is primarily used for what purpose?
    answers:
      - value: To define and validate application configuration schemas.
        correct: true
      - value: To manage environment variables.
        correct: false
      - value: To load configuration files from different formats (YAML, XML, PHP).
        correct: false
      - value: To encrypt sensitive configuration data.
        correct: false
    help: The Config component provides a powerful way to define hierarchical
      configuration structures and validate user-provided configuration against
      these definitions.
      https://github.com/symfony/symfony-docs/blob/7.3/components/config/definition.rst#_snippet_0
  - question: >-
      Given the following configuration definition using the Symfony Config
      component:

      ```php

      $rootNode
          ->children()
              ->arrayNode('connections')
                  ->arrayPrototype()
                      ->children()
                          ->scalarNode('driver')->end()
                          ->scalarNode('host')->end()
                          ->scalarNode('username')->end()
                          ->scalarNode('password')->end()
                      ->end()
                  ->end()
              ->end()
          ->end()
      ;

      ```

      Which of the following YAML configurations would be valid for the
      `connections` node?
    answers:
      - value: >-
          connections:
              - { driver: mysql, host: localhost, username: user, password: ~ }
              - { driver: sqlite, host: localhost, username: user, password: pass }
        correct: true
      - value: |-
          connections:
              mysql:
                  driver: mysql
                  host: localhost
              sqlite:
                  driver: sqlite
                  host: localhost
        correct: false
      - value: |-
          connections:
              driver: mysql
              host: localhost
        correct: false
      - value: |-
          connections:
              - mysql
              - sqlite
        correct: false
    help: The `arrayPrototype()` method defines that the `connections` node will
      contain a list of arrays, where each inner array conforms to the specified
      children (driver, host, etc.).
      https://github.com/symfony/symfony-docs/blob/7.3/components/config/definition.rst#_snippet_10
  - question: What is the main goal of the Symfony Runtime component?
    answers:
      - value: To provide a standardized way to boot applications, decoupling them from
          global state and web servers.
        correct: true
      - value: To manage application dependencies and autoloading.
        correct: false
      - value: To handle HTTP requests and responses.
        correct: false
      - value: To generate code for new Symfony projects.
        correct: false
    help: The Symfony Runtime component aims to provide a thin layer that boots your
      application, allowing it to run in various environments (web, console,
      serverless) without modification.
      https://github.com/symfony/symfony-docs/blob/7.3/components/runtime.rst#_snippet_12
  - question: You want to create a simple console application with a single command
      using the Symfony Runtime component. Which of the following best
      represents the `bin/console` entry point structure for this scenario?
    answers:
      - value: >-
          ```php

          use Symfony\Component\Console\Application;

          use Symfony\Component\Console\Command\Command;

          use Symfony\Component\Console\Input\InputInterface;

          use Symfony\Component\Console\Output\OutputInterface;


          require_once dirname(__DIR__).'/vendor/autoload_runtime.php';


          return static function (array $context): Application {
              $command = new Command('hello');
              $command->setCode(static function (InputInterface $input, OutputInterface $output): void {
                  $output->write('Hello World');
              });

              $app = new Application();
              $app->add($command);
              $app->setDefaultCommand('hello', true);

              return $app;
          };

          ```
        correct: true
      - value: >-
          ```php

          require_once dirname(__DIR__).'/vendor/autoload.php';


          $kernel = new App\Kernel('dev', true);

          $application = new
          Symfony\Bundle\FrameworkBundle\Console\Application($kernel);

          $application->run();

          ```
        correct: false
      - value: |-
          ```php
          require_once dirname(__DIR__).'/vendor/autoload_runtime.php';

          return static function (): int {
              echo 'Hello World';
              return 0;
          };
          ```
        correct: false
      - value: |-
          ```php
          require_once dirname(__DIR__).'/vendor/autoload.php';

          (new App\Kernel('dev', true))->run();
          ```
        correct: false
    help: For console applications with multiple commands, the Runtime component
      allows you to return a `Symfony\Component\Console\Application` instance
      from the entry point.
      https://github.com/symfony/symfony-docs/blob/7.3/components/runtime.rst#_snippet_10
  - question: What is the core responsibility of the Symfony HttpKernel component?
    answers:
      - value: To handle requests and return responses, acting as the central dispatcher
          for the application.
        correct: true
      - value: To manage database connections and ORM entities.
        correct: false
      - value: To provide a templating engine for rendering views.
        correct: false
      - value: To handle user authentication and authorization.
        correct: false
    help: The HttpKernel component is the heart of Symfony's request-response cycle,
      responsible for taking an incoming request, dispatching it to a
      controller, and returning a response.
      https://github.com/symfony/symfony-docs/blob/7.3/create_framework/http_kernel_controller_resolver.rst#_snippet_2
  - question: What is the primary function of a Symfony Bridge?
    answers:
      - value: To provide integration between a Symfony Component and a third-party
          library.
        correct: true
      - value: To connect two different Symfony Components.
        correct: false
      - value: To facilitate communication between different Symfony applications.
        correct: false
      - value: To offer a command-line interface for Symfony applications.
        correct: false
    help: Symfony Bridges are small packages that provide integration between a
      Symfony Component and popular third-party libraries (e.g., MonologBridge,
      TwigBridge).
  - question: Which of the following is an example of a Symfony Bridge?
    answers:
      - value: MonologBridge (integrates Monolog with Symfony's logging system)
        correct: true
      - value: HttpFoundation (core component for HTTP abstractions)
        correct: false
      - value: Console (core component for CLI applications)
        correct: false
      - value: Doctrine ORM (a third-party library, not a bridge itself)
        correct: false
    help: Bridges connect Symfony components with external libraries. MonologBridge
      allows Monolog to be used seamlessly within a Symfony application.
  - question: In a standard Symfony 7 application, where should your custom
      application-specific classes (e.g., services, entities, controllers)
      typically reside?
    answers:
      - value: "`src/` directory"
        correct: true
      - value: "`vendor/` directory"
        correct: false
      - value: "`bin/` directory"
        correct: false
      - value: "`public/` directory"
        correct: false
    help: The `src/` directory is where your application's custom PHP code,
      including controllers, services, entities, and other business logic,
      should be placed.
  - question: What is the primary benefit of extending `AbstractController` for your
      controllers in Symfony 7?
    answers:
      - value: It provides convenient shortcuts to commonly used services and utilities
          (e.g., `render()`, `redirectToRoute()`, `addFlash()`).
        correct: true
      - value: It automatically makes all public methods invokable.
        correct: false
      - value: It ensures that controllers are automatically registered as services.
        correct: false
      - value: It enforces a strict one-to-one mapping between routes and controller
          methods.
        correct: false
    help: Extending `AbstractController` provides access to many helper methods that
      simplify common controller tasks by interacting with the service
      container.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_1
  - question: You have created a new service `App\Service\MyLogger` that needs to
      log messages. How would you typically inject the `Psr\Log\LoggerInterface`
      into its constructor for autowiring in Symfony 7?
    answers:
      - value: |-
          ```php
          namespace App\Service;

          use Psr\Log\LoggerInterface;

          class MyLogger
          {
              public function __construct(
                  private LoggerInterface $logger,
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          namespace App\Service;

          class MyLogger
          {
              public function __construct(
                  private $logger
              ) {
                  $this->logger = new Logger();
              }
          }
          ```
        correct: false
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyLogger
          {
              public function __construct(
                  #[Autowire(service: 'logger')] private $logger
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          namespace App\Service;

          class MyLogger
          {
              public function __construct(
                  private Logger $logger
              ) {}
          }
          ```
        correct: false
    help: Symfony's autowiring automatically injects services based on type hints.
      For logging, type-hinting `Psr\Log\LoggerInterface` is the standard
      approach.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_5
  - question: Consider a multi-application Symfony project. According to best
      practices, where would you typically place the application-specific
      configuration files (e.g., `bundles.php`, `routes.yaml`, `services.yaml`)
      for an application named `admin`?
    answers:
      - value: "`apps/admin/config/`"
        correct: true
      - value: "`config/admin/`"
        correct: false
      - value: "`src/admin/config/`"
        correct: false
      - value: "`var/config/admin/`"
        correct: false
    help: For multi-application setups, Symfony recommends organizing each
      application's specific files, including configuration, within its own
      directory under `apps/`.
      https://github.com/symfony/symfony-docs/blob/7.3/configuration/multiple_kernels.rst#_snippet_14
  - question: Which component is responsible for converting an incoming HTTP request
      into a `Symfony\Component\HttpFoundation\Request` object and dispatching
      it through the kernel?
    answers:
      - value: HttpKernel
        correct: true
      - value: HttpFoundation
        correct: false
      - value: Routing
        correct: false
      - value: EventDispatcher
        correct: false
    help: The HttpKernel component is the central dispatcher that processes incoming
      requests and orchestrates the entire request-response cycle.
      HttpFoundation provides the `Request` and `Response` objects.
  - question: In Symfony 7, what is the recommended way to define routes for your
      controllers?
    answers:
      - value: Using PHP attributes (e.g., `#[Route]`) directly on controller classes
          and methods.
        correct: true
      - value: Defining routes exclusively in XML files.
        correct: false
      - value: Defining routes exclusively in YAML files.
        correct: false
      - value: Using annotations (deprecated in favor of attributes).
        correct: false
    help: PHP attributes are the modern and recommended way to define routes in
      Symfony 7, offering a more concise and co-located configuration.
      https://github.com/symfony/symfony-docs/blob/7.3/controller/service.rst#_snippet_4
  - question: >-
      Given the following controller action:

      ```php

      // src/Controller/ProductController.php

      namespace App\Controller;


      use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

      use Symfony\Component\HttpFoundation\Request;

      use Symfony\Component\HttpFoundation\Response;

      use Symfony\Component\Routing\Attribute\Route;


      class ProductController extends AbstractController

      {
          #[Route('/product/{id}', name: 'app_product_show')]
          public function show(int $id, Request $request): Response
          {
              // ...
          }
      }

      ```

      How would you access a query parameter named `category` from the URL
      `/product/123?category=electronics` within the `show` method?
    answers:
      - value: "`$request->query->get('category')`"
        correct: true
      - value: "`$request->attributes->get('category')`"
        correct: false
      - value: "`$request->request->get('category')`"
        correct: false
      - value: "`$_GET['category']`"
        correct: false
    help: "The `Request` object's `query` property is a `ParameterBag` that holds
      all query parameters. You can access them using the `get()` method.
      `$_GET` should be avoided for direct access in Symfony. "
  - question: When an unhandled exception occurs in a Symfony 7 application, which
      component is primarily responsible for catching it and converting it into
      an appropriate HTTP response (e.g., a 500 Internal Server Error page)?
    answers:
      - value: HttpKernel (specifically, the `kernel.exception` event listener)
        correct: true
      - value: ErrorHandler
        correct: false
      - value: DebugBundle
        correct: false
      - value: Logger
        correct: false
    help: The HttpKernel component dispatches the `kernel.exception` event, allowing
      listeners (like the one in FrameworkBundle) to catch exceptions and create
      a proper HTTP response, often rendering an error page.
  - question: What is the primary purpose of the Symfony Event Dispatcher component?
    answers:
      - value: To implement the Observer design pattern, allowing components to
          communicate without tight coupling.
        correct: true
      - value: To manage asynchronous tasks and messages.
        correct: false
      - value: To handle database transactions.
        correct: false
      - value: To resolve service dependencies.
        correct: false
    help: The Event Dispatcher component provides a generic way for objects to
      communicate by dispatching events and allowing listeners to react to them,
      promoting loose coupling.
  - question: Which of the following is a common Kernel Event dispatched during the
      Symfony request lifecycle?
    answers:
      - value: "`kernel.request`"
        correct: true
      - value: "`kernel.controller`"
        correct: true
      - value: "`kernel.view`"
        correct: true
      - value: "`kernel.response`"
        correct: true
      - value: "`kernel.terminate`"
        correct: true
    help: Symfony's HttpKernel dispatches several events during the request
      lifecycle, allowing bundles and applications to hook into various stages.
      Common ones include `kernel.request`, `kernel.controller`, `kernel.view`,
      `kernel.response`, and `kernel.terminate`.
  - question: You want to execute some custom logic immediately after a controller
      has been executed but before the response is sent. Which Kernel Event
      would be most appropriate to listen to?
    answers:
      - value: "`kernel.view`"
        correct: true
      - value: "`kernel.request`"
        correct: false
      - value: "`kernel.controller`"
        correct: false
      - value: "`kernel.response`"
        correct: false
    help: The `kernel.view` event is dispatched after the controller has returned a
      value (but not yet a `Response` object), allowing you to convert that
      value into a `Response` or modify it before the `kernel.response` event.
      If the controller returns a `Response` directly, `kernel.view` is skipped
      and `kernel.response` is dispatched immediately.
  - question: What is the main advantage of using autowiring for services in Symfony 7?
    answers:
      - value: It automatically injects dependencies into service constructors and
          methods based on type hints, reducing manual configuration.
        correct: true
      - value: It eliminates the need for a Dependency Injection Container.
        correct: false
      - value: It makes all services public and accessible globally.
        correct: false
      - value: It automatically generates service classes based on configuration.
        correct: false
    help: Autowiring simplifies dependency injection by automatically identifying
      and injecting services based on their type hints, making service
      definitions much cleaner and easier to manage.
      https://github.com/symfony/symfony-docs/blob/7.3/service_container/autowiring.rst#_snippet_10
  - question: What is the recommended way to manage sensitive configuration values
      (like database credentials) in a Symfony 7 application, especially across
      different environments?
    answers:
      - value: Using environment variables (e.g., in `.env` files, or actual system
          environment variables).
        correct: true
      - value: Hardcoding them directly in `config/services.yaml`.
        correct: false
      - value: Storing them in version control alongside the application code.
        correct: false
      - value: Using PHP constants defined in a global file.
        correct: false
    help: Symfony strongly recommends using environment variables for sensitive data
      and environment-specific configurations, typically loaded from `.env`
      files.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_10
  - question: You need to configure a router option differently for the `prod`
      environment compared to `dev`. Which of the following is the correct way
      to do this in `config/packages/routing.yaml`?
    answers:
      - value: |-
          ```yaml
          # config/packages/routing.yaml
          framework:
              router:
                  utf8: true

          when@prod:
              framework:
                  router:
                      strict_requirements: null
          ```
        correct: true
      - value: |-
          ```yaml
          # config/packages/routing.yaml
          framework:
              router:
                  utf8: true

          prod:
              framework:
                  router:
                      strict_requirements: null
          ```
        correct: false
      - value: |-
          ```yaml
          # config/packages/routing.yaml
          framework:
              router:
                  utf8: true
                  strict_requirements: true # default for dev

          # config/packages/routing_prod.yaml
          framework:
              router:
                  strict_requirements: null
          ```
        correct: false
      - value: |-
          ```yaml
          # config/packages/routing.yaml
          framework:
              router:
                  utf8: true

          if env == 'prod':
              framework:
                  router:
                      strict_requirements: null
          ```
        correct: false
    help: Symfony provides the `when@env` syntax in configuration files (YAML, XML,
      PHP) to apply specific configurations only for a given environment.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_8
  - question: Why is it considered a best practice to separate business logic into
      services rather than placing it directly in controllers?
    answers:
      - value: To improve reusability, testability, and maintainability by adhering to
          the Single Responsibility Principle.
        correct: true
      - value: Controllers are not designed to hold any logic beyond handling HTTP
          requests.
        correct: false
      - value: Services are automatically optimized by Symfony, leading to better
          performance.
        correct: false
      - value: To prevent direct database access from controllers.
        correct: false
    help: Separating business logic into services promotes a cleaner architecture,
      making code easier to test in isolation, reuse across different parts of
      the application, and maintain over time. Controllers should primarily
      handle request/response flow.
  - question: You want to ensure that browsers always fetch the latest version of
      your `app.css` file after a new deployment, preventing caching issues.
      Which `framework.yaml` configuration option would you use for global asset
      versioning?
    answers:
      - value: "`assets.version`"
        correct: true
      - value: "`assets.json_manifest_path`"
        correct: false
      - value: "`assets.strict_mode`"
        correct: false
      - value: "`assets.base_path`"
        correct: false
    help: The `assets.version` option allows you to globally append a query
      parameter (e.g., `?v=123`) to all rendered asset paths, effectively
      busting browser caches. You must manually increment this value on
      deployment.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_9
  - question: What is the benefit of using PHP attributes (e.g., `#[Route]`,
      `#[AsCommand]`) for configuration in Symfony 7?
    answers:
      - value: They allow configuration to be co-located with the code it configures,
          improving readability and maintainability.
        correct: true
      - value: They replace the need for the Dependency Injection Container.
        correct: false
      - value: They automatically generate all necessary boilerplate code.
        correct: false
      - value: They are faster to parse than YAML or XML configuration files.
        correct: false
    help: PHP attributes provide a modern and convenient way to configure various
      aspects of a Symfony application directly within the PHP code, making the
      configuration more discoverable and closer to its usage.
  - question: What is the typical release cycle for a Symfony Long Term Support
      (LTS) version?
    answers:
      - value: Released every two years, with three years of bug fixes and four years of
          security fixes.
        correct: true
      - value: Released annually, with one year of bug fixes and two years of security
          fixes.
        correct: false
      - value: Released every six months, with six months of bug fixes and one year of
          security fixes.
        correct: false
      - value: Released on demand, with no fixed support period.
        correct: false
    help: Symfony LTS versions are released every two years and receive extended
      support, making them suitable for projects requiring long-term stability.
  - question: How often are new major Symfony versions (e.g., Symfony 6, Symfony 7)
      typically released?
    answers:
      - value: Every two years.
        correct: true
      - value: Every six months.
        correct: false
      - value: Annually.
        correct: false
      - value: Every three years.
        correct: false
    help: New major Symfony versions are typically released every two years, with an
      LTS version every other major release.
  - question: What does Symfony's Backward Compatibility Promise (BCP) primarily
      guarantee?
    answers:
      - value: That minor and patch releases will not introduce breaking changes to
          public APIs.
        correct: true
      - value: That major releases will always be fully backward compatible.
        correct: false
      - value: That all internal classes and methods will remain stable across versions.
        correct: false
      - value: That deprecated features will never be removed.
        correct: false
    help: The BCP ensures that applications can upgrade between minor and patch
      versions without encountering breaking changes, providing stability for
      developers. Breaking changes are reserved for major versions.
  - question: Under which circumstances might a backward compatibility break be
      introduced in a Symfony release?
    answers:
      - value: Only in a new major version (e.g., Symfony 7.0 to Symfony 8.0).
        correct: true
      - value: In any minor version (e.g., Symfony 7.0 to Symfony 7.1).
        correct: false
      - value: In any patch version (e.g., Symfony 7.0.0 to Symfony 7.0.1).
        correct: false
      - value: Only for security fixes.
        correct: false
    help: Backward compatibility breaks are strictly reserved for new major versions
      of Symfony to maintain stability for users on minor and patch releases.
  - question: How does Symfony typically signal that a feature or API is being
      phased out and will be removed in a future major version?
    answers:
      - value: By marking the feature or API as `deprecated` and issuing deprecation
          warnings.
        correct: true
      - value: By removing it immediately in a minor release.
        correct: false
      - value: By changing its behavior without prior notice.
        correct: false
      - value: By only documenting the removal in release notes.
        correct: false
    help: Symfony uses PHP's `#[Deprecated]` attribute (or `@deprecated` PHPDoc tag
      for older versions) and issues deprecation warnings to inform developers
      about features that will be removed in the next major version, giving them
      time to adapt.
  - question: You see deprecation warnings in your Symfony 7 application's logs.
      What is the recommended approach to address these warnings?
    answers:
      - value: Update your code to use the recommended alternative APIs or practices
          mentioned in the deprecation message.
        correct: true
      - value: Ignore them, as they will automatically disappear in the next major
          version.
        correct: false
      - value: Downgrade Symfony to a previous version where the deprecation did not
          exist.
        correct: false
      - value: Disable deprecation warnings in your `php.ini`.
        correct: false
    help: Deprecation warnings are crucial for preparing your application for future
      Symfony upgrades. Addressing them proactively ensures a smoother
      transition to new major versions.
  - question: In Symfony, what does "overloading" typically refer to in the context
      of framework components or bundles?
    answers:
      - value: The ability to override or customize default configurations, templates,
          or services provided by Symfony or its bundles.
        correct: true
      - value: The use of PHP's magic methods like `__call()` or `__get()`.
        correct: false
      - value: Running multiple Symfony applications on the same server.
        correct: false
      - value: Loading too many bundles, leading to performance issues.
        correct: false
    help: Framework overloading in Symfony refers to the mechanism that allows
      developers to replace or extend parts of the framework's default behavior,
      such as overriding templates, configuration, or even services provided by
      core bundles.
  - question: You want to customize the default error pages provided by Symfony.
      Which of the following is the most common and recommended way to achieve
      this?
    answers:
      - value: Override the default error templates in your application's
          `templates/bundles/TwigBundle/Exception/` directory.
        correct: true
      - value: Create a custom error controller and configure it in
          `config/routes.yaml`.
        correct: false
      - value: Modify the core Symfony error handling classes directly.
        correct: false
      - value: Use a third-party bundle specifically for error page customization.
        correct: false
    help: Symfony allows you to override templates from bundles by placing a file
      with the same path under `templates/bundles/` in your application. This is
      the standard way to customize error pages.
  - question: Which PHP Standard Recommendation (PSR) is fundamental to Symfony's
      logging capabilities, allowing for interchangeable logging libraries?
    answers:
      - value: PSR-3 (Logger Interface)
        correct: true
      - value: PSR-7 (HTTP Message Interfaces)
        correct: false
      - value: PSR-4 (Autoloader)
        correct: false
      - value: PSR-11 (Container Interface)
        correct: false
    help: Symfony adheres to PSR-3 for logging, meaning it uses
      `Psr\Log\LoggerInterface` for its logging services, allowing you to easily
      swap out logging implementations (like Monolog) without changing your
      application code.
  - question: Why is adherence to PSRs (PHP Standard Recommendations) important for
      a framework like Symfony?
    answers:
      - value: It promotes interoperability and standardization across different PHP
          projects and libraries.
        correct: true
      - value: It ensures that Symfony applications are always backward compatible with
          older PHP versions.
        correct: false
      - value: It dictates the specific design patterns that must be used within the
          framework.
        correct: false
      - value: It guarantees optimal performance for all Symfony applications.
        correct: false
    help: PSRs define common interfaces and coding standards, making it easier for
      developers to use components from different vendors together and to switch
      between frameworks or libraries.
  - question: When injecting a logger into a Symfony service or controller, which
      interface from PSR-3 is commonly type-hinted to ensure interoperability?
    answers:
      - value: "`Psr\\Log\\LoggerInterface`"
        correct: true
      - value: "`Monolog\\Logger`"
        correct: false
      - value: "`Symfony\\Component\\HttpKernel\\Log\\Logger`"
        correct: false
      - value: "`LoggerAwareInterface`"
        correct: false
    help: Type-hinting against `Psr\Log\LoggerInterface` allows Symfony's autowiring
      to provide the correct logger instance, regardless of the underlying
      logging library (e.g., Monolog).
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_1
  - question: What is the standard naming convention for Symfony controllers?
    answers:
      - value: Class names ending with `Controller` (e.g., `ProductController`).
        correct: true
      - value: Class names starting with `Ctrl`.
        correct: false
      - value: Class names matching the route name.
        correct: false
      - value: Any valid PHP class name.
        correct: false
    help: Symfony follows conventions to make development easier. Controllers are
      typically named with the `Controller` suffix.
  - question: In Symfony, what is the recommended naming convention for service IDs
      when explicitly defining them (though autowiring often makes this
      unnecessary)?
    answers:
      - value: Lowercase with dots (e.g., `app.my_service`, `app.greeting_generator`).
        correct: true
      - value: CamelCase (e.g., `MyService`).
        correct: false
      - value: Snake_case (e.g., `my_service`).
        correct: false
      - value: Uppercase with underscores (e.g., `MY_SERVICE`).
        correct: false
    help: While autowiring reduces the need for explicit service IDs, when they are
      used, the convention is lowercase with dots (e.g., `app.my_service`).
  - question: What is the typical naming convention for configuration files in
      Symfony (e.g., for packages, services, routes)?
    answers:
      - value: Lowercase with underscores, followed by the format extension (e.g.,
          `framework.yaml`, `services.xml`, `routes.php`).
        correct: true
      - value: CamelCase with no extension.
        correct: false
      - value: Uppercase with hyphens.
        correct: false
      - value: Any valid filename.
        correct: false
    help: Symfony configuration files typically follow a lowercase,
      underscore-separated naming convention, with the file extension indicating
      the format (YAML, XML, PHP).
  - question: What is the purpose of the `var/` directory in a Symfony application?
    answers:
      - value: To store volatile data such as cache, logs, and sessions.
        correct: true
      - value: To store public web assets like CSS and JavaScript files.
        correct: false
      - value: To store source code for custom bundles.
        correct: false
      - value: To store Composer dependencies.
        correct: false
    help: The `var/` directory is used for generated files that change during the
      application's lifetime, such as cache, logs, and session data. It should
      typically be excluded from version control.
  - question: You want to prevent `PropertyAccessor::getValue()` from throwing a
      `NoSuchPropertyException` when a property path does not exist, and instead
      have it return `null`. How would you configure the
      `PropertyAccessorBuilder` to achieve this?
    answers:
      - value: |-
          ```php
          $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
              ->disableExceptionOnInvalidPropertyPath()
              ->getPropertyAccessor();
          ```
        correct: true
      - value: |-
          ```php
          $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
              ->ignoreInvalidPropertyPath()
              ->getPropertyAccessor();
          ```
        correct: false
      - value: |-
          ```php
          $propertyAccessor = PropertyAccess::createPropertyAccessorBuilder()
              ->setExceptionOnInvalidPropertyPath(false)
              ->getPropertyAccessor();
          ```
        correct: false
      - value: This behavior is not configurable; it always throws an exception.
        correct: false
    help: The `disableExceptionOnInvalidPropertyPath()` method on
      `PropertyAccessorBuilder` allows you to change the behavior of
      `getValue()` to return `null` instead of throwing an exception for
      non-existent paths.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_access.rst#_snippet_10
  - question: What is the primary role of the `public/index.php` file in a Symfony 7
      application?
    answers:
      - value: It serves as the front controller, bootstrapping the application and
          handling all incoming HTTP requests.
        correct: true
      - value: It contains all the application's routing definitions.
        correct: false
      - value: It is where all services are defined and configured.
        correct: false
      - value: It stores sensitive environment variables.
        correct: false
    help: The `public/index.php` file is the single entry point for all web requests
      to a Symfony application. It initializes the kernel and handles the
      request-response cycle.
  - question: Which of the following is NOT a core concept or component of the
      Symfony Messenger component?
    answers:
      - value: Router
        correct: true
      - value: Sender
        correct: false
      - value: Receiver
        correct: false
      - value: Envelope
        correct: false
      - value: Middleware
        correct: false
    help: The Messenger component deals with sending and receiving messages, using
      concepts like Senders, Receivers, Handlers, Middleware, and Envelopes. The
      Router component is part of the HTTP layer, not Messenger.
      https://github.com/symfony/symfony-docs/blob/7.3/components/messenger.rst#_snippet_1
  - question: Which of the following describes the `MicroKernelTrait` in Symfony?
    answers:
      - value: A trait that simplifies the creation of small, self-contained Symfony
          applications or microservices.
        correct: true
      - value: A trait used for managing database connections in micro-applications.
        correct: false
      - value: A trait that provides methods for interacting with external APIs.
        correct: false
      - value: A trait that enables asynchronous message processing.
        correct: false
    help: The `MicroKernelTrait` is designed for building compact Symfony
      applications or microservices, providing a streamlined way to configure
      the kernel.
      https://github.com/symfony/symfony-docs/blob/7.3/configuration/micro_kernel_trait.rst#_snippet_5
  - question: When defining asset versions in `framework.yaml`, what is the purpose
      of the `version_format` option?
    answers:
      - value: It defines a `sprintf` pattern to construct the asset's path by
          incorporating its version, allowing for query string or path-based
          versioning.
        correct: true
      - value: It specifies the format of the version string itself (e.g., date, hash).
        correct: false
      - value: It determines the file extension for versioned assets.
        correct: false
      - value: It sets the default version for all assets if no specific version is
          provided.
        correct: false
    help: The `version_format` option gives fine-grained control over how the asset
      version is incorporated into the URL, using a `sprintf` pattern.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_12
  - question: Which of the following is a valid way to configure a base path for
      assets in Symfony 7?
    answers:
      - value: |-
          ```yaml
          # config/packages/framework.yaml
          framework:
              assets:
                  base_path: '/images'
          ```
        correct: true
      - value: |-
          ```yaml
          # config/packages/framework.yaml
          assets:
              base_path: '/images'
          ```
        correct: false
      - value: |-
          ```php
          // config/packages/assets.php
          $container->setParameter('assets.base_path', '/images');
          ```
        correct: false
      - value: |-
          ```html
          <base href="/images/">
          ```
        correct: false
    help: The `base_path` option under `framework.assets` in `framework.yaml` (or
      equivalent XML/PHP) allows you to define a common prefix for all asset
      URLs.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_2
  - question: What is the purpose of the `strict_mode` option in Symfony's asset
      configuration?
    answers:
      - value: When enabled, it asserts that all requested assets are present in the
          manifest file, helping detect typos or missing assets.
        correct: true
      - value: It forces all asset URLs to use HTTPS.
        correct: false
      - value: It prevents assets from being served if their version does not match the
          configured version.
        correct: false
      - value: It enables strict caching headers for all assets.
        correct: false
    help: The `strict_mode` option (recommended to be set to `%kernel.debug%`)
      ensures that assets requested via the `asset()` function actually exist in
      the manifest, preventing broken links in production.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_8
  - question: Which of the following PHP versions is the minimum requirement for
      Symfony 7.0?
    answers:
      - value: PHP 8.2
        correct: true
      - value: PHP 8.0
        correct: false
      - value: PHP 7.4
        correct: false
      - value: PHP 8.1
        correct: false
    help: Symfony 7.0 requires PHP 8.2 or higher.
  - question: When using the `PropertyAccessor` component, what is the default
      behavior if you try to access an invalid index of an array (e.g.,
      `$array[99]` when the array only has 10 elements)?
    answers:
      - value: It returns `null` (unless `throw_exception_on_invalid_index` is enabled).
        correct: true
      - value: It throws a `NoSuchPropertyException`.
        correct: false
      - value: It automatically expands the array to include the index.
        correct: false
      - value: It logs a warning but continues execution.
        correct: false
    help: By default, the `property_accessor` service does not throw an exception
      when accessing an invalid array index; it returns `null`. This behavior
      can be changed with the `throw_exception_on_invalid_index` option.
      https://github.com/symfony/symfony-docs/blob/7.3/reference/configuration/framework.rst#_snippet_108
  - question: Which of the following best describes the `__invoke()` magic method in
      the context of Symfony controllers?
    answers:
      - value: It allows a controller class to be called as a function, making the class
          itself the callable for a route.
        correct: true
      - value: It is automatically called when a controller is instantiated.
        correct: false
      - value: It defines the default action for a controller if no method is specified
          in the route.
        correct: false
      - value: It is used for injecting services into a controller.
        correct: false
    help: Invokable controllers, using the `__invoke()` method, are a clean way to
      define controllers, especially for single-action controllers, as the class
      itself becomes the callable.
      https://github.com/symfony/symfony-docs/blob/7.3/controller/service.rst#_snippet_4
  - question: When using `PropertyAccessor::getValue()` with an object that
      implements PHP's magic `__get()` method, what other magic method should
      ideally also be implemented for proper behavior?
    answers:
      - value: "`__isset()`"
        correct: true
      - value: "`__set()`"
        correct: false
      - value: "`__call()`"
        correct: false
      - value: "`__unset()`"
        correct: false
    help: When `__get()` is implemented, `__isset()` should also be implemented to
      ensure that `isset()` and `empty()` checks behave as expected for dynamic
      properties accessed via `PropertyAccessor`.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_access.rst#_snippet_12
  - question: What is the purpose of the `getBuiltInType()` method of a
      `Symfony\Component\PropertyInfo\Type` object?
    answers:
      - value: It returns the fundamental PHP data type (e.g., 'string', 'int',
          'object').
        correct: true
      - value: It returns the fully-qualified class name for object types.
        correct: false
      - value: It indicates whether the property can be null.
        correct: false
      - value: It returns the type of elements if the property is a collection.
        correct: false
    help: The `getBuiltInType()` method provides the basic PHP type of a property,
      such as 'string', 'int', 'bool', 'array', or 'object'.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_info.rst#_snippet_15
  - question: Which of the following is a key responsibility of `Middleware` in the
      Symfony Messenger component?
    answers:
      - value: Accessing the message and its envelope during dispatch.
        correct: true
      - value: Implementing cross-cutting concerns like logging or validation.
        correct: true
      - value: Calling the next middleware in the chain or interrupting it.
        correct: true
      - value: Retrieving messages from a message queue.
        correct: false
    help: Middleware in Messenger allows you to intercept messages during dispatch,
      perform actions (like logging, validation, or transactions), and then pass
      the message to the next middleware or stop the chain.
      https://github.com/symfony/symfony-docs/blob/7.3/components/messenger.rst#_snippet_1
  - question: What is the significance of the `symfony.lock` file in a Symfony Flex
      project?
    answers:
      - value: It stores the exact versions of Symfony Flex recipes applied to the
          project, ensuring consistent installations.
        correct: true
      - value: It locks the Composer dependencies to specific versions.
        correct: false
      - value: It contains the application's secret key for security.
        correct: false
      - value: It is a cache file for the Dependency Injection Container.
        correct: false
    help: The `symfony.lock` file is managed by Symfony Flex and records the state
      of the Flex recipes applied to your project, ensuring that `composer
      install` always results in the same application structure.
  - question: When developing a custom Twig filter in Symfony 7, what PHP attribute
      can be used to automatically register the filter with Twig?
    answers:
      - value: "`#[AsTwigFilter('filter_name')]`"
        correct: true
      - value: "`#[TwigFilter('filter_name')]`"
        correct: false
      - value: "`#[Filter('filter_name')]`"
        correct: false
      - value: "`#[TwigExtension]`"
        correct: false
    help: The `#[AsTwigFilter]` attribute (from `Twig\Attribute`) is used for
      autoconfiguration of Twig filters in Symfony 7, simplifying their
      registration.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_6
  - question: What is the primary purpose of the `config/services.yaml` file in a
      Symfony 7 application?
    answers:
      - value: To define and configure the application's services and their
          dependencies.
        correct: true
      - value: To define the application's routes.
        correct: false
      - value: To manage environment variables.
        correct: false
      - value: To declare the bundles used by the application.
        correct: false
    help: The `config/services.yaml` file is the primary location for defining and
      configuring services within the Symfony Dependency Injection Container.
  - question: Which of the following is true regarding the `APP_ENV` environment
      variable in a Symfony 7 application?
    answers:
      - value: It determines the current application environment (e.g., `dev`, `prod`,
          `test`).
        correct: true
      - value: It defines the application's secret key.
        correct: false
      - value: It is only used for debugging purposes and has no effect in production.
        correct: false
      - value: It specifies the database connection string.
        correct: false
    help: The `APP_ENV` environment variable is crucial for Symfony applications, as
      it dictates which configuration files are loaded and influences various
      behaviors like debugging and caching.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architecture.rst#_snippet_9
  - question: What is the role of the `ContainerConfigurator` object when
      configuring services or routes in a PHP configuration file (e.g.,
      `config/services.php`) in Symfony 7?
    answers:
      - value: It provides methods to import other configuration files and define
          service parameters.
        correct: true
      - value: It represents the entire Dependency Injection Container itself.
        correct: false
      - value: It is used to define new controller actions.
        correct: false
      - value: It is a service that can be autowired into other services.
        correct: false
    help: The `ContainerConfigurator` object is passed to PHP configuration files
      and provides a fluent API to define services, parameters, and import other
      configurations.
  - question: When building a form type in Symfony, what is the purpose of the
      `getParent()` method?
    answers:
      - value: To return the fully-qualified class name of the parent form type from
          which the current type inherits functionality.
        correct: true
      - value: To get the parent form object in the form hierarchy.
        correct: false
      - value: To define the parent entity for a data-bound form.
        correct: false
      - value: To retrieve the parent Twig template for rendering.
        correct: false
    help: The `getParent()` method is used in custom form types to specify which
      existing form type they extend, allowing for shared functionality without
      direct PHP inheritance.
      https://github.com/symfony/symfony-docs/blob/7.3/form/create_custom_field_type.rst#_snippet_3
  - question: Which of the following is a valid way to define a prototyped array of
      scalar values in Symfony's Config component, and how would it appear in
      YAML?
    answers:
      - value: |-
          PHP: `->scalarPrototype()->end()`
          YAML: `drivers: ['mysql', 'sqlite']`
        correct: true
      - value: |-
          PHP: `->arrayPrototype()->scalarNode()->end()`
          YAML: `drivers: { 0: mysql, 1: sqlite }`
        correct: false
      - value: |-
          PHP: `->scalarNode()->arrayPrototype()->end()`
          YAML: `drivers:
              - mysql
              - sqlite`
        correct: false
      - value: |-
          PHP: `->prototype('scalar')->end()`
          YAML: `drivers: mysql, sqlite`
        correct: false
    help: The `scalarPrototype()` method is used to define a numerically indexed
      array where each element is a scalar value. In YAML, this is represented
      as a simple list.
      https://github.com/symfony/symfony-docs/blob/7.3/components/config/definition.rst#_snippet_13
  - question: What is the primary benefit of using `HandleTrait` in a class within
      the Symfony Messenger component for synchronous query handling?
    answers:
      - value: It provides a convenient `handle()` method to dispatch a message and
          immediately retrieve its result, suitable for query buses.
        correct: true
      - value: It automatically makes the class a message handler.
        correct: false
      - value: It enables asynchronous processing of messages.
        correct: false
      - value: It ensures that messages are always retried on failure.
        correct: false
    help: The `HandleTrait` simplifies synchronous message dispatching, allowing you
      to send a message and directly get the result back, which is common for
      query patterns in CQRS.
      https://github.com/symfony/symfony-docs/blob/7.3/messenger.rst#_snippet_78
  - question: Which of the following is NOT a valid built-in type returned by
      `Symfony\Component\PropertyInfo\Type::getBuiltInType()`?
    answers:
      - value: "'resource'"
        correct: false
      - value: "'void'"
        correct: true
      - value: "'array'"
        correct: false
      - value: "'callable'"
        correct: false
      - value: "'iterable'"
        correct: false
    help: The `Type::getBuiltInType()` method returns one of the standard PHP
      built-in types. 'void' is a return type declaration in PHP, but not a
      built-in data type that a property can hold.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_info.rst#_snippet_15
  - question: What is the purpose of the `getLogDir()` method in a custom Symfony
      Kernel (especially in a multi-application setup)?
    answers:
      - value: To define the directory where application logs should be stored.
        correct: true
      - value: To retrieve the path to the application's source code.
        correct: false
      - value: To specify the directory for cached files.
        correct: false
      - value: To get the path to the application's configuration files.
        correct: false
    help: The `getLogDir()` method in the Kernel determines the location for log
      files. In multi-application setups, it can be overridden to separate logs
      per application.
      https://github.com/symfony/symfony-docs/blob/7.3/configuration/multiple_kernels.rst#_snippet_3
  - question: Which of the following is a key characteristic of Symfony's approach
      to backward compatibility?
    answers:
      - value: Public APIs are stable within a major version, and breaking changes are
          announced via deprecations.
        correct: true
      - value: All internal classes and methods are guaranteed to be stable across all
          versions.
        correct: false
      - value: New features are immediately introduced with breaking changes to
          encourage rapid adoption.
        correct: false
      - value: Backward compatibility is only maintained for LTS releases.
        correct: false
    help: Symfony's BCP focuses on stability of public APIs within a major version,
      using deprecations to signal upcoming breaking changes in the next major
      release.
  - question: What is the primary reason for using `array_rand()` when generating a
      random greeting in a service like `GreetingGenerator`?
    answers:
      - value: To select a random key from an array, which can then be used to retrieve
          a random value.
        correct: true
      - value: To shuffle the entire array of greetings.
        correct: false
      - value: To ensure that each greeting is returned only once.
        correct: false
      - value: To sort the greetings alphabetically.
        correct: false
    help: "`array_rand()` returns one or more random keys from an array, allowing
      you to then access the corresponding random value.
      https://github.com/symfony/symfony-docs/blob/7.3/quick_tour/the_architect\
      ure.rst#_snippet_3"
  - question: "When defining a routing attribute like `#[Route('/hello/{name}',
      name: 'hello')]`, what does the `name` parameter signify?"
    answers:
      - value: A unique identifier for the route, used for generating URLs and
          referencing it in code.
        correct: true
      - value: The name of the controller action that handles the route.
        correct: false
      - value: The default value for the `name` path parameter.
        correct: false
      - value: A human-readable title for the route in debugging tools.
        correct: false
    help: The `name` parameter in a route attribute provides a unique identifier,
      which is essential for generating URLs with `url_for()` or `path()` in
      Twig, or `generateUrl()` in controllers.
  - question: Which of the following is a valid way to define a service in Symfony 7
      using PHP attributes for autoconfiguration?
    answers:
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\DependencyInjection\Attribute\Autoconfigure;

          #[Autoconfigure]
          class MyService
          {
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\DependencyInjection\Attribute\Service;

          #[Service]
          class MyService
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          namespace App\Service;

          #[AsService]
          class MyService
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          // config/services.yaml
          services:
              App\Service\MyService:
                  autowire: true
          ```
        correct: false
    help: While `config/services.yaml` is common, services can also be
      autoconfigured using attributes like `#[Autoconfigure]` or `#[AsService]`
      (if a specific bundle provides it) directly on the class.
  - question: What is the purpose of the `getCacheDir()` method in a custom Symfony
      Kernel?
    answers:
      - value: To define the directory where the application's cache files are stored.
        correct: true
      - value: To retrieve the path to the application's log files.
        correct: false
      - value: To specify the directory for Composer dependencies.
        correct: false
      - value: To get the path to the application's public assets.
        correct: false
    help: The `getCacheDir()` method determines the location for Symfony's cache
      files, which include compiled container, routes, and Twig templates. It's
      often customized in multi-application setups.
      https://github.com/symfony/symfony-docs/blob/7.3/configuration/multiple_kernels.rst#_snippet_3
  - question: Which of the following is a common practice for managing database
      schema changes in a Symfony application?
    answers:
      - value: Using Doctrine Migrations.
        correct: true
      - value: Manually executing SQL commands on the production server.
        correct: false
      - value: Modifying the database schema directly via a GUI tool.
        correct: false
      - value: Relying solely on `doctrine:schema:update --force`.
        correct: false
    help: Doctrine Migrations provide a robust and version-controlled way to manage
      database schema changes, ensuring consistency across environments and
      deployments.
  - question: What is the purpose of the `#[ORM\Column]` attribute in a Doctrine
      entity in Symfony 7?
    answers:
      - value: To map a PHP property to a database column and define its characteristics
          (e.g., type, length, nullability).
        correct: true
      - value: To define a route for the entity.
        correct: false
      - value: To inject services into the entity.
        correct: false
      - value: To specify the entity's primary key.
        correct: false
    help: The `#[ORM\Column]` attribute is used by Doctrine ORM to define how a PHP
      property corresponds to a column in the database table, including its data
      type and other constraints.
      https://github.com/symfony/symfony-docs/blob/7.3/doctrine.rst#_snippet_11
  - question: In a flat PHP application, what is a significant disadvantage compared
      to a Symfony application regarding database interaction?
    answers:
      - value: Direct embedding of SQL queries and connection logic within presentation
          code, leading to poor separation of concerns.
        correct: true
      - value: Inability to connect to a database.
        correct: false
      - value: Slower database query execution.
        correct: false
      - value: Lack of support for prepared statements.
        correct: false
    help: Flat PHP applications often mix database logic with HTML, making them hard
      to maintain, test, and scale, unlike Symfony which promotes clear
      separation of concerns (e.g., using Doctrine for ORM).
      https://github.com/symfony/symfony-docs/blob/7.3/introduction/from_flat_php_to_symfony.rst#_snippet_0
  - question: What is the primary benefit of using `Psr\Log\LoggerInterface` for
      logging in Symfony, rather than directly using a concrete logger class
      like `Monolog\Logger`?
    answers:
      - value: It allows for easy swapping of logging implementations without modifying
          application code.
        correct: true
      - value: It provides more logging levels than concrete implementations.
        correct: false
      - value: It automatically sends logs to external services.
        correct: false
      - value: It is faster than using concrete logger classes.
        correct: false
    help: Adhering to PSR-3's `LoggerInterface` promotes interoperability. Your code
      depends on an interface, not a specific implementation, making it flexible
      and testable.
  - question: Which of the following is a common method used by
      `PropertyInfoExtractor` to get a list of properties for a given class?
    answers:
      - value: "`getProperties()`"
        correct: true
      - value: "`getAttributes()`"
        correct: false
      - value: "`getFields()`"
        correct: false
      - value: "`getMembers()`"
        correct: false
    help: The `PropertyInfoExtractor` provides a `getProperties()` method (from
      `PropertyListExtractorInterface`) to list the properties of a class.
      https://github.com/symfony/symfony-docs/blob/7.3/components/property_info.rst#_snippet_4
  - question: When defining a custom service in Symfony, what is the best practice
      for making it available for autowiring?
    answers:
      - value: Place the service class in the `src/` directory and ensure it's correctly
          namespaced.
        correct: true
      - value: "Manually register the service in `config/services.yaml` with `autowire:
          true`."
        correct: false
      - value: Add a `#[Service]` attribute to the class.
        correct: false
      - value: Implement the `ContainerAwareInterface`.
        correct: false
    help: By default, Symfony autowires services located in the `src/` directory
      based on their class names and type hints, provided they are correctly
      namespaced.
  - question: What is the primary purpose of the `composer.json` file in a Symfony 7
      project?
    answers:
      - value: To declare the project's dependencies and metadata, managed by Composer.
        correct: true
      - value: To define the application's routing configuration.
        correct: false
      - value: To store environment-specific variables.
        correct: false
      - value: To configure the Symfony Flex recipes.
        correct: false
    help: The `composer.json` file is Composer's manifest, listing all direct and
      indirect dependencies of the project, as well as other project metadata.
  - question: Which of the following is a benefit of using environment variables
      (e.g., `APP_ENV`, `DATABASE_URL`) in Symfony 7 applications?
    answers:
      - value: They allow configuration to be easily changed between different
          deployment environments without modifying code.
        correct: true
      - value: They are automatically encrypted, providing enhanced security for
          sensitive data.
        correct: false
      - value: They eliminate the need for a Dependency Injection Container.
        correct: false
      - value: They improve the performance of the application by caching configuration
          values.
        correct: false
    help: Environment variables are a standard practice for managing configuration
      that varies between environments (development, testing, production)
      without hardcoding values into the application's source code.
  - question: What is the role of the `vendor/autoload.php` file in a Symfony 7
      application?
    answers:
      - value: It registers Composer's autoloader, making all installed classes
          available without manual `require` statements.
        correct: true
      - value: It contains the main application logic.
        correct: false
      - value: It defines all the application's services.
        correct: false
      - value: It handles all incoming HTTP requests.
        correct: false
    help: The `vendor/autoload.php` file, generated by Composer, is crucial for PHP
      applications as it sets up the autoloader, allowing classes from installed
      packages and your application to be loaded on demand.
  - question: Which of the following is a characteristic of a Symfony Bundle?
    answers:
      - value: It is a structured set of files (PHP classes, configuration, templates)
          that implements a feature and can be reused.
        correct: true
      - value: It is a lightweight component that provides a single, specific
          functionality.
        correct: false
      - value: It is a standalone executable application.
        correct: false
      - value: It is a database migration script.
        correct: false
    help: A Symfony Bundle is similar to a plugin in other software. It's a
      directory structure that holds everything related to a feature, including
      controllers, services, configuration, and templates, making it reusable.
  - question: What is the purpose of the `config/bundles.php` file in a Symfony 7
      application?
    answers:
      - value: It registers all the bundles that are enabled in the application for
          different environments.
        correct: true
      - value: It defines the application's database connections.
        correct: false
      - value: It contains the application's security configuration.
        correct: false
      - value: It lists all the services available in the container.
        correct: false
    help: The `config/bundles.php` file is where you declare which Symfony bundles
      your application uses, often conditionally based on the environment (e.g.,
      `dev`, `test`, `prod`).
  - question: When developing a Symfony application, what is the recommended
      approach for managing static assets (CSS, JavaScript, images)?
    answers:
      - value: Using Symfony's Asset component and a tool like Webpack Encore for asset
          compilation and versioning.
        correct: true
      - value: Hardcoding asset URLs directly in Twig templates.
        correct: false
      - value: Storing all assets in the `src/` directory.
        correct: false
      - value: Manually adding query strings to asset URLs for cache busting.
        correct: false
    help: Symfony's Asset component, often combined with Webpack Encore, provides
      robust features for managing, processing, and versioning static assets,
      improving performance and maintainability.
      https://github.com/symfony/symfony-docs/blob/7.3/components/asset.rst#_snippet_0
  - question: What is the primary benefit of using `#[AsCommand]` attribute for
      console commands in Symfony 7?
    answers:
      - value: It allows console commands to be automatically registered as services and
          configured directly in the class.
        correct: true
      - value: It enables the command to be executed directly from a web browser.
        correct: false
      - value: It injects all available services into the command automatically.
        correct: false
      - value: It makes the command available globally on the system path.
        correct: false
    help: The `#[AsCommand]` attribute simplifies the definition and registration of
      console commands, allowing you to specify the command name and description
      directly on the class.
      https://symfony.com/doc/current/console.html#configuring-the-command
  - question: Which of the following describes the purpose of the `getProjectDir()`
      method in a Symfony Kernel?
    answers:
      - value: It returns the absolute path to the root directory of the Symfony
          project.
        correct: true
      - value: It returns the path to the `src/` directory.
        correct: false
      - value: It returns the path to the `public/` directory.
        correct: false
      - value: It returns the path to the `vendor/` directory.
        correct: false
    help: The `getProjectDir()` method is a utility method provided by the Kernel to
      get the root directory of the Symfony project, which is useful for
      resolving other paths.
  - question: What is the general principle behind Symfony's approach to framework
      interoperability?
    answers:
      - value: Adherence to PHP Standards Recommendations (PSRs) and providing decoupled
          components.
        correct: true
      - value: Encouraging the use of Symfony-specific proprietary standards.
        correct: false
      - value: Requiring all dependencies to be Symfony components.
        correct: false
      - value: Limiting integration with other frameworks or libraries.
        correct: false
    help: Symfony is designed with interoperability in mind, largely achieved
      through its adherence to PSRs and its component-based architecture,
      allowing its parts to be used independently or with other frameworks.
  - question: What is the main advantage of using `#[Autowire]` attribute for
      specific service injection in Symfony 7?
    answers:
      - value: It allows injecting a specific service by its ID when type-hinting alone
          is ambiguous or insufficient.
        correct: true
      - value: It replaces the need for type-hinting in constructors.
        correct: false
      - value: It makes the service public and globally accessible.
        correct: false
      - value: It automatically creates a new instance of the service on every
          injection.
        correct: false
    help: The `#[Autowire]` attribute is useful when you need to inject a specific
      service by its ID, especially when multiple services implement the same
      interface or when injecting a scalar value.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-specific-services
