category: Symfony Architecture
questions:
  - question: What is the primary purpose of Symfony Flex in a Symfony 7.0 application?
    answers:
      - value: To manage application dependencies and automate common tasks through
          recipes.
        correct: true
      - value: To provide a graphical user interface for Symfony development.
        correct: false
      - value: To replace Composer as the primary package manager.
        correct: false
      - value: To generate database migrations automatically.
        correct: false
    help: Symfony Flex is a Composer plugin that automates common tasks for Symfony
      applications, such as installing and configuring bundles, by applying
      'recipes'.
  - question: When installing a new Symfony component like `symfony/monolog-bundle`
      using Composer Flex, what typically happens regarding configuration?
    answers:
      - value: Flex automatically creates or updates configuration files (e.g.,
          `config/packages/monolog.yaml`).
        correct: true
      - value: You must manually create all configuration files after installation.
        correct: false
      - value: Flex only installs the code; configuration is handled by a separate
          Symfony command.
        correct: false
      - value: The component is immediately functional without any configuration.
        correct: false
    help: Symfony Flex applies 'recipes' during Composer operations, which often
      include setting up initial configuration files for installed bundles and
      components.
  - question: Which file is automatically updated by Symfony Flex to include
      environment variables like `DATABASE_URL` after installing a package like
      `doctrine/doctrine-bundle`?
    answers:
      - value: "`.env`"
        correct: true
      - value: "`config/services.yaml`"
        correct: false
      - value: "`composer.json`"
        correct: false
      - value: "`public/index.php`"
        correct: false
    help: Symfony Flex recipes commonly add or modify entries in the `.env` file to
      manage environment-specific configurations like database connection
      strings.
  - question: What is the purpose of the `symfony.lock` file generated by Symfony Flex?
    answers:
      - value: It tracks the exact versions of Symfony recipes applied to the project.
        correct: true
      - value: It locks the Composer dependencies to specific versions.
        correct: false
      - value: It stores the application's secret key.
        correct: false
      - value: It defines the application's routing configuration.
        correct: false
    help: The `symfony.lock` file records which Symfony Flex recipes have been
      applied to your project, ensuring consistent recipe application across
      different environments.
  - question: Which command is used to create a new Symfony 7.0 project using the
      Symfony CLI, leveraging Symfony Flex internally?
    answers:
      - value: "`symfony new my_project_directory`"
        correct: true
      - value: "`composer create-project symfony/skeleton my_project_directory`"
        correct: true
      - value: "`php bin/console init`"
        correct: false
      - value: "`symfony create my_project_directory`"
        correct: false
    help: The `symfony new` command is the recommended way to create new Symfony
      projects, and it internally uses Composer to create the project based on
      the Symfony skeleton and Flex.
  - question: Which of the following is a core principle of Symfony's
      component-based architecture?
    answers:
      - value: Each component is a standalone library that can be used independently.
        correct: true
      - value: Components are tightly coupled and cannot be used without the full
          framework.
        correct: false
      - value: Components are primarily designed for frontend development.
        correct: false
      - value: All components must be installed via Symfony Flex.
        correct: false
    help: Symfony is built as a collection of decoupled components, allowing
      developers to use only the parts they need, even outside of a full Symfony
      application.
  - question: The `symfony/http-foundation` component provides which fundamental
      classes for handling web requests?
    answers:
      - value: "`Request` and `Response`"
        correct: true
      - value: "`Controller` and `Service`"
        correct: false
      - value: "`EntityManager` and `Repository`"
        correct: false
      - value: "`EventDispatcher` and `EventListener`"
        correct: false
    help: The HttpFoundation component defines an object-oriented layer for the HTTP
      specification, providing the `Request` and `Response` classes to abstract
      HTTP interactions.
  - question: Which Symfony component is responsible for managing object
      dependencies and injecting them into classes?
    answers:
      - value: DependencyInjection
        correct: true
      - value: EventDispatcher
        correct: false
      - value: HttpFoundation
        correct: false
      - value: Routing
        correct: false
    help: The DependencyInjection component provides a powerful and flexible way to
      manage services and their dependencies, promoting loose coupling and
      testability.
  - question: What is the primary role of the `symfony/routing` component?
    answers:
      - value: To match incoming URLs to specific controller actions.
        correct: true
      - value: To handle form submissions and validation.
        correct: false
      - value: To manage database connections.
        correct: false
      - value: To send emails.
        correct: false
    help: The Routing component is responsible for parsing incoming request URLs and
      determining which controller and action should handle them.
  - question: Which component provides the `LoggerInterface` that Symfony's
      autowiring can inject for logging purposes?
    answers:
      - value: Psr\Log\LoggerInterface (from PSR-3)
        correct: true
      - value: Symfony\Component\HttpKernel\Log\LoggerInterface
        correct: false
      - value: Symfony\Component\Monolog\LoggerInterface
        correct: false
      - value: App\Service\LoggerInterface
        correct: false
    help: Symfony integrates with PSR-3, the standard for logging interfaces.
      Therefore, `Psr\Log\LoggerInterface` is the correct type-hint for
      autowiring a logger.
  - question: The `symfony/messenger` component is primarily used for what
      architectural pattern?
    answers:
      - value: Message queuing and asynchronous processing.
        correct: true
      - value: Request-response cycle management.
        correct: false
      - value: Database abstraction.
        correct: false
      - value: User authentication and authorization.
        correct: false
    help: The Messenger component provides tools for sending and receiving messages,
      enabling asynchronous processing, queuing, and event-driven architectures
      (like CQRS).
  - question: Which component is essential for adding form handling capabilities to
      a Symfony application?
    answers:
      - value: symfony/form
        correct: true
      - value: symfony/http-client
        correct: false
      - value: symfony/mailer
        correct: false
      - value: symfony/workflow
        correct: false
    help: The Symfony Form component provides a flexible and powerful way to create,
      process, and display forms in your application.
  - question: What is a 'bridge' in the context of Symfony components?
    answers:
      - value: A component that integrates a third-party library with Symfony's core
          functionalities.
        correct: true
      - value: A deprecated Symfony component.
        correct: false
      - value: A mechanism for connecting two different Symfony applications.
        correct: false
      - value: A type of database connection.
        correct: false
    help: Bridges are Symfony components that provide integration between Symfony's
      core features and popular third-party libraries, allowing them to work
      seamlessly together (e.g., TwigBridge, MonologBridge).
  - question: Consider a Symfony application that needs to gradually migrate from a
      legacy PHP application. Which approach involving a 'bridge' is
      demonstrated for handling requests?
    answers:
      - value: The Symfony front controller handles requests, and if a route is not
          found, it delegates to a legacy bridge.
        correct: true
      - value: The legacy application handles all requests and calls Symfony for
          specific functionalities.
        correct: false
      - value: Both Symfony and the legacy application run on separate web servers and
          communicate via API.
        correct: false
      - value: A bridge converts all legacy code into Symfony bundles.
        correct: false
    help: A common migration strategy involves setting up Symfony as the primary
      front controller and, if Symfony cannot handle a request (e.g., 404),
      delegating it to the legacy application via a bridge.
  - question: What is the recommended directory structure for a Symfony 7.0 project,
      especially for source code?
    answers:
      - value: "`src/` for all application-specific PHP code (controllers, services,
          entities)."
        correct: true
      - value: "`app/` for all application logic."
        correct: false
      - value: "`bundle/` for custom bundles."
        correct: false
      - value: "`lib/` for third-party libraries."
        correct: false
    help: The `src/` directory is the standard location for all your application's
      custom PHP code, including controllers, services, entities, commands, and
      more.
  - question: Which directory typically contains the main entry point (`index.php`)
      for a Symfony 7.0 web application?
    answers:
      - value: "`public/`"
        correct: true
      - value: "`bin/`"
        correct: false
      - value: "`config/`"
        correct: false
      - value: "`var/`"
        correct: false
    help: The `public/` directory is the web root of your Symfony application, and
      `public/index.php` serves as the front controller for all incoming web
      requests.
  - question: Where are Symfony's main configuration files (e.g., `services.yaml`,
      `routes.yaml`, `bundles.php`) located by default?
    answers:
      - value: "`config/`"
        correct: true
      - value: "`app/config/`"
        correct: false
      - value: "`src/config/`"
        correct: false
      - value: "`var/config/`"
        correct: false
    help: The `config/` directory holds all the application's configuration files,
      including those for services, routing, and registered bundles.
  - question: How does Symfony typically handle autoloading for classes within the
      `App` namespace, mapped to the `src/` directory?
    answers:
      - value: Via PSR-4 autoloading configured in `composer.json`.
        correct: true
      - value: Through a custom autoloader defined in `public/index.php`.
        correct: false
      - value: By scanning the entire `src/` directory at runtime.
        correct: false
      - value: Using a global `require_once` for each class.
        correct: false
    help: Symfony applications leverage Composer's PSR-4 autoloading standard, where
      the `App\` namespace is typically mapped to the `src/` directory in
      `composer.json`.
  - question: What is the purpose of creating a custom service like
      `GreetingGenerator` in Symfony?
    answers:
      - value: To encapsulate reusable business logic.
        correct: true
      - value: To define new database entities.
        correct: false
      - value: To handle HTTP requests directly.
        correct: false
      - value: To generate Twig templates.
        correct: false
    help: Custom services allow you to organize and encapsulate specific business
      logic, making your code more modular, reusable, and testable.
  - question: When injecting a service into another service's constructor, how does
      Symfony's autowiring typically resolve the dependency?
    answers:
      - value: By type-hinting the service's class or interface.
        correct: true
      - value: By explicitly defining the service ID in a configuration file.
        correct: false
      - value: By using a global variable.
        correct: false
      - value: By manually instantiating the dependent service.
        correct: false
    help: Symfony's autowiring automatically identifies and injects dependencies
      based on type-hints in constructors, methods, or properties, reducing the
      need for explicit configuration.
  - question: Which command can you use to list all services and interfaces that
      Symfony can autowire into your classes?
    answers:
      - value: "`php bin/console debug:autowiring`"
        correct: true
      - value: "`php bin/console debug:container`"
        correct: false
      - value: "`php bin/console list:services`"
        correct: false
      - value: "`php bin/console show:dependencies`"
        correct: false
    help: The `debug:autowiring` command is a powerful tool for inspecting which
      services and interfaces are available for autowiring in your application's
      dependency injection container.
  - question: What is the role of the `public/index.php` file in a Symfony 7.0
      application?
    answers:
      - value: It acts as the front controller, handling all incoming HTTP requests.
        correct: true
      - value: It contains all the application's business logic.
        correct: false
      - value: It is responsible for rendering Twig templates.
        correct: false
      - value: It defines the database schema.
        correct: false
    help: The `index.php` file in the `public/` directory is the single entry point
      for all web requests, initializing the Symfony kernel and dispatching the
      request.
  - question: In Symfony 7.0, how are routes typically defined for controllers using
      PHP attributes?
    answers:
      - value: Using the `#[Route]` attribute directly above controller methods.
        correct: true
      - value: In `config/routes.yaml` files.
        correct: false
      - value: In `config/routes.xml` files.
        correct: false
      - value: By implementing a `RouteInterface` in the controller.
        correct: false
    help: Symfony 7.0 heavily relies on PHP attributes (like `#[Route]`) for
      defining routes directly within controller classes, simplifying routing
      configuration.
  - question: |-
      ```yaml
      blog_show:
          path:     /blog/show/{id}
          controller: App\\Controller\\BlogController::show
      ```
    answers:
      - value: "`$this->generateUrl('blog_show', ['id' => 10])`"
        correct: true
      - value: "`$this->redirectToRoute('blog_show', ['id' => 10])`"
        correct: false
      - value: "`$this->url('blog_show', ['id' => 10])`"
        correct: false
      - value: "`$this->router->generate('blog_show', ['id' => 10])`"
        correct: true
    help: The `generateUrl()` method (available in `AbstractController`) and the
      `generate()` method of the `RouterInterface` are used to create URLs from
      route names and parameters.
  - question: What is the purpose of the `Request` object in Symfony's request
      handling process?
    answers:
      - value: It encapsulates all information from the HTTP request (headers, GET/POST
          parameters, etc.).
        correct: true
      - value: It represents the HTTP response to be sent back to the client.
        correct: false
      - value: It defines the application's routing rules.
        correct: false
      - value: It manages database transactions.
        correct: false
    help: The `Request` object, provided by the HttpFoundation component, is a
      powerful abstraction of the raw HTTP request, making it easy to access
      request data.
  - question: Which class is typically extended by Symfony controllers to gain
      access to helper methods like `render()`, `generateUrl()`, and
      `redirectToRoute()`?
    answers:
      - value: "`Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController`"
        correct: true
      - value: "`Symfony\\Component\\HttpFoundation\\Controller\\Controller`"
        correct: false
      - value: "`App\\Controller\\BaseController`"
        correct: false
      - value: "`Psr\\Container\\ContainerInterface`"
        correct: false
    help: Extending `AbstractController` provides convenient access to commonly used
      services and methods without needing to manually inject them.
  - question: How can you configure the Symfony router to have `strict_requirements`
      set to `null` only in the `prod` environment using YAML?
    answers:
      - value: |-
          ```yaml
          when@prod:
              framework:
                  router:
                      strict_requirements: null
          ```
        correct: true
      - value: |-
          ```yaml
          framework:
              router:
                  strict_requirements:
                      prod: null
          ```
        correct: false
      - value: |-
          ```yaml
          if env == 'prod':
              framework:
                  router:
                      strict_requirements: null
          ```
        correct: false
      - value: |-
          ```yaml
          prod:
              framework:
                  router:
                      strict_requirements: null
          ```
        correct: false
    help: Symfony's `when@env` syntax in configuration files allows you to apply
      specific configurations only when the application is running in a
      particular environment.
  - question: What is the primary benefit of using a single front controller
      (`index.php`) in a Symfony application compared to direct file access
      (e.g., `show.php`, `list.php`)?
    answers:
      - value: Centralized request handling, routing, and bootstrapping.
        correct: true
      - value: Improved SEO by hiding file extensions.
        correct: false
      - value: Reduced server load.
        correct: false
      - value: Elimination of the need for a web server.
        correct: false
    help: A front controller centralizes the entire request lifecycle, allowing for
      consistent bootstrapping, security, routing, and error handling across the
      application.
  - question: When a Symfony controller needs to return an HTTP 404 'Not Found'
      response, which method from `AbstractController` can be used?
    answers:
      - value: "`$this->createNotFoundException()`"
        correct: true
      - value: "`$this->notFound()`"
        correct: false
      - value: "`new Response('', Response::HTTP_NOT_FOUND)`"
        correct: true
      - value: "`$this->error(404)`"
        correct: false
    help: The `createNotFoundException()` helper method is a convenient way to throw
      a `NotFoundHttpException`, which Symfony's exception listener will catch
      and convert into a 404 HTTP response.
  - question: What is the purpose of the `EventDispatcher` component in Symfony?
    answers:
      - value: To allow different parts of an application to communicate without tight
          coupling.
        correct: true
      - value: To manage database connections.
        correct: false
      - value: To handle HTTP requests and responses.
        correct: false
      - value: To render Twig templates.
        correct: false
    help: The EventDispatcher component implements the Observer pattern, enabling a
      publish-subscribe mechanism where components can dispatch events and other
      components can listen and react to them.
  - question: How do you register an event listener with the `TraceableEventDispatcher`?
    answers:
      - value: Using the `addListener()` method.
        correct: true
      - value: By defining it as a service with a specific tag.
        correct: true
      - value: By extending `AbstractEventListener`.
        correct: false
      - value: Through a configuration file only.
        correct: false
    help: Event listeners can be registered programmatically using `addListener()`
      or automatically via service tags (e.g., `kernel.event_listener`) in the
      dependency injection container.
  - question: Which of the following is considered an official best practice for
      Symfony project structure?
    answers:
      - value: Keeping the `src/` directory flat and self-explanatory.
        correct: true
      - value: Placing all configuration files directly in the project root.
        correct: false
      - value: Storing all assets directly in the `public/` directory without
          subfolders.
        correct: false
      - value: Manually managing vendor dependencies.
        correct: false
    help: Symfony best practices advocate for a clear, flat `src/` directory
      structure that is easy to navigate and understand, promoting good code
      organization.
  - question: What is the recommended way to create a new Symfony application that
      includes a fully functional demo to learn from?
    answers:
      - value: "`symfony new my_project_directory --demo`"
        correct: true
      - value: "`composer create-project symfony/symfony-demo my_project_directory`"
        correct: false
      - value: "`php bin/console install:demo`"
        correct: false
      - value: "`symfony demo my_project_directory`"
        correct: false
    help: The `--demo` flag with `symfony new` command creates a project based on
      the Symfony Demo application, which is a great learning resource.
  - question: What is the purpose of the `bin/console` executable in a Symfony project?
    answers:
      - value: To run command-line tasks and interact with the Symfony application.
        correct: true
      - value: To start the built-in web server.
        correct: false
      - value: To compile frontend assets.
        correct: false
      - value: To manage database migrations only.
        correct: false
    help: The `bin/console` script is the entry point for all command-line
      interactions with your Symfony application, providing access to various
      commands for development, debugging, and deployment.
  - question: Which command provides general information about your current Symfony
      project, including its version and environment?
    answers:
      - value: "`php bin/console about`"
        correct: true
      - value: "`php bin/console info`"
        correct: false
      - value: "`php bin/console status`"
        correct: false
      - value: "`php bin/console version`"
        correct: false
    help: The `about` command displays a summary of your Symfony project, including
      its environment, kernel details, and installed bundles.
  - question: What is Symfony's general policy regarding backward compatibility?
    answers:
      - value: Symfony aims for strong backward compatibility within major versions.
        correct: true
      - value: Backward compatibility is not a priority; breaking changes are common.
        correct: false
      - value: Backward compatibility is only guaranteed for LTS releases.
        correct: false
      - value: All public APIs are guaranteed to never change.
        correct: false
    help: Symfony has a strong backward compatibility promise within its major
      versions, meaning that code written for Symfony 7.0 should continue to
      work with future minor releases of Symfony 7.x.
  - question: When a feature is deprecated in Symfony, what is the typical process?
    answers:
      - value: It is marked as deprecated, and a clear migration path is provided before
          its removal in a future major version.
        correct: true
      - value: It is immediately removed without warning.
        correct: false
      - value: It is replaced by a new feature in the same minor version.
        correct: false
      - value: It remains indefinitely but is no longer maintained.
        correct: false
    help: Symfony follows a deprecation policy where features are first marked as
      deprecated, providing developers with time and guidance to migrate their
      code before the feature is eventually removed in a new major version.
  - question: What is the significance of Long Term Support (LTS) releases in
      Symfony's release management?
    answers:
      - value: LTS releases receive bug fixes and security updates for a longer period
          (typically 3 years).
        correct: true
      - value: LTS releases introduce major breaking changes.
        correct: false
      - value: LTS releases are only for experimental features.
        correct: false
      - value: LTS releases are updated monthly.
        correct: false
    help: LTS releases are designed for projects requiring long-term stability and
      support, offering extended maintenance periods for bug fixes and security
      patches.
  - question: Which PHP standard (PSR) does Symfony adhere to for logging interfaces?
    answers:
      - value: PSR-3 (Logger Interface)
        correct: true
      - value: PSR-7 (HTTP Message Interfaces)
        correct: false
      - value: PSR-11 (Container Interface)
        correct: false
      - value: PSR-4 (Autoloader)
        correct: false
    help: Symfony uses PSR-3 for its logging capabilities, allowing seamless
      integration with various logging libraries that implement this standard.
  - question: Which PHP standard (PSR) is commonly used for autoloading classes in
      Symfony projects?
    answers:
      - value: PSR-4 (Autoloader)
        correct: true
      - value: PSR-1 (Basic Coding Standard)
        correct: false
      - value: PSR-2 (Coding Style Guide)
        correct: false
      - value: PSR-6 (Caching Interface)
        correct: false
    help: Symfony, like most modern PHP frameworks, relies on Composer's
      implementation of PSR-4 for autoloading classes based on their namespace
      and file path.
  - question: What is the recommended naming convention for Symfony services defined
      in `services.yaml`?
    answers:
      - value: Lowercase with dots (e.g., `app.my_service`).
        correct: true
      - value: CamelCase (e.g., `myService`).
        correct: false
      - value: PascalCase (e.g., `MyService`).
        correct: false
      - value: Uppercase with underscores (e.g., `MY_SERVICE`).
        correct: false
    help: The official Symfony best practices recommend using lowercase service IDs
      with dots as separators (e.g., `app.service_name`).
  - question: When defining a controller method in Symfony, what is the recommended
      naming convention?
    answers:
      - value: CamelCase, typically ending with `Action` (e.g., `indexAction`).
        correct: false
      - value: CamelCase, descriptive of its action (e.g., `list`, `show`).
        correct: true
      - value: Snake_case (e.g., `list_posts`).
        correct: false
      - value: All lowercase (e.g., `index`).
        correct: false
    help: Symfony best practices suggest using descriptive camelCase names for
      controller methods, without the `Action` suffix, as it's no longer
      required.
  - question: Which of the following is NOT a core component of the Symfony Framework?
    answers:
      - value: Doctrine ORM
        correct: true
      - value: HttpFoundation
        correct: false
      - value: Routing
        correct: false
      - value: DependencyInjection
        correct: false
    help: Doctrine ORM is a popular third-party library that integrates well with
      Symfony, but it is not a core component of the Symfony Framework itself.
  - question: What is the purpose of the `var/cache/` directory in a Symfony application?
    answers:
      - value: To store cached data, such as compiled templates and service container
          definitions.
        correct: true
      - value: To store application logs.
        correct: false
      - value: To store database files.
        correct: false
      - value: To store user-uploaded files.
        correct: false
    help: The `var/cache/` directory is where Symfony stores its generated cache
      files, which are crucial for performance in production environments.
  - question: Which environment variable is typically used to switch a Symfony
      application between 'dev' and 'prod' modes?
    answers:
      - value: "`APP_ENV`"
        correct: true
      - value: "`SYMFONY_ENV`"
        correct: false
      - value: "`ENV`"
        correct: false
      - value: "`APP_MODE`"
        correct: false
    help: The `APP_ENV` environment variable, usually set in the `.env` file,
      controls the current environment of the Symfony application (e.g., `dev`,
      `prod`, `test`).
  - question: What is the primary function of the `Response` object returned by a
      Symfony controller?
    answers:
      - value: To encapsulate the HTTP response (content, headers, status code) to be
          sent to the client.
        correct: true
      - value: To process user input from forms.
        correct: false
      - value: To interact with the database.
        correct: false
      - value: To log messages to a file.
        correct: false
    help: The `Response` object, provided by HttpFoundation, is the representation
      of the HTTP response that your application sends back to the client.
  - question: How can you configure a global base URL for assets in Symfony 7.0
      using PHP configuration?
    answers:
      - value: |-
          ```php
          $framework->assets()
              ->baseUrls(['http://cdn.example.com/']);
          ```
        correct: true
      - value: |-
          ```php
          $framework->assets()
              ->baseUrl('http://cdn.example.com/');
          ```
        correct: false
      - value: |-
          ```php
          $framework->assets()
              ->setBaseUrl('http://cdn.example.com/');
          ```
        correct: false
      - value: |-
          ```php
          $framework->assets()
              ->addBaseUrl('http://cdn.example.com/');
          ```
        correct: false
    help: The `baseUrls()` method on the assets configuration allows you to define
      one or more base URLs for serving assets, which is useful for CDNs.
  - question: Which directory is typically used for Twig templates in a standard
      Symfony 7.0 project?
    answers:
      - value: "`templates/`"
        correct: true
      - value: "`views/`"
        correct: false
      - value: "`app/Resources/views/`"
        correct: false
      - value: "`src/Templates/`"
        correct: false
    help: The `templates/` directory is the default and recommended location for all
      your Twig template files in a Symfony 7.0 application.
  - question: What is the primary role of the `Kernel.php` file in a Symfony application?
    answers:
      - value: It is the core of the Symfony application, responsible for bootstrapping
          and handling requests.
        correct: true
      - value: It defines all the application's routes.
        correct: false
      - value: It manages database connections.
        correct: false
      - value: It contains all the application's services.
        correct: false
    help: The `Kernel.php` class is the central orchestrator of a Symfony
      application, responsible for loading bundles, configuring the environment,
      and managing the request lifecycle.
  - question: How does Symfony handle asset versioning to prevent caching issues
      during deployments?
    answers:
      - value: By appending a unique version string or hash to asset URLs.
        correct: true
      - value: By forcing browsers to re-download all assets on every request.
        correct: false
      - value: By storing assets in the database.
        correct: false
      - value: By using a different CDN for each deployment.
        correct: false
    help: Symfony's asset component can automatically add a version string (e.g., a
      hash of the file content or a fixed version number) to asset URLs,
      ensuring that browsers fetch the latest version after a deployment.
  - question: Which of the following is a key benefit of Symfony's Dependency
      Injection Container?
    answers:
      - value: It promotes loose coupling between components.
        correct: true
      - value: It eliminates the need for Composer.
        correct: false
      - value: It automatically generates database tables.
        correct: false
      - value: It provides a built-in ORM.
        correct: false
    help: The Dependency Injection Container is central to Symfony's architecture,
      enabling services to declare their dependencies rather than creating them,
      leading to more modular and testable code.
  - question: What is the purpose of the `composer.lock` file in a Symfony project?
    answers:
      - value: It records the exact versions of all installed Composer dependencies.
        correct: true
      - value: It defines the project's required packages.
        correct: false
      - value: It stores environment variables.
        correct: false
      - value: It is used for Symfony Flex recipes.
        correct: false
    help: The `composer.lock` file ensures that everyone working on the project uses
      the exact same versions of all dependencies, preventing 'works on my
      machine' issues.
  - question: What is the main advantage of using multiple message buses in Symfony
      Messenger, as shown in a CQRS architecture?
    answers:
      - value: To separate commands, queries, and events into distinct processing flows.
        correct: true
      - value: To improve database performance.
        correct: false
      - value: To reduce the number of services in the container.
        correct: false
      - value: To enable real-time communication with the frontend.
        correct: false
    help: Multiple message buses allow for a clear separation of concerns in a CQRS
      (Command Query Responsibility Segregation) architecture, where commands,
      queries, and events are handled by different buses with specific
      middleware and handlers.
  - question: How can you configure a specific asset package in Symfony to use its
      own versioning strategy, ignoring the default?
    answers:
      - value: |-
          ```php
          $framework->assets()->package('bar_package')
              ->versionStrategy('app.asset.another_version_strategy');
          ```
        correct: true
      - value: |-
          ```php
          $framework->assets()->package('bar_package')
              ->setVersionStrategy('app.asset.another_version_strategy');
          ```
        correct: false
      - value: |-
          ```php
          $framework->assets()->package('bar_package')
              ->version('app.asset.another_version_strategy');
          ```
        correct: false
      - value: |-
          ```php
          $framework->assets()->package('bar_package')
              ->strategy('app.asset.another_version_strategy');
          ```
        correct: false
    help: The `versionStrategy()` method allows you to specify a custom service that
      implements `VersionStrategyInterface` for a particular asset package,
      overriding the global strategy.
  - question: What is the purpose of the `#[AsCommand]` attribute in a Symfony
      console command class?
    answers:
      - value: To define the command's name and description directly in the class.
        correct: true
      - value: To register the command as a service.
        correct: false
      - value: To make the command executable from the web browser.
        correct: false
      - value: To inject arguments into the command's `execute` method.
        correct: false
    help: The `#[AsCommand]` attribute (available since Symfony 6.0) is the modern
      way to configure console commands directly within their class definitions,
      replacing static properties.
  - question: Which of the following describes Symfony's approach to framework
      overloading?
    answers:
      - value: Symfony discourages modifying core framework files directly.
        correct: true
      - value: It encourages modifying vendor files for customization.
        correct: false
      - value: It provides built-in mechanisms to override any framework class.
        correct: false
      - value: Overloading is the primary way to extend Symfony's functionality.
        correct: false
    help: Symfony's architecture is designed for extensibility through bundles,
      services, and configuration, rather than direct modification or
      'overloading' of core framework files, which would make upgrades
      difficult.
  - question: What is the main benefit of using `AbstractController` in Symfony 7.0?
    answers:
      - value: It provides convenient helper methods and access to commonly used
          services without manual injection.
        correct: true
      - value: It makes controllers stateless.
        correct: false
      - value: It automatically handles all routing.
        correct: false
      - value: It is required for all Symfony controllers.
        correct: false
    help: "`AbstractController` simplifies controller development by offering
      shortcuts for common tasks like rendering templates, generating URLs, and
      redirecting, while still allowing for dependency injection."
  - question: How can you install the Symfony Profiler Pack for development purposes?
    answers:
      - value: "`composer require --dev symfony/profiler-pack`"
        correct: true
      - value: "`composer install symfony/profiler-pack`"
        correct: false
      - value: "`php bin/console profiler:install`"
        correct: false
      - value: "`symfony install profiler`"
        correct: false
    help: The `--dev` flag ensures that the profiler pack is installed only in your
      development environment, as it's not needed in production.
  - question: What is the purpose of the `config/bundles.php` file?
    answers:
      - value: It registers all the bundles enabled in the application for different
          environments.
        correct: true
      - value: It defines the application's services.
        correct: false
      - value: It stores environment variables.
        correct: false
      - value: It configures database connections.
        correct: false
    help: "`bundles.php` is a crucial file that lists all the bundles (Symfony's
      plugin system) that are active in your application, often with
      environment-specific conditions."
  - question: Which command would you use to install the Symfony Security Bundle,
      which automatically generates a `security.yaml` file?
    answers:
      - value: "`composer require symfony/security-bundle`"
        correct: true
      - value: "`php bin/console security:install`"
        correct: false
      - value: "`symfony install security`"
        correct: false
      - value: "`composer add security`"
        correct: false
    help: Using Composer `require` with Symfony Flex will automatically install the
      bundle and apply its recipe, including creating the default
      `security.yaml` configuration.
  - question: What is the primary function of the `var/log/` directory in a Symfony
      application?
    answers:
      - value: To store application logs, including errors and debugging information.
        correct: true
      - value: To store cached data.
        correct: false
      - value: To store database files.
        correct: false
      - value: To store user-uploaded files.
        correct: false
    help: The `var/log/` directory is where Symfony writes its log files, which are
      essential for monitoring application behavior and debugging issues.
  - question: How can you define a custom Twig filter in Symfony 7.0?
    answers:
      - value: By creating a class that extends `Twig\Extension\AbstractExtension` and
          implementing `getFilters()`.
        correct: true
      - value: By defining a service with a `twig.filter` tag.
        correct: false
      - value: By adding a function to `config/services.yaml`.
        correct: false
      - value: By directly modifying the Twig environment service.
        correct: false
    help: Custom Twig extensions are the standard way to add new filters, functions,
      or tags to Twig. Symfony's autoconfiguration typically registers these
      extensions automatically.
  - question: What is the purpose of the `#[Route]` attribute in a Symfony
      controller method?
    answers:
      - value: To map a specific URL path to the controller method.
        correct: true
      - value: To define the method's return type.
        correct: false
      - value: To inject services into the method.
        correct: false
      - value: To specify the HTTP method allowed for the route.
        correct: true
    help: The `#[Route]` attribute is used to configure routing for a controller
      action, including the path, name, and allowed HTTP methods.
  - question: "When configuring assets in Symfony, what is the effect of setting
      `base_path: '/images'`?"
    answers:
      - value: All asset URLs generated by Symfony will be prefixed with `/images/`.
        correct: true
      - value: Assets will only be loaded from the `public/images/` directory.
        correct: false
      - value: It creates a new directory named `images` in the project root.
        correct: false
      - value: It defines a new asset package named `images`.
        correct: false
    help: The `base_path` option in asset configuration prepends a specified path to
      all asset URLs, useful for organizing assets under a common virtual
      directory.
  - question: What is the role of the `Dotenv` component in a Symfony application's
      `public/index.php`?
    answers:
      - value: To load environment variables from the `.env` file.
        correct: true
      - value: To parse incoming HTTP requests.
        correct: false
      - value: To handle database connections.
        correct: false
      - value: To manage application routes.
        correct: false
    help: The `Dotenv` component is used early in the application bootstrap to load
      environment variables from the `.env` file, making them available to the
      application.
  - question: Which of the following is a key aspect of Symfony's framework
      interoperability?
    answers:
      - value: Adherence to PHP Standards Recommendations (PSRs).
        correct: true
      - value: Requiring specific web server software.
        correct: false
      - value: Exclusive use of YAML for configuration.
        correct: false
      - value: Tight coupling with Doctrine ORM.
        correct: false
    help: Symfony's commitment to PSRs (like PSR-4 for autoloading, PSR-3 for
      logging, PSR-7 for HTTP messages) ensures high interoperability with other
      PHP libraries and frameworks.
  - question: What is the purpose of the `RequestStack` service in Symfony?
    answers:
      - value: To manage a stack of `Request` objects, especially useful in sub-requests
          or embedded controllers.
        correct: true
      - value: To store all incoming requests in a database.
        correct: false
      - value: To handle request validation.
        correct: false
      - value: To send multiple HTTP requests simultaneously.
        correct: false
    help: The `RequestStack` allows you to access the current `Request` object and
      manage multiple requests in scenarios like ESI (Edge Side Includes) or
      internal sub-requests.
  - question: How does Symfony typically handle security configuration?
    answers:
      - value: Through the `security.yaml` file, often generated by the Security Bundle
          recipe.
        correct: true
      - value: By hardcoding credentials in controllers.
        correct: false
      - value: Via annotations in entity classes.
        correct: false
      - value: It relies solely on web server configuration.
        correct: false
    help: The `security.yaml` file is the central place for configuring Symfony's
      security features, including firewalls, user providers, encoders, and
      access control.
  - question: Which component would you install to enable webhook processing
      capabilities in your Symfony application?
    answers:
      - value: "`symfony/webhook`"
        correct: true
      - value: "`symfony/http-client`"
        correct: false
      - value: "`symfony/notifier`"
        correct: false
      - value: "`symfony/messenger`"
        correct: false
    help: The `symfony/webhook` component provides tools and utilities specifically
      designed for handling incoming webhooks.
  - question: What is the purpose of the `src/Kernel.php` file in a Symfony 7.0
      application?
    answers:
      - value: It is the main entry point for the Symfony framework, responsible for
          bootstrapping the application.
        correct: true
      - value: It defines all the application's services.
        correct: false
      - value: It contains all the application's controllers.
        correct: false
      - value: It handles all database interactions.
        correct: false
    help: The `Kernel.php` class is the heart of the Symfony application,
      responsible for loading bundles, configuring the environment, and managing
      the request lifecycle from request to response.
  - question: In a Symfony application, what is the primary role of the
      `composer.json` file?
    answers:
      - value: To declare the project's dependencies and autoloading rules.
        correct: true
      - value: To store environment variables.
        correct: false
      - value: To define database schema.
        correct: false
      - value: To configure web server rewrite rules.
        correct: false
    help: The `composer.json` file is Composer's manifest file, where you declare
      your project's dependencies, scripts, and autoloading configuration.
  - question: Which of the following describes the Symfony Framework's license?
    answers:
      - value: MIT License
        correct: true
      - value: GPLv3
        correct: false
      - value: Apache License 2.0
        correct: false
      - value: Proprietary License
        correct: false
    help: Symfony is open-source software released under the MIT license, which is a
      permissive free software license.
  - question: What is the purpose of the `when@prod` block in Symfony configuration
      files?
    answers:
      - value: To apply configuration settings specifically when the `APP_ENV` is set to
          `prod`.
        correct: true
      - value: To define settings for production deployment only.
        correct: false
      - value: To enable debugging features in production.
        correct: false
      - value: To specify a different database for production.
        correct: false
    help: The `when@env` syntax allows for environment-specific configuration
      overrides, making it easy to manage different settings for development,
      testing, and production.
  - question: Which component is essential for enabling translation capabilities in
      a Symfony application?
    answers:
      - value: "`symfony/translation`"
        correct: true
      - value: "`symfony/intl`"
        correct: false
      - value: "`symfony/locale`"
        correct: false
      - value: "`symfony/twig-bundle`"
        correct: false
    help: The `symfony/translation` component provides the core functionalities for
      managing and using translations in your Symfony application.
  - question: What is the primary benefit of using `Debug::enable()` in
      `public/index.php` for development?
    answers:
      - value: It enables detailed error reporting and a user-friendly error page.
        correct: true
      - value: It optimizes application performance.
        correct: false
      - value: It disables all logging.
        correct: false
      - value: It prevents all exceptions from being thrown.
        correct: false
    help: "`Debug::enable()` (from `symfony/error-handler`) is crucial in
      development environments for displaying comprehensive error information
      and stack traces, aiding in debugging."
  - question: In Symfony 7.0, how are multiple asset base URLs handled for load
      balancing or CDN integration?
    answers:
      - value: Symfony randomly selects one of the configured base URLs for each asset.
        correct: true
      - value: All base URLs are used simultaneously for each asset.
        correct: false
      - value: The first configured base URL is always used.
        correct: false
      - value: It requires manual selection of the base URL in Twig.
        correct: false
    help: When multiple `base_urls` are configured for assets, Symfony intelligently
      distributes asset requests across them, which is beneficial for load
      balancing and leveraging multiple CDNs.
  - question: What is the purpose of the `symfony/serializer-pack`?
    answers:
      - value: To provide tools for converting PHP objects to various formats (JSON,
          XML) and vice versa.
        correct: true
      - value: To manage HTTP sessions.
        correct: false
      - value: To handle file uploads.
        correct: false
      - value: To create command-line applications.
        correct: false
    help: The Serializer component allows you to serialize PHP objects into
      different formats (like JSON or XML) and deserialize them back into
      objects, commonly used in APIs.
  - question: Which of the following is a common practice for organizing multiple
      distinct applications (e.g., 'admin', 'api') within a single Symfony
      project?
    answers:
      - value: Using separate kernels and dedicated configuration directories within an
          `apps/` folder.
        correct: true
      - value: Creating entirely separate Symfony projects for each application.
        correct: false
      - value: Placing all application code in the `src/` directory without further
          separation.
        correct: false
      - value: Using a single kernel and relying solely on routing to differentiate
          applications.
        correct: false
    help: For complex projects with distinct applications, Symfony supports multiple
      kernels, each with its own configuration and entry point, often organized
      under an `apps/` directory.
