category: Dependency Injection

questions:
  -
    question: >
      What is the primary purpose of the Symfony Dependency Injection Container?
    answers:
      - { value: "To manage and centralize the instantiation and configuration of objects (services) in an application.", correct: true }
      - { value: "To handle HTTP requests and responses.", correct: false }
      - { value: "To manage database connections and ORM entities.", correct: false }
      - { value: "To provide a templating engine for rendering views.", correct: false }
    help: |
      The Dependency Injection Container (DIC) is a tool that manages the instantiation of services and injects their dependencies. It centralizes service creation and configuration, promoting loose coupling and reusability.
      https://symfony.com/doc/current/service_container.html

  -
    question: |
      Which of the following methods is used to retrieve a service from the Symfony Dependency Injection Container by its ID?
    answers:
      - { value: "`$container->get('service_id')`", correct: true }
      - { value: "`$container->find('service_id')`", correct: false }
      - { value: "`$container->load('service_id')`", correct: false }
      - { value: "`$container->fetch('service_id')`", correct: false }
    help: |
      The `get()` method of the container is used to retrieve a service by its unique ID.
      https://symfony.com/doc/current/components/dependency_injection.html#retrieving-services

  -
    question: >
      In Symfony, what happens during the "compilation" phase of the Dependency Injection Container?
    answers:
      - { value: "The container is optimized for performance by compiling service definitions into a highly optimized PHP class.", correct: true }
      - { value: "All services are instantiated and their dependencies are resolved.", correct: false }
      - { value: "Configuration files (YAML, XML, PHP) are parsed and validated.", correct: false }
      - { value: "The application's cache is cleared and rebuilt.", correct: false }
    help: |
      During compilation, the container builder processes all service definitions, applies compiler passes, and dumps an optimized PHP class that represents the compiled container. This compiled container is then used at runtime for performance.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: |
      Consider the following YAML service definition. How would you configure `App\\Mail\\NewsletterManager` to use constructor injection for the `mailer` service?

      ```yaml
      # config/services.yaml
      services:
          # ...
          App\Mail\NewsletterManager:
              # ???
      ```
    answers:
      - { value: "`arguments: ['@mailer']`", correct: true }
      - { value: "`calls: [{ method: '__construct', arguments: ['@mailer'] }]`", correct: false }
      - { value: "`properties: { mailer: '@mailer' }`", correct: false }
      - { value: "`autowire: true`", correct: false }
    help: |
      For constructor injection in YAML, you use the `arguments` key to specify the services or parameters to be passed to the constructor.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: |
      Given the following PHP class, which Symfony attribute would you use on the `setLogger` method to ensure it's automatically called by autowiring for dependency injection, even if the dependency is optional?

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Contracts\Service\Attribute\Required; // Assume this is available

      class MessageGenerator
      {
          private LoggerInterface $logger;

          // ???
          public function setLogger(LoggerInterface $logger): void
          {
              $this->logger = $logger;
          }
      }
      ```
    answers:
      - { value: "`#[Required]`", correct: true }
      - { value: "`#[Autowire]`", correct: false }
      - { value: "`#[Inject]`", correct: false }
      - { value: "`#[Service]`", correct: false }
    help: |
      The `#[Required]` attribute marks a setter method (or public property) as required for autowiring. Symfony will ensure this dependency is provided.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: >
      Which of the following is a common built-in service in Symfony that you would typically inject for logging purposes?
    answers:
      - { value: "`Psr\\Log\\LoggerInterface`", correct: true }
      - { value: "`Symfony\\Component\\HttpFoundation\\Request`", correct: false }
      - { value: "`Symfony\\Component\\Mailer\\MailerInterface`", correct: false }
      - { value: "`Symfony\\Component\\EventDispatcher\\EventDispatcherInterface`", correct: false }
    help: |
      Symfony integrates with PSR-3 for logging, and `Psr\\Log\\LoggerInterface` is the standard interface to type-hint for injecting a logger.
      https://symfony.com/doc/current/logging.html#autowiring-logger-channels

  -
    question: |
      You want to inject a specific environment variable `APP_ENV` into your service. Which `#[Autowire]` parameter should you use?
    answers:
      - { value: "`env: 'APP_ENV'`", correct: true }
      - { value: "`param: 'APP_ENV'`", correct: false }
      - { value: "`service: 'APP_ENV'`", correct: false }
      - { value: "`expression: 'env("APP_ENV")'`", correct: false }
    help: |
      The `env` parameter of the `#[Autowire]` attribute is used to inject environment variables.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the purpose of a "parameter" in the Symfony Dependency Injection Container?
    answers:
      - { value: "To store scalar values (strings, numbers, booleans) that can be injected into services.", correct: true }
      - { value: "To define the arguments for a service's constructor.", correct: false }
      - { value: "To mark a service for specific processing by a compiler pass.", correct: false }
      - { value: "To create an alias for an existing service ID.", correct: false }
    help: |
      Parameters in the container are used to store simple configuration values that can be reused across different service definitions.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to use an immutable setter `withMailer(MailerInterface $mailer)`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`calls: { withMailer: !returns_clone ['@mailer'] }`", correct: true }
      - { value: "`calls: { withMailer: ['@mailer'] }`", correct: false }
      - { value: "`arguments: { withMailer: '@mailer' }`", correct: false }
      - { value: "`properties: { mailer: '@mailer', returns_clone: true }`", correct: false }
    help: |
      For immutable setter injection (wither methods) in YAML, you use the `!returns_clone` tag with the method call to indicate that the container should use the returned cloned instance.
      https://symfony.com/doc/current/service_container/injection_types.html#immutable-setter-injection

  -
    question: >
      Which of the following best describes "service autowiring" in Symfony?
    answers:
      - { value: "Automatically injecting dependencies into a service based on type-hints in its constructor, setter methods, or public properties.", correct: true }
      - { value: "Manually defining every dependency for every service in configuration files.", correct: false }
      - { value: "Loading all services into the container at application bootstrap.", correct: false }
      - { value: "Generating a unique ID for every service in the container.", correct: false }
    help: |
      Autowiring automatically reads the type-hints on your constructor arguments, setter methods, and public properties and passes the correct services to them.
      https://symfony.com/doc/current/service_container/autowiring.html

  -
    question: |
      You have two services, `App\\Util\\Rot13Transformer` and `App\\Util\\CaesarCipherTransformer`, both implementing `App\\Util\\TransformerInterface`. In `App\\Service\\TwitterClient`, you want to inject specifically the `Rot13Transformer`. How can you achieve this using PHP attributes?

      ```php
      namespace App\Service;

      use App\Util\TransformerInterface;
      use Symfony\Component\DependencyInjection\Attribute\Target;

      class TwitterClient
      {
          public function __construct(
              // ???
              private TransformerInterface $transformer,
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[Target('rot13Transformer')]`", correct: true }
      - { value: "`#[Autowire(service: 'rot13Transformer')]`", correct: true }
      - { value: "`#[Required]`", correct: false }
      - { value: "`#[Service('rot13Transformer')]`", correct: false }
    help: |
      The `#[Target]` attribute allows you to specify which named service should be injected when multiple services implement the same interface. Alternatively, `#[Autowire(service: 'service_id')]` can be used for explicit service injection.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: >
      What is the primary benefit of using constructor injection over public property injection in Symfony?
    answers:
      - { value: "Constructor injection ensures that all required dependencies are provided at the time of object creation, making the object always in a valid state.", correct: true }
      - { value: "Property injection is faster because it bypasses the constructor.", correct: false }
      - { value: "Constructor injection allows for optional dependencies more easily.", correct: false }
      - { value: "Property injection makes services easier to test.", correct: false }
    help: |
      Constructor injection makes dependencies explicit and ensures the object is fully initialized and valid upon creation. Property injection can lead to less predictable states.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: |
      You want to collect all services tagged with `app.handler` into an `iterable` argument in your `HandlerCollection` class. Which attribute should you use?

      ```php
      namespace App;

      use Symfony\Component\DependencyInjection\Attribute\AutowireIterator;

      class HandlerCollection
      {
          public function __construct(
              // ???
              iterable $handlers
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[AutowireIterator('app.handler')]`", correct: true }
      - { value: "`#[Target('app.handler')]`", correct: false }
      - { value: "`#[Autowire(tag: 'app.handler')]`", correct: false }
      - { value: "`#[CollectServices('app.handler')]`", correct: false }
    help: |
      The `#[AutowireIterator]` attribute is used to inject all services tagged with a specific name as an `iterable` (or `array`, `\Traversable`, `\Iterator`).
      https://symfony.com/doc/current/service_container/tags.html#autowiring-tagged-services

  -
    question: >
      Which interface must a class implement to be considered a "service subscriber" and allow for lazy loading of specific dependencies via a service locator?
    answers:
      - { value: "`Symfony\\Contracts\\Service\\ServiceSubscriberInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\ContainerAwareInterface`", correct: false }
      - { value: "`Psr\\Container\\ContainerInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\KernelInterface`", correct: false }
    help: |
      Classes implementing `ServiceSubscriberInterface` can declare their dependencies via the `getSubscribedServices()` method, which Symfony uses to generate a service locator for them.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#service-subscribers

  -
    question: >
      What is the purpose of "service decoration" in Symfony?
    answers:
      - { value: "To replace an existing service with a new one, while still allowing the original service to be used internally by the decorator.", correct: true }
      - { value: "To add new methods to an existing service at runtime.", correct: false }
      - { value: "To make a private service public.", correct: false }
      - { value: "To define a service that depends on multiple other services.", correct: false }
    help: |
      Service decoration allows you to wrap an existing service with a new one, enabling you to add or modify behavior without changing the original service's code.
      https://symfony.com/doc/current/service_container/service_decoration.html

  -
    question: |
      You want to define a service `my_app.mailer` that is created by calling the static method `MailerFactory::createMailer()`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`factory: ['App\\Factory\\MailerFactory', 'createMailer']`", correct: true }
      - { value: "`class: App\\Factory\\MailerFactory, method: createMailer`", correct: false }
      - { value: "`arguments: ['@App\\Factory\\MailerFactory', 'createMailer']`", correct: false }
      - { value: "`factory: App\\Factory\\MailerFactory::createMailer`", correct: false }
    help: |
      The `factory` key in a service definition allows you to specify a callable (an array with class/service ID and method name) that will be used to create the service instance.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      What is a "compiler pass" in the context of the Symfony Dependency Injection Container?
    answers:
      - { value: "A PHP class that allows you to inspect and modify service definitions before the container is compiled.", correct: true }
      - { value: "A method used to compile Twig templates.", correct: false }
      - { value: "A command-line tool for optimizing Symfony applications.", correct: false }
      - { value: "A mechanism for defining routes in a Symfony application.", correct: false }
    help: |
      Compiler passes are PHP classes that hook into the container's compilation process, allowing for programmatic manipulation of service definitions.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html

  -
    question: |
      You have a bundle `AcmeDemoBundle` and want to prepend configuration for another bundle's extension (e.g., `framework`) during the container compilation. Which interface should your bundle's extension implement?
    answers:
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\PrependExtensionInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface`", correct: false }
      - { value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`", correct: false }
    help: |
      Bundles that need to prepend configuration for other extensions must implement `PrependExtensionInterface` and define the `prepend()` method.
      https://symfony.com/doc/current/bundles/prepend_extension.html

  -
    question: |
      Consider the following service definition in `config/services.yaml`:

      ```yaml
      services:
          App\Service\MyService:
              arguments:
                  $param1: '%app.config.value%'
      ```
      What does `%app.config.value%` represent?
    answers:
      - { value: "A container parameter named `app.config.value`.", correct: true }
      - { value: "A service ID named `app.config.value`.", correct: false }
      - { value: "An environment variable named `APP_CONFIG_VALUE`.", correct: false }
      - { value: "A Twig global variable.", correct: false }
    help: |
      Values enclosed in `%` are interpreted as container parameters.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html

  -
    question: >
      When should you consider making a service "private" in Symfony?
    answers:
      - { value: "When the service is only intended to be injected into other services and not retrieved directly from the container using `$container->get()`.", correct: true }
      - { value: "When the service contains sensitive information.", correct: false }
      - { value: "When the service is not used by any other service.", correct: false }
      - { value: "When the service needs to be lazy-loaded.", correct: false }
    help: |
      Services are private by default in Symfony 4.0 and later. Private services cannot be retrieved directly from the container via `get()`, but can still be injected into other services. This promotes better encapsulation and prevents misuse.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: |
      Which of the following configuration formats are officially supported for defining services in Symfony 7?
    answers:
      - { value: "YAML", correct: true }
      - { value: "XML", correct: true }
      - { value: "PHP", correct: true }
      - { value: "JSON", correct: false }
      - { value: "INI", correct: false }
    help: |
      Symfony officially supports YAML, XML, and PHP for defining services in the Dependency Injection Container.
      https://symfony.com/doc/current/service_container.html#configuration-formats

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject the `kernel.project_dir` parameter into its constructor. How would you do this using the `#[Autowire]` attribute?

      ```php
      namespace App\Service;

      use Symfony\Component\DependencyInjection\Attribute\Autowire;

      class MyService
      {
          public function __construct(
              // ???
              string $projectDir
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[Autowire('%kernel.project_dir%')]`", correct: true }
      - { value: "`#[Autowire(param: 'kernel.project_dir')]`", correct: true }
      - { value: "`#[Autowire(env: 'kernel.project_dir')]`", correct: false }
      - { value: "`#[Autowire(service: 'kernel.project_dir')]`", correct: false }
    help: |
      The `#[Autowire]` attribute can inject parameter values by prefixing the parameter name with `%` or by using the `param` argument.
      https://symfony.com/doc/current/controller.html#injecting-services-and-parameters

  -
    question: >
      What is the primary role of the `ContainerBuilder` class in Symfony's Dependency Injection component?
    answers:
      - { value: "It is used to define, register, and compile service definitions.", correct: true }
      - { value: "It provides a runtime interface for retrieving services.", correct: false }
      - { value: "It manages the application's configuration tree.", correct: false }
      - { value: "It handles routing for incoming HTTP requests.", correct: false }
    help: |
      The `ContainerBuilder` is the central class for building and managing the dependency injection container during the compilation process.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a `Psr\\Log\\LoggerInterface` into its public property `$logger`. Which attribute would you use on the property to enable autowiring?

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Contracts\Service\Attribute\Required;

      class MyService
      {
          // ???
          public LoggerInterface $logger;
      }
      ```
    answers:
      - { value: "`#[Required]`", correct: true }
      - { value: "`#[Autowire]`", correct: false }
      - { value: "`#[Inject]`", correct: false }
      - { value: "`#[Property]`", correct: false }
    help: |
      The `#[Required]` attribute can be applied to public properties to enable autowiring for them.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-public-property-injection

  -
    question: >
      Which of the following is a valid way to define a service alias in Symfony's YAML configuration?
    answers:
      - { value: "`Symfony\\Component\\HttpKernel\\Profiler\\Profiler: '@profiler'`", correct: true }
      - { value: "`profiler_alias: { alias_of: 'profiler' }`", correct: false }
      - { value: "`alias: profiler, service: Symfony\\Component\\HttpKernel\\Profiler\\Profiler`", correct: false }
      - { value: "`@profiler: Symfony\\Component\\HttpKernel\\Profiler\\Profiler`", correct: false }
    help: |
      In YAML, you can define an alias by mapping the alias ID to the original service ID using the `@` symbol.
      https://symfony.com/doc/current/service_container/alias_private.html#aliasing

  -
    question: >
      What is the main advantage of using "tags" for services in Symfony?
    answers:
      - { value: "To mark services that belong to a certain group or fulfill a specific contract, allowing them to be collected and processed by compiler passes or autowired as collections.", correct: true }
      - { value: "To define the visibility of a service (public or private).", correct: false }
      - { value: "To specify the arguments for a service's constructor.", correct: false }
      - { value: "To enable lazy loading for a service.", correct: false }
    help: |
      Tags are metadata assigned to services. They are primarily used by compiler passes to find and process groups of services, or by autowiring to inject collections of services.
      https://symfony.com/doc/current/service_container/tags.html

  -
    question: |
      You are developing a bundle and want to define its configuration tree. Which interface must your configuration class implement?
    answers:
      - { value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface`", correct: false }
      - { value: "`Symfony\\Component\\Config\\ConfigCacheInterface`", correct: false }
    help: |
      The configuration class for a bundle's semantic configuration must implement `ConfigurationInterface` and define the `getConfigTreeBuilder()` method.
      https://symfony.com/doc/current/bundles/extension.html#semantic-configuration

  -
    question: >
      What is a "synthetic service" in Symfony's Dependency Injection Container?
    answers:
      - { value: "A service that is not instantiated by the container but is an existing object injected into the container at runtime.", correct: true }
      - { value: "A service that is generated automatically by autowiring.", correct: false }
      - { value: "A service that is always lazy-loaded.", correct: false }
      - { value: "A service that is only available in the `dev` environment.", correct: false }
    help: |
      Synthetic services are services for which the container does not create the instance. Instead, an existing object instance is injected into the container at runtime using `Container::set()`.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: |
      How can you load service definitions from a PHP configuration file (`services.php`) into a `ContainerBuilder`?
    answers:
      - { value: "Using `Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader`.", correct: true }
      - { value: "Using `Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader`.", correct: false }
      - { value: "Using `Symfony\\Component\\DependencyInjection\\Loader\\XmlFileLoader`.", correct: false }
      - { value: "By directly including the PHP file.", correct: false }
    help: |
      The `PhpFileLoader` is used to load service definitions from PHP files.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-php-files

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to execute an Expression Language expression to determine a dependency. Which `#[Autowire]` parameter would you use?
    answers:
      - { value: "`expression: 'service("my_other_service").someMethod()'`", correct: true }
      - { value: "`service: 'expression:service("my_other_service").someMethod()'`", correct: false }
      - { value: "`param: 'expression:service("my_other_service").someMethod()'`", correct: false }
      - { value: "`env: 'expression:service("my_other_service").someMethod()'`", correct: false }
    help: |
      The `expression` parameter of the `#[Autowire]` attribute allows you to inject the result of a Symfony Expression Language expression.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the purpose of the `#[AsCommand]` attribute when defining a console command as a service in Symfony?
    answers:
      - { value: "To register the command as a service and define its name and description.", correct: true }
      - { value: "To make the command automatically executable without manual registration.", correct: false }
      - { value: "To inject services into the command's `execute` method.", correct: false }
      - { value: "To mark the command as a required service.", correct: false }
    help: |
      The `#[AsCommand]` attribute is used to configure console commands directly in their class, including their name and description, when they are defined as services.
      https://symfony.com/doc/current/console/commands_as_services.html

  -
    question: >
      Which of the following statements is TRUE regarding the default behavior of services in Symfony 7?
    answers:
      - { value: "Services are private by default.", correct: true }
      - { value: "Services are public by default.", correct: false }
      - { value: "Services are shared by default.", correct: true }
      - { value: "Services are non-shared (always new instance) by default.", correct: false }
    help: |
      Since Symfony 4.0, services are private by default. Services are also shared by default, meaning the container returns the same instance every time it's requested.
      https://symfony.com/doc/current/service_container/alias_private.html
      https://symfony.com/doc/current/service_container.html#service-container-shared

  -
    question: |
      You want to inject a service closure (lazy-loaded service) into your constructor. Which attribute can automatically create this closure for a service?
    answers:
      - { value: "`#[AutowireServiceClosure]`", correct: true }
      - { value: "`#[Lazy]`", correct: false }
      - { value: "`#[ServiceClosure]`", correct: false }
      - { value: "`#[Autowire(lazy: true)]`", correct: false }
    help: |
      The `#[AutowireServiceClosure]` attribute automatically creates an anonymous function (closure) that returns the service, useful for lazy-loading.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-service-closures

  -
    question: >
      What is the main benefit of using a "service locator" pattern in Symfony?
    answers:
      - { value: "To provide a way to lazily load optional dependencies, avoiding injecting the entire container or many services into a class.", correct: true }
      - { value: "To make all services globally accessible.", correct: false }
      - { value: "To replace the entire Dependency Injection Container.", correct: false }
      - { value: "To explicitly define all service dependencies in configuration.", correct: false }
    help: |
      Service locators (often implemented via `ServiceSubscriberInterface`) allow you to declare and lazily retrieve specific services, avoiding constructor bloat when dealing with many optional dependencies.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      Given the following PHP service definition, how would you configure it in `config/services.yaml` to use setter injection for the `mailer` service?

      ```php
      namespace App\Mail;

      use Symfony\Component\Mailer\MailerInterface;

      class NewsletterManager
      {
          private MailerInterface $mailer;

          public function setMailer(MailerInterface $mailer): void
          {
              $this->mailer = $mailer;
          }
      }
      ```
    answers:
      - { value: "`calls: { setMailer: ['@mailer'] }`", correct: true }
      - { value: "`arguments: { setMailer: '@mailer' }`", correct: false }
      - { value: "`properties: { mailer: '@mailer' }`", correct: false }
      - { value: "`autowire: true, setter: setMailer`", correct: false }
    help: |
      For setter injection in YAML, you use the `calls` key to specify the method to call and its arguments.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: >
      Which of the following is a valid way to define a parameter in Symfony's PHP service configuration?
    answers:
      - { value: "`$container->parameters()->set('mailer.transport', 'sendmail');`", correct: true }
      - { value: "`$container->addParameter('mailer.transport', 'sendmail');`", correct: false }
      - { value: "`$container->setParameter('mailer.transport', 'sendmail');`", correct: false }
      - { value: "`$container->config()->set('mailer.transport', 'sendmail');`", correct: false }
    help: |
      In PHP service configuration files (e.g., `config/services.php`), parameters are defined using `$container->parameters()->set()`.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-parameters

  -
    question: >
      What is the purpose of the `#[Autoconfigure]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To define autoconfiguration rules (e.g., tags) directly on a class, which apply when the class is registered as a service.", correct: true }
      - { value: "To automatically inject all dependencies without explicit configuration.", correct: false }
      - { value: "To mark a service as an alias for another service.", correct: false }
      - { value: "To specify a factory method for a service.", correct: false }
    help: |
      The `#[Autoconfigure]` attribute allows you to define autoconfiguration rules (like adding tags) directly on a class, which will be applied when that class is registered as a service.
      https://symfony.com/doc/current/service_container/tags.html#autoconfigure-attribute

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to access the `request_stack` service. Which of the following is the most idiomatic way to inject it in Symfony 7 with autowiring enabled?
    answers:
      - { value: "Type-hint `Symfony\\Component\\HttpFoundation\\RequestStack` in the constructor.", correct: true }
      - { value: "Use `$container->get('request_stack')` inside the service.", correct: false }
      - { value: "Define `request_stack` in `arguments` in `services.yaml`.", correct: false }
      - { value: "Implement `ContainerAwareInterface` and use `setContainer`.", correct: false }
    help: |
      With autowiring enabled, type-hinting the `RequestStack` interface or class in your constructor is the preferred and most idiomatic way to inject the service.
      https://symfony.com/doc/current/service_container.html#injecting-a-single-service

  -
    question: >
      Which of the following is NOT a valid type of dependency injection supported by Symfony's service container?
    answers:
      - { value: "Method injection (non-setter)", correct: true }
      - { value: "Constructor injection", correct: false }
      - { value: "Setter injection", correct: false }
      - { value: "Property injection", correct: false }
      - { value: "Immutable setter injection (wither)", correct: false }
    help: |
      Symfony supports constructor, setter, property, and immutable setter injection. While you can call any method, "method injection" typically refers to injecting dependencies via arbitrary public methods, which is not a primary DI type in Symfony's container.
      https://symfony.com/doc/current/service_container/injection_types.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a specific logger channel, e.g., `monolog.logger.event`. How would you achieve this using the `#[Autowire]` attribute?

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Component\DependencyInjection\Attribute\Autowire;

      class MyService
      {
          public function __construct(
              // ???
              LoggerInterface $eventLogger
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[Autowire(service: 'monolog.logger.event')]`", correct: true }
      - { value: "`#[Target('monolog.logger.event')]`", correct: false }
      - { value: "`#[Autowire(channel: 'event')]`", correct: false }
      - { value: "`#[Autowire('%monolog.logger.event%')]`", correct: false }
    help: |
      The `#[Autowire(service: 'service_id')]` attribute allows you to explicitly specify which service ID to inject, overriding autowiring's default behavior.
      https://symfony.com/doc/current/controller.html#injecting-services-and-parameters

  -
    question: >
      What is the purpose of the `public: false` setting for a service in Symfony's configuration?
    answers:
      - { value: "It makes the service inaccessible directly via `$container->get()`, but it can still be injected into other services.", correct: true }
      - { value: "It prevents the service from being instantiated.", correct: false }
      - { value: "It makes the service available only in the `dev` environment.", correct: false }
      - { value: "It marks the service as deprecated.", correct: false }
    help: |
      Setting `public: false` (or relying on the default `private` behavior in modern Symfony) means the service cannot be retrieved directly from the container using `get()`. This promotes proper dependency injection.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.php` using the `ContainerConfigurator`. How would you configure a setter injection for the `setLogger` method?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\MyService;
      use Symfony\Component\DependencyInjection\Reference;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(MyService::class)
              // ???
          ;
      };
      ```
    answers:
      - { value: "`->call('setLogger', [service('logger')])`", correct: true }
      - { value: "`->addMethodCall('setLogger', [new Reference('logger')])`", correct: true }
      - { value: "`->setter('setLogger', service('logger'))`", correct: false }
      - { value: "`->setLogger(service('logger'))`", correct: false }
    help: |
      In PHP service configuration, you use the `call()` method (or `addMethodCall()` on a `Definition` object) to configure setter injection. `service()` is a helper function to create a service reference.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: >
      What is the primary difference between a "shared" and a "non-shared" service in Symfony?
    answers:
      - { value: "A shared service returns the same instance every time it's requested, while a non-shared service (prototype) returns a new instance each time.", correct: true }
      - { value: "Shared services are public, non-shared services are private.", correct: false }
      - { value: "Shared services are lazy-loaded, non-shared services are not.", correct: false }
      - { value: "Shared services are compiled, non-shared services are not.", correct: false }
    help: |
      By default, services are shared (singleton). You can explicitly mark a service as `shared: false` to make it a prototype, meaning a new instance is created on each request.
      https://symfony.com/doc/current/service_container.html#service-container-shared

  -
    question: |
      You want to inject the `kernel.debug` parameter as a boolean into your bundle's `Configuration` class constructor. How would you define the constructor?

      ```php
      namespace App\DependencyInjection;

      use Symfony\Component\Config\Definition\Builder\TreeBuilder;
      use Symfony\Component\Config\Definition\ConfigurationInterface;

      class Configuration implements ConfigurationInterface
      {
          private bool $debug;

          // ???
          public function __construct(private bool $debug)
          {
          }

          // ...
      }
      ```
    answers:
      - { value: "`public function __construct(private bool $debug)`", correct: true }
      - { value: "`public function __construct(#[Autowire('%kernel.debug%')] private bool $debug)`", correct: true }
      - { value: "`public function __construct(bool $debug)`", correct: false }
      - { value: "`public function __construct(#[Autowire(param: 'kernel.debug')] private bool $debug)`", correct: true }
    help: |
      Symfony can autowire parameters into constructors. For boolean parameters like `kernel.debug`, type-hinting `bool` is sufficient. Using `#[Autowire]` explicitly is also valid.
      https://symfony.com/doc/current/configuration/using_parameters_in_dic.html#injecting-kernel-debug-parameter

  -
    question: >
      Which of the following is a key responsibility of a bundle's `Extension` class (implementing `ExtensionInterface`) in Symfony's Dependency Injection?
    answers:
      - { value: "Loading the bundle's service definitions and configuration into the container builder.", correct: true }
      - { value: "Defining the bundle's routes.", correct: false }
      - { value: "Registering event listeners for the bundle.", correct: false }
      - { value: "Managing database migrations for the bundle.", correct: false }
    help: |
      The `Extension` class is responsible for loading the bundle's configuration and service definitions into the `ContainerBuilder` during the compilation process.
      https://symfony.com/doc/current/bundles/extension.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a `Psr\\Log\\LoggerInterface` into its public property `$logger` using YAML configuration. How would you do this?

      ```yaml
      # config/services.yaml
      services:
          App\Service\MyService:
              # ???
      ```
    answers:
      - { value: "`properties: { logger: '@logger' }`", correct: true }
      - { value: "`arguments: { $logger: '@logger' }`", correct: false }
      - { value: "`calls: { setLogger: ['@logger'] }`", correct: false }
      - { value: "`autowire: true, public_properties: ['logger']`", correct: false }
    help: |
      For public property injection in YAML, you use the `properties` key to map property names to service IDs or parameter values.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      When should you use a "compiler pass" in Symfony?
    answers:
      - { value: "To dynamically modify service definitions based on certain conditions or to collect tagged services.", correct: true }
      - { value: "To define new services at runtime based on user input.", correct: false }
      - { value: "To replace the entire service container with a custom implementation.", correct: false }
      - { value: "To inject environment variables into services.", correct: false }
    help: |
      Compiler passes are powerful tools for advanced container manipulation, such as finding all services with a specific tag and injecting them into another service, or applying custom logic to service definitions.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject the result of a Symfony Expression Language expression `service('my_other_service').getData()` into its constructor. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`arguments: ['@=service("my_other_service").getData()']`", correct: true }
      - { value: "`arguments: ['%service("my_other_service").getData()%']`", correct: false }
      - { value: "`arguments: [{ expression: 'service("my_other_service").getData()' }]`", correct: false }
      - { value: "`arguments: ['@my_other_service.getData()']`", correct: false }
    help: |
      In YAML, expressions are prefixed with `@=` to indicate that the argument should be evaluated as a Symfony Expression Language expression.
      https://symfony.com/doc/current/service_container/expression_language.html

  -
    question: >
      What is the purpose of the `#[AsAlias]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To define an alias for a service, allowing it to be referenced by an alternative name.", correct: true }
      - { value: "To mark a service as an abstract service.", correct: false }
      - { value: "To specify a service as a factory.", correct: false }
      - { value: "To make a service public.", correct: false }
    help: |
      The `#[AsAlias]` attribute allows you to define an alias for a service directly on the service class.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-alias

  -
    question: |
      You want to load services from an XML configuration file (`services.xml`). Which loader class should you use with `ContainerBuilder`?
    answers:
      - { value: "`Symfony\\Component\\DependencyInjection\\Loader\\XmlFileLoader`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader`", correct: false }
      - { value: "`Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader`", correct: false }
      - { value: "`Symfony\\Component\\Config\\Loader\\FileLoader`", correct: false }
    help: |
      The `XmlFileLoader` is specifically designed to load service definitions from XML files into the container.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-xml-files

  -
    question: >
      Which of the following is a common use case for a "service locator" in Symfony?
    answers:
      - { value: "When a class needs access to a large number of optional services, but only a few are used in any given request.", correct: true }
      - { value: "When a service needs to be globally accessible from anywhere in the application.", correct: false }
      - { value: "When you want to completely decouple a service from the container.", correct: false }
      - { value: "When a service needs to be instantiated only once per application lifecycle.", correct: false }
    help: |
      Service locators help avoid "constructor bloat" by providing a way to lazily retrieve optional dependencies only when they are actually needed.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject a parameter `app.api_key` into its constructor. How would you do this in `config/services.php` using the `ContainerConfigurator`?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\MyService;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(MyService::class)
              // ???
          ;
      };
      ```
    answers:
      - { value: "`->args([param('app.api_key')])`", correct: true }
      - { value: "`->args(['%app.api_key%'])`", correct: true }
      - { value: "`->addArgument(param('app.api_key'))`", correct: true }
      - { value: "`->addArgument('%app.api_key%')`", correct: true }
    help: |
      In PHP service configuration, you can use the `param()` helper function or the `%parameter_name%` string to inject parameters into service arguments.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-parameters

  -
    question: >
      What is the purpose of the `#[AutowireLocator]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To automatically create and inject a service locator for a collection of services, typically tagged services.", correct: true }
      - { value: "To inject a single service by its ID.", correct: false }
      - { value: "To define a factory for a service.", correct: false }
      - { value: "To mark a service as an alias.", correct: false }
    help: |
      The `#[AutowireLocator]` attribute is used to automatically create and inject a service locator, often for services tagged with a specific name.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#autowiring-service-locators

  -
    question: >
      Which of the following is the correct way to retrieve a parameter named `app.debug_mode` from the `ContainerBuilder` instance?
    answers:
      - { value: "`$container->getParameter('app.debug_mode')`", correct: true }
      - { value: "`$container->getParam('app.debug_mode')`", correct: false }
      - { value: "`$container->findParameter('app.debug_mode')`", correct: false }
      - { value: "`$container->parameters['app.debug_mode']`", correct: false }
    help: |
      The `getParameter()` method is used to retrieve the value of a defined parameter from the container.
      https://symfony.com/doc/current/components/dependency_injection.html#retrieving-parameters

  -
    question: |
      You have a service `App\\Service\\MyService` that depends on a `MailerInterface`. You want to configure it with constructor injection using PHP attributes. How would you define the constructor?

      ```php
      namespace App\Service;

      use Symfony\Component\Mailer\MailerInterface;

      class MyService
      {
          // ???
          public function __construct(
              private MailerInterface $mailer,
          ) {
          }
      }
      ```
    answers:
      - { value: "`public function __construct(private MailerInterface $mailer)`", correct: true }
      - { value: "`public function __construct(#[Autowire] private MailerInterface $mailer)`", correct: true }
      - { value: "`public function __construct(#[Service('mailer')] private MailerInterface $mailer)`", correct: false }
      - { value: "`public function __construct(MailerInterface $mailer)`", correct: true }
    help: |
      With autowiring enabled, simply type-hinting the interface in the constructor is sufficient for Symfony to inject the correct service. Explicitly using `#[Autowire]` is also valid but often redundant for simple type-hints.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-constructor-arguments

  -
    question: >
      What is the purpose of the `services.yaml` file in a Symfony application?
    answers:
      - { value: "To define and configure the application's services and their dependencies.", correct: true }
      - { value: "To define the application's routes.", correct: false }
      - { value: "To configure database connections.", correct: false }
      - { value: "To manage security settings.", correct: false }
    help: |
      The `services.yaml` file (or its XML/PHP equivalents) is the primary location for defining and configuring services in a Symfony application.
      https://symfony.com/doc/current/service_container.html#configuration-formats

  -
    question: >
      Which built-in Symfony service provides access to the current HTTP request?
    answers:
      - { value: "`request_stack`", correct: true }
      - { value: "`request`", correct: false }
      - { value: "`http_kernel`", correct: false }
      - { value: "`router`", correct: false }
    help: |
      The `request_stack` service (an instance of `Symfony\\Component\\HttpFoundation\\RequestStack`) provides access to the current request and manages a stack of requests.
      https://symfony.com/doc/current/components/http_foundation/requests.html#request-stack

  -
    question: |
      You want to configure a service `App\\Service\\MyDecorator` to decorate an existing service `my_app.original_service`. How would you do this in `config/services.yaml`?

      ```yaml
      services:
          App\Service\MyDecorator:
              decorates: my_app.original_service
              arguments:
                  - '@.inner' # Inject the original service
                  # ... other arguments for MyDecorator
      ```
      What does `@.inner` refer to in this context?
    answers:
      - { value: "The original `my_app.original_service` instance being decorated.", correct: true }
      - { value: "A private service within `MyDecorator`.", correct: false }
      - { value: "A service named `inner`.", correct: false }
      - { value: "A parameter named `inner`.", correct: false }
    help: |
      When decorating a service, `@.inner` is a special reference that points to the original service instance that is being decorated.
      https://symfony.com/doc/current/service_container/service_decoration.html#decorating-a-service

  -
    question: >
      What is the main purpose of "semantic configuration" in Symfony bundles?
    answers:
      - { value: "To provide a structured and validated way for users to configure a bundle's services and features.", correct: true }
      - { value: "To automatically generate service definitions for the bundle.", correct: false }
      - { value: "To define the bundle's routes and controllers.", correct: false }
      - { value: "To manage the bundle's assets.", correct: false }
    help: |
      Semantic configuration allows bundles to define a clear, validated configuration structure, making it easier for users to configure the bundle in `config/packages/*.yaml` files.
      https://symfony.com/doc/current/bundles/extension.html#semantic-configuration

  -
    question: |
      You are registering a service `App\\Service\\MyService` in `config/services.php`. You want to add a tag `app.my_tag` with a specific attribute `priority: 10`. How would you do this?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\MyService;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(MyService::class)
              // ???
          ;
      };
      ```
    answers:
      - { value: "`->tag('app.my_tag', ['priority' => 10])`", correct: true }
      - { value: "`->addTag('app.my_tag', ['priority' => 10])`", correct: true }
      - { value: "`->tag('app.my_tag', 'priority: 10')`", correct: false }
      - { value: "`->addTag('app.my_tag', 'priority=10')`", correct: false }
    help: |
      In PHP service configuration, you use the `tag()` method (or `addTag()` on a `Definition` object) to add tags to a service, passing an array for tag attributes.
      https://symfony.com/doc/current/service_container/tags.html#adding-tags-in-php

  -
    question: >
      Which of the following is a valid way to define a service in Symfony's YAML configuration without specifying a `class` if autowiring is enabled and the service ID matches the class name?
    answers:
      - { value: "`App\\Service\\MyService:`", correct: true }
      - { value: "`my_service: { class: App\\Service\\MyService }`", correct: false }
      - { value: "`my_service: ~`", correct: false }
      - { value: "`App\\Service\\MyService: { autowire: true }`", correct: false }
    help: |
      When autowiring is enabled, if the service ID is the fully qualified class name, you can omit the `class` key.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-type

  -
    question: >
      What is the primary purpose of the `FileLocator` class when loading service definitions in Symfony?
    answers:
      - { value: "To locate configuration files within specific directories (e.g., bundle `Resources/config` directories).", correct: true }
      - { value: "To parse the content of configuration files.", correct: false }
      - { value: "To validate the schema of configuration files.", correct: false }
      - { value: "To cache the loaded configuration.", correct: false }
    help: |
      `FileLocator` helps loaders find configuration files by searching in a predefined set of paths.
      https://symfony.com/doc/current/components/config/file_locator.html

  -
    question: |
      You want to inject a specific service named `apiClient1.serializer` into a controller method argument `SerializerInterface $apiClient1Serializer`. Which attribute would you use?

      ```php
      namespace App\Controller;

      use Symfony\Component\Serializer\SerializerInterface;
      use Symfony\Component\DependencyInjection\Attribute\Target;

      class PersonController extends AbstractController
      {
          public function index(
              // ???
              SerializerInterface $apiClient1Serializer,
          ) {
              // ...
          }
      }
      ```
    answers:
      - { value: "`#[Target('apiClient1.serializer')]`", correct: true }
      - { value: "`#[Autowire(service: 'apiClient1.serializer')]`", correct: true }
      - { value: "`#[Inject('apiClient1.serializer')]`", correct: false }
      - { value: "`#[Service('apiClient1.serializer')]`", correct: false }
    help: |
      The `#[Target]` attribute allows you to specify the exact service ID to inject when autowiring, especially useful when multiple services implement the same interface. `#[Autowire(service: 'service_id')]` provides similar explicit control.
      https://symfony.com/doc/current/serializer.html#injecting-named-serializers

  -
    question: >
      Which of the following is a valid way to define a parameter named `app.mailer.transport` with value `smtp` in Symfony's YAML configuration?
    answers:
      - { value: "`parameters: { app.mailer.transport: 'smtp' }`", correct: true }
      - { value: "`app.mailer.transport: smtp`", correct: false }
      - { value: "`config: { parameters: { app.mailer.transport: 'smtp' } }`", correct: false }
      - { value: "`parameters.app.mailer.transport: smtp`", correct: false }
    help: |
      Parameters are defined under the `parameters` key in YAML configuration files.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html#defining-parameters-in-yaml

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject a value from the `APP_DEBUG` environment variable, converting it to a boolean. How would you do this using the `#[Autowire]` attribute?
    answers:
      - { value: "`#[Autowire(env: 'bool:APP_DEBUG')]`", correct: true }
      - { value: "`#[Autowire(env: 'APP_DEBUG', type: 'bool')]`", correct: false }
      - { value: "`#[Autowire(expression: 'env("APP_DEBUG") == "1"')`", correct: false }
      - { value: "`#[Autowire(param: 'bool:APP_DEBUG')]`", correct: false }
    help: |
      The `env` parameter of `#[Autowire]` supports processors like `bool:` to automatically convert environment variable values to the desired type.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the main advantage of using `#[Required]` attribute on a setter method compared to always injecting via the constructor?
    answers:
      - { value: "It allows for optional dependencies that are still autowired if available, preventing constructor bloat for non-essential services.", correct: true }
      - { value: "It makes the service non-shared.", correct: false }
      - { value: "It forces the service to be lazy-loaded.", correct: false }
      - { value: "It makes the service public.", correct: false }
    help: |
      `#[Required]` on setters is useful for dependencies that are technically optional for the class to function, but should be injected by the container if they exist. This helps keep constructors clean for truly essential dependencies.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: |
      You are creating a custom compiler pass. Which method must you implement in your compiler pass class?
    answers:
      - { value: "`process(ContainerBuilder $container)`", correct: true }
      - { value: "`compile(ContainerBuilder $container)`", correct: false }
      - { value: "`build(ContainerBuilder $container)`", correct: false }
      - { value: "`handle(ContainerBuilder $container)`", correct: false }
    help: |
      All compiler passes must implement the `process()` method, which receives the `ContainerBuilder` instance.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html#creating-a-compiler-pass

  -
    question: >
      Which of the following is a valid way to define a service in Symfony's PHP configuration using the `ContainerConfigurator`?
    answers:
      - { value: "`$services->set('app.my_service', App\\Service\\MyService::class);`", correct: true }
      - { value: "`$container->register('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$services->add('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$services->define('app.my_service', App\\Service\\MyService::class);`", correct: false }
    help: |
      In PHP service configuration with `ContainerConfigurator`, you use `$services->set()` to define a new service.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-services-in-php

  -
    question: >
      What is the purpose of the `autoconfigure: true` setting for services in Symfony?
    answers:
      - { value: "It automatically applies common configuration (like adding tags for autowiring) to services based on their class, interfaces, or attributes.", correct: true }
      - { value: "It enables autowiring for all services in the application.", correct: false }
      - { value: "It makes all services public by default.", correct: false }
      - { value: "It prevents services from being compiled.", correct: false }
    help: |
      `autoconfigure: true` tells Symfony to automatically apply common configuration, such as adding tags for services that implement certain interfaces (e.g., `EventSubscriberInterface`).
      https://symfony.com/doc/current/service_container/tags.html#autoconfiguration

  -
    question: |
      You want to define a service `App\\Service\\MyService` that uses a factory service `App\\Factory\\MyFactory` and its method `createService()`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`factory: ['@App\\Factory\\MyFactory', 'createService']`", correct: true }
      - { value: "`factory: App\\Factory\\MyFactory::createService`", correct: false }
      - { value: "`arguments: ['@App\\Factory\\MyFactory', 'createService']`", correct: false }
      - { value: "`class: App\\Service\\MyService, factory_service: App\\Factory\\MyFactory, factory_method: createService`", correct: false }
    help: |
      When the factory is itself a service, you reference it with `@` and then specify the method name.
      https://symfony.com/doc/current/service_container/factories.html#factory-as-a-service

  -
    question: >
      Which of the following is a built-in service in Symfony that provides access to the application's kernel?
    answers:
      - { value: "`kernel`", correct: true }
      - { value: "`app.kernel`", correct: false }
      - { value: "`http_kernel`", correct: false }
      - { value: "`container.kernel`", correct: false }
    help: |
      The `kernel` service (an instance of `Symfony\\Component\\HttpKernel\\KernelInterface`) provides access to the application's kernel.
      https://symfony.com/doc/current/reference/dic_tags.html#kernel-tags

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to be instantiated only when it's first requested (lazy loading). How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`lazy: true`", correct: true }
      - { value: "`shared: false`", correct: false }
      - { value: "`public: false`", correct: false }
      - { value: "`instantiate: lazy`", correct: false }
    help: |
      Setting `lazy: true` for a service tells the container to create a proxy for the service, and the actual service instance will only be created when it's first accessed.
      https://symfony.com/doc/current/service_container/lazy_services.html

  -
    question: >
      What is the primary benefit of using Dependency Injection in a Symfony application?
    answers:
      - { value: "Reduced coupling between components, improved testability, and enhanced reusability of code.", correct: true }
      - { value: "Faster application startup time.", correct: false }
      - { value: "Automatic generation of database schemas.", correct: false }
      - { value: "Simplified routing configuration.", correct: false }
    help: |
      Dependency Injection promotes loose coupling by allowing dependencies to be injected rather than hardcoded, leading to more modular, testable, and reusable code.
      https://symfony.com/doc/current/service_container.html#why-use-a-dependency-injection-container

  -
    question: |
      You want to register a PHP attribute for autoconfiguration, so that any service using this attribute gets a specific tag. Which method of `ContainerBuilder` would you use?
    answers:
      - { value: "`registerAttributeForAutoconfiguration(attributeClass: string, callable: callable)`", correct: true }
      - { value: "`registerForAutoconfiguration(interfaceOrClass: string)`", correct: false }
      - { value: "`addAutoconfigureAttribute(attributeClass: string, callable: callable)`", correct: false }
      - { value: "`configureAttribute(attributeClass: string)`", correct: false }
    help: |
      The `registerAttributeForAutoconfiguration()` method allows you to define a callback that will be executed for any service that uses the specified PHP attribute.
      https://symfony.com/doc/current/service_container/tags.html#registering-php-attributes-for-autoconfiguration

  -
    question: >
      Which of the following is a built-in service in Symfony that handles dispatching events?
    answers:
      - { value: "`event_dispatcher`", correct: true }
      - { value: "`dispatcher`", correct: false }
      - { value: "`event_manager`", correct: false }
      - { value: "`symfony.event_dispatcher`", correct: false }
    help: |
      The `event_dispatcher` service (an instance of `Symfony\\Component\\EventDispatcher\\EventDispatcherInterface`) is the central hub for event management in Symfony.
      https://symfony.com/doc/current/components/event_dispatcher.html

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.yaml`. You want to configure property injection for a public property named `myProperty` with the value of a parameter `app.my_param`. How would you do this?
    answers:
      - { value: "`properties: { myProperty: '%app.my_param%' }`", correct: true }
      - { value: "`arguments: { $myProperty: '%app.my_param%' }`", correct: false }
      - { value: "`calls: { setMyProperty: ['%app.my_param%'] }`", correct: false }
      - { value: "`property_injection: { myProperty: '%app.my_param%' }`", correct: false }
    help: |
      Property injection is configured using the `properties` key, mapping the property name to the service or parameter to inject.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      What is the purpose of the `ContainerConfigurator` class in Symfony's PHP service configuration?
    answers:
      - { value: "It provides a fluent API for defining services and parameters in PHP configuration files.", correct: true }
      - { value: "It is the main class for the compiled container.", correct: false }
      - { value: "It is used for loading YAML configuration files.", correct: false }
      - { value: "It manages environment variables.", correct: false }
    help: |
      `ContainerConfigurator` is the object passed to PHP service configuration files, offering a convenient way to define services, parameters, and aliases.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-services-in-php

  -
    question: |
      You want to define a service `App\\Service\\MyService` and explicitly set its class to `App\\Service\\MyConcreteService` in `config/services.yaml`, even if the service ID is different. How would you do this?
    answers:
      - { value: "`my_service_id: { class: App\\Service\\MyConcreteService }`", correct: true }
      - { value: "`my_service_id: App\\Service\\MyConcreteService`", correct: false }
      - { value: "`my_service_id: { type: App\\Service\\MyConcreteService }`", correct: false }
      - { value: "`my_service_id: { instance_of: App\\Service\\MyConcreteService }`", correct: false }
    help: |
      The `class` key explicitly defines the class to be instantiated for a service, regardless of its ID.
      https://symfony.com/doc/current/service_container.html#defining-services

  -
    question: >
      Which of the following is a built-in service in Symfony that provides functionality for sending emails?
    answers:
      - { value: "`mailer`", correct: true }
      - { value: "`email_sender`", correct: false }
      - { value: "`swiftmailer`", correct: false }
      - { value: "`symfony.mailer`", correct: false }
    help: |
      The `mailer` service (an instance of `Symfony\\Component\\Mailer\\MailerInterface`) is the primary service for sending emails in Symfony.
      https://symfony.com/doc/current/mailer.html

  -
    question: |
      You want to register an interface `App\\Contract\\MyInterface` for autoconfiguration, so that any service implementing it automatically gets a specific tag. Which method of `ContainerBuilder` would you use?
    answers:
      - { value: "`registerForAutoconfiguration(interfaceOrClass: string)`", correct: true }
      - { value: "`registerAttributeForAutoconfiguration(attributeClass: string, callable: callable)`", correct: false }
      - { value: "`addAutoconfigureInterface(interfaceOrClass: string)`", correct: false }
      - { value: "`configureInterface(interfaceOrClass: string)`", correct: false }
    help: |
      The `registerForAutoconfiguration()` method is used to apply autoconfiguration rules to interfaces or classes.
      https://symfony.com/doc/current/service_container/tags.html#registering-interfaces-for-autoconfiguration

  -
    question: >
      What is the purpose of the `#[Target]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To specify a named service to be injected when multiple services implement the same interface or when the service ID doesn't match the type-hint.", correct: true }
      - { value: "To define the target class for a service.", correct: false }
      - { value: "To mark a service as a target for a compiler pass.", correct: false }
      - { value: "To specify the environment a service should be used in.", correct: false }
    help: |
      The `#[Target]` attribute is crucial for disambiguating which service to inject when autowiring encounters multiple services that could satisfy a type-hint.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.yaml`. You want to prevent it from being shared, meaning a new instance is created every time it's requested. How would you configure this?
    answers:
      - { value: "`shared: false`", correct: true }
      - { value: "`lazy: true`", correct: false }
      - { value: "`public: false`", correct: false }
      - { value: "`instantiate: new`", correct: false }
    help: |
      Setting `shared: false` makes a service a "prototype," ensuring a new instance is returned each time it's retrieved from the container.
      https://symfony.com/doc/current/service_container.html#service-container-shared

  -
    question: >
      Which of the following is a built-in service in Symfony that provides access to the application's router?
    answers:
      - { value: "`router`", correct: true }
      - { value: "`url_generator`", correct: false }
      - { value: "`matcher`", correct: false }
      - { value: "`symfony.router`", correct: false }
    help: |
      The `router` service (an instance of `Symfony\\Component\\Routing\\RouterInterface`) is used for generating URLs and matching incoming requests to routes.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: |
      You want to inject the `kernel.environment` parameter into your service's constructor. How would you define the constructor argument using PHP attributes?
    answers:
      - { value: "`#[Autowire('%kernel.environment%')] string $env`", correct: true }
      - { value: "`#[Autowire(param: 'kernel.environment')] string $env`", correct: true }
      - { value: "`#[Autowire(env: 'kernel.environment')] string $env`", correct: false }
      - { value: "`string $env` (if autowiring by name is enabled and matches)`", correct: true }
    help: |
      You can explicitly inject parameters using `#[Autowire('%parameter_name%')]` or `#[Autowire(param: 'parameter_name')]`. If autowiring by name is enabled and the argument name matches the parameter name (e.g., `$kernelEnvironment`), it might also work without explicit attributes.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the primary role of the `ContainerInterface` (from `Psr\\Container`) in Symfony?
    answers:
      - { value: "To provide a standardized way to retrieve services from a container, promoting interoperability.", correct: true }
      - { value: "To define how services are compiled.", correct: false }
      - { value: "To manage the application's configuration.", correct: false }
      - { value: "To handle HTTP requests.", correct: false }
    help: |
      `Psr\\Container\\ContainerInterface` defines a common interface for dependency injection containers, allowing for interchangeable container implementations. Symfony's `Container` implements this interface.
      https://www.php-fig.org/psr/psr-11/

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject a value that is the result of a static method call `MyHelper::calculateValue()`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`arguments: ['@=App\\Helper\\MyHelper::calculateValue()']`", correct: true }
      - { value: "`arguments: ['App\\Helper\\MyHelper::calculateValue()']`", correct: false }
      - { value: "`factory: ['App\\Helper\\MyHelper', 'calculateValue']`", correct: true }
      - { value: "`arguments: [{ static_call: 'App\\Helper\\MyHelper::calculateValue' }]`", correct: false }
    help: |
      You can use Expression Language (`@=`) to call static methods and inject their return values. Alternatively, you can use the `factory` key if the static method is intended as a service factory.
      https://symfony.com/doc/current/service_container/expression_language.html
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      When should you consider using a "factory" to create a service in Symfony?
    answers:
      - { value: "When the service's construction logic is complex, involves external resources, or requires conditional instantiation.", correct: true }
      - { value: "When the service has no dependencies.", correct: false }
      - { value: "When the service needs to be lazy-loaded.", correct: false }
      - { value: "When the service is an alias of another service.", correct: false }
    help: |
      Factories are useful when the service cannot be simply instantiated with `new Class()`, but requires more complex setup logic.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.php`. You want to make it an alias of `App\\Service\\OriginalService`. How would you do this?
    answers:
      - { value: "`$services->alias(App\\Service\\MyService::class, App\\Service\\OriginalService::class);`", correct: true }
      - { value: "`$services->set(App\\Service\\MyService::class)->alias(App\\Service\\OriginalService::class);`", correct: false }
      - { value: "`$services->set(App\\Service\\MyService::class)->args([service(App\\Service\\OriginalService::class)]);`", correct: false }
      - { value: "`$container->setAlias(App\\Service\\MyService::class, App\\Service\\OriginalService::class);`", correct: true }
    help: |
      In PHP configuration, you can use `$services->alias()` or `$container->setAlias()` to create an alias for a service.
      https://symfony.com/doc/current/service_container/alias_private.html#aliasing-in-php

  -
    question: >
      What is the primary role of the `#[Required]` attribute when applied to a constructor argument?
    answers:
      - { value: "It ensures that the argument is always autowired, even if it could be resolved from multiple services, effectively making it mandatory for autowiring.", correct: true }
      - { value: "It makes the dependency optional.", correct: false }
      - { value: "It marks the service as a factory.", correct: false }
      - { value: "It forces the service to be public.", correct: false }
    help: |
      While constructor arguments are generally required, `#[Required]` can be used to explicitly signal that a dependency must be autowired, especially in cases where autowiring might otherwise fail due to ambiguity.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required (applies conceptually to constructor too for clarity)

  -
    question: |
      You want to inject the `kernel.project_dir` parameter into a service's constructor, ensuring it's always a string. Which type-hint and attribute combination is most robust?
    answers:
      - { value: "`#[Autowire('%kernel.project_dir%')] string $projectDir`", correct: true }
      - { value: "`string $projectDir`", correct: false }
      - { value: "`#[Autowire(param: 'kernel.project_dir')] string $projectDir`", correct: true }
      - { value: "`#[Autowire(env: 'string:kernel.project_dir')] string $projectDir`", correct: false }
    help: |
      Explicitly using `#[Autowire('%parameter_name%')]` or `#[Autowire(param: 'parameter_name')]` with a type-hint ensures the correct parameter is injected and type-checked.
      https://symfony.com/doc/current/controller.html#injecting-services-and-parameters

  -
    question: >
      Which of the following describes the "autowire by name" feature in Symfony?
    answers:
      - { value: "When a constructor argument or setter method parameter's name matches a registered service ID or parameter name, Symfony automatically injects it.", correct: true }
      - { value: "Automatically generating service IDs based on class names.", correct: false }
      - { value: "Injecting services based on their fully qualified class name.", correct: false }
      - { value: "Using `#[Target]` to specify a service by its name.", correct: false }
    help: |
      Autowire by name is a feature where Symfony attempts to inject a service or parameter if its ID or name matches the argument name, even without a type-hint or explicit attribute.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-name

  -
    question: |
      You are developing a bundle and want to register a compiler pass. Where should you typically add your compiler pass?
    answers:
      - { value: "In the `build()` method of your bundle's main class (e.g., `AppBundle.php`).", correct: true }
      - { value: "In the `load()` method of your bundle's extension class.", correct: false }
      - { value: "In the `boot()` method of your bundle's main class.", correct: false }
      - { value: "In `config/services.yaml`.", correct: false }
    help: |
      Compiler passes are added to the `ContainerBuilder` during the `build()` method of your bundle's main class.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html#registering-a-compiler-pass

  -
    question: >
      What is the primary difference between `#[Autowire(service: 'service_id')]` and `#[Target('service_id')]`?
    answers:
      - { value: "`#[Autowire(service: 'service_id')]` explicitly injects a service by its ID, bypassing autowiring logic, while `#[Target('service_id')]` guides autowiring to pick a specific service when multiple candidates exist for a type-hint.", correct: true }
      - { value: "They are completely interchangeable and serve the exact same purpose.", correct: false }
      - { value: "`#[Target]` is for parameters, `#[Autowire]` is for services.", correct: false }
      - { value: "`#[Autowire]` is for constructor injection, `#[Target]` is for setter injection.", correct: false }
    help: |
      `#[Autowire(service: ...)]` provides direct, explicit control over which service is injected. `#[Target(...)]` is used specifically to resolve ambiguity when autowiring by type, telling autowiring which of several matching services to choose.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: >
      Which of the following is a built-in service in Symfony that provides access to the application's HTTP client?
    answers:
      - { value: "`http_client`", correct: true }
      - { value: "`guzzle_client`", correct: false }
      - { value: "`web_client`", correct: false }
      - { value: "`symfony.http_client`", correct: false }
    help: |
      The `http_client` service (an instance of `Symfony\\Contracts\\HttpClient\\HttpClientInterface`) is the default service for making HTTP requests.
      https://symfony.com/doc/current/http_client.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` that depends on a `Psr\\Log\\LoggerInterface`. You prefer autowiring. How would you define the service in `config/services.yaml` to enable autowiring for it?
    answers:
      - { value: "`App\\Service\\MyService: ~`", correct: true }
      - { value: "`App\\Service\\MyService: { autowire: true }`", correct: true }
      - { value: "`App\\Service\\MyService: { arguments: ['@logger'] }`", correct: false }
      - { value: "`App\\Service\\MyService: { class: App\\Service\\MyService, autowire: true }`", correct: true }
    help: |
      By default, `config/services.yaml` has `_defaults: { autowire: true, public: false }`. So `App\\Service\\MyService: ~` is sufficient. Explicitly setting `autowire: true` is also correct.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-type

  -
    question: >
      What is the purpose of the `#[AutowireServiceClosure]` attribute?
    answers:
      - { value: "To inject a lazy-loading closure for a service, delaying its instantiation until the closure is invoked.", correct: true }
      - { value: "To automatically create a service from a closure.", correct: false }
      - { value: "To define a service as a closure.", correct: false }
      - { value: "To inject a service into a closure.", correct: false }
    help: |
      `#[AutowireServiceClosure]` is used to inject a callable that, when called, returns the service instance. This is a form of lazy injection.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-service-closures

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to be decorated by `App\\Service\\MyDecorator`. The decorator also needs the original service. How would you configure this in `config/services.yaml`?

      ```yaml
      services:
          App\Service\MyDecorator:
              decorates: App\Service\MyService
              arguments:
                  - '@.inner'
                  # ... other arguments for MyDecorator
      ```
      What is the significance of the `decorates` key?
    answers:
      - { value: "It specifies the ID of the service that this service will replace and wrap.", correct: true }
      - { value: "It defines the class that this service extends.", correct: false }
      - { value: "It indicates that this service is an alias of another.", correct: false }
      - { value: "It marks this service as a factory.", correct: false }
    help: |
      The `decorates` key is used to tell Symfony that this service should replace another existing service. The original service becomes available via the special `@.inner` reference.
      https://symfony.com/doc/current/service_container/service_decoration.html#decorating-a-service

  -
    question: >
      Which of the following is a valid way to define a service in Symfony's PHP configuration using the `ContainerBuilder` directly (less common in modern Symfony apps)?
    answers:
      - { value: "`$container->register('app.my_service', App\\Service\\MyService::class);`", correct: true }
      - { value: "`$container->set('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$container->add('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$container->define('app.my_service', App\\Service\\MyService::class);`", correct: false }
    help: |
      The `register()` method on `ContainerBuilder` is used to define a new service definition programmatically.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-services-in-php

  -
    question: >
      What is the primary role of the `#[Autowire]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To explicitly control how a specific constructor argument, setter method, or property is autowired, allowing injection of specific services, parameters, environment variables, or expression results.", correct: true }
      - { value: "To enable autowiring for an entire class.", correct: false }
      - { value: "To mark a service as required.", correct: false }
      - { value: "To define an alias for a service.", correct: false }
    help: |
      The `#[Autowire]` attribute provides fine-grained control over autowiring, allowing you to specify exactly what should be injected into a particular dependency.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowirecategory: Dependency Injection

questions:
  -
    question: >
      What is the primary purpose of the Symfony Dependency Injection Container?
    answers:
      - { value: "To manage and centralize the instantiation and configuration of objects (services) in an application.", correct: true }
      - { value: "To handle HTTP requests and responses.", correct: false }
      - { value: "To manage database connections and ORM entities.", correct: false }
      - { value: "To provide a templating engine for rendering views.", correct: false }
    help: |
      The Dependency Injection Container (DIC) is a tool that manages the instantiation of services and injects their dependencies. It centralizes service creation and configuration, promoting loose coupling and reusability.
      https://symfony.com/doc/current/service_container.html

  -
    question: |
      Which of the following methods is used to retrieve a service from the Symfony Dependency Injection Container by its ID?
    answers:
      - { value: "`$container->get('service_id')`", correct: true }
      - { value: "`$container->find('service_id')`", correct: false }
      - { value: "`$container->load('service_id')`", correct: false }
      - { value: "`$container->fetch('service_id')`", correct: false }
    help: |
      The `get()` method of the container is used to retrieve a service by its unique ID.
      https://symfony.com/doc/current/components/dependency_injection.html#retrieving-services

  -
    question: >
      In Symfony, what happens during the "compilation" phase of the Dependency Injection Container?
    answers:
      - { value: "The container is optimized for performance by compiling service definitions into a highly optimized PHP class.", correct: true }
      - { value: "All services are instantiated and their dependencies are resolved.", correct: false }
      - { value: "Configuration files (YAML, XML, PHP) are parsed and validated.", correct: false }
      - { value: "The application's cache is cleared and rebuilt.", correct: false }
    help: |
      During compilation, the container builder processes all service definitions, applies compiler passes, and dumps an optimized PHP class that represents the compiled container. This compiled container is then used at runtime for performance.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: |
      Consider the following YAML service definition. How would you configure `App\\Mail\\NewsletterManager` to use constructor injection for the `mailer` service?

      ```yaml
      # config/services.yaml
      services:
          # ...
          App\Mail\NewsletterManager:
              # ???
      ```
    answers:
      - { value: "`arguments: ['@mailer']`", correct: true }
      - { value: "`calls: [{ method: '__construct', arguments: ['@mailer'] }]`", correct: false }
      - { value: "`properties: { mailer: '@mailer' }`", correct: false }
      - { value: "`autowire: true`", correct: false }
    help: |
      For constructor injection in YAML, you use the `arguments` key to specify the services or parameters to be passed to the constructor.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: |
      Given the following PHP class, which Symfony attribute would you use on the `setLogger` method to ensure it's automatically called by autowiring for dependency injection, even if the dependency is optional?

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Contracts\Service\Attribute\Required; // Assume this is available

      class MessageGenerator
      {
          private LoggerInterface $logger;

          // ???
          public function setLogger(LoggerInterface $logger): void
          {
              $this->logger = $logger;
          }
      }
      ```
    answers:
      - { value: "`#[Required]`", correct: true }
      - { value: "`#[Autowire]`", correct: false }
      - { value: "`#[Inject]`", correct: false }
      - { value: "`#[Service]`", correct: false }
    help: |
      The `#[Required]` attribute marks a setter method (or public property) as required for autowiring. Symfony will ensure this dependency is provided.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: >
      Which of the following is a common built-in service in Symfony that you would typically inject for logging purposes?
    answers:
      - { value: "`Psr\\Log\\LoggerInterface`", correct: true }
      - { value: "`Symfony\\Component\\HttpFoundation\\Request`", correct: false }
      - { value: "`Symfony\\Component\\Mailer\\MailerInterface`", correct: false }
      - { value: "`Symfony\\Component\\EventDispatcher\\EventDispatcherInterface`", correct: false }
    help: |
      Symfony integrates with PSR-3 for logging, and `Psr\\Log\\LoggerInterface` is the standard interface to type-hint for injecting a logger.
      https://symfony.com/doc/current/logging.html#autowiring-logger-channels

  -
    question: |
      You want to inject a specific environment variable `APP_ENV` into your service. Which `#[Autowire]` parameter should you use?
    answers:
      - { value: "`env: 'APP_ENV'`", correct: true }
      - { value: "`param: 'APP_ENV'`", correct: false }
      - { value: "`service: 'APP_ENV'`", correct: false }
      - { value: "`expression: 'env("APP_ENV")'`", correct: false }
    help: |
      The `env` parameter of the `#[Autowire]` attribute is used to inject environment variables.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the purpose of a "parameter" in the Symfony Dependency Injection Container?
    answers:
      - { value: "To store scalar values (strings, numbers, booleans) that can be injected into services.", correct: true }
      - { value: "To define the arguments for a service's constructor.", correct: false }
      - { value: "To mark a service for specific processing by a compiler pass.", correct: false }
      - { value: "To create an alias for an existing service ID.", correct: false }
    help: |
      Parameters in the container are used to store simple configuration values that can be reused across different service definitions.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to use an immutable setter `withMailer(MailerInterface $mailer)`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`calls: { withMailer: !returns_clone ['@mailer'] }`", correct: true }
      - { value: "`calls: { withMailer: ['@mailer'] }`", correct: false }
      - { value: "`arguments: { withMailer: '@mailer' }`", correct: false }
      - { value: "`properties: { mailer: '@mailer', returns_clone: true }`", correct: false }
    help: |
      For immutable setter injection (wither methods) in YAML, you use the `!returns_clone` tag with the method call to indicate that the container should use the returned cloned instance.
      https://symfony.com/doc/current/service_container/injection_types.html#immutable-setter-injection

  -
    question: >
      Which of the following best describes "service autowiring" in Symfony?
    answers:
      - { value: "Automatically injecting dependencies into a service based on type-hints in its constructor, setter methods, or public properties.", correct: true }
      - { value: "Manually defining every dependency for every service in configuration files.", correct: false }
      - { value: "Loading all services into the container at application bootstrap.", correct: false }
      - { value: "Generating a unique ID for every service in the container.", correct: false }
    help: |
      Autowiring automatically reads the type-hints on your constructor arguments, setter methods, and public properties and passes the correct services to them.
      https://symfony.com/doc/current/service_container/autowiring.html

  -
    question: |
      You have two services, `App\\Util\\Rot13Transformer` and `App\\Util\\CaesarCipherTransformer`, both implementing `App\\Util\\TransformerInterface`. In `App\\Service\\TwitterClient`, you want to inject specifically the `Rot13Transformer`. How can you achieve this using PHP attributes?

      ```php
      namespace App\Service;

      use App\Util\TransformerInterface;
      use Symfony\Component\DependencyInjection\Attribute\Target;

      class TwitterClient
      {
          public function __construct(
              // ???
              private TransformerInterface $transformer,
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[Target('rot13Transformer')]`", correct: true }
      - { value: "`#[Autowire(service: 'rot13Transformer')]`", correct: true }
      - { value: "`#[Required]`", correct: false }
      - { value: "`#[Service('rot13Transformer')]`", correct: false }
    help: |
      The `#[Target]` attribute allows you to specify which named service should be injected when multiple services implement the same interface. Alternatively, `#[Autowire(service: 'service_id')]` can be used for explicit service injection.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: >
      What is the primary benefit of using constructor injection over public property injection in Symfony?
    answers:
      - { value: "Constructor injection ensures that all required dependencies are provided at the time of object creation, making the object always in a valid state.", correct: true }
      - { value: "Property injection is faster because it bypasses the constructor.", correct: false }
      - { value: "Constructor injection allows for optional dependencies more easily.", correct: false }
      - { value: "Property injection makes services easier to test.", correct: false }
    help: |
      Constructor injection makes dependencies explicit and ensures the object is fully initialized and valid upon creation. Property injection can lead to less predictable states.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: |
      You want to collect all services tagged with `app.handler` into an `iterable` argument in your `HandlerCollection` class. Which attribute should you use?

      ```php
      namespace App;

      use Symfony\Component\DependencyInjection\Attribute\AutowireIterator;

      class HandlerCollection
      {
          public function __construct(
              // ???
              iterable $handlers
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[AutowireIterator('app.handler')]`", correct: true }
      - { value: "`#[Target('app.handler')]`", correct: false }
      - { value: "`#[Autowire(tag: 'app.handler')]`", correct: false }
      - { value: "`#[CollectServices('app.handler')]`", correct: false }
    help: |
      The `#[AutowireIterator]` attribute is used to inject all services tagged with a specific name as an `iterable` (or `array`, `\Traversable`, `\Iterator`).
      https://symfony.com/doc/current/service_container/tags.html#autowiring-tagged-services

  -
    question: >
      Which interface must a class implement to be considered a "service subscriber" and allow for lazy loading of specific dependencies via a service locator?
    answers:
      - { value: "`Symfony\\Contracts\\Service\\ServiceSubscriberInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\ContainerAwareInterface`", correct: false }
      - { value: "`Psr\\Container\\ContainerInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\KernelInterface`", correct: false }
    help: |
      Classes implementing `ServiceSubscriberInterface` can declare their dependencies via the `getSubscribedServices()` method, which Symfony uses to generate a service locator for them.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#service-subscribers

  -
    question: >
      What is the purpose of "service decoration" in Symfony?
    answers:
      - { value: "To replace an existing service with a new one, while still allowing the original service to be used internally by the decorator.", correct: true }
      - { value: "To add new methods to an existing service at runtime.", correct: false }
      - { value: "To make a private service public.", correct: false }
      - { value: "To define a service that depends on multiple other services.", correct: false }
    help: |
      Service decoration allows you to wrap an existing service with a new one, enabling you to add or modify behavior without changing the original service's code.
      https://symfony.com/doc/current/service_container/service_decoration.html

  -
    question: |
      You want to define a service `my_app.mailer` that is created by calling the static method `MailerFactory::createMailer()`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`factory: ['App\\Factory\\MailerFactory', 'createMailer']`", correct: true }
      - { value: "`class: App\\Factory\\MailerFactory, method: createMailer`", correct: false }
      - { value: "`arguments: ['@App\\Factory\\MailerFactory', 'createMailer']`", correct: false }
      - { value: "`factory: App\\Factory\\MailerFactory::createMailer`", correct: false }
    help: |
      The `factory` key in a service definition allows you to specify a callable (an array with class/service ID and method name) that will be used to create the service instance.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      What is a "compiler pass" in the context of the Symfony Dependency Injection Container?
    answers:
      - { value: "A PHP class that allows you to inspect and modify service definitions before the container is compiled.", correct: true }
      - { value: "A method used to compile Twig templates.", correct: false }
      - { value: "A command-line tool for optimizing Symfony applications.", correct: false }
      - { value: "A mechanism for defining routes in a Symfony application.", correct: false }
    help: |
      Compiler passes are PHP classes that hook into the container's compilation process, allowing for programmatic manipulation of service definitions.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html

  -
    question: |
      You have a bundle `AcmeDemoBundle` and want to prepend configuration for another bundle's extension (e.g., `framework`) during the container compilation. Which interface should your bundle's extension implement?
    answers:
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\PrependExtensionInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface`", correct: false }
      - { value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`", correct: false }
    help: |
      Bundles that need to prepend configuration for other extensions must implement `PrependExtensionInterface` and define the `prepend()` method.
      https://symfony.com/doc/current/bundles/prepend_extension.html

  -
    question: |
      Consider the following service definition in `config/services.yaml`:

      ```yaml
      services:
          App\Service\MyService:
              arguments:
                  $param1: '%app.config.value%'
      ```
      What does `%app.config.value%` represent?
    answers:
      - { value: "A container parameter named `app.config.value`.", correct: true }
      - { value: "A service ID named `app.config.value`.", correct: false }
      - { value: "An environment variable named `APP_CONFIG_VALUE`.", correct: false }
      - { value: "A Twig global variable.", correct: false }
    help: |
      Values enclosed in `%` are interpreted as container parameters.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html

  -
    question: >
      When should you consider making a service "private" in Symfony?
    answers:
      - { value: "When the service is only intended to be injected into other services and not retrieved directly from the container using `$container->get()`.", correct: true }
      - { value: "When the service contains sensitive information.", correct: false }
      - { value: "When the service is not used by any other service.", correct: false }
      - { value: "When the service needs to be lazy-loaded.", correct: false }
    help: |
      Services are private by default in Symfony 4.0 and later. Private services cannot be retrieved directly from the container via `get()`, but can still be injected into other services. This promotes better encapsulation and prevents misuse.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: |
      Which of the following configuration formats are officially supported for defining services in Symfony 7?
    answers:
      - { value: "YAML", correct: true }
      - { value: "XML", correct: true }
      - { value: "PHP", correct: true }
      - { value: "JSON", correct: false }
      - { value: "INI", correct: false }
    help: |
      Symfony officially supports YAML, XML, and PHP for defining services in the Dependency Injection Container.
      https://symfony.com/doc/current/service_container.html#configuration-formats

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject the `kernel.project_dir` parameter into its constructor. How would you do this using the `#[Autowire]` attribute?

      ```php
      namespace App\Service;

      use Symfony\Component\DependencyInjection\Attribute\Autowire;

      class MyService
      {
          public function __construct(
              // ???
              string $projectDir
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[Autowire('%kernel.project_dir%')]`", correct: true }
      - { value: "`#[Autowire(param: 'kernel.project_dir')]`", correct: true }
      - { value: "`#[Autowire(env: 'kernel.project_dir')]`", correct: false }
      - { value: "`#[Autowire(service: 'kernel.project_dir')]`", correct: false }
    help: |
      The `#[Autowire]` attribute can inject parameter values by prefixing the parameter name with `%` or by using the `param` argument.
      https://symfony.com/doc/current/controller.html#injecting-services-and-parameters

  -
    question: >
      What is the primary role of the `ContainerBuilder` class in Symfony's Dependency Injection component?
    answers:
      - { value: "It is used to define, register, and compile service definitions.", correct: true }
      - { value: "It provides a runtime interface for retrieving services.", correct: false }
      - { value: "It manages the application's configuration tree.", correct: false }
      - { value: "It handles routing for incoming HTTP requests.", correct: false }
    help: |
      The `ContainerBuilder` is the central class for building and managing the dependency injection container during the compilation process.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a `Psr\\Log\\LoggerInterface` into its public property `$logger`. Which attribute would you use on the property to enable autowiring?

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Contracts\Service\Attribute\Required;

      class MyService
      {
          // ???
          public LoggerInterface $logger;
      }
      ```
    answers:
      - { value: "`#[Required]`", correct: true }
      - { value: "`#[Autowire]`", correct: false }
      - { value: "`#[Inject]`", correct: false }
      - { value: "`#[Property]`", correct: false }
    help: |
      The `#[Required]` attribute can be applied to public properties to enable autowiring for them.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-public-property-injection

  -
    question: >
      Which of the following is a valid way to define a service alias in Symfony's YAML configuration?
    answers:
      - { value: "`Symfony\\Component\\HttpKernel\\Profiler\\Profiler: '@profiler'`", correct: true }
      - { value: "`profiler_alias: { alias_of: 'profiler' }`", correct: false }
      - { value: "`alias: profiler, service: Symfony\\Component\\HttpKernel\\Profiler\\Profiler`", correct: false }
      - { value: "`@profiler: Symfony\\Component\\HttpKernel\\Profiler\\Profiler`", correct: false }
    help: |
      In YAML, you can define an alias by mapping the alias ID to the original service ID using the `@` symbol.
      https://symfony.com/doc/current/service_container/alias_private.html#aliasing

  -
    question: >
      What is the main advantage of using "tags" for services in Symfony?
    answers:
      - { value: "To mark services that belong to a certain group or fulfill a specific contract, allowing them to be collected and processed by compiler passes or autowired as collections.", correct: true }
      - { value: "To define the visibility of a service (public or private).", correct: false }
      - { value: "To specify the arguments for a service's constructor.", correct: false }
      - { value: "To enable lazy loading for a service.", correct: false }
    help: |
      Tags are metadata assigned to services. They are primarily used by compiler passes to find and process groups of services, or by autowiring to inject collections of services.
      https://symfony.com/doc/current/service_container/tags.html

  -
    question: |
      You are developing a bundle and want to define its configuration tree. Which interface must your configuration class implement?
    answers:
      - { value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Bundle\\BundleInterface`", correct: false }
      - { value: "`Symfony\\Component\\Config\\ConfigCacheInterface`", correct: false }
    help: |
      The configuration class for a bundle's semantic configuration must implement `ConfigurationInterface` and define the `getConfigTreeBuilder()` method.
      https://symfony.com/doc/current/bundles/extension.html#semantic-configuration

  -
    question: >
      What is a "synthetic service" in Symfony's Dependency Injection Container?
    answers:
      - { value: "A service that is not instantiated by the container but is an existing object injected into the container at runtime.", correct: true }
      - { value: "A service that is generated automatically by autowiring.", correct: false }
      - { value: "A service that is always lazy-loaded.", correct: false }
      - { value: "A service that is only available in the `dev` environment.", correct: false }
    help: |
      Synthetic services are services for which the container does not create the instance. Instead, an existing object instance is injected into the container at runtime using `Container::set()`.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: |
      How can you load service definitions from a PHP configuration file (`services.php`) into a `ContainerBuilder`?
    answers:
      - { value: "Using `Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader`.", correct: true }
      - { value: "Using `Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader`.", correct: false }
      - { value: "Using `Symfony\\Component\\DependencyInjection\\Loader\\XmlFileLoader`.", correct: false }
      - { value: "By directly including the PHP file.", correct: false }
    help: |
      The `PhpFileLoader` is used to load service definitions from PHP files.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-php-files

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject the result of a Symfony Expression Language expression `service('my_other_service').getData()` into its constructor. Which `#[Autowire]` parameter would you use?
    answers:
      - { value: "`expression: 'service("my_other_service").getData()'`", correct: true }
      - { value: "`service: 'expression:service("my_other_service").getData()'`", correct: false }
      - { value: "`param: 'expression:service("my_other_service").getData()'`", correct: false }
      - { value: "`env: 'expression:service("my_other_service").getData()'`", correct: false }
    help: |
      The `expression` parameter of the `#[Autowire]` attribute allows you to inject the result of a Symfony Expression Language expression.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the purpose of the `#[AsCommand]` attribute when defining a console command as a service in Symfony?
    answers:
      - { value: "To register the command as a service and define its name and description.", correct: true }
      - { value: "To make the command automatically executable without manual registration.", correct: false }
      - { value: "To inject services into the command's `execute` method.", correct: false }
      - { value: "To mark the command as a required service.", correct: false }
    help: |
      The `#[AsCommand]` attribute is used to configure console commands directly in their class, including their name and description, when they are defined as services.
      https://symfony.com/doc/current/console/commands_as_services.html

  -
    question: >
      Which of the following statements is TRUE regarding the default behavior of services in Symfony 7?
    answers:
      - { value: "Services are private by default.", correct: true }
      - { value: "Services are shared by default.", correct: true }
      - { value: "Services are public by default.", correct: false }
      - { value: "Services are non-shared (always new instance) by default.", correct: false }
    help: |
      Since Symfony 4.0, services are private by default. Services are also shared by default, meaning the container returns the same instance every time it's requested.
      https://symfony.com/doc/current/service_container/alias_private.html
      https://symfony.com/doc/current/service_container.html#service-container-shared

  -
    question: |
      You want to inject a service closure (lazy-loaded service) into your constructor. Which attribute can automatically create this closure for a service?
    answers:
      - { value: "`#[AutowireServiceClosure]`", correct: true }
      - { value: "`#[Lazy]`", correct: false }
      - { value: "`#[ServiceClosure]`", correct: false }
      - { value: "`#[Autowire(lazy: true)]`", correct: false }
    help: |
      The `#[AutowireServiceClosure]` attribute automatically creates an anonymous function (closure) that returns the service, useful for lazy-loading.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-service-closures

  -
    question: >
      What is the main benefit of using a "service locator" pattern in Symfony?
    answers:
      - { value: "To provide a way to lazily load optional dependencies, avoiding injecting the entire container or many services into a class.", correct: true }
      - { value: "To make all services globally accessible.", correct: false }
      - { value: "To replace the entire Dependency Injection Container.", correct: false }
      - { value: "To explicitly define all service dependencies in configuration.", correct: false }
    help: |
      Service locators (often implemented via `ServiceSubscriberInterface`) allow you to declare and lazily retrieve specific services, avoiding constructor bloat when dealing with many optional dependencies.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      Given the following PHP service definition, how would you configure it in `config/services.yaml` to use setter injection for the `mailer` service?

      ```php
      namespace App\Mail;

      use Symfony\Component\Mailer\MailerInterface;

      class NewsletterManager
      {
          private MailerInterface $mailer;

          public function setMailer(MailerInterface $mailer): void
          {
              $this->mailer = $mailer;
          }
      }
      ```
    answers:
      - { value: "`calls: { setMailer: ['@mailer'] }`", correct: true }
      - { value: "`arguments: { setMailer: '@mailer' }`", correct: false }
      - { value: "`properties: { mailer: '@mailer' }`", correct: false }
      - { value: "`autowire: true, setter: setMailer`", correct: false }
    help: |
      For setter injection in YAML, you use the `calls` key to specify the method to call and its arguments.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: >
      Which of the following is a valid way to define a parameter in Symfony's PHP service configuration?
    answers:
      - { value: "`$container->parameters()->set('mailer.transport', 'sendmail');`", correct: true }
      - { value: "`$container->addParameter('mailer.transport', 'sendmail');`", correct: false }
      - { value: "`$container->setParameter('mailer.transport', 'sendmail');`", correct: false }
      - { value: "`$container->config()->set('mailer.transport', 'sendmail');`", correct: false }
    help: |
      In PHP service configuration files (e.g., `config/services.php`), parameters are defined using `$container->parameters()->set()`.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html

  -
    question: >
      What is the purpose of the `#[Autoconfigure]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To define autoconfiguration rules (e.g., tags) directly on a class, which apply when the class is registered as a service.", correct: true }
      - { value: "To automatically inject all dependencies without explicit configuration.", correct: false }
      - { value: "To mark a service as an alias for another service.", correct: false }
      - { value: "To specify a factory method for a service.", correct: false }
    help: |
      The `#[Autoconfigure]` attribute allows you to define autoconfiguration rules (like adding tags) directly on a class, which will be applied when that class is registered as a service.
      https://symfony.com/doc/current/service_container/tags.html#autoconfigure-attribute

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to access the `request_stack` service. Which of the following is the most idiomatic way to inject it in Symfony 7 with autowiring enabled?
    answers:
      - { value: "Type-hint `Symfony\\Component\\HttpFoundation\\RequestStack` in the constructor.", correct: true }
      - { value: "Use `$container->get('request_stack')` inside the service.", correct: false }
      - { value: "Define `request_stack` in `arguments` in `services.yaml`.", correct: false }
      - { value: "Implement `ContainerAwareInterface` and use `setContainer`.", correct: false }
    help: |
      With autowiring enabled, type-hinting the `RequestStack` interface or class in your constructor is the preferred and most idiomatic way to inject the service.
      https://symfony.com/doc/current/service_container.html#injecting-a-single-service

  -
    question: >
      Which of the following is NOT a valid type of dependency injection supported by Symfony's service container?
    answers:
      - { value: "Method injection (non-setter)", correct: true }
      - { value: "Constructor injection", correct: false }
      - { value: "Setter injection", correct: false }
      - { value: "Property injection", correct: false }
      - { value: "Immutable setter injection (wither)", correct: false }
    help: |
      Symfony supports constructor, setter, property, and immutable setter injection. While you can call any method, "method injection" typically refers to injecting dependencies via arbitrary public methods, which is not a primary DI type in Symfony's container.
      https://symfony.com/doc/current/service_container/injection_types.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a specific logger channel, e.g., `monolog.logger.event`. How would you achieve this using the `#[Autowire]` attribute?

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Component\DependencyInjection\Attribute\Autowire;

      class MyService
      {
          public function __construct(
              // ???
              LoggerInterface $eventLogger
          ) {
          }
      }
      ```
    answers:
      - { value: "`#[Autowire(service: 'monolog.logger.event')]`", correct: true }
      - { value: "`#[Target('monolog.logger.event')]`", correct: false }
      - { value: "`#[Autowire(channel: 'event')]`", correct: false }
      - { value: "`#[Autowire('%monolog.logger.event%')]`", correct: false }
    help: |
      The `#[Autowire(service: 'service_id')]` attribute allows you to explicitly specify which service ID to inject, overriding autowiring's default behavior.
      https://symfony.com/doc/current/controller.html#injecting-services-and-parameters

  -
    question: >
      What is the purpose of the `public: false` setting for a service in Symfony's configuration?
    answers:
      - { value: "It makes the service inaccessible directly via `$container->get()`, but it can still be injected into other services.", correct: true }
      - { value: "It prevents the service from being instantiated.", correct: false }
      - { value: "It makes the service available only in the `dev` environment.", correct: false }
      - { value: "It marks the service as deprecated.", correct: false }
    help: |
      Setting `public: false` (or relying on the default `private` behavior in modern Symfony) means the service cannot be retrieved directly from the container using `get()`. This promotes proper dependency injection.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.php` using the `ContainerConfigurator`. How would you configure a setter injection for the `setLogger` method?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\MyService;
      use Symfony\Component\DependencyInjection\Reference;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(MyService::class)
              // ???
          ;
      };
      ```
    answers:
      - { value: "`->call('setLogger', [service('logger')])`", correct: true }
      - { value: "`->addMethodCall('setLogger', [new Reference('logger')])`", correct: true }
      - { value: "`->setter('setLogger', service('logger'))`", correct: false }
      - { value: "`->setLogger(service('logger'))`", correct: false }
    help: |
      In PHP service configuration, you use the `call()` method (or `addMethodCall()` on a `Definition` object) to configure setter injection. `service()` is a helper function to create a service reference.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: >
      What is the primary difference between a "shared" and a "non-shared" service in Symfony?
    answers:
      - { value: "A shared service returns the same instance every time it's requested, while a non-shared service (prototype) returns a new instance each time.", correct: true }
      - { value: "Shared services are public, non-shared services are private.", correct: false }
      - { value: "Shared services are lazy-loaded, non-shared services are not.", correct: false }
      - { value: "Shared services are compiled, non-shared services are not.", correct: false }
    help: |
      By default, services are shared (singleton). You can explicitly mark a service as `shared: false` to make it a prototype, meaning a new instance is created on each request.
      https://symfony.com/doc/current/service_container.html#service-container-shared

  -
    question: |
      You want to inject the `kernel.debug` parameter as a boolean into your bundle's `Configuration` class constructor. How would you define the constructor?

      ```php
      namespace App\DependencyInjection;

      use Symfony\Component\Config\Definition\Builder\TreeBuilder;
      use Symfony\Component\Config\Definition\ConfigurationInterface;

      class Configuration implements ConfigurationInterface
      {
          private bool $debug;

          // ???
          public function __construct(private bool $debug)
          {
          }

          // ...
      }
      ```
    answers:
      - { value: "`public function __construct(private bool $debug)`", correct: true }
      - { value: "`public function __construct(#[Autowire('%kernel.debug%')] private bool $debug)`", correct: true }
      - { value: "`public function __construct(bool $debug)`", correct: false }
      - { value: "`public function __construct(#[Autowire(param: 'kernel.debug')] private bool $debug)`", correct: true }
    help: |
      Symfony can autowire parameters into constructors. For boolean parameters like `kernel.debug`, type-hinting `bool` is sufficient. Using `#[Autowire]` explicitly is also valid.
      https://symfony.com/doc/current/configuration/using_parameters_in_dic.html#injecting-kernel-debug-parameter

  -
    question: >
      Which of the following is a key responsibility of a bundle's `Extension` class (implementing `ExtensionInterface`) in Symfony's Dependency Injection?
    answers:
      - { value: "Loading the bundle's service definitions and configuration into the container builder.", correct: true }
      - { value: "Defining the bundle's routes.", correct: false }
      - { value: "Registering event listeners for the bundle.", correct: false }
      - { value: "Managing database migrations for the bundle.", correct: false }
    help: |
      The `Extension` class is responsible for loading the bundle's configuration and service definitions into the `ContainerBuilder` during the compilation process.
      https://symfony.com/doc/current/bundles/extension.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a `Psr\\Log\\LoggerInterface` into its public property `$logger` using YAML configuration. How would you do this?

      ```yaml
      # config/services.yaml
      services:
          App\Service\MyService:
              # ???
      ```
    answers:
      - { value: "`properties: { logger: '@logger' }`", correct: true }
      - { value: "`arguments: { $logger: '@logger' }`", correct: false }
      - { value: "`calls: { setLogger: ['@logger'] }`", correct: false }
      - { value: "`autowire: true, public_properties: ['logger']`", correct: false }
    help: |
      For public property injection in YAML, you use the `properties` key to map property names to service IDs or parameter values.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      When should you use a "compiler pass" in Symfony?
    answers:
      - { value: "To dynamically modify service definitions based on certain conditions or to collect tagged services.", correct: true }
      - { value: "To define new services at runtime based on user input.", correct: false }
      - { value: "To replace the entire service container with a custom implementation.", correct: false }
      - { value: "To inject environment variables into services.", correct: false }
    help: |
      Compiler passes are powerful tools for advanced container manipulation, such as finding all services with a specific tag and injecting them into another service, or applying custom logic to service definitions.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject the result of a Symfony Expression Language expression `service('my_other_service').getData()` into its constructor. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`arguments: ['@=service("my_other_service").getData()']`", correct: true }
      - { value: "`arguments: ['%service("my_other_service").getData()%']`", correct: false }
      - { value: "`arguments: [{ expression: 'service("my_other_service").getData()' }]`", correct: false }
      - { value: "`arguments: ['@my_other_service.getData()']`", correct: false }
    help: |
      In YAML, expressions are prefixed with `@=` to indicate that the argument should be evaluated as a Symfony Expression Language expression.
      https://symfony.com/doc/current/service_container/expression_language.html

  -
    question: >
      What is the purpose of the `#[AsAlias]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To define an alias for a service, allowing it to be referenced by an alternative name.", correct: true }
      - { value: "To mark a service as an abstract service.", correct: false }
      - { value: "To specify a service as a factory.", correct: false }
      - { value: "To make a service public.", correct: false }
    help: |
      The `#[AsAlias]` attribute allows you to define an alias for a service directly on the service class.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-alias

  -
    question: |
      You want to load services from an XML configuration file (`services.xml`). Which loader class should you use with `ContainerBuilder`?
    answers:
      - { value: "`Symfony\\Component\\DependencyInjection\\Loader\\XmlFileLoader`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Loader\\YamlFileLoader`", correct: false }
      - { value: "`Symfony\\Component\\DependencyInjection\\Loader\\PhpFileLoader`", correct: false }
      - { value: "`Symfony\\Component\\Config\\Loader\\FileLoader`", correct: false }
    help: |
      The `XmlFileLoader` is specifically designed to load service definitions from XML files into the container.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-xml-files

  -
    question: >
      Which of the following is a common use case for a "service locator" in Symfony?
    answers:
      - { value: "When a class needs access to a large number of optional services, but only a few are used in any given request.", correct: true }
      - { value: "When a service needs to be globally accessible from anywhere in the application.", correct: false }
      - { value: "When you want to completely decouple a service from the container.", correct: false }
      - { value: "When a service needs to be instantiated only once per application lifecycle.", correct: false }
    help: |
      Service locators help avoid "constructor bloat" by providing a way to lazily retrieve optional dependencies only when they are actually needed.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` and inject a parameter `app.api_key` into its constructor. How would you do this in `config/services.php` using the `ContainerConfigurator`?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\MyService;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(MyService::class)
              // ???
          ;
      };
      ```
    answers:
      - { value: "`->args([param('app.api_key')])`", correct: true }
      - { value: "`->args(['%app.api_key%'])`", correct: true }
      - { value: "`->addArgument(param('app.api_key'))`", correct: true }
      - { value: "`->addArgument('%app.api_key%')`", correct: true }
    help: |
      In PHP service configuration, you can use the `param()` helper function or the `%parameter_name%` string to inject parameters into service arguments.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-parameters

  -
    question: >
      What is the purpose of the `#[AutowireLocator]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To automatically create and inject a service locator for a collection of services, typically tagged services.", correct: true }
      - { value: "To inject a single service by its ID.", correct: false }
      - { value: "To define a factory for a service.", correct: false }
      - { value: "To mark a service as an alias.", correct: false }
    help: |
      The `#[AutowireLocator]` attribute is used to automatically create and inject a service locator, often for services tagged with a specific name.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#autowiring-service-locators

  -
    question: >
      Which of the following is the correct way to retrieve a parameter named `app.debug_mode` from the `ContainerBuilder` instance?
    answers:
      - { value: "`$container->getParameter('app.debug_mode')`", correct: true }
      - { value: "`$container->getParam('app.debug_mode')`", correct: false }
      - { value: "`$container->findParameter('app.debug_mode')`", correct: false }
      - { value: "`$container->parameters['app.debug_mode']`", correct: false }
    help: |
      The `getParameter()` method is used to retrieve the value of a defined parameter from the container.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` that depends on a `MailerInterface`. You want to configure it with constructor injection using PHP attributes. How would you define the constructor?

      ```php
      namespace App\Service;

      use Symfony\Component\Mailer\MailerInterface;

      class MyService
      {
          // ???
          public function __construct(
              private MailerInterface $mailer,
          ) {
          }
      }
      ```
    answers:
      - { value: "`public function __construct(private MailerInterface $mailer)`", correct: true }
      - { value: "`public function __construct(#[Autowire] private MailerInterface $mailer)`", correct: true }
      - { value: "`public function __construct(#[Service('mailer')] private MailerInterface $mailer)`", correct: false }
      - { value: "`public function __construct(MailerInterface $mailer)`", correct: true }
    help: |
      With autowiring enabled, simply type-hinting the interface in the constructor is sufficient for Symfony to inject the correct service. Explicitly using `#[Autowire]` is also valid but often redundant for simple type-hints.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-constructor-arguments

  -
    question: >
      What is the purpose of the `services.yaml` file in a Symfony application?
    answers:
      - { value: "To define and configure the application's services and their dependencies.", correct: true }
      - { value: "To define the application's routes.", correct: false }
      - { value: "To configure database connections.", correct: false }
      - { value: "To manage security settings.", correct: false }
    help: |
      The `services.yaml` file (or its XML/PHP equivalents) is the primary location for defining and configuring services in a Symfony application.
      https://symfony.com/doc/current/service_container.html#configuration-formats

  -
    question: >
      Which built-in Symfony service provides access to the current HTTP request?
    answers:
      - { value: "`request_stack`", correct: true }
      - { value: "`request`", correct: false }
      - { value: "`http_kernel`", correct: false }
      - { value: "`router`", correct: false }
    help: |
      The `request_stack` service (an instance of `Symfony\\Component\\HttpFoundation\\RequestStack`) provides access to the current request and manages a stack of requests.
      https://symfony.com/doc/current/components/http_foundation/requests.html#request-stack

  -
    question: |
      You want to configure a service `App\\Service\\MyDecorator` to decorate an existing service `my_app.original_service`. How would you do this in `config/services.yaml`?

      ```yaml
      services:
          App\Service\MyDecorator:
              decorates: my_app.original_service
              arguments:
                  - '@.inner' # Inject the original service
                  # ... other arguments for MyDecorator
      ```
      What does `@.inner` refer to in this context?
    answers:
      - { value: "The original `my_app.original_service` instance being decorated.", correct: true }
      - { value: "A private service within `MyDecorator`.", correct: false }
      - { value: "A service named `inner`.", correct: false }
      - { value: "A parameter named `inner`.", correct: false }
    help: |
      When decorating a service, `@.inner` is a special reference that points to the original service instance that is being decorated.
      https://symfony.com/doc/current/service_container/service_decoration.html#decorating-a-service

  -
    question: >
      What is the main purpose of "semantic configuration" in Symfony bundles?
    answers:
      - { value: "To provide a structured and validated way for users to configure a bundle's services and features.", correct: true }
      - { value: "To automatically generate service definitions for the bundle.", correct: false }
      - { value: "To define the bundle's routes and controllers.", correct: false }
      - { value: "To manage the bundle's assets.", correct: false }
    help: |
      Semantic configuration allows bundles to define a clear, validated configuration structure, making it easier for users to configure the bundle in `config/packages/*.yaml` files.
      https://symfony.com/doc/current/bundles/extension.html#semantic-configuration

  -
    question: |
      You are registering a service `App\\Service\\MyService` in `config/services.php`. You want to add a tag `app.my_tag` with a specific attribute `priority: 10`. How would you do this?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\MyService;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(MyService::class)
              // ???
          ;
      };
      ```
    answers:
      - { value: "`->tag('app.my_tag', ['priority' => 10])`", correct: true }
      - { value: "`->addTag('app.my_tag', ['priority' => 10])`", correct: true }
      - { value: "`->tag('app.my_tag', 'priority: 10')`", correct: false }
      - { value: "`->addTag('app.my_tag', 'priority=10')`", correct: false }
    help: |
      In PHP service configuration, you use the `tag()` method (or `addTag()` on a `Definition` object) to add tags to a service, passing an array for tag attributes.
      https://symfony.com/doc/current/service_container/tags.html#adding-tags-in-php

  -
    question: >
      Which of the following is a valid way to define a service in Symfony's YAML configuration without specifying a `class` if autowiring is enabled and the service ID matches the class name?
    answers:
      - { value: "`App\\Service\\MyService:`", correct: true }
      - { value: "`my_service: { class: App\\Service\\MyService }`", correct: false }
      - { value: "`my_service: ~`", correct: false }
      - { value: "`App\\Service\\MyService: { autowire: true }`", correct: false }
    help: |
      When autowiring is enabled, if the service ID is the fully qualified class name, you can omit the `class` key.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-type

  -
    question: >
      What is the primary purpose of the `FileLocator` class when loading service definitions in Symfony?
    answers:
      - { value: "To locate configuration files within specific directories (e.g., bundle `Resources/config` directories).", correct: true }
      - { value: "To parse the content of configuration files.", correct: false }
      - { value: "To validate the schema of configuration files.", correct: false }
      - { value: "To cache the loaded configuration.", correct: false }
    help: |
      `FileLocator` helps loaders find configuration files by searching in a predefined set of paths.
      https://symfony.com/doc/current/components/config/file_locator.html

  -
    question: |
      You want to inject a specific service named `apiClient1.serializer` into a controller method argument `SerializerInterface $apiClient1Serializer`. Which attribute would you use?

      ```php
      namespace App\Controller;

      use Symfony\Component\Serializer\SerializerInterface;
      use Symfony\Component\DependencyInjection\Attribute\Target;

      class PersonController extends AbstractController
      {
          public function index(
              // ???
              SerializerInterface $apiClient1Serializer,
          ) {
              // ...
          }
      }
      ```
    answers:
      - { value: "`#[Target('apiClient1.serializer')]`", correct: true }
      - { value: "`#[Autowire(service: 'apiClient1.serializer')]`", correct: true }
      - { value: "`#[Inject('apiClient1.serializer')]`", correct: false }
      - { value: "`#[Service('apiClient1.serializer')]`", correct: false }
    help: |
      The `#[Target]` attribute allows you to specify the exact service ID to inject when autowiring, especially useful when multiple services implement the same interface. `#[Autowire(service: 'service_id')]` provides similar explicit control.
      https://symfony.com/doc/current/serializer.html#injecting-named-serializers

  -
    question: >
      Which of the following is a valid way to define a parameter named `app.mailer.transport` with value `smtp` in Symfony's YAML configuration?
    answers:
      - { value: "`parameters: { app.mailer.transport: 'smtp' }`", correct: true }
      - { value: "`app.mailer.transport: smtp`", correct: false }
      - { value: "`config: { parameters: { app.mailer.transport: 'smtp' } }`", correct: false }
      - { value: "`parameters.app.mailer.transport: smtp`", correct: false }
    help: |
      Parameters are defined under the `parameters` key in YAML configuration files.
      https://symfony.com/doc/current/components/dependency_injection/parameters.html#defining-parameters-in-yaml

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject a value from the `APP_DEBUG` environment variable, converting it to a boolean. How would you do this using the `#[Autowire]` attribute?
    answers:
      - { value: "`#[Autowire(env: 'bool:APP_DEBUG')]`", correct: true }
      - { value: "`#[Autowire(env: 'APP_DEBUG', type: 'bool')]`", correct: false }
      - { value: "`#[Autowire(expression: 'env("APP_DEBUG") == "1"')`", correct: false }
      - { value: "`#[Autowire(param: 'bool:APP_DEBUG')]`", correct: false }
    help: |
      The `env` parameter of `#[Autowire]` supports processors like `bool:` to automatically convert environment variable values to the desired type.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the main advantage of using `#[Required]` attribute on a setter method compared to always injecting via the constructor?
    answers:
      - { value: "It allows for optional dependencies that are still autowired if available, preventing constructor bloat for non-essential services.", correct: true }
      - { value: "It makes the service non-shared.", correct: false }
      - { value: "It forces the service to be lazy-loaded.", correct: false }
      - { value: "It makes the service public.", correct: false }
    help: |
      `#[Required]` on setters is useful for dependencies that are technically optional for the class to function, but should be injected by the container if they exist. This helps keep constructors clean for truly essential dependencies.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: |
      You are creating a custom compiler pass. Which method must you implement in your compiler pass class?
    answers:
      - { value: "`process(ContainerBuilder $container)`", correct: true }
      - { value: "`compile(ContainerBuilder $container)`", correct: false }
      - { value: "`build(ContainerBuilder $container)`", correct: false }
      - { value: "`handle(ContainerBuilder $container)`", correct: false }
    help: |
      All compiler passes must implement the `process()` method, which receives the `ContainerBuilder` instance.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html#creating-a-compiler-pass

  -
    question: >
      Which of the following is a valid way to define a service in Symfony's PHP configuration using the `ContainerConfigurator`?
    answers:
      - { value: "`$services->set('app.my_service', App\\Service\\MyService::class);`", correct: true }
      - { value: "`$container->register('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$services->add('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$services->define('app.my_service', App\\Service\\MyService::class);`", correct: false }
    help: |
      In PHP service configuration with `ContainerConfigurator`, you use `$services->set()` to define a new service.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-services-in-php

  -
    question: >
      What is the purpose of the `autoconfigure: true` setting for services in Symfony?
    answers:
      - { value: "It automatically applies common configuration (like adding tags for autowiring) to services based on their class, interfaces, or attributes.", correct: true }
      - { value: "It enables autowiring for all services in the application.", correct: false }
      - { value: "It makes all services public by default.", correct: false }
      - { value: "It prevents services from being compiled.", correct: false }
    help: |
      `autoconfigure: true` tells Symfony to automatically apply common configuration, such as adding tags for services that implement certain interfaces (e.g., `EventSubscriberInterface`).
      https://symfony.com/doc/current/service_container/tags.html#autoconfiguration

  -
    question: |
      You want to define a service `App\\Service\\MyService` that uses a factory service `App\\Factory\\MyFactory` and its method `createService()`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`factory: ['@App\\Factory\\MyFactory', 'createService']`", correct: true }
      - { value: "`factory: App\\Factory\\MyFactory::createService`", correct: false }
      - { value: "`arguments: ['@App\\Factory\\MyFactory', 'createService']`", correct: false }
      - { value: "`class: App\\Service\\MyService, factory_service: App\\Factory\\MyFactory, factory_method: createService`", correct: false }
    help: |
      When the factory is itself a service, you reference it with `@` and then specify the method name.
      https://symfony.com/doc/current/service_container/factories.html#factory-as-a-service

  -
    question: >
      Which of the following is a built-in service in Symfony that provides access to the application's kernel?
    answers:
      - { value: "`kernel`", correct: true }
      - { value: "`app.kernel`", correct: false }
      - { value: "`http_kernel`", correct: false }
      - { value: "`container.kernel`", correct: false }
    help: |
      The `kernel` service (an instance of `Symfony\\Component\\HttpKernel\\KernelInterface`) provides access to the application's kernel.
      https://symfony.com/doc/current/reference/dic_tags.html#kernel-tags

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to be instantiated only when it's first requested (lazy loading). How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`lazy: true`", correct: true }
      - { value: "`shared: false`", correct: false }
      - { value: "`public: false`", correct: false }
      - { value: "`instantiate: lazy`", correct: false }
    help: |
      Setting `lazy: true` for a service tells the container to create a proxy for the service, and the actual service instance will only be created when it's first accessed.
      https://symfony.com/doc/current/service_container/lazy_services.html

  -
    question: >
      What is the primary benefit of using Dependency Injection in a Symfony application?
    answers:
      - { value: "Reduced coupling between components, improved testability, and enhanced reusability of code.", correct: true }
      - { value: "Faster application startup time.", correct: false }
      - { value: "Automatic generation of database schemas.", correct: false }
      - { value: "Simplified routing configuration.", correct: false }
    help: |
      Dependency Injection promotes loose coupling by allowing dependencies to be injected rather than hardcoded, leading to more modular, testable, and reusable code.
      https://symfony.com/doc/current/service_container.html#why-use-a-dependency-injection-container

  -
    question: |
      You want to register a PHP attribute for autoconfiguration, so that any service using this attribute gets a specific tag. Which method of `ContainerBuilder` would you use?
    answers:
      - { value: "`registerAttributeForAutoconfiguration(attributeClass: string, callable: callable)`", correct: true }
      - { value: "`registerForAutoconfiguration(interfaceOrClass: string)`", correct: false }
      - { value: "`addAutoconfigureAttribute(attributeClass: string, callable: callable)`", correct: false }
      - { value: "`configureAttribute(attributeClass: string)`", correct: false }
    help: |
      The `registerAttributeForAutoconfiguration()` method allows you to define a callback that will be executed for any service that uses the specified PHP attribute.
      https://symfony.com/doc/current/service_container/tags.html#registering-php-attributes-for-autoconfiguration

  -
    question: >
      Which of the following is a built-in service in Symfony that handles dispatching events?
    answers:
      - { value: "`event_dispatcher`", correct: true }
      - { value: "`dispatcher`", correct: false }
      - { value: "`event_manager`", correct: false }
      - { value: "`symfony.event_dispatcher`", correct: false }
    help: |
      The `event_dispatcher` service (an instance of `Symfony\\Component\\EventDispatcher\\EventDispatcherInterface`) is the central hub for event management in Symfony.
      https://symfony.com/doc/current/components/event_dispatcher.html

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.yaml`. You want to configure property injection for a public property named `myProperty` with the value of a parameter `app.my_param`. How would you do this?
    answers:
      - { value: "`properties: { myProperty: '%app.my_param%' }`", correct: true }
      - { value: "`arguments: { $myProperty: '%app.my_param%' }`", correct: false }
      - { value: "`calls: { setMyProperty: ['%app.my_param%'] }`", correct: false }
      - { value: "`property_injection: { myProperty: '%app.my_param%' }`", correct: false }
    help: |
      Property injection is configured using the `properties` key, mapping the property name to the service or parameter to inject.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      What is the purpose of the `ContainerConfigurator` class in Symfony's PHP service configuration?
    answers:
      - { value: "It provides a fluent API for defining services and parameters in PHP configuration files.", correct: true }
      - { value: "It is the main class for the compiled container.", correct: false }
      - { value: "It is used for loading YAML configuration files.", correct: false }
      - { value: "It manages environment variables.", correct: false }
    help: |
      `ContainerConfigurator` is the object passed to PHP service configuration files, offering a convenient way to define services, parameters, and aliases.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-services-in-php

  -
    question: |
      You want to define a service `App\\Service\\MyService` and explicitly set its class to `App\\Service\\MyConcreteService` in `config/services.yaml`, even if the service ID is different. How would you do this?
    answers:
      - { value: "`my_service_id: { class: App\\Service\\MyConcreteService }`", correct: true }
      - { value: "`my_service_id: App\\Service\\MyConcreteService`", correct: false }
      - { value: "`my_service_id: { type: App\\Service\\MyConcreteService }`", correct: false }
      - { value: "`my_service_id: { instance_of: App\\Service\\MyConcreteService }`", correct: false }
    help: |
      The `class` key explicitly defines the class to be instantiated for a service, regardless of its ID.
      https://symfony.com/doc/current/service_container.html#defining-services

  -
    question: >
      Which of the following is a built-in service in Symfony that provides functionality for sending emails?
    answers:
      - { value: "`mailer`", correct: true }
      - { value: "`email_sender`", correct: false }
      - { value: "`swiftmailer`", correct: false }
      - { value: "`symfony.mailer`", correct: false }
    help: |
      The `mailer` service (an instance of `Symfony\\Component\\Mailer\\MailerInterface`) is the primary service for sending emails in Symfony.
      https://symfony.com/doc/current/mailer.html

  -
    question: |
      You want to register an interface `App\\Contract\\MyInterface` for autoconfiguration, so that any service implementing it automatically gets a specific tag. Which method of `ContainerBuilder` would you use?
    answers:
      - { value: "`registerForAutoconfiguration(interfaceOrClass: string)`", correct: true }
      - { value: "`registerAttributeForAutoconfiguration(attributeClass: string, callable: callable)`", correct: false }
      - { value: "`addAutoconfigureInterface(interfaceOrClass: string)`", correct: false }
      - { value: "`configureInterface(interfaceOrClass: string)`", correct: false }
    help: |
      The `registerForAutoconfiguration()` method is used to apply autoconfiguration rules to interfaces or classes.
      https://symfony.com/doc/current/service_container/tags.html#registering-interfaces-for-autoconfiguration

  -
    question: >
      What is the purpose of the `#[Target]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To specify a named service to be injected when multiple services implement the same interface or when the service ID doesn't match the type-hint.", correct: true }
      - { value: "To define the target class for a service.", correct: false }
      - { value: "To mark a service as a target for a compiler pass.", correct: false }
      - { value: "To specify the environment a service should be used in.", correct: false }
    help: |
      The `#[Target]` attribute is crucial for disambiguating which service to inject when autowiring encounters multiple services that could satisfy a type-hint.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.yaml`. You want to prevent it from being shared, meaning a new instance is created every time it's requested. How would you configure this?
    answers:
      - { value: "`shared: false`", correct: true }
      - { value: "`lazy: true`", correct: false }
      - { value: "`public: false`", correct: false }
      - { value: "`instantiate: new`", correct: false }
    help: |
      Setting `shared: false` makes a service a "prototype," ensuring a new instance is returned each time it's retrieved from the container.
      https://symfony.com/doc/current/service_container.html#service-container-shared

  -
    question: >
      Which of the following is a built-in service in Symfony that provides access to the application's router?
    answers:
      - { value: "`router`", correct: true }
      - { value: "`url_generator`", correct: false }
      - { value: "`matcher`", correct: false }
      - { value: "`symfony.router`", correct: false }
    help: |
      The `router` service (an instance of `Symfony\\Component\\Routing\\RouterInterface`) is used for generating URLs and matching incoming requests to routes.
      https://symfony.com/doc/current/routing.html#generating-urls-in-controllers

  -
    question: |
      You want to inject the `kernel.environment` parameter into your service's constructor. How would you define the constructor argument using PHP attributes?
    answers:
      - { value: "`#[Autowire('%kernel.environment%')] string $env`", correct: true }
      - { value: "`#[Autowire(param: 'kernel.environment')] string $env`", correct: true }
      - { value: "`#[Autowire(env: 'kernel.environment')] string $env`", correct: false }
      - { value: "`string $env` (if autowiring by name is enabled and matches)`", correct: true }
    help: |
      You can explicitly inject parameters using `#[Autowire('%parameter_name%')]` or `#[Autowire(param: 'parameter_name')]`. If autowiring by name is enabled and the argument name matches the parameter name (e.g., `$kernelEnvironment`), it might also work without explicit attributes.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire

  -
    question: >
      What is the primary role of the `ContainerInterface` (from `Psr\\Container`) in Symfony?
    answers:
      - { value: "To provide a standardized way to retrieve services from a container, promoting interoperability.", correct: true }
      - { value: "To define how services are compiled.", correct: false }
      - { value: "To manage the application's configuration.", correct: false }
      - { value: "To handle HTTP requests.", correct: false }
    help: |
      `Psr\\Container\\ContainerInterface` defines a common interface for dependency injection containers, allowing for interchangeable container implementations. Symfony's `Container` implements this interface.
      https://www.php-fig.org/psr/psr-11/

  -
    question: |
      You have a service `App\\Service\\MyService` and you want to inject a value that is the result of a static method call `MyHelper::calculateValue()`. How would you configure this in `config/services.yaml`?
    answers:
      - { value: "`arguments: ['@=App\\Helper\\MyHelper::calculateValue()']`", correct: true }
      - { value: "`arguments: ['App\\Helper\\MyHelper::calculateValue()']`", correct: false }
      - { value: "`factory: ['App\\Helper\\MyHelper', 'calculateValue']`", correct: true }
      - { value: "`arguments: [{ static_call: 'App\\Helper\\MyHelper::calculateValue' }]`", correct: false }
    help: |
      You can use Expression Language (`@=`) to call static methods and inject their return values. Alternatively, you can use the `factory` key if the static method is intended as a service factory.
      https://symfony.com/doc/current/service_container/expression_language.html
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      When should you consider using a "factory" to create a service in Symfony?
    answers:
      - { value: "When the service's construction logic is complex, involves external resources, or requires conditional instantiation.", correct: true }
      - { value: "When the service has no dependencies.", correct: false }
      - { value: "When the service needs to be lazy-loaded.", correct: false }
      - { value: "When the service is an alias of another service.", correct: false }
    help: |
      Factories are useful when the service cannot be simply instantiated with `new Class()`, but requires more complex setup logic.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: |
      You are defining a service `App\\Service\\MyService` in `config/services.php`. You want to make it an alias of `App\\Service\\OriginalService`. How would you do this?
    answers:
      - { value: "`$services->alias(App\\Service\\MyService::class, App\\Service\\OriginalService::class);`", correct: true }
      - { value: "`$services->set(App\\Service\\MyService::class)->alias(App\\Service\\OriginalService::class);`", correct: false }
      - { value: "`$services->set(App\\Service\\MyService::class)->args([service(App\\Service\\OriginalService::class)]);`", correct: false }
      - { value: "`$container->setAlias(App\\Service\\MyService::class, App\\Service\\OriginalService::class);`", correct: true }
    help: |
      In PHP configuration, you can use `$services->alias()` or `$container->setAlias()` to create an alias for a service.
      https://symfony.com/doc/current/service_container/alias_private.html#aliasing-in-php

  -
    question: >
      What is the primary role of the `#[Required]` attribute when applied to a constructor argument?
    answers:
      - { value: "It ensures that the argument is always autowired, even if it could be resolved from multiple services, effectively making it mandatory for autowiring.", correct: true }
      - { value: "It makes the dependency optional.", correct: false }
      - { value: "It marks the service as a factory.", correct: false }
      - { value: "It forces the service to be public.", correct: false }
    help: |
      While constructor arguments are generally required, `#[Required]` can be used to explicitly signal that a dependency must be autowired, especially in cases where autowiring might otherwise fail due to ambiguity.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required (applies conceptually to constructor too for clarity)

  -
    question: |
      You want to inject the `kernel.project_dir` parameter into a service's constructor, ensuring it's always a string. Which type-hint and attribute combination is most robust?
    answers:
      - { value: "`#[Autowire('%kernel.project_dir%')] string $projectDir`", correct: true }
      - { value: "`string $projectDir`", correct: false }
      - { value: "`#[Autowire(param: 'kernel.project_dir')] string $projectDir`", correct: true }
      - { value: "`#[Autowire(env: 'string:kernel.project_dir')] string $projectDir`", correct: false }
    help: |
      Explicitly using `#[Autowire('%parameter_name%')]` or `#[Autowire(param: 'parameter_name')]` with a type-hint ensures the correct parameter is injected and type-checked.
      https://symfony.com/doc/current/controller.html#injecting-services-and-parameters

  -
    question: >
      Which of the following describes the "autowire by name" feature in Symfony?
    answers:
      - { value: "When a constructor argument or setter method parameter's name matches a registered service ID or parameter name, Symfony automatically injects it.", correct: true }
      - { value: "Automatically generating service IDs based on class names.", correct: false }
      - { value: "Injecting services based on their fully qualified class name.", correct: false }
      - { value: "Using `#[Target]` to specify a service by its name.", correct: false }
    help: |
      Autowire by name is a feature where Symfony attempts to inject a service or parameter if its ID or name matches the argument name, even without a type-hint or explicit attribute.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-name

  -
    question: |
      You are developing a bundle and want to register a compiler pass. Where should you typically add your compiler pass?
    answers:
      - { value: "In the `build()` method of your bundle's main class (e.g., `AppBundle.php`).", correct: true }
      - { value: "In the `load()` method of your bundle's extension class.", correct: false }
      - { value: "In the `boot()` method of your bundle's main class.", correct: false }
      - { value: "In `config/services.yaml`.", correct: false }
    help: |
      Compiler passes are added to the `ContainerBuilder` during the `build()` method of your bundle's main class.
      https://symfony.com/doc/current/components/dependency_injection/compilation/passes.html#registering-a-compiler-pass

  -
    question: >
      What is the primary difference between `#[Autowire(service: 'service_id')]` and `#[Target('service_id')]`?
    answers:
      - { value: "`#[Autowire(service: 'service_id')]` explicitly injects a service by its ID, bypassing autowiring logic, while `#[Target('service_id')]` guides autowiring to pick a specific service when multiple candidates exist for a type-hint.", correct: true }
      - { value: "They are completely interchangeable and serve the exact same purpose.", correct: false }
      - { value: "`#[Target]` is for parameters, `#[Autowire]` is for services.", correct: false }
      - { value: "`#[Autowire]` is for constructor injection, `#[Target]` is for setter injection.", correct: false }
    help: |
      `#[Autowire(service: ...)]` provides direct, explicit control over which service is injected. `#[Target(...)]` is used specifically to resolve ambiguity when autowiring by type, telling autowiring which of several matching services to choose.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: >
      Which of the following is a built-in service in Symfony that provides access to the application's HTTP client?
    answers:
      - { value: "`http_client`", correct: true }
      - { value: "`guzzle_client`", correct: false }
      - { value: "`web_client`", correct: false }
      - { value: "`symfony.http_client`", correct: false }
    help: |
      The `http_client` service (an instance of `Symfony\\Contracts\\HttpClient\\HttpClientInterface`) is the default service for making HTTP requests.
      https://symfony.com/doc/current/http_client.html

  -
    question: |
      You want to define a service `App\\Service\\MyService` that depends on a `Psr\\Log\\LoggerInterface`. You prefer autowiring. How would you define the service in `config/services.yaml` to enable autowiring for it?
    answers:
      - { value: "`App\\Service\\MyService: ~`", correct: true }
      - { value: "`App\\Service\\MyService: { autowire: true }`", correct: true }
      - { value: "`App\\Service\\MyService: { arguments: ['@logger'] }`", correct: false }
      - { value: "`App\\Service\\MyService: { class: App\\Service\\MyService, autowire: true }`", correct: true }
    help: |
      By default, `config/services.yaml` has `_defaults: { autowire: true, public: false }`. So `App\\Service\\MyService: ~` is sufficient. Explicitly setting `autowire: true` is also correct.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-type

  -
    question: >
      What is the purpose of the `#[AutowireServiceClosure]` attribute?
    answers:
      - { value: "To inject a lazy-loading closure for a service, delaying its instantiation until the closure is invoked.", correct: true }
      - { value: "To automatically create a service from a closure.", correct: false }
      - { value: "To define a service as a closure.", correct: false }
      - { value: "To inject a service into a closure.", correct: false }
    help: |
      `#[AutowireServiceClosure]` is used to inject a callable that, when called, returns the service instance. This is a form of lazy injection.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-service-closures

  -
    question: |
      You have a service `App\\Service\\MyService` that needs to be decorated by `App\\Service\\MyDecorator`. The decorator also needs the original service. How would you configure this in `config/services.yaml`?

      ```yaml
      services:
          App\Service\MyDecorator:
              decorates: App\Service\MyService
              arguments:
                  - '@.inner'
                  # ... other arguments for MyDecorator
      ```
      What is the significance of the `decorates` key?
    answers:
      - { value: "It specifies the ID of the service that this service will replace and wrap.", correct: true }
      - { value: "It defines the class that this service extends.", correct: false }
      - { value: "It indicates that this service is an alias of another.", correct: false }
      - { value: "It marks this service as a factory.", correct: false }
    help: |
      The `decorates` key is used to tell Symfony that this service should replace another existing service. The original service becomes available via the special `@.inner` reference.
      https://symfony.com/doc/current/service_container/service_decoration.html#decorating-a-service

  -
    question: >
      Which of the following is a valid way to define a service in Symfony's PHP configuration using the `ContainerBuilder` directly (less common in modern Symfony apps)?
    answers:
      - { value: "`$container->register('app.my_service', App\\Service\\MyService::class);`", correct: true }
      - { value: "`$container->set('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$container->add('app.my_service', App\\Service\\MyService::class);`", correct: false }
      - { value: "`$container->define('app.my_service', App\\Service\\MyService::class);`", correct: false }
    help: |
      The `register()` method on `ContainerBuilder` is used to define a new service definition programmatically.
      https://symfony.com/doc/current/components/dependency_injection.html#defining-services-in-php

  -
    question: >
      What is the primary role of the `#[Autowire]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To explicitly control how a specific constructor argument, setter method, or property is autowired, allowing injection of specific services, parameters, environment variables, or expression results.", correct: true }
      - { value: "To enable autowiring for an entire class.", correct: false }
      - { value: "To mark a service as required.", correct: false }
      - { value: "To define an alias for a service.", correct: false }
    help: |
      The `#[Autowire]` attribute provides fine-grained control over autowiring, allowing you to specify exactly what should be injected into a particular dependency.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-with-autowire