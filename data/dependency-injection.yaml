category: Dependency Injection
questions:
  - question: What is the primary purpose of the Symfony Service Container?
    answers:
      - value: To manage database connections and migrations.
        correct: false
      - value: To handle HTTP requests and responses.
        correct: false
      - value: To centralize the instantiation and management of objects (services) and
          their dependencies.
        correct: true
      - value: To provide a templating engine for rendering views.
        correct: false
    help: The Symfony Service Container is a tool that helps you manage the
      instantiation of your application's objects, called services, and inject
      their dependencies.
  - question: Which method is used to retrieve a service from the Symfony Service
      Container at runtime?
    answers:
      - value: "`getService()`"
        correct: false
      - value: "`find()`"
        correct: false
      - value: "`get()`"
        correct: true
      - value: "`fetch()`"
        correct: false
    help: Services are retrieved from the container using the `get()` method,
      typically after the container has been compiled.
  - question: Which of the following statements accurately describes the difference
      between `Symfony\Component\DependencyInjection\ContainerBuilder` and
      `Psr\Container\ContainerInterface`?
    answers:
      - value: "`ContainerBuilder` is used at runtime to retrieve services, while
          `ContainerInterface` is used during compilation to define services."
        correct: false
      - value: "`ContainerBuilder` is used during compilation to define and manipulate
          services, while `ContainerInterface` is a read-only interface for
          retrieving services at runtime."
        correct: true
      - value: Both interfaces are interchangeable and can be used for defining and
          retrieving services at any time.
        correct: false
      - value: "`ContainerBuilder` is for defining parameters, and `ContainerInterface`
          is for defining services."
        correct: false
    help: "`ContainerBuilder` is the mutable container used during the compilation
      process to register and configure services. `ContainerInterface` is a
      read-only interface for accessing services from the compiled container at
      runtime."
  - question: Why is the Symfony Service Container compiled?
    answers:
      - value: To reduce the application's memory footprint during development.
        correct: false
      - value: To improve performance by optimizing service definitions, resolving
          parameters, and removing unused services.
        correct: true
      - value: To enable hot-reloading of service definitions without restarting the
          server.
        correct: false
      - value: To encrypt service definitions for security purposes.
        correct: false
    help: Compiling the container optimizes it for performance by resolving
      parameters, removing unused services, and checking for circular
      references, resulting in a faster application.
  - question: What is the default behavior when you try to retrieve a non-existent
      service from the compiled Symfony container using
      `ContainerInterface::get()`?
    answers:
      - value: It returns `null`.
        correct: false
      - value: It throws a `RuntimeException` at runtime.
        correct: false
      - value: It throws an `Exception` during compilation.
        correct: true
      - value: It creates a new instance of the requested class.
        correct: false
    help: By default, if a service is not found during compilation, Symfony throws
      an exception. At runtime, if a service is requested that was not compiled,
      it would also result in an exception.
      `ContainerInterface::EXCEPTION_ON_INVALID_REFERENCE` is the default
      behavior.
  - question: Which interface should you type-hint in your service constructor to
      automatically inject the default Monolog logger in Symfony 7?
    answers:
      - value: "`Monolog\\Logger`"
        correct: false
      - value: "`Psr\\Log\\LoggerInterface`"
        correct: true
      - value: "`Symfony\\Component\\HttpKernel\\Log\\Logger`"
        correct: false
      - value: "`LoggerAwareInterface`"
        correct: false
    help: Symfony's autowiring mechanism automatically injects the default logger
      when you type-hint against `Psr\Log\LoggerInterface`.
  - question: How do you typically inject the Symfony HTTP Client into a service or
      controller?
    answers:
      - value: By type-hinting `Symfony\Component\HttpClient\HttpClient`.
        correct: false
      - value: By type-hinting `Symfony\Contracts\HttpClient\HttpClientInterface`.
        correct: true
      - value: By using the `#[Inject]` attribute with the service ID `http_client`.
        correct: false
      - value: By calling `Container::get('http_client')` directly.
        correct: false
    help: The recommended way to inject the HTTP client is by type-hinting the
      `HttpClientInterface` from `Symfony\Contracts\HttpClient`.
  - question: Which built-in service is responsible for managing the lifecycle of
      requests and sub-requests in a Symfony application?
    answers:
      - value: "`router`"
        correct: false
      - value: "`event_dispatcher`"
        correct: false
      - value: "`request_stack`"
        correct: true
      - value: "`http_kernel`"
        correct: false
    help: The `request_stack` service
      (`Symfony\Component\HttpFoundation\RequestStack`) manages the stack of
      `Request` objects, which is crucial for handling sub-requests and
      accessing the current request.
  - question: In Symfony, how would you define a parameter named `app.mailer_sender`
      with the value `noreply@example.com` in `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          parameters:
              app.mailer_sender: 'noreply@example.com'
          services:
              # ...
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              parameters:
                  app.mailer_sender: 'noreply@example.com'
              # ...
          ```
        correct: false
      - value: |-
          ```yaml
          config:
              params:
                  app.mailer_sender: 'noreply@example.com'
              # ...
          ```
        correct: false
      - value: |-
          ```yaml
          app.mailer_sender: 'noreply@example.com'
          services:
              # ...
          ```
        correct: false
    help: Parameters are defined under the `parameters` key in YAML configuration
      files.
  - question: Given a parameter `app.uploads_dir` defined in the container, how
      would you inject its value into a service's constructor using YAML
      configuration?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\Uploader:
                  arguments: ['@app.uploads_dir']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\Uploader:
                  arguments: ['%app.uploads_dir%']
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\Uploader:
                  arguments: ['parameter(app.uploads_dir)']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\Uploader:
                  arguments: ['$app.uploads_dir']
          ```
        correct: false
    help: Parameters are referenced in service definitions using the
      `%parameter_name%` syntax.
  - question: Which interface can be type-hinted in a service constructor to inject
      *all* application parameters as a collection?
    answers:
      - value: "`Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBagInt\
          erface`"
        correct: false
      - value: "`Psr\\Container\\ContainerInterface`"
        correct: false
      - value: "`Symfony\\Component\\DependencyInjection\\ParameterBag\\ContainerBagInt\
          erface`"
        correct: true
      - value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`"
        correct: false
    help: "`ContainerBagInterface` allows you to inject and access all defined
      container parameters via its `get()` method."
  - question: When defining a boolean configuration node in a Symfony extension's
      `Configuration` class, if you set `defaultValue('%kernel.debug%')`, what
      value will `processConfiguration` typically return for this node if the
      parameter is not explicitly overridden in user configuration?
    answers:
      - value: The actual boolean value of `kernel.debug` (true or false).
        correct: false
      - value: The literal string `"%kernel.debug%"`.
        correct: true
      - value: "`null`."
        correct: false
      - value: An exception will be thrown.
        correct: false
    help: When `%kernel.debug%` is used as a `defaultValue` in the `Configuration`
      class, it is treated as a literal string. To evaluate it as a parameter,
      the `Configuration` class itself needs to receive the `kernel.debug`
      value, typically via its constructor, as shown in the documentation.
  - question: >-
      Consider the following PHP class:

      ```php

      namespace App\Service;


      use Psr\Log\LoggerInterface;


      class MyService

      {
          public function __construct(private LoggerInterface $logger) {}
      }

      ```

      How would you register `App\Service\MyService` and inject the `logger`
      service into its constructor using `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  arguments: ['@logger']
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  constructor: '@logger'
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  calls:
                      - __construct: ['@logger']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  inject:
                      logger: '@logger'
          ```
        correct: false
    help: Constructor arguments are defined under the `arguments` key in YAML, with
      service references prefixed by `@`.
  - question: >-
      Given the following service class:

      ```php

      namespace App\Service;


      use Psr\Log\LoggerInterface;

      use Symfony\Contracts\Service\Attribute\Required;


      class MyService

      {
          private LoggerInterface $logger;

          #[Required]
          public function setLogger(LoggerInterface $logger): void
          {
              $this->logger = $logger;
          }
      }

      ```

      Which statement is true regarding how Symfony will inject the
      `LoggerInterface` into `MyService` if autowiring is enabled?
    answers:
      - value: Symfony will automatically call `setLogger()` and inject the
          `LoggerInterface` because of the `#[Required]` attribute.
        correct: true
      - value: You must explicitly configure a `calls` entry in `services.yaml` for
          `setLogger()`.
        correct: false
      - value: The `#[Required]` attribute only works for constructor injection.
        correct: false
      - value: Symfony will ignore this setter method.
        correct: false
    help: The `#[Required]` attribute on a setter method ensures that Symfony's
      autowiring mechanism will call this method and inject the corresponding
      dependency.
  - question: Which attribute allows Symfony to automatically inject a dependency
      into a public typed property of a service, making it mandatory?
    answers:
      - value: "`#[Autowire]`"
        correct: false
      - value: "`#[Inject]`"
        correct: false
      - value: "`#[Required]`"
        correct: true
      - value: "`#[Property]`"
        correct: false
    help: The `#[Required]` attribute can be applied directly to a public typed
      property to enable autowiring for that property.
  - question: To configure an immutable setter method (e.g., `withMailer`) in
      `config/services.yaml` that returns a new instance of the service, which
      syntax should be used?
    answers:
      - value: |-
          ```yaml
          services:
              App\Mail\NewsletterManager:
                  calls:
                      - withMailer: ['@mailer']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Mail\NewsletterManager:
                  calls:
                      - withMailer: !returns_clone ['@mailer']
          ```
        correct: true
      - value: >-
          ```yaml

          services:
              App\Mail\NewsletterManager:
                  calls:
                      - { method: withMailer, arguments: ['@mailer'], returns_clone: true }
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Mail\NewsletterManager:
                  arguments:
                      - !immutable_setter ['@mailer']
          ```
        correct: false
    help: The `!returns_clone` tag is used in YAML to indicate that a method call
      returns a new cloned instance, which is characteristic of immutable
      setters (or "withers").
  - question: What is the purpose of the `#[AsCommand]` attribute in a Symfony
      console command class?
    answers:
      - value: To mark the command as a service that should be registered in the
          container.
        correct: false
      - value: To define the command's name, description, and other configuration
          directly in the class.
        correct: true
      - value: To automatically execute the command when the application starts.
        correct: false
      - value: To specify the required arguments and options for the command.
        correct: false
    help: The `#[AsCommand]` attribute allows you to configure a console command's
      name, description, and other options directly on the command class,
      simplifying its registration.
  - question: What is the primary reason for "decorating" a service in Symfony's
      Dependency Injection component?
    answers:
      - value: To replace an existing service with a completely different
          implementation.
        correct: false
      - value: To add or modify behavior of an existing service without changing its
          original definition.
        correct: true
      - value: To make a private service public for direct access.
        correct: false
      - value: To lazy-load a service to improve performance.
        correct: false
    help: Service decoration allows you to wrap an existing service with a new
      service, enabling you to add or modify its behavior without altering the
      original service's code or definition.
  - question: Given an existing service `app.my_service`, how would you decorate it
      with `App\Service\MyServiceDecorator` in `config/services.php`?
    answers:
      - value: |-
          ```php
          $services->set(MyServiceDecorator::class)
              ->decorate('app.my_service')
              ->args([service('.inner')])
          ;
          ```
        correct: true
      - value: |-
          ```php
          $services->set(MyServiceDecorator::class)
              ->alias('app.my_service')
              ->args([service('app.my_service.inner')])
          ;
          ```
        correct: false
      - value: |-
          ```php
          $services->set(MyServiceDecorator::class)
              ->parent('app.my_service')
              ->args([service('app.my_service.inner')])
          ;
          ```
        correct: false
      - value: |-
          ```php
          $services->set(MyServiceDecorator::class)
              ->replace('app.my_service')
              ->args([service('app.my_service.decorated')])
          ;
          ```
        correct: false
    help: The `decorate()` method is used to mark a service as a decorator. The
      special `'.inner'` service ID refers to the original service being
      decorated.
  - question: What is the main purpose of "tags" in Symfony's Dependency Injection
      component?
    answers:
      - value: To categorize services for better organization in the container.
        correct: false
      - value: To allow services to be automatically discovered and integrated into
          specific Symfony features or collections.
        correct: true
      - value: To define the scope of a service (e.g., request, container).
        correct: false
      - value: To mark services as deprecated.
        correct: false
    help: Tags are metadata attached to service definitions that allow Symfony to
      automatically find and process services for specific purposes, such as
      collecting event subscribers, console commands, or data collectors.
  - question: Which tag is used to register a PHP class as a Symfony console
      command, making it discoverable by `bin/console`?
    answers:
      - value: "`command.register`"
        correct: false
      - value: "`app.command`"
        correct: false
      - value: "`console.command`"
        correct: true
      - value: "`symfony.command`"
        correct: false
    help: The `console.command` tag is specifically used to register console
      commands with the Symfony application.
  - question: What is the effect of tagging a service with `container.hot_path`?
    answers:
      - value: It makes the service available only in the development environment.
        correct: false
      - value: It ensures the service and its dependencies are always loaded early,
          improving performance by bypassing the autoloader.
        correct: true
      - value: It marks the service for removal during container compilation.
        correct: false
      - value: It prevents the service from being cached.
        correct: false
    help: The `container.hot_path` tag identifies services critical for
      bootstrapping and ensures they and their dependencies are loaded via
      `include_once` in generated factories, improving performance by avoiding
      PHP's autoloader. Use with caution.
  - question: If PHP class preloading is enabled, what does the
      `container.no_preload` tag do for a service?
    answers:
      - value: It forces the service's class to be preloaded.
        correct: false
      - value: It prevents the service's class from being preloaded.
        correct: true
      - value: It indicates that the service does not require any preloaded classes.
        correct: false
      - value: It makes the service's class available for on-demand loading only.
        correct: false
    help: The `container.no_preload` tag explicitly prevents a service's class from
      being preloaded when PHP class preloading is active.
  - question: How can you associate a service with a specific Monolog logging
      channel (e.g., `security`) using a tag in `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\SecurityLogger:
                  tags:
                      - { name: monolog.logger, channel: security }
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\SecurityLogger:
                  logger_channel: security
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\SecurityLogger:
                  channel: security
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\SecurityLogger:
                  tags: ['security_logger']
          ```
        correct: false
    help: The `monolog.logger` tag, with a `channel` attribute, allows you to
      specify a custom logging channel for a service.
  - question: Which `ContainerBuilder` method is used in a bundle extension or
      kernel's `build` method to register an interface for autoconfiguration,
      allowing services implementing it to be automatically tagged?
    answers:
      - value: "`addTagForInterface()`"
        correct: false
      - value: "`registerForAutoconfiguration()`"
        correct: true
      - value: "`autoconfigureInterface()`"
        correct: false
      - value: "`tagServices()`"
        correct: false
    help: "`ContainerBuilder::registerForAutoconfiguration()` is used to define
      autoconfiguration rules for interfaces, applying tags or other
      configurations to all services that implement them."
  - question: You have multiple services tagged with `app.handler`. How would you
      inject an `iterable` of these services into a constructor using PHP
      attributes, excluding `App\Handler\Three`?
    answers:
      - value: >-
          ```php

          use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;


          class HandlerCollection

          {
              public function __construct(
                  #[TaggedIterator('app.handler', exclude: ['App\Handler\Three'])]
                  iterable $handlers
              ) {}
          }

          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

          class HandlerCollection
          {
              public function __construct(
                  #[TaggedIterator('app.handler', except: 'App\Handler\Three')]
                  iterable $handlers
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

          class HandlerCollection
          {
              public function __construct(
                  #[TaggedIterator('app.handler', filter: '!App\Handler\Three')]
                  iterable $handlers
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\TaggedIterator;

          class HandlerCollection
          {
              public function __construct(
                  #[TaggedIterator('app.handler')]
                  #[ExcludeService('App\Handler\Three')]
                  iterable $handlers
              ) {}
          }
          ```
        correct: false
    help: The `#[TaggedIterator]` attribute supports an `exclude` option to filter
      out specific services from the injected collection.
  - question: What is the primary role of a class implementing
      `Symfony\Component\Config\Definition\ConfigurationInterface` in a Symfony
      bundle or application?
    answers:
      - value: To define the service definitions for the bundle.
        correct: false
      - value: To load configuration files (e.g., YAML, XML).
        correct: false
      - value: To define and validate the semantic configuration tree for an extension.
        correct: true
      - value: To compile the dependency injection container.
        correct: false
    help: The `ConfigurationInterface` is used to define the structure, validation
      rules, and default values for a bundle's semantic configuration.
  - question: Which class is typically used in a Symfony extension's `load()` method
      to process and validate the raw configuration arrays against the
      `Configuration` class?
    answers:
      - value: "`Symfony\\Component\\Config\\Loader\\LoaderResolver`"
        correct: false
      - value: "`Symfony\\Component\\Config\\Definition\\Processor`"
        correct: true
      - value: "`Symfony\\Component\\DependencyInjection\\Extension\\Extension`"
        correct: false
      - value: "`Symfony\\Component\\Config\\FileLocator`"
        correct: false
    help: The `Symfony\Component\Config\Definition\Processor` is responsible for
      merging and validating configuration arrays against the rules defined in a
      `Configuration` class.
  - question: If you need to generate unique identifiers (ULIDs) in your Symfony
      application, which built-in factory service would you typically inject?
    answers:
      - value: "`Symfony\\Component\\Uid\\Factory\\UuidFactory`"
        correct: false
      - value: "`Symfony\\Component\\Uid\\Factory\\UlidFactory`"
        correct: true
      - value: "`Symfony\\Component\\Uid\\UlidGenerator`"
        correct: false
      - value: "`Symfony\\Component\\Uid\\UidFactory`"
        correct: false
    help: "`UlidFactory` is the dedicated service for generating ULIDs in Symfony
      applications, promoting dependency injection for this functionality."
  - question: What is the main purpose of a Symfony Compiler Pass?
    answers:
      - value: To define new services dynamically at runtime.
        correct: false
      - value: To allow developers to manipulate service definitions and parameters
          *before* the container is compiled.
        correct: true
      - value: To provide a mechanism for lazy-loading services.
        correct: false
      - value: To register event listeners for application events.
        correct: false
    help: Compiler passes allow you to hook into the container compilation process
      to inspect, modify, or add service definitions and parameters.
  - question: To create a custom compiler pass in Symfony, which interface must your
      class implement?
    answers:
      - value: "`Symfony\\Component\\DependencyInjection\\Compiler\\PassInterface`"
        correct: false
      - value: "`Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterfa\
          ce`"
        correct: true
      - value: "`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface\
          `"
        correct: false
      - value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`"
        correct: false
    help: All custom compiler passes must implement
      `Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface` and
      the `process()` method.
  - question: How do you register a custom compiler pass with the `ContainerBuilder`
      in your kernel or bundle extension?
    answers:
      - value: "`$container->addPass(new MyCompilerPass());`"
        correct: false
      - value: "`$container->registerCompilerPass(new MyCompilerPass());`"
        correct: false
      - value: "`$container->addCompilerPass(new MyCompilerPass());`"
        correct: true
      - value: "`$container->attachCompilerPass(new MyCompilerPass());`"
        correct: false
    help: The `addCompilerPass()` method of `ContainerBuilder` is used to register
      custom compiler passes.
  - question: Which `PassConfig` constant would you use to ensure a compiler pass
      runs *after* all optimization passes and service removals have occurred?
    answers:
      - value: "`PassConfig::TYPE_BEFORE_OPTIMIZATION`"
        correct: false
      - value: "`PassConfig::TYPE_BEFORE_REMOVING`"
        correct: false
      - value: "`PassConfig::TYPE_AFTER_REMOVING`"
        correct: true
      - value: "`PassConfig::TYPE_OPTIMIZE`"
        correct: false
    help: "`PassConfig::TYPE_AFTER_REMOVING` ensures the compiler pass executes at a
      very late stage, after most optimizations and service removals."
  - question: If you have two compiler passes of the same type, `PassA` with
      priority 10 and `PassB` with priority 20, which one will execute first?
    answers:
      - value: "`PassA`"
        correct: false
      - value: "`PassB`"
        correct: true
      - value: The order is undefined.
        correct: false
      - value: They execute concurrently.
        correct: false
    help: Compiler passes with higher priority values are executed earlier within
      the same compilation phase.
  - question: What happens if an abstract argument defined in a service definition
      is not replaced by a compiler pass before the container is compiled?
    answers:
      - value: The argument will be `null`.
        correct: false
      - value: The argument will be an empty string.
        correct: false
      - value: A `RuntimeException` will be thrown.
        correct: true
      - value: The service will be automatically removed from the container.
        correct: false
    help: Abstract arguments are placeholders that *must* be replaced by a compiler
      pass. If not, a `RuntimeException` is thrown during compilation.
  - question: What is the simplest way to enable autowiring for a service in Symfony
      7, allowing its dependencies to be automatically injected based on
      type-hints?
    answers:
      - value: Explicitly define all arguments in `services.yaml`.
        correct: false
      - value: Extend `AbstractController` for all services.
        correct: false
      - value: Ensure the service is public and type-hint its dependencies.
        correct: false
      - value: "Enable `autowire: true` in `_defaults` or for the specific service."
        correct: true
    help: "Setting `autowire: true` (often in `_defaults` for an entire namespace)
      enables Symfony's autowiring mechanism."
  - question: When a service type-hints an interface (e.g.,
      `App\Util\TransformerInterface`), how does Symfony's autowiring determine
      which concrete implementation to inject by default?
    answers:
      - value: It injects the first service found that implements the interface.
        correct: false
      - value: It throws an exception, requiring explicit configuration.
        correct: false
      - value: It looks for a service whose ID matches the interface's FQCN.
        correct: true
      - value: It always injects a mock object.
        correct: false
    help: By default, Symfony's autowiring will try to find a service whose ID
      matches the fully qualified class name (FQCN) of the type-hinted
      interface. If multiple services implement the same interface and no
      explicit alias is set, an error occurs.
  - question: You have `App\Util\Rot13Transformer` and
      `App\Util\UppercaseTransformer` both implementing
      `App\Util\TransformerInterface`. You want `UppercaseTransformer` to be
      injected when the argument is named `$shoutyTransformer`. How would you
      configure this using a named autowiring alias in YAML?
    answers:
      - value: >-
          ```yaml

          services:
              App\Util\TransformerInterface $shoutyTransformer: '@App\Util\UppercaseTransformer'
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              $shoutyTransformer: '@App\Util\UppercaseTransformer'
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Util\UppercaseTransformer:
                  alias: App\Util\TransformerInterface $shoutyTransformer
          ```
        correct: false
      - value: >-
          ```yaml

          services:
              App\Util\TransformerInterface:
                  named_alias: $shoutyTransformer: '@App\Util\UppercaseTransformer'
          ```
        correct: false
    help: "Named autowiring aliases use the format `InterfaceFQN $argumentName:
      '@service_id'` to provide specific implementations based on the argument
      name."
  - question: How would you inject the `kernel.project_dir` parameter into a service
      constructor argument named `$projectRoot` using the `#[Autowire]`
      attribute?
    answers:
      - value: "`#[Autowire(param: 'kernel.project_dir')] string $projectRoot`"
        correct: false
      - value: "`#[Autowire('%kernel.project_dir%')] string $projectRoot`"
        correct: true
      - value: "`#[Autowire(parameter: 'kernel.project_dir')] string $projectRoot`"
        correct: false
      - value: "`#[Autowire(value: '%kernel.project_dir%')] string $projectRoot`"
        correct: false
    help: "The `#[Autowire]` attribute can directly take a parameter string (e.g.,
      `'%kernel.project_dir%'`) or use the `param` argument (`param:
      'kernel.project_dir'`). The direct string is a common way to inject
      parameters."
  - question: When multiple services implement the same interface (e.g.,
      `LoggerInterface`), and you want to inject a specific one (e.g., a logger
      named `requestLogger`), which attribute should you use on the constructor
      argument?
    answers:
      - value: "`#[Autowire(service: 'requestLogger')]`"
        correct: false
      - value: "`#[Target('requestLogger')]`"
        correct: true
      - value: "`#[Named('requestLogger')]`"
        correct: false
      - value: "`#[Alias('requestLogger')]`"
        correct: false
    help: The `#[Target]` attribute allows you to explicitly specify which service
      ID should be injected when multiple services could satisfy a type-hinted
      argument.
  - question: What is the benefit of using `#[AutowireServiceClosure]` to inject a
      service as a `\Closure`?
    answers:
      - value: It makes the service available globally without needing to inject it.
        correct: false
      - value: It ensures the service is always instantiated immediately, regardless of
          usage.
        correct: false
      - value: It enables lazy-loading of the service, instantiating it only when the
          closure is called.
        correct: true
      - value: It allows the service to be used as an event listener.
        correct: false
    help: "`#[AutowireServiceClosure]` injects a `\\Closure` that, when invoked,
      returns the service instance. This defers the service's instantiation
      until it's actually needed, improving performance."
  - question: What is the key difference between `#[AutowireServiceClosure]` and
      `#[AutowireCallable]` when injecting a service's method as a `\Closure`?
    answers:
      - value: "`#[AutowireServiceClosure]` creates a closure that returns the service,
          while `#[AutowireCallable]` creates a closure that directly invokes a
          specific method of the service."
        correct: true
      - value: "`#[AutowireCallable]` always creates a new service instance on each
          call, while `#[AutowireServiceClosure]` reuses the same instance."
        correct: false
      - value: "`#[AutowireCallable]` is for static methods, and
          `#[AutowireServiceClosure]` is for instance methods."
        correct: false
      - value: There is no functional difference; they are aliases for the same
          behavior.
        correct: false
    help: "`#[AutowireServiceClosure]` provides a closure that returns the service
      instance. `#[AutowireCallable]` provides a closure that directly calls a
      specified method on the service instance, passing its arguments to that
      method."
  - question: Does Symfony's autowiring support PHP 8.1+ union and intersection
      types in constructor arguments?
    answers:
      - value: No, autowiring only supports single class or interface type-hints.
        correct: false
      - value: Yes, but only for union types, not intersection types.
        correct: false
      - value: Yes, but only for intersection types, not union types.
        correct: false
      - value: Yes, Symfony's autowiring can resolve dependencies for arguments
          type-hinted with union and intersection types.
        correct: true
    help: Symfony's autowiring mechanism is designed to handle modern PHP
      type-hints, including union and intersection types, to resolve
      dependencies.
  - question: Which Symfony console command can you use to list all services and
      type-hints that can be automatically wired by the Dependency Injection
      container?
    answers:
      - value: "`debug:container`"
        correct: false
      - value: "`debug:autowiring`"
        correct: true
      - value: "`debug:services`"
        correct: false
      - value: "`debug:di`"
        correct: false
    help: The `debug:autowiring` command provides a list of all autowirable types
      and the services that will be injected for them.
  - question: What is the primary benefit of using a Service Locator (e.g., via
      `ServiceSubscriberInterface`) instead of directly injecting all
      dependencies into a service's constructor?
    answers:
      - value: It makes all services globally accessible.
        correct: false
      - value: It reduces the number of constructor arguments for services with many
          optional or conditionally used dependencies, enabling lazy loading.
        correct: true
      - value: It allows services to be created without any dependencies.
        correct: false
      - value: It enforces strict dependency order.
        correct: false
    help: Service locators allow you to inject a "container" for a specific set of
      services, enabling lazy loading and reducing constructor argument bloat
      for services that don't always need all their potential dependencies.
  - question: When implementing `ServiceSubscriberInterface`, which trait simplifies
      the boilerplate code for accessing subscribed services via private
      methods?
    answers:
      - value: "`ServiceLocatorTrait`"
        correct: false
      - value: "`ContainerAwareTrait`"
        correct: false
      - value: "`ServiceSubscriberTrait`"
        correct: true
      - value: "`DependencyInjectionTrait`"
        correct: false
    help: "`ServiceSubscriberTrait` provides the necessary implementation for
      `ServiceSubscriberInterface`, allowing you to define private methods with
      `#[SubscribedService]` attributes for lazy-loaded dependencies."
  - question: You have a service that needs to lazily access a `LoggerInterface`.
      How would you declare this dependency using the `#[SubscribedService]`
      attribute on a private method?
    answers:
      - value: |-
          ```php
          #[SubscribedService]
          private function logger(): LoggerInterface
          {
              return $this->container->get(__METHOD__);
          }
          ```
        correct: true
      - value: |-
          ```php
          #[SubscribedService(service: 'logger')]
          private function getLogger(): LoggerInterface
          {
              return $this->container->get('logger');
          }
          ```
        correct: false
      - value: |-
          ```php
          #[SubscribedService(type: LoggerInterface::class)]
          private function logger(): LoggerInterface
          {
              return $this->container->get(LoggerInterface::class);
          }
          ```
        correct: false
      - value: |-
          ```php
          #[SubscribedService(id: 'logger')]
          private function logger(): LoggerInterface
          {
              return $this->container->get(__METHOD__);
          }
          ```
        correct: false
    help: The `#[SubscribedService]` attribute on a private method, combined with
      `ServiceSubscriberTrait`, automatically makes the type-hinted service
      available via `get(__METHOD__)`.
  - question: How would you configure a service locator in `config/services.yaml` to
      inject a `ContainerInterface` that provides `App\FooCommand` and
      `App\BarCommand` services?
    answers:
      - value: |-
          ```yaml
          services:
              App\CommandBus:
                  arguments:
                    - !service_locator
                        App\FooCommand: '@app.command_handler.foo'
                        App\BarCommand: '@app.command_handler.bar'
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\CommandBus:
                  arguments:
                    - type: service_locator
                      services:
                        App\FooCommand: '@app.command_handler.foo'
                        App\BarCommand: '@app.command_handler.bar'
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\CommandBus:
                  arguments:
                    - service_locator:
                        foo_command: '@app.command_handler.foo'
                        bar_command: '@app.command_handler.bar'
          ```
        correct: false
      - value: >-
          ```yaml

          services:
              App\CommandBus:
                  arguments:
                    - { locator: true, services: { App\FooCommand: '@app.command_handler.foo', App\BarCommand: '@app.command_handler.bar' } }
          ```
        correct: false
    help: The `!service_locator` tag in YAML is used to define a service locator,
      mapping keys (often class names) to service IDs.
  - question: How does the Symfony Kernel itself get injected into the container as
      a synthetic service?
    answers:
      - value: It's automatically autowired by the framework.
        correct: false
      - value: The Kernel class implements `ContainerAwareInterface`.
        correct: false
      - value: The Kernel calls `$this->container->set('kernel', $this);` during its
          initialization.
        correct: true
      - value: It's defined as a regular service in `services.yaml`.
        correct: false
    help: The Symfony Kernel sets itself into the container as a synthetic service
      with the ID `kernel` during its initialization process.
  - question: In `config/services_test.php`, how would you completely remove a
      service defined as `App\RemovedService` from the container for the test
      environment?
    answers:
      - value: "`$services->delete(RemovedService::class);`"
        correct: false
      - value: "`$services->disable(RemovedService::class);`"
        correct: false
      - value: "`$services->remove(RemovedService::class);`"
        correct: true
      - value: "`$services->unset(RemovedService::class);`"
        correct: false
    help: The `remove()` method on the `ServiceConfigurator` is used to remove a
      service definition from the container.
  - question: Which of the following is a valid way to define a service using PHP
      configuration in Symfony 7?
    answers:
      - value: |-
          ```php
          // config/services.php
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set('App\Service\MyService', App\Service\MyService::class);
          };
          ```
        correct: true
      - value: >-
          ```php

          // config/services.php

          $container->register('App\Service\MyService',
          'App\Service\MyService');

          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;

          MyService::registerService($container);
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          $services = new ServiceCollection();
          $services->add(App\Service\MyService::class);
          ```
        correct: false
    help: Symfony's modern PHP configuration uses a `ContainerConfigurator`
      instance, accessed via a closure, to define services using the
      `services()` method and `set()`.
  - question: "When defining a service in `config/services.yaml`, what does setting
      `public: false` achieve?"
    answers:
      - value: It prevents the service from being autowired.
        correct: false
      - value: It makes the service accessible only within the container, not directly
          via `Container::get()`.
        correct: true
      - value: It marks the service as deprecated.
        correct: false
      - value: It makes the service a singleton.
        correct: false
    help: "Setting `public: false` (or `private: true`) makes a service private,
      meaning it cannot be retrieved directly from the container using
      `Container::get()`. It can still be injected as a dependency into other
      services."
  - question: What is the purpose of the `_defaults` section in `config/services.yaml`?
    answers:
      - value: To define global parameters for all services.
        correct: false
      - value: To set default configuration options (like autowire, autoconfigure,
          public) for all services defined in that file.
        correct: true
      - value: To specify default arguments for services that don't explicitly define
          them.
        correct: false
      - value: To define service aliases.
        correct: false
    help: The `_defaults` section allows you to apply common configuration options
      (like `autowire`, `autoconfigure`, `public`) to all services defined
      within the same configuration file, reducing repetition.
  - question: Which of the following describes 'autowiring' in Symfony's Dependency
      Injection?
    answers:
      - value: Manually configuring every service's arguments in a configuration file.
        correct: false
      - value: Automatically injecting service dependencies based on type-hints in
          constructors, setters, or properties.
        correct: true
      - value: Generating configuration files automatically from PHP code.
        correct: false
      - value: A mechanism for creating new service instances on every request.
        correct: false
    help: Autowiring is a feature that automatically identifies and injects service
      dependencies by inspecting the type-hints of a service's constructor,
      setter methods, or public properties.
  - question: Consider a service `App\Service\MyService` that has a constructor
      argument `$logger` type-hinted as `Psr\Log\LoggerInterface`. If autowiring
      is enabled, how will Symfony resolve this dependency by default?
    answers:
      - value: It will look for a service with the ID `logger`.
        correct: false
      - value: It will look for a service with the ID `Psr\Log\LoggerInterface`.
        correct: true
      - value: It will throw an error because interfaces cannot be autowired.
        correct: false
      - value: It will create a new instance of `Psr\Log\LoggerInterface`.
        correct: false
    help: When autowiring an interface, Symfony attempts to find a service whose ID
      matches the fully qualified class name (FQCN) of the interface. For
      `Psr\Log\LoggerInterface`, the default logger service is aliased to this
      FQCN.
  - question: What is the primary use case for
      `Symfony\Component\DependencyInjection\Attribute\Target`?
    answers:
      - value: To mark a service as a target for decoration.
        correct: false
      - value: To explicitly specify which service ID to inject when multiple services
          implement the same interface or when using named arguments.
        correct: true
      - value: To define a target directory for service compilation.
        correct: false
      - value: To specify a target method for setter injection.
        correct: false
    help: The `#[Target]` attribute is used to disambiguate autowiring when multiple
      services could satisfy a type-hint, or to inject a specific service into a
      named argument.
  - question: Which Symfony component provides the `ContainerBuilder` and
      `Definition` classes for programmatically defining and manipulating
      services?
    answers:
      - value: HttpKernel
        correct: false
      - value: Config
        correct: false
      - value: DependencyInjection
        correct: true
      - value: FrameworkBundle
        correct: false
    help: The `Symfony\Component\DependencyInjection` component is the core of
      Symfony's Dependency Injection Container, providing classes like
      `ContainerBuilder` and `Definition`.
  - question: What is a 'synthetic' service in Symfony's Dependency Injection container?
    answers:
      - value: A service that is automatically generated by Symfony.
        correct: false
      - value: A service that does not specify a class and is expected to be provided to
          the container at runtime.
        correct: true
      - value: A service that is only available in the test environment.
        correct: false
      - value: A service that is always a singleton.
        correct: false
    help: A synthetic service is one that is declared in the container but whose
      instance is provided externally at runtime, rather than being instantiated
      by the container itself. The kernel service is a prime example.
  - question: How do you provide an instance for a synthetic service at runtime?
    answers:
      - value: By calling `Container::get('my_synthetic_service', $instance);`
        correct: false
      - value: By calling `Container::set('my_synthetic_service', $instance);`
        correct: true
      - value: By using a factory method in the service definition.
        correct: false
      - value: Synthetic services cannot be provided at runtime; they are compile-time
          only.
        correct: false
    help: Once a service is declared as synthetic, its actual instance must be
      provided to the container at runtime using the `Container::set()` method.
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\EnvVarLoaderInterface`?
    answers:
      - value: To load environment variables from a `.env` file.
        correct: false
      - value: To provide custom logic for loading environment variables, overriding
          Symfony's default behavior.
        correct: true
      - value: To process environment variables for security.
        correct: false
      - value: To dump environment variables into the compiled container.
        correct: false
    help: Implement `EnvVarLoaderInterface` to define custom environment variable
      loading logic, which can be useful for complex or non-standard environment
      setups.
  - question: Which of the following is a valid way to inject an environment
      variable named `APP_ENV` into a service constructor argument using the
      `#[Autowire]` attribute?
    answers:
      - value: "`#[Autowire(env: 'APP_ENV')] string $env;`"
        correct: true
      - value: "`#[Autowire('%env(APP_ENV)%')] string $env;`"
        correct: false
      - value: "`#[Autowire(value: 'env:APP_ENV')] string $env;`"
        correct: false
      - value: "`#[Autowire(environment: 'APP_ENV')] string $env;`"
        correct: false
    help: The `#[Autowire]` attribute can inject environment variables using the
      `env` argument, optionally with processors (e.g., `bool:APP_DEBUG`).
  - question: "When configuring a service, what does the `lazy: true` option (or
      `#[Autowire(lazy: true)]`) achieve?"
    answers:
      - value: It makes the service's constructor arguments optional.
        correct: false
      - value: It ensures the service is instantiated only when it's actually used, not
          at container compilation time.
        correct: true
      - value: It marks the service for removal if not used within a certain time.
        correct: false
      - value: It allows the service to be reloaded on every request.
        correct: false
    help: Setting a service as lazy means Symfony will not instantiate it until it
      is actually needed, which can improve application startup performance.
  - question: What is the purpose of the `kernel.reset` tag in Symfony?
    answers:
      - value: To reset the entire application state on every request.
        correct: false
      - value: To clean up the state of a service between requests in application
          servers (e.g., PHP-FPM, RoadRunner).
        correct: true
      - value: To reset the service container to its initial state.
        correct: false
      - value: To mark a service that should be re-instantiated on every request.
        correct: false
    help: The `kernel.reset` tag is used for services that maintain state and need
      to be reset between requests in long-running application server processes
      to prevent memory leaks or stale data.
  - question: Which method on `Symfony\Component\DependencyInjection\Definition` is
      used to set the class name for a service definition?
    answers:
      - value: "`setServiceClass()`"
        correct: false
      - value: "`setClass()`"
        correct: true
      - value: "`defineClass()`"
        correct: false
      - value: "`setClassName()`"
        correct: false
    help: The `setClass()` method of the `Definition` object is used to specify the
      fully qualified class name of the service.
  - question: To configure a service to have an optional dependency that should be
      `null` if the referenced service does not exist, which option would you
      use in XML configuration?
    answers:
      - value: |-
          ```xml
          <argument type="service" id="logger" optional="true"/>
          ```
        correct: false
      - value: |-
          ```xml
          <argument type="service" id="logger" on-invalid="null"/>
          ```
        correct: true
      - value: |-
          ```xml
          <argument type="service" id="logger" fallback="null"/>
          ```
        correct: false
      - value: |-
          ```xml
          <argument type="service" id="logger" if-not-found="null"/>
          ```
        correct: false
    help: The `on-invalid="null"` attribute for an `<argument type="service"/>` in
      XML configuration tells Symfony to inject `null` if the referenced service
      is not found.
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator::import()`?
    answers:
      - value: To export the current service definitions to a file.
        correct: false
      - value: To load external service configuration files (YAML, XML, PHP) into the
          current container configuration.
        correct: true
      - value: To import external PHP classes into the service container.
        correct: false
      - value: To import environment variables from a `.env` file.
        correct: false
    help: The `import()` method allows you to include other service definition
      files, enabling modular and organized configuration.
  - question: When using `ContainerConfigurator::import()`, how can you silently
      discard errors if the loaded file doesn't exist?
    answers:
      - value: "`$container->import('my_config.yaml', null, true);`"
        correct: false
      - value: "`$container->import('my_config.yaml', null, 'not_found');`"
        correct: true
      - value: "`$container->import('my_config.yaml', null, 'ignore_missing');`"
        correct: false
      - value: "`$container->import('my_config.yaml', null, false);`"
        correct: false
    help: The third argument of `import()` can be set to `'not_found'` to ignore
      errors specifically when the file is missing. Setting it to `true` ignores
      all errors.
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\Extension\PrependExtensionInterface`?
    answers:
      - value: To define services that must be loaded before any other services.
        correct: false
      - value: To allow an extension to prepend configuration to other extensions before
          their `load()` methods are called.
        correct: true
      - value: To mark an extension as a dependency for other extensions.
        correct: false
      - value: To define global parameters that override bundle-specific parameters.
        correct: false
    help: Extensions implementing `PrependExtensionInterface` can modify or add
      configuration for other bundles, which is useful for setting default
      values or ensuring certain configurations are present.
  - question: Which method is called on an extension implementing
      `PrependExtensionInterface`?
    answers:
      - value: "`configure()`"
        correct: false
      - value: "`prepend()`"
        correct: true
      - value: "`beforeLoad()`"
        correct: false
      - value: "`preLoad()`"
        correct: false
    help: The `prepend(ContainerBuilder $container)` method is called before any
      other extension's `load()` method, allowing for early configuration
      manipulation.
  - question: When defining multiple services of the same class (e.g.,
      `App\Service\SiteUpdateManager`) with different configurations, how can
      you designate one as the default for autowiring when type-hinting the
      class?
    answers:
      - value: "By marking one service with `autowire: default`."
        correct: false
      - value: By creating an alias from the class FQCN to the desired service ID.
        correct: true
      - value: By making the preferred service public and others private.
        correct: false
      - value: Symfony automatically picks the first defined service.
        correct: false
    help: To specify a default service when multiple services of the same class
      exist, create an alias from the class's FQCN to the ID of the preferred
      service.
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\Dumper\PhpDumper`?
    answers:
      - value: To dump PHP code from a database schema.
        correct: false
      - value: To convert service definitions from YAML/XML to PHP arrays.
        correct: false
      - value: To compile the Dependency Injection container into an optimized PHP class
          file for caching.
        correct: true
      - value: To dump PHP unit tests for services.
        correct: false
    help: The `PhpDumper` is used to serialize the compiled `ContainerBuilder` into
      an optimized PHP class file, which can then be included for faster
      container loading on subsequent requests.
  - question: When dumping the compiled container using `PhpDumper`, how can you
      specify a custom class name for the generated container class?
    answers:
      - value: By passing a `class` option to the `dump()` method.
        correct: true
      - value: By setting a parameter `container.class_name`.
        correct: false
      - value: The class name is always `ProjectServiceContainer`.
        correct: false
      - value: By extending `PhpDumper` and overriding a method.
        correct: false
    help: The `dump()` method of `PhpDumper` accepts an array of options, including
      `class` to specify the name of the generated container class.
  - question: What is the primary benefit of using
      `Symfony\Component\Config\ConfigCache` when caching the compiled
      Dependency Injection container?
    answers:
      - value: It automatically compresses the cached container file.
        correct: false
      - value: It enables automatic cache invalidation by tracking changes in dependent
          resources (e.g., configuration files).
        correct: true
      - value: It encrypts the cached container for security.
        correct: false
      - value: It allows the container to be cached in a database.
        correct: false
    help: "`ConfigCache` is designed to manage cache files, automatically
      determining if the cache is fresh based on the modification times of the
      tracked resources, and rebuilding it if necessary."
  - question: Which Symfony CLI command would you use to debug configured autowiring
      aliases?
    answers:
      - value: "`debug:container --aliases`"
        correct: false
      - value: "`debug:autowiring`"
        correct: true
      - value: "`debug:services --aliases`"
        correct: false
      - value: "`debug:di:aliases`"
        correct: false
    help: The `debug:autowiring` command not only lists autowirable types but also
      shows any configured named autowiring aliases.
  - question: What is an 'anonymous service' in Symfony's Dependency Injection?
    answers:
      - value: A service that is defined without a specific class.
        correct: false
      - value: A service that is automatically generated by Symfony and cannot be
          accessed directly.
        correct: false
      - value: A service that does not have a public ID and is created directly where
          it's used, promoting encapsulation.
        correct: true
      - value: A service that is only available in the development environment.
        correct: false
    help: Anonymous services are defined inline as arguments to other services. They
      don't have a global ID, preventing other services from directly depending
      on them and promoting better encapsulation.
  - question: How can you inject the Symfony Profiler service into a controller or
      service for development purposes?
    answers:
      - value: By type-hinting `Symfony\Component\HttpKernel\Profiler\Profiler` and
          ensuring an alias to `@profiler` exists.
        correct: true
      - value: The Profiler is automatically injected into all controllers.
        correct: false
      - value: By calling `Container::get('profiler')` directly.
        correct: false
      - value: It's only accessible via the debug bar, not directly injectable.
        correct: false
    help: To inject the Profiler, an alias from
      `Symfony\Component\HttpKernel\Profiler\Profiler` to the built-in
      `profiler` service ID is typically configured in `services_dev.yaml`.
  - question: What is the purpose of the `controller.service_arguments` tag when
      applied to a controller service in Symfony?
    answers:
      - value: It marks the controller as a public service.
        correct: false
      - value: It enables dependency injection into the controller's action method
          parameters, even if the controller doesn't extend
          `AbstractController`.
        correct: true
      - value: It ensures the controller is a singleton.
        correct: false
      - value: It registers the controller as an event subscriber.
        correct: false
    help: The `controller.service_arguments` tag makes a controller service public
      and enables argument autowiring for its action methods, providing
      flexibility beyond extending `AbstractController`.
  - question: In a PHP service definition, how would you configure a setter method
      `setLogger` to be called with the `logger` service as an argument?
    answers:
      - value: >-
          ```php

          $services->set(MyService::class)->call('setLogger',
          [service('logger')]);

          ```
        correct: true
      - value: >-
          ```php

          $services->set(MyService::class)->addArgument('setLogger',
          service('logger'));

          ```
        correct: false
      - value: |-
          ```php
          $services->set(MyService::class)->setter('setLogger', 'logger');
          ```
        correct: false
      - value: |-
          ```php
          $services->set(MyService::class)->method('setLogger')->with(service('logger'));
          ```
        correct: false
    help: The `call()` method on a service definition is used to configure method
      calls for setter injection.
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\Attribute\AutowireDecorated`?
    answers:
      - value: To autowire a service that is being decorated.
        correct: true
      - value: To mark a service as a decorator.
        correct: false
      - value: To automatically decorate all services of a certain type.
        correct: false
      - value: To specify the order of decoration.
        correct: false
    help: The `#[AutowireDecorated]` attribute is specifically used within a service
      decorator's constructor to inject the original (decorated) service
      instance.
  - question: Which expression language function allows you to retrieve a parameter
      value from the container?
    answers:
      - value: "`get_parameter('param_name')`"
        correct: false
      - value: "`parameter('param_name')`"
        correct: true
      - value: "`param('param_name')`"
        correct: false
      - value: "`container.getParameter('param_name')`"
        correct: false
    help: The `parameter()` function in Symfony's Expression Language is used to
      access container parameters within service definitions or other
      expressions.
  - question: "When defining a service, what does `abstract: true` (or
      `->abstract()`) signify?"
    answers:
      - value: The service cannot be instantiated directly and must be extended by other
          services.
        correct: true
      - value: The service is a singleton.
        correct: false
      - value: The service is automatically removed during compilation.
        correct: false
      - value: The service's class does not exist.
        correct: false
    help: An abstract service definition serves as a template for other services. It
      cannot be instantiated directly but can be inherited by child services
      using the `parent` option.
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\Definition::setFile()`?
    answers:
      - value: To specify a file where the service's configuration is stored.
        correct: false
      - value: To include an external PHP file (via `require_once`) just before the
          service is loaded.
        correct: true
      - value: To define the path to the service's class file.
        correct: false
      - value: To set the logger file for the service.
        correct: false
    help: The `setFile()` method is used to ensure a specific PHP file is included
      before the service is instantiated, which can be useful for classes that
      are not autoloaded or require specific setup.
  - question: When configuring a tagged iterator in PHP, how can you specify a
      method on the tagged services to use for prioritizing them?
    answers:
      - value: "`tagged_iterator('tag_name', null, null, 'getPriority')`"
        correct: true
      - value: "`tagged_iterator('tag_name')->orderBy('getPriority')`"
        correct: false
      - value: "`tagged_iterator('tag_name', priorityMethod: 'getPriority')`"
        correct: false
      - value: "`tagged_iterator('tag_name', method: 'getPriority')`"
        correct: false
    help: The `tagged_iterator` helper function accepts a fourth argument for
      `default-priority-method` (or `priorityMethod` in some contexts) to
      specify a method for ordering the collected services.
  - question: What is the main benefit of using
      `Symfony\Contracts\Service\ServiceSubscriberInterface`?
    answers:
      - value: It allows a service to subscribe to events dispatched by other services.
        correct: false
      - value: It provides a mechanism for lazy-loading services via a service locator,
          reducing the number of direct constructor dependencies.
        correct: true
      - value: It enables a service to be a global singleton.
        correct: false
      - value: It allows a service to be configured using PHP attributes only.
        correct: false
    help: "`ServiceSubscriberInterface` (often used with `ServiceSubscriberTrait`)
      allows a service to declare its dependencies in a way that enables lazy
      loading through a service locator, improving performance for services with
      many optional dependencies."
  - question: How can you deprecate a container parameter in a Symfony extension's
      `load()` method, providing a custom message?
    answers:
      - value: "`$containerBuilder->deprecateParameter('param_name', 'vendor/package',
          '1.0', 'Custom message.');`"
        correct: true
      - value: "`$containerBuilder->markParameterDeprecated('param_name', 'Custom
          message.');`"
        correct: false
      - value: "`$containerBuilder->setParameter('param_name',
          $value)->setDeprecated('Custom message.');`"
        correct: false
      - value: "`$containerBuilder->addDeprecation('param_name', 'Custom message.');`"
        correct: false
    help: The `deprecateParameter()` method on `ContainerBuilder` allows you to mark
      a parameter as deprecated, specifying the package, version, and an
      optional custom message.
  - question: Which of the following describes 'autoconfiguration' in Symfony's
      Dependency Injection?
    answers:
      - value: Manually adding tags and arguments to every service definition.
        correct: false
      - value: Automatically applying tags or other configurations to services based on
          their class, implemented interfaces, or attributes.
        correct: true
      - value: Generating service definitions from database schemas.
        correct: false
      - value: A feature that automatically reloads service definitions when files
          change.
        correct: false
    help: Autoconfiguration automatically applies tags or other configurations to
      services based on rules defined for interfaces or attributes, reducing
      boilerplate in service definitions.
  - question: What is the primary purpose of the
      `Symfony\Component\DependencyInjection\Attribute\TaggedIterator`
      attribute?
    answers:
      - value: To inject a single service that has a specific tag.
        correct: false
      - value: To inject an `iterable` (e.g., `array` or `Traversable`) of all services
          tagged with a specific name.
        correct: true
      - value: To create a service that iterates over all defined services.
        correct: false
      - value: To mark a service as an iterator.
        correct: false
    help: The `#[TaggedIterator]` attribute is used to inject a collection of
      services that share a common tag, allowing for dynamic service discovery
      and collection.
  - question: What is the primary purpose of the
      `Symfony\Component\DependencyInjection\Attribute\TaggedLocator` attribute?
    answers:
      - value: To inject a service locator that provides access to all services tagged
          with a specific name.
        correct: true
      - value: To inject a single service that has a specific tag.
        correct: false
      - value: To create a service that locates files based on tags.
        correct: false
      - value: To mark a service as a service locator.
        correct: false
    help: The `#[TaggedLocator]` attribute injects a
      `Psr\Container\ContainerInterface` (a service locator) that can retrieve
      individual services tagged with a specific name, providing lazy access to
      a collection of services by their individual IDs.
  - question: When defining a service with a constructor argument, how can you
      specify a named argument (PHP 8+) in YAML configuration?
    answers:
      - value: |-
          ```yaml
          arguments:
              $myArgument: '@my_service'
          ```
        correct: true
      - value: |-
          ```yaml
          arguments:
              myArgument: '@my_service'
          ```
        correct: false
      - value: |-
          ```yaml
          arguments:
              - name: myArgument
                value: '@my_service'
          ```
        correct: false
      - value: |-
          ```yaml
          arguments:
              - '$myArgument': '@my_service'
          ```
        correct: false
    help: In YAML, named arguments for PHP 8+ constructors are specified by
      prefixing the argument name with a dollar sign (`$`).
  - question: What is the purpose of
      `Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator::parameters()`?
    answers:
      - value: To retrieve parameters from the container.
        correct: false
      - value: To define and manipulate parameters within the PHP service configuration.
        correct: true
      - value: To get a list of all defined parameters.
        correct: false
      - value: To set global environment variables.
        correct: false
    help: The `parameters()` method on `ContainerConfigurator` returns a
      `ParameterConfigurator` instance, which is used to define and manage
      parameters in PHP-based service definitions.
  - question: "When using `#[Autowire(service: 'monolog.logger.request')]` on a
      `LoggerInterface` argument, what is the effect?"
    answers:
      - value: It injects the default logger, but with the channel set to 'request'.
        correct: false
      - value: It explicitly injects the service with the ID `monolog.logger.request`,
          overriding default autowiring behavior.
        correct: true
      - value: It creates a new logger instance specifically for the request.
        correct: false
      - value: It makes the logger service lazy-loaded.
        correct: false
    help: "The `#[Autowire(service: 'service_id')]` attribute allows you to
      explicitly specify which service ID to inject, even if the type-hint could
      be satisfied by another service or if the service ID doesn't match the
      FQCN."
  - question: What is the role of `Symfony\Component\Config\FileLocator` when
      loading service definitions?
    answers:
      - value: To locate and parse configuration files from various paths.
        correct: true
      - value: To convert file formats (e.g., YAML to XML).
        correct: false
      - value: To validate the syntax of configuration files.
        correct: false
      - value: To cache loaded configuration files.
        correct: false
    help: "`FileLocator` helps loaders find configuration files by searching a
      predefined set of paths, making it easier to manage configuration across
      different bundles or environments."
  - question: In the context of Dependency Injection, what is a 'circular reference'?
    answers:
      - value: When a service calls itself recursively.
        correct: false
      - value: When two or more services directly or indirectly depend on each other,
          creating an infinite loop during instantiation.
        correct: true
      - value: When a service is defined multiple times in the container.
        correct: false
      - value: When a service uses a deprecated dependency.
        correct: false
    help: A circular reference occurs when Service A depends on Service B, and
      Service B, in turn, depends on Service A (or a chain of services leading
      back to A). This prevents the container from being able to instantiate
      either service.
  - question: How does Symfony typically handle circular references during container
      compilation?
    answers:
      - value: It automatically breaks the cycle by making one of the services lazy.
        correct: false
      - value: It throws an exception, indicating a design flaw that needs to be
          resolved manually.
        correct: true
      - value: It logs a warning and continues, potentially leading to runtime errors.
        correct: false
      - value: It creates a proxy for one of the services to resolve the cycle.
        correct: false
    help: Symfony's compiler passes detect circular references during compilation
      and throw an exception, forcing developers to resolve the dependency
      cycle, often by introducing lazy loading or refactoring.
