category: Dependency Injection

questions:
  -
    question: >
      What is the primary purpose of the Symfony Dependency Injection Container?
    answers:
      - { value: "To manage and centralize the instantiation and configuration of objects (services).", correct: true }
      - { value: "To handle HTTP requests and responses.", correct: false }
      - { value: "To manage database connections and ORM entities.", correct: false }
      - { value: "To define routes and map them to controllers.", correct: false }
    help: |
      The Dependency Injection Container is a tool that manages the instantiation of services and injects their dependencies.
      https://symfony.com/doc/current/service_container.html

  -
    question: |
      Given the following PHP code, how would you register the `App\Mail\NewsletterManager` service with constructor injection for the `mailer` service using the PHP configuration format?

      ```php
      // src/Mail/NewsletterManager.php
      namespace App\Mail;

      use Symfony\Component\Mailer\MailerInterface;

      class NewsletterManager
      {
          public function __construct(
              private MailerInterface $mailer,
          ) {}
      }
      ```
    answers:
      - { value: "$services->set(NewsletterManager::class)->args(service('mailer'));", correct: true }
      - { value: "$services->set(NewsletterManager::class)->call('__construct', [service('mailer')]);", correct: false }
      - { value: "$services->set(NewsletterManager::class)->property('mailer', service('mailer'));", correct: false }
      - { value: "$services->set(NewsletterManager::class)->factory('create', [service('mailer')]);", correct: false }
    help: |
      In PHP configuration, `->args()` is used to define constructor arguments.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: >
      Which of the following best describes "autowiring" in Symfony's Dependency Injection component?
    answers:
      - { value: "Automatically injecting services into a class's constructor or methods based on type-hints.", correct: true }
      - { value: "Automatically generating routes from controller annotations.", correct: false }
      - { value: "Automatically compiling Twig templates.", correct: false }
      - { value: "Automatically creating database migrations.", correct: false }
    help: |
      Autowiring is Symfony's feature that can automatically read the type-hints on your constructor (or other methods) and pass the correct services.
      https://symfony.com/doc/current/service_container/autowiring.html

  -
    question: |
      Consider the following service definition in `config/services.yaml`:

      ```yaml
      # config/services.yaml
      services:
          App\Service\MessageGenerator:
              calls:
                  - setLogger: ['@logger']
      ```
      What type of dependency injection is being used for the `setLogger` method?
    answers:
      - { value: "Setter Injection", correct: true }
      - { value: "Constructor Injection", correct: false }
      - { value: "Property Injection", correct: false }
      - { value: "Immutable Setter Injection", correct: false }
    help: |
      The `calls` key in YAML service definitions is used to invoke methods on the service instance after it has been created, commonly for setter injection.
      https://symfony.com/doc/current/service_container/calls.html

  -
    question: >
      What is the purpose of the `#[Required]` attribute in Symfony's Dependency Injection?
    answers:
      - { value: "To mark a setter method or public property as mandatory for autowiring.", correct: true }
      - { value: "To define a service as a required dependency for another service.", correct: false }
      - { value: "To indicate that a service must be lazy-loaded.", correct: false }
      - { value: "To force a service to be public.", correct: false }
    help: |
      The `#[Required]` attribute is used to mark a setter method or public property as required for autowiring, ensuring that a dependency is provided.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: |
      You have a service that needs to inject *all* services tagged with `app.handler`. Which attribute would you use on the constructor argument to achieve this with autowiring?
    answers:
      - { value: "`#[AutowireIterator('app.handler')]`", correct: true }
      - { value: "`#[Target('app.handler')]`", correct: false }
      - { value: "`#[Autowire(tag: 'app.handler')]`", correct: false }
      - { value: "`#[Required(tag: 'app.handler')]`", correct: false }
    help: |
      The `#[AutowireIterator]` attribute is used to inject all services tagged with a specific tag into an `iterable` or `array` argument.
      https://symfony.com/doc/current/service_container/tags.html#autowiring-tagged-services

  -
    question: >
      Which of the following methods is used to retrieve a service from the container at runtime, typically discouraged in favor of dependency injection?
    answers:
      - { value: "`$container->get('service_id')`", correct: true }
      - { value: "`$container->load('service_id')`", correct: false }
      - { value: "`$container->find('service_id')`", correct: false }
      - { value: "`$container->resolve('service_id')`", correct: false }
    help: |
      The `$container->get()` method is used to retrieve a service from the container. While functional, direct container access is generally discouraged in favor of explicit dependency injection.
      https://symfony.com/doc/current/components/dependency_injection.html#retrieving-services

  -
    question: |
      You want to inject a specific named logger service, `monolog.logger.request`, into a controller method argument. Which attribute should you use?
    answers:
      - { value: "`#[Autowire(service: 'monolog.logger.request')]`", correct: true }
      - { value: "`#[Target('monolog.logger.request')]`", correct: false }
      - { value: "`#[Required]`", correct: false }
      - { value: "`#[Inject('monolog.logger.request')]`", correct: false }
    help: |
      The `#[Autowire(service: 'service_id')]` attribute allows you to explicitly specify which service ID should be injected, overriding autowiring's default behavior.
      https://symfony.com/doc/current/controller.html#autowiring-arguments

  -
    question: >
      What is a "parameter" in the context of the Symfony Dependency Injection Container?
    answers:
      - { value: "A configuration value that can be injected into services.", correct: true }
      - { value: "An argument passed to a console command.", correct: false }
      - { value: "A route placeholder in a URL.", correct: false }
      - { value: "A query string variable in an HTTP request.", correct: false }
    help: |
      Parameters are simple configuration values (strings, booleans, integers, arrays) that can be defined in the container and then injected into services.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: |
      How do you define a service as an alias for another existing service in YAML configuration?
    answers:
      - { value: "```yaml\nservices:\n    MyServiceAlias: '@original_service_id'\n```", correct: true }
      - { value: "```yaml\nservices:\n    MyServiceAlias:\n        alias: original_service_id\n```", correct: true }
      - { value: "```yaml\nservices:\n    MyServiceAlias:\n        target: original_service_id\n```", correct: false }
      - { value: "```yaml\nservices:\n    MyServiceAlias:\n        extends: original_service_id\n```", correct: false }
    help: |
      An alias allows you to refer to a service by an alternative name. This can be done by simply setting the alias service ID to `@original_service_id` or by using the `alias` key.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: >
      What is the purpose of a "Compiler Pass" in the Symfony Dependency Injection component?
    answers:
      - { value: "To modify the service container definition before it is compiled and optimized.", correct: true }
      - { value: "To compile Twig templates into PHP code.", correct: false }
      - { value: "To compile assets like CSS and JavaScript.", correct: false }
      - { value: "To compile PHP code into bytecode.", correct: false }
    help: |
      Compiler passes allow you to manipulate the service container definition before it is compiled into an optimized, immutable container. This is where bundles can register services, modify existing ones, or add new definitions based on tags.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html#compiler-passes

  -
    question: |
      Which of the following is the correct way to define a service using a factory method in YAML?
    answers:
      - { value: "```yaml\nservices:\n    app.mailer:\n        class: App\\Factory\\MailerFactory\n        factory: 'createMailer'\n        arguments: ['%mailer.transport%']\n```", correct: false }
      - { value: "```yaml\nservices:\n    app.mailer:\n        factory: ['App\\Factory\\MailerFactory', 'createMailer']\n        arguments: ['%mailer.transport%']\n```", correct: true }
      - { value: "```yaml\nservices:\n    app.mailer:\n        factory:\n            class: App\\Factory\\MailerFactory\n            method: createMailer\n        arguments: ['%mailer.transport%']\n```", correct: false }
      - { value: "```yaml\nservices:\n    app.mailer:\n        call: ['App\\Factory\\MailerFactory', 'createMailer']\n        arguments: ['%mailer.transport%']\n```", correct: false }
    help: |
      When defining a service using a factory, the `factory` key specifies a callable (either a static method or a service and its method) that returns the service instance.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      What is "Service Decoration" in Symfony's Dependency Injection?
    answers:
      - { value: "Replacing an existing service with a new one that wraps or extends its functionality.", correct: true }
      - { value: "Adding visual styling to a service in the Symfony Profiler.", correct: false }
      - { value: "Injecting multiple services into a single argument.", correct: false }
      - { value: "Marking a service as public for direct access.", correct: false }
    help: |
      Service decoration allows you to replace an existing service with a new one that "decorates" it, meaning it wraps or extends the original service's functionality.
      https://symfony.com/doc/current/service_container/service_decoration.html

  -
    question: |
      How can you configure a service to use "immutable setter injection" (wither methods) in Symfony's PHP configuration?
    answers:
      - { value: "$services->set(NewsletterManager::class)->addMethodCall('withMailer', [service('mailer')], true);", correct: true }
      - { value: "$services->set(NewsletterManager::class)->call('withMailer', [service('mailer')], true);", correct: true }
      - { value: "$services->set(NewsletterManager::class)->addMethodCall('withMailer', [service('mailer')]);", correct: false }
      - { value: "$services->set(NewsletterManager::class)->call('withMailer', [service('mailer')]);", correct: false }
    help: |
      For immutable setter injection, you must specify `true` as the third argument to `addMethodCall` (or `call` in the configurator) to indicate that the method returns a new instance.
      https://symfony.com/doc/current/service_container/injection_types.html#immutable-setter-injection

  -
    question: >
      Which attribute is used to inject a specific named service when multiple services implement the same interface, resolving autowiring ambiguity?
    answers:
      - { value: "`#[Target('service_name')]`", correct: true }
      - { value: "`#[Autowire(service: 'service_name')]`", correct: true }
      - { value: "`#[Required]`", correct: false }
      - { value: "`#[AsService]`", correct: false }
    help: |
      Both `#[Target]` and `#[Autowire(service: ...)]` can be used to specify a named service for injection when autowiring encounters ambiguity due to multiple implementations of an interface.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services

  -
    question: >
      What is the purpose of the `ContainerBuilder` class in Symfony's Dependency Injection component?
    answers:
      - { value: "It is used to build and compile the service container definition.", correct: true }
      - { value: "It is responsible for handling HTTP requests.", correct: false }
      - { value: "It provides methods for interacting with the database.", correct: false }
      - { value: "It is a class used for creating new Symfony projects.", correct: false }
    help: |
      The `ContainerBuilder` is the central class for building and managing the dependency injection container. It allows you to register service definitions, parameters, and compile the container.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      How can you inject an environment variable named `APP_ENV` into a service's constructor argument using PHP attributes?
    answers:
      - { value: "`#[Autowire(env: 'APP_ENV')]`", correct: true }
      - { value: "`#[Autowire('%env(APP_ENV)%')]`", correct: false }
      - { value: "`#[Target('env:APP_ENV')]`", correct: false }
      - { value: "`#[Env('APP_ENV')]`", correct: false }
    help: |
      The `#[Autowire(env: 'ENV_VAR_NAME')]` attribute allows you to inject the value of an environment variable directly.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: >
      What is the primary benefit of using constructor injection over public property injection in Symfony?
    answers:
      - { value: "Constructor injection ensures that all required dependencies are provided at object instantiation, making the object always in a valid state.", correct: true }
      - { value: "Constructor injection allows for optional dependencies, which is not possible with property injection.", correct: false }
      - { value: "Constructor injection is faster than property injection.", correct: false }
      - { value: "Constructor injection makes services public by default.", correct: false }
    help: |
      Constructor injection ensures that a service's dependencies are always available when the service is instantiated, promoting immutability and predictable state. Property injection bypasses encapsulation.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: |
      You need to load service definitions from a `services.yaml` file into a `ContainerBuilder`. Which loader would you use?
    answers:
      - { value: "`YamlFileLoader`", correct: true }
      - { value: "`XmlFileLoader`", correct: false }
      - { value: "`PhpFileLoader`", correct: false }
      - { value: "`IniFileLoader`", correct: false }
    help: |
      The `YamlFileLoader` is specifically designed to load service definitions from YAML files.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-a-file

  -
    question: >
      What is a "Service Locator" in Symfony, and when might you use it?
    answers:
      - { value: "A service that provides access to a subset of other services, typically used to avoid injecting many optional dependencies.", correct: true }
      - { value: "A service that helps locate files on the filesystem.", correct: false }
      - { value: "A service that tracks the location of users.", correct: false }
      - { value: "A service that provides a list of all available services in the container.", correct: false }
    help: |
      A service locator is a service that knows how to retrieve (locate) other services. It's useful for injecting a collection of optional dependencies without injecting the entire container.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      How can you register a PHP attribute for autoconfiguration in a `ContainerBuilder` to apply definitions (e.g., tags) to services that use this attribute?
    answers:
      - { value: "`$container->registerAttributeForAutoconfiguration(MyAttribute::class, function(ChildDefinition $definition, MyAttribute $attribute, \ReflectionClass|\ReflectionMethod $reflector) { /* ... */ });`", correct: true }
      - { value: "`$container->registerForAutoconfiguration(MyAttribute::class, function(Definition $definition) { /* ... */ });`", correct: false }
      - { value: "`$container->addCompilerPass(new MyAttributeCompilerPass());`", correct: false }
      - { value: "`$container->configureAttribute(MyAttribute::class);`", correct: false }
    help: |
      The `registerAttributeForAutoconfiguration()` method allows you to define a callback that will be executed for any service class, method, or property that uses the specified attribute.
      https://symfony.com/doc/current/service_container/tags.html#autowiring-with-attributes

  -
    question: >
      Which of the following is a built-in service often used for logging messages in Symfony applications?
    answers:
      - { value: "`logger`", correct: true }
      - { value: "`database`", correct: false }
      - { value: "`router`", correct: false }
      - { value: "`cache`", correct: false }
    help: |
      Symfony provides a `logger` service (implementing `Psr\Log\LoggerInterface`) for logging messages.
      https://symfony.com/doc/current/logging.html

  -
    question: |
      What is the correct way to inject a container parameter named `kernel.project_dir` into a service's constructor argument using PHP attributes?
    answers:
      - { value: "`#[Autowire('%kernel.project_dir%')]`", correct: true }
      - { value: "`#[Autowire(param: 'kernel.project_dir')]`", correct: true }
      - { value: "`#[Target('kernel.project_dir')]`", correct: false }
      - { value: "`#[Parameter('kernel.project_dir')]`", correct: false }
    help: |
      The `#[Autowire]` attribute can inject parameters using either the `%param_name%` syntax directly or by specifying the `param` argument.
      https://symfony.com/doc/current/controller.html#autowiring-arguments

  -
    question: >
      When is the `prepend` method of a bundle extension (implementing `PrependExtensionInterface`) called during the container compilation process?
    answers:
      - { value: "Before the `load` method of other bundle extensions.", correct: true }
      - { value: "After all `load` methods have been called.", correct: false }
      - { value: "Only when the container is dumped to a file.", correct: false }
      - { value: "During the request handling phase, not compilation.", correct: false }
    help: |
      The `prepend` method is called early in the compilation process, allowing a bundle to prepend configuration to other extensions before their `load` methods are executed.
      https://symfony.com/doc/current/bundles/prepend_extension.html

  -
    question: |
      Which of the following is a valid way to define a service in YAML configuration?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments: ['@another_service']\n```", correct: true }
      - { value: "```yaml\nservices:\n    my_service:\n        class: App\\Service\\MyService\n        arguments: ['@another_service']\n```", correct: true }
      - { value: "```yaml\nservices:\n    my_service:\n        instance: App\\Service\\MyService\n        dependencies: ['@another_service']\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_service:\n        type: App\\Service\\MyService\n        inject: ['@another_service']\n```", correct: false }
    help: |
      Services can be defined using their FQCN as the ID or a custom ID with the `class` key. `arguments` defines constructor dependencies.
      https://symfony.com/doc/current/service_container/calling_services.html

  -
    question: >
      What is the primary benefit of using `ServiceSubscriberInterface` for a service locator?
    answers:
      - { value: "It explicitly declares the services a class needs, allowing for compile-time validation and better optimization.", correct: true }
      - { value: "It makes all services in the container available to the class.", correct: false }
      - { value: "It automatically registers the class as a public service.", correct: false }
      - { value: "It allows for lazy-loading of all dependencies without any configuration.", correct: false }
    help: |
      `ServiceSubscriberInterface` (via its `getSubscribedServices()` method) explicitly lists the services a class might need, which helps Symfony optimize the container and validate dependencies at compile time.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#service-subscribers

  -
    question: |
      You have a service `App\Service\MyService` with a public property `$logger`. How would you inject the `logger` service into this property using YAML configuration?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        properties:\n            logger: '@logger'\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        calls:\n            - setLogger: ['@logger']\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            $logger: '@logger'\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        inject:\n            logger: '@logger'\n```", correct: false }
    help: |
      The `properties` key in YAML configuration is used to inject services or parameters into public properties of a service.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      Which of the following describes a "synthetic service" in Symfony?
    answers:
      - { value: "A service that is not instantiated by the container but is injected into it at runtime.", correct: true }
      - { value: "A service that is automatically generated by Symfony based on configuration.", correct: false }
      - { value: "A service that is only available in the test environment.", correct: false }
      - { value: "A service that is always shared and never creates new instances.", correct: false }
    help: |
      Synthetic services are services that are not instantiated by the container itself but are injected into the container from outside, typically at runtime.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: |
      How can you register a service using PHP attributes directly on the class, assuming autowiring is enabled?
    answers:
      - { value: "By simply defining the class and ensuring it's located in a directory scanned by autowire.", correct: true }
      - { value: "Using `#[AsService]` attribute.", correct: false }
      - { value: "Using `#[Service]` attribute.", correct: false }
      - { value: "Services are only registered via YAML or XML.", correct: false }
    help: |
      With autowiring enabled, Symfony automatically registers classes as services if they are located in a configured autowire path (e.g., `src/`). No explicit attribute is needed for basic registration.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-services

  -
    question: >
      What is the purpose of the `#[AutowireServiceClosure]` attribute?
    answers:
      - { value: "To automatically create an anonymous function (closure) that returns a service, useful for lazy-loading or non-shared service dependencies.", correct: true }
      - { value: "To define a service as a closure.", correct: false }
      - { value: "To inject a service that is a closure.", correct: false }
      - { value: "To make a service callable.", correct: false }
    help: |
      The `#[AutowireServiceClosure]` attribute is used to inject a service as a closure, allowing for lazy-loading of the service.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      You want to define a custom configuration for your bundle using "semantic configuration". Which interface must your bundle's `Extension` class implement?
    answers:
      - { value: "`ConfigurationInterface`", correct: false }
      - { value: "`ExtensionInterface`", correct: true }
      - { value: "`BundleInterface`", correct: false }
      - { value: "`CompilerPassInterface`", correct: false }
    help: |
      Your bundle's extension class (e.g., `AppExtension`) must implement `ExtensionInterface` and define a `load()` method to process configuration. The `Configuration` class implements `ConfigurationInterface`.
      https://symfony.com/doc/current/bundles/extension.html#loading-the-configuration

  -
    question: >
      Which of the following is a core concept related to the Symfony Dependency Injection Container?
    answers:
      - { value: "Inversion of Control (IoC)", correct: true }
      - { value: "Model-View-Controller (MVC)", correct: false }
      - { value: "Representational State Transfer (REST)", correct: false }
      - { value: "Test-Driven Development (TDD)", correct: false }
    help: |
      Dependency Injection is a specific form of Inversion of Control, where the control of creating and managing dependencies is inverted from the consuming class to a container.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      How can you load service definitions from an XML configuration file into a `ContainerBuilder`?
    answers:
      - { value: "Using `XmlFileLoader`.", correct: true }
      - { value: "Using `YamlFileLoader`.", correct: false }
      - { value: "Using `PhpFileLoader`.", correct: false }
      - { value: "Using `JsonFileLoader`.", correct: false }
    help: |
      The `XmlFileLoader` is used to load service definitions from XML files.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-a-file

  -
    question: >
      What is the default scope for services in the Symfony Dependency Injection Container (i.e., how many instances are created)?
    answers:
      - { value: "Singleton (shared)", correct: true }
      - { value: "Prototype (new instance every time)", correct: false }
      - { value: "Request (new instance per request)", correct: false }
      - { value: "Session (new instance per session)", correct: false }
    help: |
      By default, services in Symfony are "shared" (singleton scope), meaning only one instance of the service is created and reused throughout the application's lifecycle.
      https://symfony.com/doc/current/service_container/scopes.html

  -
    question: |
      You have a service `App\Service\MyService` and you want to inject the result of a Symfony Expression Language expression into one of its arguments. Which attribute would you use?
    answers:
      - { value: "`#[Autowire(expression: 'service("my_other_service").someMethod()')]`", correct: true }
      - { value: "`#[Target(expression: '...')]`", correct: false }
      - { value: "`#[Required(expression: '...')]`", correct: false }
      - { value: "`#[Expression('...')]`", correct: false }
    help: |
      The `#[Autowire(expression: '...')]` attribute allows you to inject the result of a Symfony Expression Language expression.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: >
      What is the purpose of tagging services in Symfony?
    answers:
      - { value: "To allow services to be easily found and collected by other services or compiler passes.", correct: true }
      - { value: "To mark services as public or private.", correct: false }
      - { value: "To define the arguments for a service's constructor.", correct: false }
      - { value: "To specify the class name of a service.", correct: false }
    help: |
      Tags are metadata assigned to services, allowing other services or compiler passes to find and process them, often for collecting services that implement a certain interface or fulfill a specific role.
      https://symfony.com/doc/current/service_container/tags.html

  -
    question: |
      Which built-in service provides access to the current HTTP request?
    answers:
      - { value: "`request_stack`", correct: true }
      - { value: "`http_client`", correct: false }
      - { value: "`router`", correct: false }
      - { value: "`session`", correct: false }
    help: |
      The `request_stack` service (an instance of `Symfony\Component\HttpFoundation\RequestStack`) provides access to the current request and manages a stack of requests.
      https://symfony.com/doc/current/components/http_foundation/requests.html#accessing-the-request

  -
    question: >
      What is the role of the `FileLocator` class when loading service definitions from files (YAML, XML, PHP)?
    answers:
      - { value: "To locate the configuration files within a given set of paths.", correct: true }
      - { value: "To parse the content of the configuration files.", correct: false }
      - { value: "To validate the schema of the configuration files.", correct: false }
      - { value: "To compile the service container.", correct: false }
    help: |
      The `FileLocator` is used by loaders (like `YamlFileLoader`) to find the actual configuration files on the filesystem, given a set of lookup paths.
      https://symfony.com/doc/current/components/config/file_locator.html

  -
    question: |
      Consider the following PHP class:

      ```php
      namespace App\Service;

      use Psr\Log\LoggerInterface;
      use Symfony\Contracts\Service\Attribute\Required;

      class MyService
      {
          private LoggerInterface $logger;

          #[Required]
          public function setLogger(LoggerInterface $logger): void
          {
              $this->logger = $logger;
          }
      }
      ```
      What type of injection is demonstrated here, and what does `#[Required]` ensure?
    answers:
      - { value: "Setter Injection; `#[Required]` ensures the setter is called by autowiring.", correct: true }
      - { value: "Property Injection; `#[Required]` ensures the property is public.", correct: false }
      - { value: "Constructor Injection; `#[Required]` ensures the constructor is called.", correct: false }
      - { value: "Method Call Injection; `#[Required]` ensures the method returns a clone.", correct: false }
    help: |
      This is setter injection. The `#[Required]` attribute tells Symfony's autowiring that this setter method must be called to inject the dependency.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: >
      What is "semantic configuration" in Symfony bundles?
    answers:
      - { value: "A way for bundles to define their own structured configuration schema, which is then processed by the Dependency Injection component.", correct: true }
      - { value: "A configuration format that uses semantic versioning.", correct: false }
      - { value: "A configuration that is automatically generated by the bundle.", correct: false }
      - { value: "A configuration that is only used for logging purposes.", correct: false }
    help: |
      Semantic configuration allows bundles to define a clear and structured configuration schema, which is then validated and processed by the Dependency Injection component, making bundle configuration more robust.
      https://symfony.com/doc/current/bundles/extension.html#loading-the-configuration

  -
    question: |
      How can you prevent a service from being autowired by default in Symfony?
    answers:
      - { value: "Set `autowire: false` for the service definition.", correct: true }
      - { value: "Set `public: false` for the service definition.", correct: false }
      - { value: "Set `shared: false` for the service definition.", correct: false }
      - { value: "Remove all type-hints from the service's constructor.", correct: false }
    help: |
      You can explicitly disable autowiring for a specific service by setting `autowire: false` in its definition.
      https://symfony.com/doc/current/service_container/autowiring.html#disabling-autowiring

  -
    question: >
      Which of the following is a valid way to define a parameter in `config/services.yaml`?
    answers:
      - { value: "```yaml\nparameters:\n    app.mailer.transport: 'sendmail'\n```", correct: true }
      - { value: "```yaml\nparams:\n    app.mailer.transport: 'sendmail'\n```", correct: false }
      - { value: "```yaml\nconfig:\n    app.mailer.transport: 'sendmail'\n```", correct: false }
      - { value: "```yaml\nvariables:\n    app.mailer.transport: 'sendmail'\n```", correct: false }
    help: |
      Parameters are defined under the `parameters` key in YAML configuration files.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: |
      You have a `TwitterClient` service that depends on a `TransformerInterface`. You have two implementations: `Rot13Transformer` and `ShoutyTransformer`. How would you inject the `ShoutyTransformer` specifically into `TwitterClient`'s constructor using PHP attributes?
    answers:
      - { value: "```php\npublic function __construct(\n    #[Target('shoutyTransformer')]\n    private TransformerInterface $transformer,\n) {}\n```", correct: true }
      - { value: "```php\npublic function __construct(\n    #[Autowire(service: 'shoutyTransformer')]\n    private TransformerInterface $transformer,\n) {}\n```", correct: true }
      - { value: "```php\npublic function __construct(\n    #[Required]\n    private TransformerInterface $transformer,\n) {}\n```", correct: false }
      - { value: "```php\npublic function __construct(\n    #[Service('shoutyTransformer')]\n    private TransformerInterface $transformer,\n) {}\n```", correct: false }
    help: |
      Both `#[Target]` and `#[Autowire(service: ...)]` attributes can be used to specify a particular service when multiple services implement the same interface.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services

  -
    question: >
      What is the effect of setting `public: false` for a service definition in Symfony?
    answers:
      - { value: "The service cannot be retrieved directly from the container using `$container->get()`, but can still be injected as a dependency.", correct: true }
      - { value: "The service is completely unavailable and cannot be used anywhere.", correct: false }
      - { value: "The service will be lazy-loaded automatically.", correct: false }
      - { value: "The service will always be a new instance (not shared).", correct: false }
    help: |
      Setting `public: false` makes a service "private". Private services cannot be retrieved directly from the container but can still be injected as dependencies into other services.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: |
      Which of the following is a common use case for a Compiler Pass?
    answers:
      - { value: "Collecting all services tagged with a specific tag and injecting them into another service.", correct: true }
      - { value: "Handling incoming HTTP requests and routing them to controllers.", correct: false }
      - { value: "Rendering HTML templates with dynamic data.", correct: false }
      - { value: "Persisting data to a database.", correct: false }
    help: |
      Compiler passes are frequently used to implement the "tagging" pattern, where services are tagged to be collected and injected into a "collector" service.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html#compiler-passes

  -
    question: >
      What is the primary benefit of using Dependency Injection in a Symfony application?
    answers:
      - { value: "It promotes loose coupling between components, making code more modular, testable, and maintainable.", correct: true }
      - { value: "It significantly reduces the amount of code needed for an application.", correct: false }
      - { value: "It automatically generates all necessary configuration files.", correct: false }
      - { value: "It encrypts sensitive data before storing it.", correct: false }
    help: |
      Dependency Injection is a design pattern that helps achieve loose coupling, making components independent and easier to test and maintain.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      You want to define a service that uses a static factory method `create` from `App\Factory\MyFactory`. How would you configure this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    my_service:\n        factory: [App\\Factory\\MyFactory, create]\n```", correct: true }
      - { value: "```yaml\nservices:\n    my_service:\n        class: App\\Factory\\MyFactory::create\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_service:\n        static_factory: App\\Factory\\MyFactory::create\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_service:\n        method: App\\Factory\\MyFactory::create\n```", correct: false }
    help: |
      The `factory` key can take an array where the first element is the class name and the second is the static method name.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      Which built-in service is responsible for dispatching events in Symfony?
    answers:
      - { value: "`event_dispatcher`", correct: true }
      - { value: "`http_kernel`", correct: false }
      - { value: "`router`", correct: false }
      - { value: "`security.token_storage`", correct: false }
    help: |
      The `event_dispatcher` service (an instance of `Symfony\Component\EventDispatcher\EventDispatcher`) is the central hub for Symfony's event system.
      https://symfony.com/doc/current/components/event_dispatcher.html

  -
    question: |
      How can you inject the `kernel.debug` parameter as a boolean into a custom bundle's `Configuration` class constructor?
    answers:
      - { value: "By type-hinting `bool $debug` in the constructor and configuring the parameter injection in the extension.", correct: true }
      - { value: "By accessing `$_ENV['APP_DEBUG']` directly in the `Configuration` class.", correct: false }
      - { value: "By using `#[Autowire('%kernel.debug%')]` on a property in the `Configuration` class.", correct: false }
      - { value: "The `Configuration` class cannot receive injected parameters.", correct: false }
    help: |
      The `Configuration` class can receive parameters via its constructor, which are then injected by the bundle's extension during compilation.
      https://symfony.com/doc/current/configuration/using_parameters_in_dic.html#injecting-parameters-into-the-configuration-class

  -
    question: >
      What is the effect of setting `shared: false` for a service definition in Symfony?
    answers:
      - { value: "A new instance of the service will be created every time it is requested from the container.", correct: true }
      - { value: "The service will be private and cannot be retrieved directly.", correct: false }
      - { value: "The service will be lazy-loaded.", correct: false }
      - { value: "The service will be automatically autowired.", correct: false }
    help: |
      Setting `shared: false` (or `public: false` in older Symfony versions for non-shared services) means the service is a "prototype" and a new instance is created each time it's requested.
      https://symfony.com/doc/current/service_container/scopes.html#non-shared-services

  -
    question: |
      You want to alias the `profiler` service to `Symfony\Component\HttpKernel\Profiler\Profiler` for autowiring purposes. Which of the following YAML configurations achieves this?
    answers:
      - { value: "```yaml\nservices:\n    Symfony\\Component\\HttpKernel\\Profiler\\Profiler: '@profiler'\n```", correct: true }
      - { value: "```yaml\nservices:\n    profiler:\n        alias: Symfony\\Component\\HttpKernel\\Profiler\\Profiler\n```", correct: false }
      - { value: "```yaml\nservices:\n    Symfony\\Component\\HttpKernel\\Profiler\\Profiler:\n        target: profiler\n```", correct: false }
      - { value: "```yaml\nservices:\n    profiler:\n        class: Symfony\\Component\\HttpKernel\\Profiler\\Profiler\n```", correct: false }
    help: |
      Aliasing a service to a class name allows autowiring to inject that specific service when the class is type-hinted.
      https://symfony.com/doc/current/profiler.html#accessing-the-profiler-programmatically

  -
    question: >
      What is the primary difference between `#[Autowire]` and `#[Target]` attributes?
    answers:
      - { value: "`#[Autowire]` injects specific values (service, param, expression, env), while `#[Target]` resolves autowiring ambiguity for interfaces by specifying a named service.", correct: true }
      - { value: "`#[Autowire]` is for constructor arguments, `#[Target]` is for setter methods.", correct: false }
      - { value: "`#[Autowire]` is for public services, `#[Target]` is for private services.", correct: false }
      - { value: "There is no functional difference; they are aliases for each other.", correct: false }
    help: |
      `#[Autowire]` provides fine-grained control over what is injected (a specific service, parameter, expression, or environment variable). `#[Target]` specifically addresses autowiring ambiguity when multiple services implement the same interface.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      You have a console command `App\Command\CreateUserCommand` and you want to inject `App\Service\UserManager` into its constructor. How would you define this command as a service with dependency injection using PHP attributes?
    answers:
      - { value: "```php\n#[AsCommand(name: 'app:create-user')]\nclass CreateUserCommand\n{\n    public function __construct(\n        private UserManager $userManager\n    ) {}\n}\n```", correct: true }
      - { value: "```php\n#[Command(name: 'app:create-user')]\nclass CreateUserCommand\n{\n    public function __construct(\n        private UserManager $userManager\n    ) {}\n}\n```", correct: false }
      - { value: "```php\n#[Service]\n#[AsCommand(name: 'app:create-user')]\nclass CreateUserCommand\n{\n    public function __construct(\n        private UserManager $userManager\n    ) {}\n}\n```", correct: false }
      - { value: "Console commands cannot use constructor injection.", correct: false }
    help: |
      Symfony console commands can be defined as services using the `#[AsCommand]` attribute, and their dependencies can be injected via constructor autowiring.
      https://symfony.com/doc/current/console/commands_as_services.html

  -
    question: >
      What is the purpose of the `ContainerConfigurator` class in PHP service definitions?
    answers:
      - { value: "It provides a fluent interface for defining services and parameters in PHP configuration files.", correct: true }
      - { value: "It is used to compile the service container.", correct: false }
      - { value: "It is a class that holds all the compiled service definitions.", correct: false }
      - { value: "It is used to load configuration from YAML files.", correct: false }
    help: |
      `ContainerConfigurator` is a helper class that provides a fluent API for defining services, parameters, and aliases in PHP configuration files (e.g., `config/services.php`).
      https://symfony.com/doc/current/service_container/php_config.html

  -
    question: |
      How can you inject a service as an anonymous function (closure) for lazy loading, without explicitly defining a factory, using PHP attributes?
    answers:
      - { value: "By using the `#[AutowireServiceClosure]` attribute on the argument.", correct: true }
      - { value: "By type-hinting `callable` and using `#[Autowire(service: 'my_service')]`.", correct: false }
      - { value: "By setting `lazy: true` in the service definition.", correct: false }
      - { value: "This is not possible with attributes; requires YAML/XML.", correct: false }
    help: |
      The `#[AutowireServiceClosure]` attribute automatically wraps the service in a closure, enabling lazy loading.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: >
      When might you choose to use property injection over constructor or setter injection?
    answers:
      - { value: "When integrating with third-party libraries that expose public properties for configuration and cannot be modified.", correct: true }
      - { value: "When all dependencies are strictly required for the object to function.", correct: false }
      - { value: "When you want to ensure the object is always in a valid state.", correct: false }
      - { value: "When you need to make dependencies optional.", correct: false }
    help: |
      Property injection is generally discouraged due to breaking encapsulation, but it can be useful when dealing with legacy code or third-party libraries that rely on public properties for configuration.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: |
      Which of the following is a correct way to define a parameter in PHP configuration using `ContainerConfigurator`?
    answers:
      - { value: "$container->parameters()->set('app.mailer.transport', 'sendmail');", correct: true }
      - { value: "$container->setParam('app.mailer.transport', 'sendmail');", correct: false }
      - { value: "$container->addParameter('app.mailer.transport', 'sendmail');", correct: false }
      - { value: "$container->parameter('app.mailer.transport', 'sendmail');", correct: false }
    help: |
      The `parameters()` method on `ContainerConfigurator` returns a `ParametersConfigurator` object, which has a `set()` method for defining parameters.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: >
      What is the purpose of the `#[AsAlias]` attribute in Symfony?
    answers:
      - { value: "Defines an alias for a service, allowing it to be referenced by an alternative name.", correct: true }
      - { value: "Marks a service as an abstract alias.", correct: false }
      - { value: "Specifies a service as an alias for a parameter.", correct: false }
      - { value: "Automatically creates an alias for all services in a namespace.", correct: false }
    help: |
      The `#[AsAlias]` attribute can be used to define an alias for a service directly on the class.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      You have a service `App\Service\MyService` that implements `ServiceSubscriberInterface`. How would you define a subscribed service named `my_logger` that injects the `monolog.logger.event` service, using PHP attributes within `getSubscribedServices()`?
    answers:
      - { value: "```php\nnew SubscribedService('my_logger', LoggerInterface::class, attributes: new Autowire(service: 'monolog.logger.event'))\n```", correct: true }
      - { value: "```php\n'my_logger' => new Autowire(service: 'monolog.logger.event')\n```", correct: false }
      - { value: "```php\nnew SubscribedService('my_logger', 'monolog.logger.event')\n```", correct: false }
      - { value: "```php\n'my_logger' => LoggerInterface::class\n```", correct: false }
    help: |
      When using `ServiceSubscriberInterface`, you return an array of `SubscribedService` objects. The `attributes` parameter of `SubscribedService` allows you to apply `#[Autowire]` or other DI attributes.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#using-dependency-injection-attributes-in-getsubscribedservices

  -
    question: >
      What is the main advantage of using immutable setter (wither) injection over traditional setter injection?
    answers:
      - { value: "It promotes immutability by returning a new instance of the object with the dependency set, preserving the original object's state.", correct: true }
      - { value: "It is faster to execute than traditional setter injection.", correct: false }
      - { value: "It makes the dependency optional by default.", correct: false }
      - { value: "It allows for circular dependencies.", correct: false }
    help: |
      Immutable setter injection (wither methods) ensures that the original object remains unchanged, and a new object with the injected dependency is returned, which is beneficial for maintaining object integrity.
      https://symfony.com/doc/current/service_container/injection_types.html#immutable-setter-injection

  -
    question: |
      Which built-in service provides access to the kernel's project directory?
    answers:
      - { value: "`kernel.project_dir` (as a parameter)", correct: true }
      - { value: "`kernel.root_dir`", correct: false }
      - { value: "`kernel.cache_dir`", correct: false }
      - { value: "`kernel.logs_dir`", correct: false }
    help: |
      `kernel.project_dir` is a built-in parameter that holds the absolute path to the project's root directory.
      https://symfony.com/doc/current/configuration.html#built-in-parameters

  -
    question: |
      You are decorating a service named `app.original_mailer` with `App\Service\DecoratingMailer`. How would you reference the original service inside `DecoratingMailer`'s constructor in YAML?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\DecoratingMailer:\n        decorates: app.original_mailer\n        arguments: ['@.inner']\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\DecoratingMailer:\n        decorates: app.original_mailer\n        arguments: ['@app.original_mailer']\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\DecoratingMailer:\n        decorates: app.original_mailer\n        arguments: ['@decorated']\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\DecoratingMailer:\n        decorates: app.original_mailer\n        arguments: ['@parent']\n```", correct: false }
    help: |
      When decorating a service, the special `_inner` service ID (or `_inner` alias) refers to the original, undecorated service.
      https://symfony.com/doc/current/service_container/service_decoration.html

  -
    question: >
      What is the primary role of the `ContainerBuilder::registerForAutoconfiguration()` method?
    answers:
      - { value: "To register an interface or class for autoconfiguration, allowing automatic tagging or other definitions for services implementing/extending it.", correct: true }
      - { value: "To register a new service definition with a specific ID.", correct: false }
      - { value: "To register a compiler pass.", correct: false }
      - { value: "To register a new parameter.", correct: false }
    help: |
      `registerForAutoconfiguration()` is used in compiler passes or extensions to apply configuration (like tags) to services that implement a certain interface or extend a base class.
      https://symfony.com/doc/current/service_container/tags.html#autowiring-with-attributes

  -
    question: |
      You have a service that needs to access a collection of services that are not necessarily related by a common interface, but you want to lazy-load them. Which feature would be most appropriate?
    answers:
      - { value: "Service Locator", correct: true }
      - { value: "Service Decoration", correct: false }
      - { value: "Compiler Pass", correct: false }
      - { value: "AutowiringIterator", correct: false }
    help: |
      A Service Locator is ideal for situations where you need access to a collection of services that are not necessarily related by a common interface, and you want to lazy-load them to avoid unnecessary instantiation.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      Which of the following is the correct way to load service definitions from a PHP configuration file (`services.php`) into a `ContainerBuilder`?
    answers:
      - { value: "```php\n$loader = new PhpFileLoader($container, new FileLocator(__DIR__));\n$loader->load('services.php');\n```", correct: true }
      - { value: "```php\n$loader = new YamlFileLoader($container, new FileLocator(__DIR__));\n$loader->load('services.php');\n```", correct: false }
      - { value: "```php\n$container->load('services.php');\n```", correct: false }
      - { value: "```php\nrequire 'services.php';\n```", correct: false }
    help: |
      The `PhpFileLoader` is specifically designed to load service definitions from PHP files.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-configuration-from-a-file

  -
    question: >
      What is the purpose of the `#[Autowire]` attribute's `param` option?
    answers:
      - { value: "To inject a container parameter by its name.", correct: true }
      - { value: "To define a new parameter in the container.", correct: false }
      - { value: "To inject a service whose ID matches the parameter name.", correct: false }
      - { value: "To specify a default value for a parameter.", correct: false }
    help: |
      The `param` option within the `#[Autowire]` attribute allows you to explicitly inject a container parameter by its name.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      What happens if you try to retrieve a private service directly from the container using `$container->get('private_service_id')`?
    answers:
      - { value: "An exception will be thrown, indicating the service is private.", correct: true }
      - { value: "The service will be returned, but a deprecation warning will be issued.", correct: false }
      - { value: "A new instance of the service will be created and returned.", correct: false }
      - { value: "The container will attempt to autowire the service.", correct: false }
    help: |
      Private services are not accessible directly via `$container->get()`. Attempting to do so will result in an exception.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: >
      Which built-in service provides access to the current environment (e.g., 'dev', 'prod')?
    answers:
      - { value: "`kernel.environment` (as a parameter)", correct: true }
      - { value: "`kernel.debug`", correct: false }
      - { value: "`kernel.name`", correct: false }
      - { value: "`kernel.container_class`", correct: false }
    help: |
      The `kernel.environment` parameter holds the current environment string.
      https://symfony.com/doc/current/configuration.html#built-in-parameters

  -
    question: |
      You are defining a service in YAML and want to inject a parameter named `app.api_key`. What is the correct syntax?
    answers:
      - { value: "`arguments: ['%app.api_key%']`", correct: true }
      - { value: "`arguments: ['@app.api_key']`", correct: false }
      - { value: "`arguments: ['param:app.api_key']`", correct: false }
      - { value: "`arguments: ['env:APP_API_KEY']`", correct: false }
    help: |
      Parameters are injected using the `%parameter_name%` syntax in YAML.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: >
      What is the primary characteristic of a "shared" service in Symfony's Dependency Injection Container?
    answers:
      - { value: "Only one instance of the service is created and reused throughout the application's lifecycle.", correct: true }
      - { value: "The service is accessible from anywhere in the application.", correct: false }
      - { value: "The service is automatically autowired.", correct: false }
      - { value: "The service can be decorated by other services.", correct: false }
    help: |
      Shared services are singletons within the container; only one instance is ever created and reused.
      https://symfony.com/doc/current/service_container/scopes.html

  -
    question: |
      Which of the following is a valid way to define a service in PHP configuration using `ContainerConfigurator`?
    answers:
      - { value: "$services->set('my_service_id', App\\Service\\MyService::class);", correct: true }
      - { value: "$services->set(App\\Service\\MyService::class);", correct: true }
      - { value: "$services->add('my_service_id', App\\Service\\MyService::class);", correct: false }
      - { value: "$services->register('my_service_id', App\\Service\\MyService::class);", correct: false }
    help: |
      The `set()` method on the `ServicesConfigurator` is used to define a service. You can provide an ID and a class, or just the class for autowiring.
      https://symfony.com/doc/current/service_container/php_config.html

  -
    question: >
      What is the main purpose of the `#[Autoconfigure]` attribute?
    answers:
      - { value: "To define autoconfiguration rules directly on classes, such as adding tags or aliases.", correct: true }
      - { value: "To enable autowiring for a specific class.", correct: false }
      - { value: "To automatically generate a service definition for a class.", correct: false }
      - { value: "To mark a class as a service.", correct: false }
    help: |
      The `#[Autoconfigure]` attribute allows you to define autoconfiguration rules (e.g., adding tags, setting arguments) directly on a class.
      https://symfony.com/doc/current/service_container/tags.html#autowiring-with-attributes

  -
    question: |
      You want to make a service `App\Service\MyOptionalService` optional for injection into `App\Service\MainService`'s constructor. How would you configure this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MainService:\n        arguments:\n            $optionalService: '@App\\Service\\MyOptionalService?'\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MainService:\n        arguments:\n            $optionalService: '@?App\\Service\\MyOptionalService'\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MainService:\n        arguments:\n            $optionalService: '@App\\Service\\MyOptionalService(optional: true)'\n```", correct: false }
      - { value: "Optional services are only supported via PHP attributes.", correct: false }
    help: |
      Adding a `?` suffix to a service ID in YAML marks it as optional. If the service does not exist, `null` will be injected.
      https://symfony.com/doc/current/service_container/optional_dependencies.html

  -
    question: >
      Which built-in service provides access to the application's routing capabilities?
    answers:
      - { value: "`router`", correct: true }
      - { value: "`url_generator`", correct: true }
      - { value: "`matcher`", correct: true }
      - { value: "`request_context`", correct: false }
    help: |
      The `router` service (or `url_generator` and `matcher` which are often aliases or components of the router) provides functionalities like URL generation and matching.
      https://symfony.com/doc/current/routing.html

  -
    question: |
      What is the purpose of the `ContainerBuilder::compile()` method?
    answers:
      - { value: "To optimize the service container definition for performance and create an immutable container.", correct: true }
      - { value: "To compile PHP code into bytecode.", correct: false }
      - { value: "To generate a cache file for the container.", correct: false }
      - { value: "To execute all services in the container.", correct: false }
    help: |
      The `compile()` method processes all service definitions, applies compiler passes, and optimizes the container into an immutable, highly performant version.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: |
      You want to inject a service `App\Service\MyService` into a controller method argument, but you want to ensure it's always a *new* instance, even if the service is configured as shared. How can you achieve this with attributes?
    answers:
      - { value: "This is not directly achievable with attributes for a shared service; you would typically configure the service itself as non-shared.", correct: true }
      - { value: "Use `#[Autowire(shared: false)]`.", correct: false }
      - { value: "Use `#[Target(new: true)]`.", correct: false }
      - { value: "Use `#[Required(new: true)]`.", correct: false }
    help: |
      The shared/non-shared behavior is defined at the service definition level. Attributes primarily control *which* service or value is injected, not its shared status. To get a new instance, the service itself must be configured as `shared: false`.
      https://symfony.com/doc/current/service_container/scopes.html#non-shared-services

  -
    question: >
      Which of the following is a key advantage of using PHP configuration files for services over YAML or XML?
    answers:
      - { value: "It allows for more complex logic and dynamic service definitions, leveraging the full power of PHP.", correct: true }
      - { value: "It is generally faster to parse than YAML or XML.", correct: false }
      - { value: "It provides better syntax highlighting in most IDEs.", correct: false }
      - { value: "It is the only format that supports autowiring.", correct: false }
    help: |
      PHP configuration files offer the most flexibility, allowing you to use PHP's full expressive power for dynamic service definitions, conditional logic, and more complex scenarios.
      https://symfony.com/doc/current/service_container/php_config.html

  -
    question: |
      What is the default behavior for service IDs when autowiring is enabled and you define a service using its FQCN (Fully Qualified Class Name)?
    answers:
      - { value: "The FQCN itself becomes the service ID.", correct: true }
      - { value: "A camelCase version of the FQCN is used as the ID.", correct: false }
      - { value: "A random UUID is generated as the service ID.", correct: false }
      - { value: "The service is not assigned an ID by default.", correct: false }
    help: |
      When autowiring is enabled and you define a service by its FQCN (e.g., `App\Service\MyService:` in YAML), the FQCN itself is used as the service ID.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-services

  -
    question: >
      What is the purpose of the `#[Autowire(env: 'VAR_NAME')]` attribute?
    answers:
      - { value: "To inject the value of an environment variable.", correct: true }
      - { value: "To set an environment variable for the service.", correct: false }
      - { value: "To define a service that depends on an environment variable.", correct: false }
      - { value: "To make a service available only in a specific environment.", correct: false }
    help: |
      The `env` option in the `#[Autowire]` attribute allows you to inject environment variable values directly into arguments or properties.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      You want to define a service `App\Service\MyService` with an argument that is a service, but you want to ensure that if the service is not found, `null` is injected instead of throwing an error. How would you do this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - '@App\\Service\\OptionalDependency?'\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - '@?App\\Service\\OptionalDependency'\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - !optional '@App\\Service\\OptionalDependency'\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - '@App\\Service\\OptionalDependency(nullable: true)'\n```", correct: false }
    help: |
      Appending a `?` to a service reference in YAML makes it optional. If the service doesn't exist, `null` is injected.
      https://symfony.com/doc/current/service_container/optional_dependencies.html

  -
    question: >
      Which built-in service provides access to the current application kernel instance?
    answers:
      - { value: "`kernel`", correct: true }
      - { value: "`container`", correct: false }
      - { value: "`app`", correct: false }
      - { value: "`http_kernel`", correct: false }
    help: |
      The `kernel` service (an instance of `Symfony\Component\HttpKernel\KernelInterface`) represents the application's kernel.
      https://symfony.com/doc/current/reference/dic_tags.html#kernel-tags

  -
    question: |
      What is the purpose of the `#[Autowire(expression: '...')]` attribute?
    answers:
      - { value: "To inject the result of a Symfony Expression Language expression.", correct: true }
      - { value: "To define a new expression in the container.", correct: false }
      - { value: "To inject a service that is an expression.", correct: false }
      - { value: "To evaluate a PHP expression at runtime.", correct: false }
    help: |
      The `expression` option in the `#[Autowire]` attribute allows you to inject values derived from Symfony Expression Language expressions.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      You have a service `App\Service\MyService` and you want to inject a specific parameter named `app.max_items` into its constructor. How would you do this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments: ['%app.max_items%']\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            $maxItems: '%app.max_items%'\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - param('app.max_items')\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - 'app.max_items'\n```", correct: false }
    help: |
      Parameters are referenced using the `%parameter_name%` syntax in YAML. You can either list them directly or use named arguments.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: >
      What is the benefit of using `#[Required]` attribute on a setter method compared to simply type-hinting in the constructor for a mandatory dependency?
    answers:
      - { value: "It allows for optional dependencies to be marked as mandatory for autowiring, providing flexibility for dependencies that might not always be needed at construction.", correct: true }
      - { value: "It makes the service lazy-loaded.", correct: false }
      - { value: "It ensures the service is always public.", correct: false }
      - { value: "It prevents circular dependencies.", correct: false }
    help: |
      `#[Required]` on a setter allows a dependency to be optional for the object's initial construction but still mandatory for autowiring, which can help break circular dependencies or manage optional but autowired dependencies.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: |
      Which of the following is a valid way to define a service with a custom ID in YAML?
    answers:
      - { value: "```yaml\nservices:\n    my_custom_service_id:\n        class: App\\Service\\MyService\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        id: my_custom_service_id\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_custom_service_id:\n        type: App\\Service\\MyService\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_custom_service_id:\n        instance: App\\Service\\MyService\n```", correct: false }
    help: |
      In YAML, you define a service with a custom ID by using the ID as the key under `services:` and then specifying the `class` for that ID.
      https://symfony.com/doc/current/service_container/calling_services.html

  -
    question: >
      What is the primary difference between a "service" and a "parameter" in the Dependency Injection Container?
    answers:
      - { value: "A service is an object instance, while a parameter is a simple scalar value or array.", correct: true }
      - { value: "Services are always public, parameters are always private.", correct: false }
      - { value: "Services are configured in YAML, parameters in XML.", correct: false }
      - { value: "Services are always lazy-loaded, parameters are not.", correct: false }
    help: |
      Services are objects managed by the container, while parameters are simple configuration values.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      You want to make a service `App\Service\MyService` lazy-loaded. How would you configure this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        lazy: true\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        shared: false\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        autowire: lazy\n```", correct: false }
      - { value: "Lazy loading is automatic for all services.", correct: false }
    help: |
      The `lazy: true` option in a service definition configures the service to be lazy-loaded, meaning it's only instantiated when it's actually needed.
      https://symfony.com/doc/current/service_container/lazy_services.html

  -
    question: >
      What is the purpose of the `#[Autowire]` attribute's `service` option?
    answers:
      - { value: "To explicitly inject a service by its ID, bypassing autowiring's default behavior.", correct: true }
      - { value: "To define a new service in the container.", correct: false }
      - { value: "To make a service public.", correct: false }
      - { value: "To automatically generate a service ID.", correct: false }
    help: |
      The `service` option in the `#[Autowire]` attribute allows you to specify the exact service ID to inject, providing explicit control over dependency resolution.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      When using `ContainerConfigurator` in PHP, how do you reference a service named `my_mailer` as an argument?
    answers:
      - { value: "`service('my_mailer')`", correct: true }
      - { value: "`param('my_mailer')`", correct: false }
      - { value: "`@my_mailer`", correct: false }
      - { value: "`new Reference('my_mailer')`", correct: false }
    help: |
      The `service()` helper function is used to create a service reference in PHP configuration files.
      https://symfony.com/doc/current/service_container/php_config.html#referencing-services

  -
    question: >
      What is the primary benefit of using autowiring in Symfony?
    answers:
      - { value: "It reduces the amount of explicit configuration needed for services, making the setup faster and cleaner.", correct: true }
      - { value: "It eliminates the need for any service configuration files.", correct: false }
      - { value: "It automatically resolves all circular dependencies.", correct: false }
      - { value: "It makes all services public by default.", correct: false }
    help: |
      Autowiring significantly reduces the need for explicit service configuration by automatically injecting dependencies based on type-hints.
      https://symfony.com/doc/current/service_container/autowiring.html

  -
    question: |
      You need to define a service that uses a non-static factory method `create` on an *existing service* named `app.factory_service`. How would you configure this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    my_service:\n        factory: ['@app.factory_service', 'create']\n```", correct: true }
      - { value: "```yaml\nservices:\n    my_service:\n        factory:\n            service: app.factory_service\n            method: create\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_service:\n        call: ['@app.factory_service', 'create']\n```", correct: false }
      - { value: "```yaml\nservices:\n    my_service:\n        class: App\\Service\\MyService\n        factory_method: create\n        factory_service: app.factory_service\n```", correct: false }
    help: |
      The `factory` key can specify an existing service and its method to be used as a factory.
      https://symfony.com/doc/current/service_container/factories.html#referencing-an-existing-service

  -
    question: >
      What is the purpose of the `AbstractBundle::prependExtension()` method (available from Symfony 7.1)?
    answers:
      - { value: "It allows a bundle to prepend configuration to other extensions during the container compilation, using `ContainerConfigurator`.", correct: true }
      - { value: "It loads the bundle's main configuration into the container.", correct: false }
      - { value: "It registers compiler passes for the bundle.", correct: false }
      - { value: "It defines the bundle's default parameters.", correct: false }
    help: |
      The `prependExtension()` method (part of `PrependExtensionInterface` and available on `AbstractBundle` from Symfony 7.1) allows a bundle to add configuration that will be processed before other extensions' `load` methods.
      https://symfony.com/doc/current/bundles/prepend_extension.html#using-the-prependextension-method

  -
    question: |
      Which of the following is a built-in service that provides access to the application's HTTP client for making external requests?
    answers:
      - { value: "`http_client`", correct: true }
      - { value: "`guzzle_client`", correct: false }
      - { value: "`curl_client`", correct: false }
      - { value: "`request_client`", correct: false }
    help: |
      Symfony provides a built-in `http_client` service (an instance of `Symfony\Contracts\HttpClient\HttpClientInterface`) for making HTTP requests.
      https://symfony.com/doc/current/http_client.html

  -
    question: |
      You have a service `App\Service\MyService` that needs to inject a `LoggerInterface`. If you have multiple logger services defined (e.g., `monolog.logger.app`, `monolog.logger.security`), and you want to inject the default one without specifying its ID, what is the best approach for autowiring?
    answers:
      - { value: "Ensure the default logger is aliased to `Psr\Log\LoggerInterface` or the specific logger service you want is the primary one for that interface.", correct: true }
      - { value: "Use `#[Autowire(service: 'default_logger')]`.", correct: false }
      - { value: "Use `#[Target('default')]`.", correct: false }
      - { value: "Symfony will automatically pick the first logger it finds.", correct: false }
    help: |
      For autowiring to work correctly with interfaces that have multiple implementations, Symfony needs a clear default. This is often achieved by aliasing one implementation to the interface or by explicitly configuring a primary service for that interface.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-interfaces

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Attribute\AsAlias` attribute?
    answers:
      - { value: "To define an alias for a service directly on its class.", correct: true }
      - { value: "To mark a service as an abstract alias.", correct: false }
      - { value: "To specify a service as an alias for a parameter.", correct: false }
      - { value: "To automatically create an alias for all services in a namespace.", correct: false }
    help: |
      The `#[AsAlias]` attribute allows you to define an alias for a service directly on the class definition.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      When creating a custom bundle, which method in your bundle's `Extension` class is responsible for loading the bundle's configuration into the `ContainerBuilder`?
    answers:
      - { value: "`load(array $configs, ContainerBuilder $container)`", correct: true }
      - { value: "`build(ContainerBuilder $container)`", correct: false }
      - { value: "`configure(ContainerBuilder $container)`", correct: false }
      - { value: "`register(ContainerBuilder $container)`", correct: false }
    help: |
      The `load()` method of your bundle's extension class is where you define and load your bundle's services and parameters into the container.
      https://symfony.com/doc/current/bundles/extension.html#loading-the-configuration

  -
    question: >
      What does it mean for a service to be "private" in Symfony's Dependency Injection Container?
    answers:
      - { value: "It cannot be retrieved directly from the container using `$container->get()`, but can still be injected as a dependency into other services.", correct: true }
      - { value: "It is only available in the `dev` environment.", correct: false }
      - { value: "It is not subject to autowiring.", correct: false }
      - { value: "It is automatically lazy-loaded.", correct: false }
    help: |
      Private services (configured with `public: false`) can only be injected as dependencies into other services and cannot be fetched directly from the container.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: |
      You are using `ServiceSubscriberInterface` and want to inject a specific logger channel, `monolog.logger.event`, into a property named `logger`. How would you define this in `getSubscribedServices()` using attributes?
    answers:
      - { value: "```php\nnew SubscribedService('logger', LoggerInterface::class, attributes: new Autowire(service: 'monolog.logger.event'))\n```", correct: true }
      - { value: "```php\n'logger' => new Autowire(service: 'monolog.logger.event')\n```", correct: false }
      - { value: "```php\n'logger' => LoggerInterface::class\n```", correct: false }
      - { value: "```php\nnew SubscribedService('logger', 'monolog.logger.event')\n```", correct: false }
    help: |
      The `SubscribedService` object allows specifying the service ID, type, and additional attributes like `#[Autowire]` for fine-grained control over injection.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#using-dependency-injection-attributes-in-getsubscribedservices

  -
    question: >
      What is the primary role of the `Symfony\Component\DependencyInjection\Container` interface?
    answers:
      - { value: "It defines the public API for interacting with the compiled service container at runtime.", correct: true }
      - { value: "It is used to build and compile the service container.", correct: false }
      - { value: "It provides methods for defining service definitions.", correct: false }
      - { value: "It is responsible for loading configuration files.", correct: false }
    help: |
      The `Container` interface (implemented by the compiled container) provides methods like `get()`, `has()`, and `getParameter()` for interacting with services and parameters at runtime.
      https://symfony.com/doc/current/components/dependency_injection.html

  -
    question: |
      You have a service `App\Service\MyService` that needs to receive an argument that is the result of a complex calculation or dynamic value. Which method of injection would be most suitable if you want to define this logic directly in the service definition?
    answers:
      - { value: "Factory method injection", correct: true }
      - { value: "Constructor injection with a simple service reference", correct: false }
      - { value: "Setter injection with a parameter", correct: false }
      - { value: "Property injection", correct: false }
    help: |
      Factory methods allow you to define a callable that is responsible for creating the service instance, enabling complex logic to determine the service's arguments or even the service itself.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Reference` class when defining services programmatically?
    answers:
      - { value: "To explicitly indicate that an argument is a reference to another service in the container.", correct: true }
      - { value: "To define a new service with a specific ID.", correct: false }
      - { value: "To create a new instance of a service.", correct: false }
      - { value: "To mark a service as optional.", correct: false }
    help: |
      The `Reference` class is used when programmatically defining service arguments to specify that an argument should be another service from the container, rather than a literal value.
      https://symfony.com/doc/current/components/dependency_injection.html#referencing-services

  -
    question: |
      Which of the following is a valid way to define a parameter in XML configuration?
    answers:
      - { value: "```xml\n<parameters>\n    <parameter key=\"app.mailer.transport\">sendmail</parameter>\n</parameters>\n```", correct: true }
      - { value: "```xml\n<params>\n    <param name=\"app.mailer.transport\" value=\"sendmail\"/>\n</params>\n```", correct: false }
      - { value: "```xml\n<config>\n    <setting name=\"app.mailer.transport\">sendmail</setting>\n</config>\n```", correct: false }
      - { value: "```xml\n<variables>\n    <variable name=\"app.mailer.transport\">sendmail</variable>\n</variables>\n```", correct: false }
    help: |
      Parameters are defined within the `<parameters>` section using `<parameter>` tags with a `key` attribute and content for the value.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Attribute\Autowire` attribute?
    answers:
      - { value: "To explicitly wire a constructor argument or property with a specific value, bypassing standard autowiring.", correct: true }
      - { value: "To enable autowiring for a class.", correct: false }
      - { value: "To define a service as an autowired service.", correct: false }
      - { value: "To automatically generate a service definition.", correct: false }
    help: |
      The `#[Autowire]` attribute provides fine-grained control over what is injected, allowing you to specify a service ID, parameter, expression, or environment variable.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-attribute

  -
    question: |
      You have a service `App\Service\MyService` that needs to inject the `router` service. How would you configure this in XML?
    answers:
      - { value: "```xml\n<service id=\"App\\Service\\MyService\">\n    <argument type=\"service\" id=\"router\"/>\n</service>\n```", correct: true }
      - { value: "```xml\n<service id=\"App\\Service\\MyService\">\n    <argument service=\"router\"/>\n</service>\n```", correct: true }
      - { value: "```xml\n<service id=\"App\\Service\\MyService\">\n    <argument ref=\"router\"/>\n</service>\n```", correct: false }
      - { value: "```xml\n<service id=\"App\\Service\\MyService\">\n    <argument value=\"@router\"/>\n</service>\n```", correct: false }
    help: |
      In XML, service arguments are defined using `<argument>` tags. To reference another service, use `type="service"` and `id="service_id"`.
      https://symfony.com/doc/current/components/dependency_injection.html#referencing-services

  -
    question: >
      What is the primary function of the `Symfony\Component\HttpKernel\KernelInterface` in relation to the Dependency Injection Container?
    answers:
      - { value: "It is responsible for building and compiling the service container during the boot process.", correct: true }
      - { value: "It provides all services directly without the need for a container.", correct: false }
      - { value: "It only handles routing and HTTP requests.", correct: false }
      - { value: "It manages database connections.", correct: false }
    help: |
      The Kernel is responsible for bootstrapping the Symfony application, which includes building and compiling the Dependency Injection Container.
      https://symfony.com/doc/current/components/http_kernel.html

  -
    question: |
      You want to define a service `App\Service\MyService` and inject a literal string value, "Hello World", into its constructor. How would you do this in YAML?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments: ['Hello World']\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - \"Hello World\"\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            $message: 'Hello World'\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - literal: 'Hello World'\n```", correct: false }
    help: |
      Literal string values are simply enclosed in quotes (single or double) in YAML arguments. Named arguments are also supported.
      https://symfony.com/doc/current/service_container/calling_services.html

  -
    question: >
      Which of the following is a common reason to use a Service Locator instead of directly injecting all dependencies?
    answers:
      - { value: "To avoid injecting a large number of optional dependencies into a constructor, which can lead to 'constructor-hell'.", correct: true }
      - { value: "To make all services public.", correct: false }
      - { value: "To force all dependencies to be lazy-loaded.", correct: false }
      - { value: "To prevent any services from being shared.", correct: false }
    help: |
      Service locators are often used to manage a collection of optional dependencies, preventing constructors from becoming overly long when many dependencies are not always needed.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      What is the purpose of the `Symfony\Component\DependencyInjection\Loader\Configurator\service()` helper function in PHP service definitions?
    answers:
      - { value: "To create a reference to another service in the container.", correct: true }
      - { value: "To define a new service.", correct: false }
      - { value: "To retrieve a service from the container at runtime.", correct: false }
      - { value: "To define a parameter.", correct: false }
    help: |
      The `service()` helper function is a concise way to create a service reference when defining services in PHP configuration files.
      https://symfony.com/doc/current/service_container/php_config.html#referencing-services

  -
    question: >
      What is the main difference between "constructor injection" and "setter injection"?
    answers:
      - { value: "Constructor injection provides mandatory dependencies at object creation, while setter injection provides optional dependencies after creation.", correct: true }
      - { value: "Constructor injection is for private services, setter injection is for public services.", correct: false }
      - { value: "Constructor injection is faster, setter injection is slower.", correct: false }
      - { value: "Constructor injection uses attributes, setter injection uses YAML.", correct: false }
    help: |
      Constructor injection ensures dependencies are present from the start, making them mandatory. Setter injection is typically used for optional dependencies that can be set after object instantiation.
      https://symfony.com/doc/current/service_container/injection_types.html

  -
    question: |
      You want to define a service `App\Service\MyService` in YAML and inject a parameter named `app.debug_mode` into its constructor. How would you configure this?
    answers:
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments: ['%app.debug_mode%']\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - \"@app.debug_mode\"\n```", correct: false }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            debugMode: '%app.debug_mode%'\n```", correct: true }
      - { value: "```yaml\nservices:\n    App\\Service\\MyService:\n        arguments:\n            - param('app.debug_mode')\n```", correct: false }
    help: |
      Parameters are injected using the `%parameter_name%` syntax in YAML. Both positional and named arguments are supported.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Attribute\Target` attribute?
    answers:
      - { value: "To specify a named service to be injected when multiple services implement the same interface, resolving autowiring ambiguity.", correct: true }
      - { value: "To target a specific method for injection.", correct: false }
      - { value: "To define a service as a target for other services.", correct: false }
      - { value: "To mark a service as a target for decoration.", correct: false }
    help: |
      The `#[Target]` attribute is used to resolve autowiring ambiguity by explicitly naming the service to be injected when multiple services implement the same interface.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services

  -
    question: |
      Which of the following describes a "lazy" service in Symfony's Dependency Injection Container?
    answers:
      - { value: "A service that is only instantiated when it is actually needed, rather than at container compilation or initial request.", correct: true }
      - { value: "A service that is always shared.", correct: false }
      - { value: "A service that is automatically autowired.", correct: false }
      - { value: "A service that is only available in the test environment.", correct: false }
    help: |
      Lazy services are not instantiated until they are actually retrieved or injected, which can improve application startup performance.
      https://symfony.com/doc/current/service_container/lazy_services.html

  -
    question: |
      You want to register a custom event listener `App\EventListener\MyListener` as a service and add it as a subscriber to the `event_dispatcher` service. How would you do this programmatically in PHP?
    answers:
      - { value: "```php\n$container->register('app.my_listener', App\\EventListener\\MyListener::class);\n$container->getDefinition('event_dispatcher')->addMethodCall('addSubscriber', [new Reference('app.my_listener')]);\n```", correct: true }
      - { value: "```php\n$container->set('app.my_listener', new App\\EventListener\\MyListener());\n$container->get('event_dispatcher')->addSubscriber($container->get('app.my_listener'));\n```", correct: false }
      - { value: "```php\n$container->register('app.my_listener', App\\EventListener\\MyListener::class)->addTag('kernel.event_subscriber');\n```", correct: true }
      - { value: "```php\n$container->getDefinition('event_dispatcher')->addArgument(new Reference('app.my_listener'));\n```", correct: false }
    help: |
      You can either explicitly add the subscriber via `addMethodCall` on the dispatcher's definition, or more commonly, tag the listener service with `kernel.event_subscriber` for automatic registration.
      https://symfony.com/doc/current/event_dispatcher.html#registering-event-subscribers

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Attribute\Required` attribute?
    answers:
      - { value: "To mark a setter method or public property as mandatory for autowiring, ensuring the dependency is provided.", correct: true }
      - { value: "To define a service as a required dependency for another service.", correct: false }
      - { value: "To indicate that a service must be lazy-loaded.", correct: false }
      - { value: "To force a service to be public.", correct: false }
    help: |
      The `#[Required]` attribute ensures that a setter or public property dependency is satisfied via autowiring.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required