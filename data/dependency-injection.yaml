category: Dependency Injection

questions:
  -
    question: >
      What is the primary purpose of the Symfony Service Container?
    answers:
      - { value: "To manage the lifecycle of objects (services) and inject their dependencies.", correct: true }
      - { value: "To handle HTTP requests and responses.", correct: false }
      - { value: "To store application configuration parameters only.", correct: false }
      - { value: "To provide a global registry for all PHP classes.", correct: false }
    help: |
      The Symfony Service Container is a tool that manages the instantiation and injection of dependencies for your application's services, promoting loose coupling and testability.
      https://symfony.com/doc/current/service_container.html

  -
    question: |
      Given the following PHP code, how would you retrieve the `mailer` service from the `$container` instance?

      ```php
      use Symfony\Component\DependencyInjection\ContainerBuilder;

      $container = new ContainerBuilder();
      // ... service definitions ...
      ```
    answers:
      - { value: "`$container->get('mailer');`", correct: true }
      - { value: "`$container->find('mailer');`", correct: false }
      - { value: "`$container->load('mailer');`", correct: false }
      - { value: "`$container->resolve('mailer');`", correct: false }
    help: |
      The `get()` method of the `ContainerBuilder` (or the compiled container) is used to retrieve a service by its ID.
      https://symfony.com/doc/current/components/dependency_injection.html#retrieving-services

  -
    question: >
      Which of the following best describes a "private" service in Symfony's Dependency Injection Container?
    answers:
      - { value: "A service that cannot be retrieved directly using `$container->get()` but can be injected into other services.", correct: true }
      - { value: "A service that is only available in the `dev` environment.", correct: false }
      - { value: "A service whose class is marked as `private` in PHP.", correct: false }
      - { value: "A service that is automatically removed during compilation.", correct: false }
    help: |
      Private services cannot be retrieved directly from the container using `get()`, but they can be injected into other services. This helps prevent direct access to internal services.
      https://symfony.com/doc/current/service_container/alias_private.html

  -
    question: >
      What is a "synthetic" service in Symfony's Dependency Injection Container?
    answers:
      - { value: "A service that is not instantiated by the container but is injected into it at runtime.", correct: true }
      - { value: "A service that is generated automatically by a compiler pass.", correct: false }
      - { value: "A service that is only used for testing purposes.", correct: false }
      - { value: "A service that is always shared and never creates new instances.", correct: false }
    help: |
      A synthetic service is one that is not created by the container itself but is injected into the container at runtime using `Container::set()`.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: >
      Which of the following interfaces is commonly type-hinted for injecting a logger service in Symfony?
    answers:
      - { value: "`Psr\\Log\\LoggerInterface`", correct: true }
      - { value: "`Symfony\\Component\\HttpKernel\\Log\\Logger`", correct: false }
      - { value: "`Monolog\\Logger`", correct: false }
      - { value: "`Psr\\Container\\ContainerInterface`", correct: false }
    help: |
      Symfony encourages type-hinting against PSR interfaces, such as `Psr\\Log\\LoggerInterface`, for common services like loggers to ensure interoperability and flexibility.
      https://symfony.com/doc/current/service_container.html#injecting-services-into-services

  -
    question: >
      How can you inject the `kernel.project_dir` parameter into a service's constructor using PHP attributes?
    answers:
      - { value: "`#[Autowire('%kernel.project_dir%')] string $projectDir`", correct: true }
      - { value: "`#[Param('kernel.project_dir')] string $projectDir`", correct: false }
      - { value: "`#[Inject('kernel.project_dir')] string $projectDir`", correct: false }
      - { value: "`#[Service('%kernel.project_dir%')] string $projectDir`", correct: false }
    help: |
      The `#[Autowire]` attribute can be used to explicitly inject a container parameter by its name using the `%parameter_name%` syntax.
      https://symfony.com/doc/current/controller.html#autowiring-specific-services-or-parameters

  -
    question: |
      Consider the following `services.yaml` configuration:

      ```yaml
      # config/services.yaml
      parameters:
          app.mailer.transport: 'smtp'
      services:
          App\Service\Mailer:
              arguments: ['%app.mailer.transport%']
      ```

      What is the value of the `app.mailer.transport` parameter?
    answers:
      - { value: "`smtp`", correct: true }
      - { value: "`%app.mailer.transport%`", correct: false }
      - { value: "It's undefined until runtime.", correct: false }
      - { value: "It defaults to `sendmail`.", correct: false }
    help: |
      Parameters are defined under the `parameters` key in YAML configuration files and are referenced using the `%parameter_name%` syntax.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: |
      Which of the following is the correct way to define a parameter in `config/services.php` using the `ContainerConfigurator`?
    answers:
      - { value: "`$container->parameters()->set('my_param', 'value');`", correct: true }
      - { value: "`$container->addParameter('my_param', 'value');`", correct: false }
      - { value: "`$container->setParam('my_param', 'value');`", correct: false }
      - { value: "`$container->parameter('my_param', 'value');`", correct: false }
    help: |
      In PHP configuration files, parameters are defined using the `parameters()` method of the `ContainerConfigurator` and then `set()`.
      https://symfony.com/doc/current/components/dependency_injection.html#parameters

  -
    question: |
      You have a service `App\Service\MyService` that needs the `kernel.debug` parameter. How would you configure its constructor injection in `config/services.yaml`?

      ```yaml
      # config/services.yaml
      services:
          App\Service\MyService:
              arguments:
                  - ???
      ```
    answers:
      - { value: "`%kernel.debug%`", correct: true }
      - { value: "`@kernel.debug`", correct: false }
      - { value: "`$kernel.debug`", correct: false }
      - { value: "`param('kernel.debug')`", correct: false }
    help: |
      Parameters are injected into service arguments using the `%parameter_name%` syntax in YAML.
      https://symfony.com/doc/current/service_container/parameters.html

  -
    question: >
      Which of the following is the recommended way to register services in Symfony 7 applications?
    answers:
      - { value: "Using PHP attributes for autoconfiguration and explicit YAML/PHP for complex cases.", correct: true }
      - { value: "Exclusively using XML configuration files.", correct: false }
      - { value: "Manually instantiating all services in the application bootstrap.", correct: false }
      - { value: "Storing service definitions in a database.", correct: false }
    help: |
      Symfony 7 heavily promotes autowiring and autoconfiguration using PHP attributes, complemented by YAML or PHP configuration for more explicit or complex service definitions.
      https://symfony.com/doc/current/service_container/autowiring.html

  -
    question: |
      Given the following PHP class:

      ```php
      namespace App\Command;

      use Symfony\Component\Console\Attribute\AsCommand;
      use Symfony\Component\Console\Command\Command;

      #[AsCommand(name: 'app:greet', description: 'Greets the user')]
      class GreetCommand extends Command
      {
          // ...
      }
      ```

      How would this command typically be registered as a service in Symfony 7 without explicit YAML/XML configuration?
    answers:
      - { value: "It is automatically registered as a service due to the `#[AsCommand]` attribute and autoconfiguration.", correct: true }
      - { value: "It requires a manual entry in `services.yaml` with `public: true`.", correct: false }
      - { value: "It must be tagged with `console.command` manually.", correct: false }
      - { value: "It is not registered as a service; it's a standalone command.", correct: false }
    help: |
      The `#[AsCommand]` attribute, combined with Symfony's autoconfiguration, automatically registers console commands as services.
      https://symfony.com/doc/current/console/commands_as_services.html

  -
    question: |
      You have a service `App\Service\ReportGenerator` that needs a `LoggerInterface`. How would you configure constructor injection for this service in `config/services.php`?

      ```php
      // config/services.php
      namespace Symfony\Component\DependencyInjection\Loader\Configurator;

      use App\Service\ReportGenerator;
      use Psr\Log\LoggerInterface;

      return function(ContainerConfigurator $container): void {
          $services = $container->services();

          $services->set(ReportGenerator::class)
              ->args([
                  ???
              ]);
      };
      ```
    answers:
      - { value: "`service(LoggerInterface::class)`", correct: true }
      - { value: "`new Reference(LoggerInterface::class)`", correct: true }
      - { value: "`'@logger'`", correct: false }
      - { value: "`LoggerInterface::class`", correct: false }
    help: |
      In PHP service configuration, you can use `service()` helper function or `new Reference()` to inject other services by their ID or class name (if autowired).
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: |
      Which of the following YAML configurations correctly configures setter injection for `App\Service\MyService` to inject the `mailer` service?

      A)
      ```yaml
      services:
          App\Service\MyService:
              calls:
                  - setMailer: ['@mailer']
      ```

      B)
      ```yaml
      services:
          App\Service\MyService:
              arguments:
                  setMailer: '@mailer'
      ```

      C)
      ```yaml
      services:
          App\Service\MyService:
              properties:
                  setMailer: '@mailer'
      ```
    answers:
      - { value: "A", correct: true }
      - { value: "B", correct: false }
      - { value: "C", correct: false }
    help: |
      Setter injection is configured using the `calls` key in YAML, where each item is a method name followed by an array of arguments.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: |
      You want to use immutable setter injection (wither methods) for a service. Which YAML syntax correctly configures the `withMailer` method to return a cloned instance?

      ```yaml
      services:
          App\Mail\NewsletterManager:
              calls:
                  - withMailer: ??? ['@mailer']
      ```
    answers:
      - { value: "`!returns_clone`", correct: true }
      - { value: "`!clone`", correct: false }
      - { value: "`!immutable`", correct: false }
      - { value: "`!new_instance`", correct: false }
    help: |
      For immutable setter injection, the `!returns_clone` tag is used in YAML to indicate that the method returns a new instance of the object.
      https://symfony.com/doc/current/service_container/injection_types.html#immutable-setter-injection-with-methods

  -
    question: |
      Consider the following PHP class:

      ```php
      namespace App\Service;

      use Symfony\Contracts\Service\Attribute\Required;
      use Psr\Log\LoggerInterface;

      class MyService
      {
          private LoggerInterface $logger;

          #[Required]
          public function setLogger(LoggerInterface $logger): void
          {
              $this->logger = $logger;
          }
      }
      ```

      What is the purpose of the `#[Required]` attribute on the `setLogger` method?
    answers:
      - { value: "It ensures that the `setLogger` method is always called during autowiring, even if the dependency is optional.", correct: true }
      - { value: "It makes the `MyService` class a required service for the application.", correct: false }
      - { value: "It marks the `logger` property as read-only.", correct: false }
      - { value: "It prevents other services from injecting a logger.", correct: false }
    help: |
      The `#[Required]` attribute ensures that a setter method (or public property) is always called by the autowiring system, making the dependency mandatory for autowired services.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: >
      What is the primary use case for service decoration in Symfony?
    answers:
      - { value: "To add or override behavior of an existing service without modifying its original definition.", correct: true }
      - { value: "To make a service public so it can be accessed directly from the container.", correct: false }
      - { value: "To define a service that depends on multiple other services.", correct: false }
      - { value: "To mark a service as deprecated.", correct: false }
    help: |
      Service decoration allows you to replace an existing service with a new one, while still being able to access the original service. This is useful for extending or modifying behavior.
      https://symfony.com/doc/current/service_container/service_decoration.html

  -
    question: |
      You want to decorate the `app.original_mailer` service with `App\Service\CustomMailer`. Which YAML configuration correctly sets up the decoration?

      ```yaml
      services:
          App\Service\CustomMailer:
              decorates: app.original_mailer
              arguments: ['@.inner']
      ```
      What does `@.inner` refer to in this context?
    answers:
      - { value: "The original `app.original_mailer` service.", correct: true }
      - { value: "The `App\\Service\\CustomMailer` service itself.", correct: false }
      - { value: "A randomly generated service ID.", correct: false }
      - { value: "The first argument passed to the constructor.", correct: false }
    help: |
      When decorating a service, `@.inner` is a special reference that points to the original service being decorated, allowing the decorator to interact with it.
      https://symfony.com/doc/current/service_container/service_decoration.html#accessing-the-decorated-service

  -
    question: >
      What is the main purpose of service tags in Symfony's Dependency Injection component?
    answers:
      - { value: "To identify and group services that share a common purpose or interface, allowing them to be collected by compiler passes or autowired as collections.", correct: true }
      - { value: "To define the scope of a service (e.g., request scope, container scope).", correct: false }
      - { value: "To mark services as private or public.", correct: false }
      - { value: "To specify the environment in which a service should be loaded.", correct: false }
    help: |
      Tags are metadata attached to services, used to identify services that fulfill a certain role or implement a specific interface, enabling their collection and processing.
      https://symfony.com/doc/current/service_container/tags.html

  -
    question: |
      You have multiple services implementing `App\Handler\HandlerInterface`. How can you inject all services tagged with `app.handler` into a constructor argument as an `iterable` using PHP attributes?

      ```php
      namespace App;

      use Symfony\Component\DependencyInjection\Attribute\AutowireIterator;

      class HandlerCollection
      {
          public function __construct(
              #[AutowireIterator('app.handler')]
              iterable $handlers
          ) {
              // ...
          }
      }
      ```
      Is this code correct for injecting tagged services?
    answers:
      - { value: "Yes, the `#[AutowireIterator]` attribute correctly injects all services tagged with `app.handler`.", correct: true }
      - { value: "No, `AutowireIterator` is only for injecting specific services by name.", correct: false }
      - { value: "No, you must use `#[Autowire(tag: 'app.handler')]` instead.", correct: false }
      - { value: "No, `iterable` cannot be used for service collections; an array is required.", correct: false }
    help: |
      The `#[AutowireIterator]` attribute allows injecting all services tagged with a specific name as an `iterable` (or `array`) into a constructor argument.
      https://symfony.com/doc/current/service_container/tags.html#autowiring-tagged-services

  -
    question: >
      What is the purpose of `ContainerBuilder::registerForAutoconfiguration()` in a Compiler Pass?
    answers:
      - { value: "To define autoconfiguration rules for services that implement a specific interface or extend a class.", correct: true }
      - { value: "To register a new service definition with the container.", correct: false }
      - { value: "To mark a service as public for direct retrieval.", correct: false }
      - { value: "To compile the service container immediately.", correct: false }
    help: |
      `registerForAutoconfiguration()` allows you to apply common configurations (like tags) to all services that implement a given interface or extend a specific class, without explicitly defining them for each service.
      https://symfony.com/doc/current/service_container/tags.html#autoconfiguration

  -
    question: >
      What is "semantic configuration" in Symfony, and why is it used?
    answers:
      - { value: "It's a structured way to define bundle-specific configuration using a `Configuration` class, providing validation and default values.", correct: true }
      - { value: "It refers to the process of automatically wiring services based on their type-hints.", correct: false }
      - { value: "It's a method for defining services directly within a controller.", correct: false }
      - { value: "It's a mechanism for translating configuration keys into different languages.", correct: false }
    help: |
      Semantic configuration allows bundles to define a structured configuration tree, which is then validated and merged during the container compilation process. This provides clear, self-documenting, and validated configuration.
      https://symfony.com/doc/current/bundles/extension.html#semantic-configuration

  -
    question: >
      Which class is typically implemented to define the configuration tree for a Symfony bundle's semantic configuration?
    answers:
      - { value: "`Symfony\\Component\\Config\\Definition\\ConfigurationInterface`", correct: true }
      - { value: "`Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface`", correct: false }
      - { value: "`Symfony\\Component\\HttpKernel\\Bundle\\Bundle`", correct: false }
      - { value: "`Symfony\\Component\\Config\\Builder\\TreeBuilder`", correct: false }
    help: |
      The `ConfigurationInterface` defines the `getConfigTreeBuilder()` method, which is responsible for building the configuration tree using `TreeBuilder`.
      https://symfony.com/doc/current/bundles/extension.html#semantic-configuration

  -
    question: >
      When would you typically use a "factory" to create a service in Symfony's Dependency Injection Container?
    answers:
      - { value: "When a service cannot be instantiated directly via its constructor and requires a static method or a service method to create its instance.", correct: true }
      - { value: "When you want to make a service immutable.", correct: false }
      - { value: "When a service needs to be decorated by another service.", correct: false }
      - { value: "When you want to inject multiple services of the same type.", correct: false }
    help: |
      Factories are used when the instantiation logic for a service is more complex than a simple `new Class()` call, such as when using a static factory method or a method on another service.
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: |
      How would you configure a service `App\Service\MyService` to be created by the static method `create()` on `App\Factory\MyFactory` in `config/services.yaml`?

      ```yaml
      services:
          App\Service\MyService:
              factory: [App\Factory\MyFactory, 'create']
      ```
      Is this configuration correct?
    answers:
      - { value: "Yes, this is the correct YAML syntax for a static factory method.", correct: true }
      - { value: "No, the `factory` key should point to a service ID, not a class name.", correct: false }
      - { value: "No, static methods cannot be used as factories.", correct: false }
      - { value: "No, the method name should be prefixed with `::`.", correct: false }
    help: |
      The `factory` key in YAML can specify a static method on a class (using `[ClassName, 'methodName']`) or a method on another service (using `['@service_id', 'methodName']`).
      https://symfony.com/doc/current/service_container/factories.html

  -
    question: >
      What is the primary role of a "Compiler Pass" in Symfony's Dependency Injection component?
    answers:
      - { value: "To modify service definitions and the container itself before it is compiled and dumped.", correct: true }
      - { value: "To compile PHP code into bytecode for faster execution.", correct: false }
      - { value: "To translate service IDs into class names.", correct: false }
      - { value: "To resolve environment variables during runtime.", correct: false }
    help: |
      Compiler passes are executed during the container compilation process, allowing developers to programmatically modify service definitions, add tags, or perform other manipulations.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      When do Symfony Compiler Passes execute?
    answers:
      - { value: "During the container compilation process, typically when the cache is warmed up or the application is deployed.", correct: true }
      - { value: "Every time a service is retrieved from the container at runtime.", correct: false }
      - { value: "Only when the application is running in debug mode.", correct: false }
      - { value: "Before any services are defined in configuration files.", correct: false }
    help: |
      Compiler passes are part of the container compilation, which happens once (e.g., during cache warm-up or deployment) to optimize the container for performance.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: |
      In a Compiler Pass, how would you find all services tagged with `app.event_subscriber`?

      ```php
      use Symfony\Component\DependencyInjection\ContainerBuilder;
      use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;

      class MyCompilerPass implements CompilerPassInterface
      {
          public function process(ContainerBuilder $container): void
          {
              $taggedServices = ???;
              // ...
          }
      }
      ```
    answers:
      - { value: "`$container->findTaggedServiceIds('app.event_subscriber');`", correct: true }
      - { value: "`$container->getServicesByTag('app.event_subscriber');`", correct: false }
      - { value: "`$container->findServicesWithTag('app.event_subscriber');`", correct: false }
      - { value: "`$container->getTaggedServices('app.event_subscriber');`", correct: false }
    help: |
      The `findTaggedServiceIds()` method of `ContainerBuilder` returns an array of service IDs that have a given tag.
      https://symfony.com/doc/current/service_container/tags.html#finding-services-by-tag

  -
    question: >
      What is "autowiring" in Symfony's Dependency Injection component?
    answers:
      - { value: "The automatic injection of service dependencies based on type-hints in constructors, setters, or public properties.", correct: true }
      - { value: "A feature that automatically generates service definitions from PHP classes.", correct: false }
      - { value: "A mechanism for automatically compiling the service container.", correct: false }
      - { value: "A tool for automatically detecting circular dependencies.", correct: false }
    help: |
      Autowiring simplifies dependency injection by automatically identifying and injecting dependencies based on type-hints, reducing the need for explicit configuration.
      https://symfony.com/doc/current/service_container/autowiring.html

  -
    question: |
      Given the following PHP class:

      ```php
      namespace App\Service;

      use App\Util\Rot13Transformer;

      class TwitterClient
      {
          public function __construct(
              private Rot13Transformer $transformer,
          ) {
          }
      }
      ```

      Assuming autowiring is enabled, how does Symfony know which `Rot13Transformer` service to inject?
    answers:
      - { value: "It injects the service whose ID matches the type-hinted class name (`App\\Util\\Rot13Transformer`).", correct: true }
      - { value: "It searches for any service tagged with `transformer`.", correct: false }
      - { value: "It requires a manual alias to be configured.", correct: false }
      - { value: "It injects the first service it finds in the container.", correct: false }
    help: |
      When autowiring, Symfony attempts to find a service whose ID matches the type-hinted class or interface name.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-by-type

  -
    question: >
      When multiple services implement the same interface, how can you explicitly tell Symfony which specific service to inject using PHP attributes?
    answers:
      - { value: "Using the `#[Target('service_id')]` attribute.", correct: true }
      - { value: "Using the `#[Autowire(service: 'service_id')]` attribute.", correct: true }
      - { value: "Using the `#[Alias('service_id')]` attribute.", correct: false }
      - { value: "Using the `#[Inject('service_id')]` attribute.", correct: false }
    help: |
      The `#[Target]` attribute (for disambiguation by name) and `#[Autowire(service: ...)]` attribute (for explicit service injection) can be used to specify a particular service when multiple services implement the same interface.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: >
      What is the purpose of the `#[AutowireServiceClosure]` attribute?
    answers:
      - { value: "To automatically create an anonymous function (closure) that returns a service, enabling lazy-loading of that service.", correct: true }
      - { value: "To define a service that is always a closure.", correct: false }
      - { value: "To inject a service as a callable.", correct: false }
      - { value: "To prevent a service from being autowired.", correct: false }
    help: |
      `#[AutowireServiceClosure]` is used to inject a service as a callable (closure), which allows the service to be lazy-loaded only when the closure is invoked.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-service-closures

  -
    question: >
      What is a "Service Locator" in Symfony, and what problem does it solve?
    answers:
      - { value: "It's a service that allows you to retrieve a subset of services on demand, solving the problem of injecting too many optional dependencies into a constructor.", correct: true }
      - { value: "It's a global registry for all services in the application.", correct: false }
      - { value: "It's a tool for locating external APIs.", correct: false }
      - { value: "It's a pattern for creating singletons.", correct: false }
    help: |
      Service locators provide a way to access services by ID from a limited collection, avoiding "constructor hell" when a service has many optional dependencies.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html

  -
    question: |
      To implement a service locator, a class should implement which interface?
    answers:
      - { value: "`Symfony\\Contracts\\Service\\ServiceSubscriberInterface`", correct: true }
      - { value: "`Psr\\Container\\ContainerInterface`", correct: false }
      - { value: "`Symfony\\Component\\DependencyInjection\\ServiceLocator`", correct: false }
      - { value: "`Symfony\\Contracts\\Service\\ServiceLocatorInterface`", correct: false }
    help: |
      Classes that want to use a service locator should implement `ServiceSubscriberInterface` and define the services they subscribe to in `getSubscribedServices()`.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#service-subscriber

  -
    question: |
      Consider the following PHP class using a service locator:

      ```php
      namespace App\Service;

      use Symfony\Contracts\Service\ServiceSubscriberInterface;
      use Psr\Container\ContainerInterface;

      class MyService implements ServiceSubscriberInterface
      {
          public function __construct(private ContainerInterface $locator)
          {
          }

          public static function getSubscribedServices(): array
          {
              return [
                  'logger' => 'Psr\\Log\\LoggerInterface',
                  'mailer' => '?MailerInterface',
              ];
          }

          public function doSomething(): void
          {
              $logger = $this->locator->get('logger');
              // ...
          }
      }
      ```
      What does the `?` prefix in `?MailerInterface` signify in `getSubscribedServices()`?
    answers:
      - { value: "The `mailer` service is optional; if it's not available, `get('mailer')` will return `null` instead of throwing an exception.", correct: true }
      - { value: "The `mailer` service is a private service.", correct: false }
      - { value: "The `mailer` service is a synthetic service.", correct: false }
      - { value: "The `mailer` service is an alias.", correct: false }
    help: |
      The `?` prefix indicates that the service is optional. If the service is not found in the container, `get()` will return `null` instead of throwing a `ServiceNotFoundException`.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#optional-services

  -
    question: >
      Which of the following is NOT a valid method for injecting dependencies into a service in Symfony?
    answers:
      - { value: "Global variable injection", correct: true }
      - { value: "Constructor injection", correct: false }
      - { value: "Setter injection", correct: false }
      - { value: "Property injection", correct: false }
    help: |
      Symfony's Dependency Injection component supports constructor, setter, and property injection. Relying on global variables is an anti-pattern and not a supported injection method.
      https://symfony.com/doc/current/service_container/injection_types.html

  -
    question: >
      What is the purpose of the `#[Autowire]` attribute when used with an `expression` parameter?
    answers:
      - { value: "To inject the result of a Symfony Expression Language expression.", correct: true }
      - { value: "To define a regular expression for service matching.", correct: false }
      - { value: "To dynamically generate a service ID.", correct: false }
      - { value: "To inject an environment variable.", correct: false }
    help: |
      The `#[Autowire]` attribute can take an `expression` parameter, allowing you to inject values derived from Symfony Expression Language expressions.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-expression

  -
    question: >
      Which of the following is true about the `ContainerBuilder` in Symfony?
    answers:
      - { value: "It is used to define and register services programmatically before the container is compiled.", correct: true }
      - { value: "It is the final, immutable container used at runtime.", correct: false }
      - { value: "It can only load services from YAML files.", correct: false }
      - { value: "It automatically instantiates all services upon creation.", correct: false }
    help: |
      The `ContainerBuilder` is the mutable container used during the compilation phase, where service definitions are registered and processed before the optimized, immutable container is built.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      What is the benefit of using `#[Required]` on a setter method compared to making the dependency mandatory in the constructor?
    answers:
      - { value: "It allows for optional dependencies that become mandatory only if the service is autowired, providing more flexibility for third-party code or complex setups.", correct: true }
      - { value: "It makes the service a singleton.", correct: false }
      - { value: "It prevents circular dependencies.", correct: false }
      - { value: "It forces the dependency to be injected as a closure.", correct: false }
    help: |
      `#[Required]` on a setter allows a dependency to be optional when manually configured but mandatory when autowired, offering a middle ground between strict constructor injection and fully optional dependencies.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: |
      You want to inject an environment variable `APP_ENV` into your service. Which `#[Autowire]` parameter should you use?
    answers:
      - { value: "`env: 'APP_ENV'`", correct: true }
      - { value: "`param: 'env(APP_ENV)'`", correct: false }
      - { value: "`value: '%env(APP_ENV)%'`", correct: false }
      - { value: "`var: 'APP_ENV'`", correct: false }
    help: |
      The `env` parameter of the `#[Autowire]` attribute is used to inject environment variables. You can also use processors like `bool:APP_DEBUG` for type conversion.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-env

  -
    question: >
      What is the difference between a "shared" and a "non-shared" service in Symfony?
    answers:
      - { value: "A shared service returns the same instance every time it's requested, while a non-shared service creates a new instance each time.", correct: true }
      - { value: "A shared service is public, while a non-shared service is private.", correct: false }
      - { value: "Shared services are always autowired, non-shared are not.", correct: false }
      - { value: "Shared services are compiled, non-shared are not.", correct: false }
    help: |
      By default, services are shared (singletons). You can configure a service as non-shared (prototype) if you need a fresh instance every time it's retrieved.
      https://symfony.com/doc/current/service_container/sharing.html

  -
    question: |
      How would you configure `App\Service\MyService` as a non-shared service in `config/services.yaml`?

      ```yaml
      services:
          App\Service\MyService:
              ???
      ```
    answers:
      - { value: "`shared: false`", correct: true }
      - { value: "`singleton: false`", correct: false }
      - { value: "`instantiate: always`", correct: false }
      - { value: "`new_instance: true`", correct: false }
    help: |
      The `shared: false` option in service definition configures a service to be non-shared, meaning a new instance is created on each request.
      https://symfony.com/doc/current/service_container/sharing.html

  -
    question: >
      Which of the following is a key benefit of using Dependency Injection in a Symfony application?
    answers:
      - { value: "Increased testability and maintainability due to loose coupling between components.", correct: true }
      - { value: "Reduced application startup time.", correct: false }
      - { value: "Automatic generation of database schemas.", correct: false }
      - { value: "Simplified routing configuration.", correct: false }
    help: |
      Dependency Injection promotes loose coupling, making components easier to test in isolation and improving the overall maintainability and flexibility of the application.
      https://symfony.com/doc/current/service_container.html#why-use-a-dependency-injection-container

  -
    question: >
      What is the purpose of the `#[AsAlias]` attribute?
    answers:
      - { value: "To define an alias for a service, allowing it to be referenced by an alternative name.", correct: true }
      - { value: "To mark a service as an abstract service.", correct: false }
      - { value: "To create a service that is a copy of another service.", correct: false }
      - { value: "To define a service that can only be injected as a closure.", correct: false }
    help: |
      The `#[AsAlias]` attribute allows you to create an alias for an existing service, providing an alternative ID to refer to it.
      https://symfony.com/doc/current/service_container/alias_private.html#aliasing-services

  -
    question: |
      You have a base service `App\Service\BaseProcessor` and you want to define `App\Service\SpecificProcessor` that inherits its configuration. How would you do this in `config/services.yaml`?

      ```yaml
      services:
          App\Service\BaseProcessor:
              # ... base config ...

          App\Service\SpecificProcessor:
              ???
      ```
    answers:
      - { value: "`parent: App\\Service\\BaseProcessor`", correct: true }
      - { value: "`inherits: App\\Service\\BaseProcessor`", correct: false }
      - { value: "`extends: App\\Service\\BaseProcessor`", correct: false }
      - { value: "`use: App\\Service\\BaseProcessor`", correct: false }
    help: |
      The `parent` key in a service definition allows a service to inherit configuration from another service, which is useful for creating variations of a base service.
      https://symfony.com/doc/current/service_container/parent_services.html

  -
    question: >
      What is the primary benefit of using `#[Autowire(expression: 'service("my_service").myMethod()')]` over direct service injection?
    answers:
      - { value: "It allows for dynamic values or complex logic to determine the injected value at compile time.", correct: true }
      - { value: "It makes the service private.", correct: false }
      - { value: "It forces the service to be lazy-loaded.", correct: false }
      - { value: "It's a way to inject multiple services at once.", correct: false }
    help: |
      Using an expression with `#[Autowire]` provides a powerful way to inject values that are not simple service references or parameters, allowing for more complex logic evaluated by the Expression Language.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-expression

  -
    question: >
      Which of the following is a common use case for a Compiler Pass?
    answers:
      - { value: "Registering services based on a specific tag and injecting them into a collector service.", correct: true }
      - { value: "Handling incoming HTTP requests.", correct: false }
      - { value: "Rendering Twig templates.", correct: false }
      - { value: "Managing database connections at runtime.", correct: false }
    help: |
      Compiler passes are frequently used to find services with specific tags and then inject them into a "collector" service (e.g., an event dispatcher or a command bus) that manages a collection of similar objects.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html#finding-services-by-tag

  -
    question: >
      What is the purpose of the `#[Autoconfigure]` attribute?
    answers:
      - { value: "To define autoconfiguration rules directly on a class, such as applying specific tags or method calls.", correct: true }
      - { value: "To mark a class as eligible for autowiring.", correct: false }
      - { value: "To automatically generate a service ID for a class.", correct: false }
      - { value: "To prevent a class from being registered as a service.", correct: false }
    help: |
      The `#[Autoconfigure]` attribute allows you to apply autoconfiguration rules (like adding tags or method calls) to a class directly, without needing external configuration files.
      https://symfony.com/doc/current/service_container/tags.html#autoconfiguration-attribute

  -
    question: >
      When is it appropriate to disable autowiring for a specific service?
    answers:
      - { value: "When the service has ambiguous dependencies that cannot be resolved by type-hinting alone, and explicit configuration is clearer.", correct: true }
      - { value: "When the service is very simple and has no dependencies.", correct: false }
      - { value: "When the service is public and needs to be accessed directly.", correct: false }
      - { value: "When the service is a built-in Symfony service.", correct: false }
    help: |
      Autowiring can be disabled for individual services when their dependencies are ambiguous or when explicit configuration provides better clarity and control.
      https://symfony.com/doc/current/service_container/autowiring.html#disabling-autowiring-for-a-specific-service

  -
    question: |
      Which of the following is the correct way to define a service `App\Service\MyService` with a constructor argument in `config/services.yaml`?

      A)
      ```yaml
      services:
          App\Service\MyService:
              arguments:
                  - '@some_other_service'
      ```

      B)
      ```yaml
      services:
          App\Service\MyService:
              constructor: ['@some_other_service']
      ```

      C)
      ```yaml
      services:
          App\Service\MyService:
              args: ['@some_other_service']
      ```
    answers:
      - { value: "A", correct: true }
      - { value: "B", correct: false }
      - { value: "C", correct: false }
    help: |
      Constructor arguments are defined under the `arguments` key as a list in YAML.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: >
      What is the purpose of the `public: false` setting for a service in Symfony?
    answers:
      - { value: "It makes the service private, meaning it cannot be retrieved directly from the container using `get()`, but can still be injected into other services.", correct: true }
      - { value: "It prevents the service from being autowired.", correct: false }
      - { value: "It marks the service as deprecated.", correct: false }
      - { value: "It makes the service a non-shared instance.", correct: false }
    help: |
      Setting `public: false` makes a service private. Private services are typically injected into other services but are not accessible directly via `$container->get()`, promoting encapsulation.
      https://symfony.com/doc/current/service_container/alias_private.html#private-services

  -
    question: >
      Which of the following describes the behavior of a service defined with `lazy: true`?
    answers:
      - { value: "The service is only instantiated when it is actually needed, not when the container is built or the service is first referenced.", correct: true }
      - { value: "The service is always instantiated, but its dependencies are lazy-loaded.", correct: false }
      - { value: "The service is only available in lazy-loading environments.", correct: false }
      - { value: "The service is automatically decorated.", correct: false }
    help: |
      Lazy services are instantiated only when they are first accessed, which can improve application startup performance by avoiding the creation of unused objects.
      https://symfony.com/doc/current/service_container/lazy_services.html

  -
    question: |
      How would you configure a service `App\Service\HeavyService` to be lazy-loaded in `config/services.yaml`?

      ```yaml
      services:
          App\Service\HeavyService:
              ???
      ```
    answers:
      - { value: "`lazy: true`", correct: true }
      - { value: "`instantiate: lazy`", correct: false }
      - { value: "`load: lazy`", correct: false }
      - { value: "`on_demand: true`", correct: false }
    help: |
      The `lazy: true` option in a service definition configures it for lazy loading.
      https://symfony.com/doc/current/service_container/lazy_services.html

  -
    question: >
      What is the main reason to use `#[Autowire(service: 'monolog.logger.request')]` instead of just type-hinting `LoggerInterface`?
    answers:
      - { value: "To inject a specific named logger channel when multiple loggers are configured.", correct: true }
      - { value: "To prevent the default logger from being injected.", correct: false }
      - { value: "To make the logger service private.", correct: false }
      - { value: "To ensure the logger is always lazy-loaded.", correct: false }
    help: |
      When multiple services implement the same interface (like `LoggerInterface`), `#[Autowire(service: '...')` allows you to specify exactly which named service (e.g., a specific logger channel) should be injected.
      https://symfony.com/doc/current/controller.html#autowiring-specific-services-or-parameters

  -
    question: >
      Which of the following is true about the `ContainerConfigurator` in PHP service definitions?
    answers:
      - { value: "It provides a fluent interface for defining services, parameters, and aliases.", correct: true }
      - { value: "It is used for runtime service retrieval only.", correct: false }
      - { value: "It can only define services, not parameters.", correct: false }
      - { value: "It is deprecated in Symfony 7.", correct: false }
    help: |
      `ContainerConfigurator` is the recommended way to define services and parameters in PHP configuration files, offering a clean and fluent API.
      https://symfony.com/doc/current/components/dependency_injection.html#php-configuration

  -
    question: >
      What is the purpose of the `#[AsEventListener]` attribute?
    answers:
      - { value: "To register a class as an event listener or subscriber, automatically tagging it for the event dispatcher.", correct: true }
      - { value: "To define a service that listens for HTTP requests.", correct: false }
      - { value: "To mark a service as an event source.", correct: false }
      - { value: "To inject the event dispatcher service.", correct: false }
    help: |
      The `#[AsEventListener]` attribute is part of autoconfiguration, automatically tagging the class with `kernel.event_listener` or `kernel.event_subscriber` and configuring its methods to listen to specific events.
      https://symfony.com/doc/current/components/event_dispatcher.html#event-listeners-as-services

  -
    question: >
      When defining a service in `config/services.yaml`, what is the default scope (shared/non-shared) for a service?
    answers:
      - { value: "Shared (singleton)", correct: true }
      - { value: "Non-shared (prototype)", correct: false }
      - { value: "Request-scoped", correct: false }
      - { value: "Session-scoped", correct: false }
    help: |
      By default, all services in Symfony's Dependency Injection Container are "shared," meaning only one instance of the service is created and reused throughout the application lifecycle.
      https://symfony.com/doc/current/service_container/sharing.html

  -
    question: >
      What happens if you try to retrieve a private service directly using `$container->get('private_service_id')`?
    answers:
      - { value: "A `ServiceNotFoundException` will be thrown.", correct: true }
      - { value: "The service will be instantiated and returned.", correct: false }
      - { value: "It will return `null`.", correct: false }
      - { value: "The application will crash silently.", correct: false }
    help: |
      Attempting to retrieve a private service directly via `get()` will result in a `ServiceNotFoundException`, as private services are not intended for direct access.
      https://symfony.com/doc/current/service_container/alias_private.html#private-services

  -
    question: >
      Which of the following is the correct way to define a service `App\Service\MyService` using PHP attributes for autowiring its constructor dependencies?
    answers:
      - { value: "No special attribute is needed; type-hinting constructor arguments is enough if autowiring is enabled.", correct: true }
      - { value: "`#[Autoservice]` on the class.", correct: false }
      - { value: "`#[Injectable]` on the class.", correct: false }
      - { value: "`#[Service]` on the class.", correct: false }
    help: |
      For basic constructor autowiring, simply type-hinting the constructor arguments is sufficient when autowiring is enabled in Symfony. No specific attribute is required on the class itself for this.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-constructor-arguments

  -
    question: >
      What is the purpose of the `ContainerBuilder::addCompilerPass()` method?
    answers:
      - { value: "To register a custom compiler pass that will modify the container during compilation.", correct: true }
      - { value: "To add a new service to the container.", correct: false }
      - { value: "To compile a single service definition.", correct: false }
      - { value: "To add a new parameter to the container.", correct: false }
    help: |
      `addCompilerPass()` is used to register custom compiler passes with the `ContainerBuilder`, allowing them to participate in the container's compilation process.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html#registering-compiler-passes

  -
    question: >
      When defining a service, what is the effect of setting `autowire: false`?
    answers:
      - { value: "It disables autowiring for that specific service, requiring all its dependencies to be explicitly configured.", correct: true }
      - { value: "It makes the service private.", correct: false }
      - { value: "It prevents the service from being instantiated.", correct: false }
      - { value: "It makes the service lazy-loaded.", correct: false }
    help: |
      Setting `autowire: false` for a service means that Symfony will not attempt to automatically resolve its dependencies based on type-hints; all arguments must be explicitly defined.
      https://symfony.com/doc/current/service_container/autowiring.html#disabling-autowiring-for-a-specific-service

  -
    question: >
      Which of the following is a valid way to inject a service into a public property using PHP attributes?
    answers:
      - { value: "`#[Required] public LoggerInterface $logger;`", correct: true }
      - { value: "`#[Autowire] public LoggerInterface $logger;`", correct: false }
      - { value: "`#[Inject] public LoggerInterface $logger;`", correct: false }
      - { value: "`public #[Service] LoggerInterface $logger;`", correct: false }
    help: |
      The `#[Required]` attribute can be used on public properties to ensure they are autowired. While possible, property injection is generally less recommended than constructor or setter injection.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-public-property-injection-with-required

  -
    question: >
      What is the primary advantage of using `ContainerConfigurator` for PHP service definitions over raw `ContainerBuilder` calls?
    answers:
      - { value: "It provides a more readable and concise syntax, especially for common configurations, and supports auto-completion.", correct: true }
      - { value: "It allows for runtime modification of the container.", correct: false }
      - { value: "It is the only way to define parameters in PHP.", correct: false }
      - { value: "It automatically compiles the container without explicit calls.", correct: false }
    help: |
      `ContainerConfigurator` offers a modern, fluent API that simplifies PHP service definitions, making them more readable and easier to manage compared to direct `ContainerBuilder` method calls.
      https://symfony.com/doc/current/components/dependency_injection.html#php-configuration

  -
    question: >
      When should you consider using a Service Locator instead of injecting all dependencies directly into a constructor?
    answers:
      - { value: "When a service has many optional dependencies that are not always needed, to avoid a large constructor signature.", correct: true }
      - { value: "When all dependencies are mandatory and frequently used.", correct: false }
      - { value: "When you need to create multiple instances of the same service.", correct: false }
      - { value: "When you want to prevent any form of dependency injection.", correct: false }
    help: |
      Service locators are useful for "lazy" or "optional" dependencies, preventing "constructor hell" by allowing services to fetch specific dependencies only when they are actually required.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#when-to-use-service-locators

  -
    question: >
      What is the purpose of the `#[Autowire(param: 'my_bundle.some_value')]` attribute?
    answers:
      - { value: "To inject a specific container parameter by its name.", correct: true }
      - { value: "To define a parameter for the service.", correct: false }
      - { value: "To inject a service whose ID is a parameter.", correct: false }
      - { value: "To inject a parameter from an environment variable.", correct: false }
    help: |
      The `param` key within the `#[Autowire]` attribute allows you to explicitly inject a container parameter into a constructor argument or property.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-param

  -
    question: >
      Which of the following is a valid way to load service definitions from an XML file into the `ContainerBuilder`?
    answers:
      - { value: "`$loader = new XmlFileLoader($container, new FileLocator(__DIR__)); $loader->load('services.xml');`", correct: true }
      - { value: "`$container->loadXml('services.xml');`", correct: false }
      - { value: "`$container->import('services.xml', 'xml');`", correct: false }
      - { value: "`$loader = new XmlLoader($container, 'services.xml');`", correct: false }
    help: |
      The `XmlFileLoader` is used with a `FileLocator` to load service definitions from XML files into the `ContainerBuilder`.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-definitions

  -
    question: >
      What is the role of `Symfony\Component\Config\FileLocator` when loading service definitions?
    answers:
      - { value: "It helps locate configuration files within defined paths, making it easier to load resources from bundles or specific directories.", correct: true }
      - { value: "It validates the syntax of configuration files.", correct: false }
      - { value: "It converts configuration files between different formats (YAML, XML, PHP).", correct: false }
      - { value: "It caches the loaded configuration files.", correct: false }
    help: |
      `FileLocator` is a utility class that helps locate files by searching through a list of predefined paths, commonly used by configuration loaders to find service definition files.
      https://symfony.com/doc/current/components/config/file_locator.html

  -
    question: >
      When defining a custom bundle, which method in the bundle's `Extension` class is responsible for loading its service definitions into the container?
    answers:
      - { value: "`load(array $configs, ContainerBuilder $container)`", correct: true }
      - { value: "`build(ContainerBuilder $container)`", correct: false }
      - { value: "`configure(ContainerBuilder $container)`", correct: false }
      - { value: "`register(ContainerBuilder $container)`", correct: false }
    help: |
      The `load()` method of a bundle's `Extension` class is where the bundle's service definitions (from YAML, XML, or PHP files) are loaded into the `ContainerBuilder`.
      https://symfony.com/doc/current/bundles/extension.html#loading-configuration

  -
    question: >
      What is the purpose of the `prependExtensionConfig()` method in a bundle's extension?
    answers:
      - { value: "To prepend configuration to another bundle's extension before its `load()` method is called, allowing one bundle to influence another's default configuration.", correct: true }
      - { value: "To load configuration from a specific file within the current bundle.", correct: false }
      - { value: "To merge the current bundle's configuration with the application's main configuration.", correct: false }
      - { value: "To define parameters that are only available during the compilation phase.", correct: false }
    help: |
      The `prependExtensionConfig()` method (part of `PrependExtensionInterface`) allows a bundle to add configuration to another bundle's extension. This configuration is processed before the target extension's `load()` method, enabling bundles to provide default settings that can still be overridden by the user.
      https://symfony.com/doc/current/bundles/prepend_extension.html

  -
    question: >
      Which of the following is true regarding the order of execution for compiler passes?
    answers:
      - { value: "Compiler passes are executed in the order they are added to the `ContainerBuilder`.", correct: true }
      - { value: "Compiler passes are executed in reverse alphabetical order of their class names.", correct: false }
      - { value: "Compiler passes are executed randomly.", correct: false }
      - { value: "Compiler passes are executed based on their priority, with higher priority running first.", correct: true }
    help: |
      Compiler passes are executed in the order they are added to the `ContainerBuilder`. However, they can also implement `PrioritizedPassInterface` to define a specific priority, influencing their execution order.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html#compiler-pass-priorities

  -
    question: >
      What is the primary reason for compiling the Dependency Injection Container in Symfony?
    answers:
      - { value: "To optimize performance by transforming service definitions into highly optimized PHP code, reducing runtime overhead.", correct: true }
      - { value: "To validate all service definitions against a schema.", correct: false }
      - { value: "To ensure all services are instantiated at application startup.", correct: false }
      - { value: "To encrypt service definitions for security.", correct: false }
    help: |
      The compilation process transforms the flexible, but slower, `ContainerBuilder` into an optimized, immutable container that can quickly instantiate and manage services at runtime.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      Which of the following is a key characteristic of a "dumped" (compiled) container?
    answers:
      - { value: "It is an optimized, immutable PHP class that directly instantiates services.", correct: true }
      - { value: "It can be modified at runtime to add new services.", correct: false }
      - { value: "It only exists in the `dev` environment.", correct: false }
      - { value: "It requires all services to be public.", correct: false }
    help: |
      After compilation, the container is "dumped" into a highly optimized PHP class. This compiled container is immutable and designed for maximum performance at runtime.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      What is the purpose of the `#[AsMessageHandler]` attribute?
    answers:
      - { value: "To register a class as a message handler for the Messenger component, automatically tagging it for message routing.", correct: true }
      - { value: "To define a service that sends messages to a queue.", correct: false }
      - { value: "To inject the Messenger bus service.", correct: false }
      - { value: "To mark a service as a message producer.", correct: false }
    help: |
      The `#[AsMessageHandler]` attribute is used in the Symfony Messenger component to automatically register a class as a message handler, making it discoverable by the message bus.
      https://symfony.com/doc/current/messenger.html#message-handlers

  -
    question: >
      When manually registering a service in PHP using `ContainerBuilder`, how do you add a constructor argument that is another service?
    answers:
      - { value: "`->addArgument(new Reference('service_id'))`", correct: true }
      - { value: "`->addArgument('@service_id')`", correct: false }
      - { value: "`->addServiceArgument('service_id')`", correct: false }
      - { value: "`->argument('service_id')`", correct: false }
    help: |
      When manually defining services with `ContainerBuilder`, use `new Reference('service_id')` to inject other services as arguments.
      https://symfony.com/doc/current/components/dependency_injection.html#referencing-services

  -
    question: >
      What is the main advantage of using `param()` helper function in PHP service definitions (e.g., `args([param('my_param')])`)?
    answers:
      - { value: "It provides a more concise and readable way to reference parameters compared to string interpolation (`%my_param%`).", correct: true }
      - { value: "It allows for dynamic parameter values at runtime.", correct: false }
      - { value: "It makes the parameter private.", correct: false }
      - { value: "It forces the parameter to be an object.", correct: false }
    help: |
      The `param()` helper function (available in `ContainerConfigurator` contexts) offers a cleaner syntax for injecting parameters into service arguments in PHP configuration.
      https://symfony.com/doc/current/components/dependency_injection.html#php-configuration

  -
    question: >
      Which of the following is a valid way to define a service `App\Service\MyService` with a public property `logger` that is injected with the `logger` service in `config/services.php`?
    answers:
      - { value: "`$services->set(App\\Service\\MyService::class)->property('logger', service('logger'));`", correct: true }
      - { value: "`$services->set(App\\Service\\MyService::class)->addProperty('logger', service('logger'));`", correct: false }
      - { value: "`$services->set(App\\Service\\MyService::class)->set('logger', service('logger'));`", correct: false }
      - { value: "`$services->set(App\\Service\\MyService::class)->prop('logger', service('logger'));`", correct: false }
    help: |
      In PHP service definitions using `ContainerConfigurator`, the `property()` method is used to configure property injection.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      What is the purpose of the `ContainerBuilder::registerAttributeForAutoconfiguration()` method?
    answers:
      - { value: "To register a PHP attribute and a callback function that applies definitions (e.g., tags) to services using that attribute.", correct: true }
      - { value: "To register a service based on a PHP attribute.", correct: false }
      - { value: "To automatically generate attributes for services.", correct: false }
      - { value: "To prevent certain attributes from being processed.", correct: false }
    help: |
      `registerAttributeForAutoconfiguration()` allows you to define custom autoconfiguration logic triggered by the presence of a specific PHP attribute on a class.
      https://symfony.com/doc/current/service_container/tags.html#autoconfiguration-attribute

  -
    question: >
      Which of the following is true about the `ContainerBuilder::set()` method?
    answers:
      - { value: "It is used to inject an *existing* object instance into the container as a synthetic service.", correct: true }
      - { value: "It is used to define a new service definition from scratch.", correct: false }
      - { value: "It is used to retrieve a service from the container.", correct: false }
      - { value: "It is used to set a parameter value.", correct: false }
    help: |
      The `set()` method on `ContainerBuilder` (and the compiled container) is specifically for injecting an already instantiated object into the container, making it available as a service. This is commonly used for synthetic services.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: >
      What is the main difference between `#[Autowire(service: 'my_service')]` and `#[Target('my_service')]`?
    answers:
      - { value: "`#[Autowire]` explicitly injects a service by ID, bypassing autowiring, while `#[Target]` disambiguates autowiring when multiple services implement the same interface.", correct: true }
      - { value: "`#[Autowire]` is for parameters, `#[Target]` is for services.", correct: false }
      - { value: "They are functionally identical.", correct: false }
      - { value: "`#[Autowire]` is for constructor injection, `#[Target]` is for setter injection.", correct: false }
    help: |
      `#[Autowire(service: ...)]` is a direct instruction to inject a specific service. `#[Target(...)]` is used when autowiring would be ambiguous (multiple services of the same type), telling Symfony which *named* service to pick among them.
      https://symfony.com/doc/current/service_container/autowiring.html#injecting-specific-services-with-target

  -
    question: >
      What is the primary benefit of using autowiring for service dependencies?
    answers:
      - { value: "It reduces the amount of explicit configuration required for services, making service definitions more concise.", correct: true }
      - { value: "It makes services immutable by default.", correct: false }
      - { value: "It automatically generates service IDs.", correct: false }
      - { value: "It prevents circular dependencies.", correct: false }
    help: |
      Autowiring significantly reduces the verbosity of service configuration by automatically resolving dependencies based on type-hints.
      https://symfony.com/doc/current/service_container/autowiring.html#what-is-autowiring

  -
    question: >
      Which of the following is a valid way to define a service `App\Service\MyService` with a setter method `setMailer` that injects the `mailer` service in `config/services.php`?
    answers:
      - { value: "`$services->set(App\\Service\\MyService::class)->call('setMailer', [service('mailer')]);`", correct: true }
      - { value: "`$services->set(App\\Service\\MyService::class)->addCall('setMailer', service('mailer'));`", correct: false }
      - { value: "`$services->set(App\\Service\\MyService::class)->method('setMailer', service('mailer'));`", correct: false }
      - { value: "`$services->set(App\\Service\\MyService::class)->setter('setMailer', service('mailer'));`", correct: false }
    help: |
      In PHP service definitions using `ContainerConfigurator`, the `call()` method is used to configure setter injection.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: >
      What is the purpose of the `#[AutowireIterator]` attribute when used with an `array` type-hint?
    answers:
      - { value: "To inject all services tagged with a specific name as an array.", correct: true }
      - { value: "To inject a single service as an array.", correct: false }
      - { value: "To inject an array of parameters.", correct: false }
      - { value: "To inject a service locator.", correct: false }
    help: |
      `#[AutowireIterator]` can inject tagged services as either an `iterable` or an `array`, providing a convenient way to collect related services.
      https://symfony.com/doc/current/service_container/tags.html#autowiring-tagged-services

  -
    question: >
      When should you use `#[Autowire(expression: 'container.getEnv("APP_DEBUG") ? "debug_logger" : "prod_logger"')]`?
    answers:
      - { value: "When you need to conditionally inject a service or value based on an environment variable or other runtime logic.", correct: true }
      - { value: "When you want to inject a service that is always debug-specific.", correct: false }
      - { value: "When you want to inject a service that is always production-specific.", correct: false }
      - { value: "When you are defining a synthetic service.", correct: false }
    help: |
      Using an expression with `#[Autowire]` allows for dynamic dependency resolution, such as injecting different services based on the application environment.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-expression

  -
    question: >
      What is the primary difference between a service definition in `services.yaml` and a service registered directly via `ContainerBuilder` in PHP?
    answers:
      - { value: "YAML definitions are parsed and compiled, while `ContainerBuilder` calls are programmatic and can be more dynamic during the build process.", correct: true }
      - { value: "YAML definitions are always public, PHP definitions are always private.", correct: false }
      - { value: "YAML supports autowiring, PHP does not.", correct: false }
      - { value: "There is no functional difference; it's just a matter of preference.", correct: false }
    help: |
      YAML (and XML) are declarative configuration formats that are parsed into `Definition` objects. Direct `ContainerBuilder` calls in PHP allow for more programmatic and conditional service registration during the container's build phase.
      https://symfony.com/doc/current/components/dependency_injection.html#loading-service-definitions

  -
    question: >
      Which of the following is true about the `#[AutowireLocator]` attribute?
    answers:
      - { value: "It automatically creates a service locator for a collection of services, typically based on a tag or explicit service IDs.", correct: true }
      - { value: "It injects a single service instance.", correct: false }
      - { value: "It is used to define a factory for services.", correct: false }
      - { value: "It replaces the need for `ServiceSubscriberInterface`.", correct: false }
    help: |
      `#[AutowireLocator]` simplifies the creation and injection of service locators, allowing you to define a map of services that can be retrieved on demand.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#autowirelocator

  -
    question: >
      What is the purpose of the `ContainerBuilder::addMethodCall()` method when defining a service programmatically?
    answers:
      - { value: "To configure a method to be called on the service instance after it has been instantiated, typically for setter injection or initialization.", correct: true }
      - { value: "To define a static method that creates the service instance.", correct: false }
      - { value: "To add a new method to the service class at runtime.", correct: false }
      - { value: "To call a method on another service.", correct: false }
    help: |
      `addMethodCall()` is used to specify methods that should be invoked on the service object after its construction, often for injecting dependencies via setters or performing other initialization tasks.
      https://symfony.com/doc/current/components/dependency_injection.html#method-calls

  -
    question: >
      When defining a service, what is the effect of setting `abstract: true`?
    answers:
      - { value: "It marks the service definition as a template that cannot be instantiated directly but can be inherited by other services using `parent`.", correct: true }
      - { value: "It makes the service class an abstract PHP class.", correct: false }
      - { value: "It prevents the service from being autowired.", correct: false }
      - { value: "It makes the service lazy-loaded.", correct: false }
    help: |
      An abstract service definition serves as a template. It cannot be instantiated itself but provides a base configuration that other services can inherit from using the `parent` keyword.
      https://symfony.com/doc/current/service_container/parent_services.html#abstract-services

  -
    question: >
      Which of the following is a valid way to define a parameter in `config/services.xml`?
    answers:
      - { value: "`<parameters><parameter key=\"my_param\">value</parameter></parameters>`", correct: true }
      - { value: "`<param name=\"my_param\">value</param>`", correct: false }
      - { value: "`<parameter id=\"my_param\">value</parameter>`", correct: false }
      - { value: "`<config><param key=\"my_param\">value</param></config>`", correct: false }
    help: |
      In XML service definitions, parameters are defined within the `<parameters>` tag using `<parameter key="name">value</parameter>`.
      https://symfony.com/doc/current/components/dependency_injection.html#xml-configuration

  -
    question: >
      What is the purpose of the `service()` helper function in PHP service definitions (e.g., `args([service('my_service')])`)?
    answers:
      - { value: "It provides a concise way to reference another service as an argument.", correct: true }
      - { value: "It defines a new service.", correct: false }
      - { value: "It retrieves a service at runtime.", correct: false }
      - { value: "It marks a service as public.", correct: false }
    help: |
      The `service()` helper function (available in `ContainerConfigurator` contexts) is a shorthand for creating a `Reference` to another service, making PHP configuration more readable.
      https://symfony.com/doc/current/components/dependency_injection.html#php-configuration

  -
    question: >
      What is the effect of setting `autowire: true` for a service that has explicit `arguments` defined?
    answers:
      - { value: "Explicitly defined `arguments` will take precedence over autowiring for those specific arguments.", correct: true }
      - { value: "Autowiring will override all explicit `arguments`.", correct: false }
      - { value: "An error will be thrown due to conflicting configurations.", correct: false }
      - { value: "The service will be ignored by the container.", correct: false }
    help: |
      When both autowiring and explicit arguments are present, explicit arguments always take precedence for the parameters they define. Autowiring will only apply to arguments not explicitly configured.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-and-explicit-arguments

  -
    question: >
      Which of the following is true about injecting `Psr\Container\ContainerInterface` directly into a service?
    answers:
      - { value: "It is generally discouraged as it leads to the Service Locator anti-pattern, making dependencies less explicit.", correct: true }
      - { value: "It is the recommended way to access all services from within another service.", correct: false }
      - { value: "It automatically makes all services public.", correct: false }
      - { value: "It is only allowed for root services.", correct: false }
    help: |
      Injecting the full `ContainerInterface` directly into a service is considered an anti-pattern (Service Locator) because it hides dependencies and makes the service harder to test and understand. Service Locators (via `ServiceSubscriberInterface`) are a more controlled alternative for specific use cases.
      https://symfony.com/doc/current/service_container/service_subscribers_locators.html#when-to-use-service-locators

  -
    question: >
      What is the purpose of the `#[Autowire(env: 'bool:APP_DEBUG')]` attribute?
    answers:
      - { value: "To inject the `APP_DEBUG` environment variable, casting its value to a boolean.", correct: true }
      - { value: "To inject the `APP_DEBUG` environment variable as a string.", correct: false }
      - { value: "To inject a service named `bool:APP_DEBUG`.", correct: false }
      - { value: "To define a boolean parameter named `APP_DEBUG`.", correct: false }
    help: |
      The `env` parameter of `#[Autowire]` supports processors (like `bool:`, `int:`, `float:`, `json:`) to cast the environment variable's string value to a specific PHP type.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-env

  -
    question: >
      Which of the following is a valid way to define a service `App\Service\MyService` in `config/services.xml` with a constructor argument that is another service `mailer`?
    answers:
      - { value: "`<service id=\"App\\Service\\MyService\"><argument type=\"service\" id=\"mailer\"/></service>`", correct: true }
      - { value: "`<service id=\"App\\Service\\MyService\" arguments=\"@mailer\"/>`", correct: false }
      - { value: "`<service id=\"App\\Service\\MyService\"><constructor-arg service=\"mailer\"/></service>`", correct: false }
      - { value: "`<service id=\"App\\Service\\MyService\"><arg service=\"mailer\"/></service>`", correct: false }
    help: |
      In XML service definitions, constructor arguments are defined using the `<argument>` tag with `type="service"` and `id` attributes.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: >
      What is the significance of the `services:` key in `config/services.yaml`?
    answers:
      - { value: "It is the top-level key under which all service definitions are placed.", correct: true }
      - { value: "It defines a list of all built-in Symfony services.", correct: false }
      - { value: "It specifies the version of the service container.", correct: false }
      - { value: "It is used for defining service tags only.", correct: false }
    help: |
      The `services:` key is the root element in Symfony's YAML service configuration files, containing all service definitions.
      https://symfony.com/doc/current/service_container.html#service-configuration

  -
    question: >
      What is the purpose of the `bind` keyword in `services.yaml`?
    answers:
      - { value: "To automatically inject specific services or parameters into constructor arguments or setter methods based on their names or types, without explicit `arguments` or `calls`.", correct: true }
      - { value: "To create an alias for a service.", correct: false }
      - { value: "To define a factory for a service.", correct: false }
      - { value: "To mark a service as lazy-loaded.", correct: false }
    help: |
      The `bind` keyword allows you to automatically inject specific services or parameters into constructor arguments or setter methods across multiple services, reducing repetitive configuration.
      https://symfony.com/doc/current/service_container/autowiring.html#binding-arguments-by-name-or-type

  -
    question: >
      Which of the following is a valid way to use `bind` to inject a specific logger channel into any service that type-hints `LoggerInterface` with an argument named `$appLogger`?
    answers:
      - { value: "`_defaults: { bind: { Psr\\Log\\LoggerInterface $appLogger: '@monolog.logger.app' } }`", correct: true }
      - { value: "`_defaults: { bind: { $appLogger: '@monolog.logger.app' } }`", correct: false }
      - { value: "`_defaults: { bind: { LoggerInterface: '@monolog.logger.app' } }`", correct: false }
      - { value: "`_defaults: { bind: { appLogger: '@monolog.logger.app' } }`", correct: false }
    help: |
      `bind` can map a specific service to a type-hinted argument name. The syntax `TypeHint $argumentName` is used to specify this binding.
      https://symfony.com/doc/current/service_container/autowiring.html#binding-arguments-by-name-or-type

  -
    question: >
      What is the purpose of the `_defaults` section in `services.yaml`?
    answers:
      - { value: "To define default configuration options (like autowire, public, tags, bind) that apply to all services defined in that file or section.", correct: true }
      - { value: "To define parameters that are used as default values for services.", correct: false }
      - { value: "To specify default environment variables.", correct: false }
      - { value: "To define default aliases for services.", correct: false }
    help: |
      The `_defaults` section allows you to set common configuration options for a group of services, reducing repetition and making configuration more manageable.
      https://symfony.com/doc/current/service_container.html#default-service-configuration

  -
    question: >
      When defining a service, what is the effect of setting `autowire: true` and `autoconfigure: true`?
    answers:
      - { value: "Autowire enables automatic dependency injection by type-hint, and autoconfigure applies automatic tags and method calls based on interfaces/attributes.", correct: true }
      - { value: "They are synonyms and have the same effect.", correct: false }
      - { value: "Autowire is for parameters, autoconfigure is for services.", correct: false }
      - { value: "Autowire applies to constructor, autoconfigure to setters.", correct: false }
    help: |
      Autowire handles the injection of dependencies. Autoconfigure automatically applies common configurations (like adding tags for event listeners or console commands) based on the service's class or implemented interfaces.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-autoconfiguration

  -
    question: >
      Which of the following is true about using `#[Autowire]` with a `service` parameter?
    answers:
      - { value: "It explicitly tells Symfony to inject the service identified by the given ID, overriding autowiring rules for that specific argument.", correct: true }
      - { value: "It defines a new service with the given ID.", correct: false }
      - { value: "It makes the service lazy-loaded.", correct: false }
      - { value: "It is only used for injecting private services.", correct: false }
    help: |
      The `service` parameter in `#[Autowire]` provides a direct way to specify which service to inject, useful for disambiguation or when autowiring is not desired for a particular dependency.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-service

  -
    question: >
      What is the primary benefit of using `#[Required]` attribute for setter injection over configuring it in YAML/XML?
    answers:
      - { value: "It makes the dependency explicit in the PHP code, improving readability and discoverability for developers.", correct: true }
      - { value: "It makes the setter method private.", correct: false }
      - { value: "It forces the service to be a singleton.", correct: false }
      - { value: "It prevents the service from being decorated.", correct: false }
    help: |
      Placing `#[Required]` directly on the setter method makes the dependency requirement visible in the class itself, which is often preferred for clarity and developer experience.
      https://symfony.com/doc/current/service_container/autowiring.html#autowiring-setter-injection-with-required

  -
    question: >
      When is it appropriate to use `Symfony\Component\DependencyInjection\Reference` in PHP service definitions?
    answers:
      - { value: "When you are manually defining service arguments or method calls and need to inject another service by its ID.", correct: true }
      - { value: "When you want to retrieve a service from the container at runtime.", correct: false }
      - { value: "When you are defining a parameter.", correct: false }
      - { value: "When you are using autowiring for all dependencies.", correct: false }
    help: |
      `Reference` objects are used in programmatic service definitions (e.g., with `ContainerBuilder` or `Definition` objects) to indicate that an argument or method call should inject another service.
      https://symfony.com/doc/current/components/dependency_injection.html#referencing-services

  -
    question: >
      What is the effect of setting `public: true` for a service?
    answers:
      - { value: "It makes the service accessible directly from the container using `$container->get()`, and it can be injected into other services.", correct: true }
      - { value: "It makes the service a singleton.", correct: false }
      - { value: "It forces the service to be autowired.", correct: false }
      - { value: "It prevents the service from being decorated.", correct: false }
    help: |
      A public service can be retrieved directly from the container using its ID. By default, services are public unless explicitly set to `public: false`.
      https://symfony.com/doc/current/service_container/alias_private.html#private-services

  -
    question: >
      Which of the following is the correct way to define a service `App\Service\MyService` in `config/services.xml` with a setter method `setLogger` that injects the `logger` service?
    answers:
      - { value: "`<service id=\"App\\Service\\MyService\"><call method=\"setLogger\"><argument type=\"service\" id=\"logger\"/></call></service>`", correct: true }
      - { value: "`<service id=\"App\\Service\\MyService\" setter=\"setLogger\" service=\"logger\"/>`", correct: false }
      - { value: "`<service id=\"App\\Service\\MyService\"><method name=\"setLogger\" service=\"logger\"/></service>`", correct: false }
      - { value: "`<service id=\"App\\Service\\MyService\"><argument method=\"setLogger\" service=\"logger\"/></service>`", correct: false }
    help: |
      In XML service definitions, setter injection is configured using the `<call>` tag with a `method` attribute, and the argument is defined within an `<argument>` tag.
      https://symfony.com/doc/current/service_container/injection_types.html#setter-injection

  -
    question: >
      What is the primary role of the `ContainerBuilder` in the Symfony Dependency Injection component?
    answers:
      - { value: "It is the mutable container used during the compilation phase to define, register, and modify service definitions.", correct: true }
      - { value: "It is the immutable container used at runtime to retrieve services.", correct: false }
      - { value: "It is responsible for handling HTTP requests.", correct: false }
      - { value: "It is a tool for managing database connections.", correct: false }
    help: |
      The `ContainerBuilder` is the central object during the container's build process, allowing for the programmatic definition and manipulation of service definitions before the container is compiled into its optimized runtime version.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      When configuring a service, what is the purpose of the `class` option?
    answers:
      - { value: "To explicitly specify the fully qualified class name of the service.", correct: true }
      - { value: "To define the service ID.", correct: false }
      - { value: "To make the service abstract.", correct: false }
      - { value: "To enable autowiring for the service.", correct: false }
    help: |
      The `class` option explicitly defines the PHP class that the service will instantiate. This is particularly important when the service ID does not directly match the class name or when autowiring is not used.
      https://symfony.com/doc/current/service_container.html#basic-service-configuration

  -
    question: >
      Which of the following is a valid way to define a service `App\Service\MyService` with a public property `mailer` that is injected with the `mailer` service in `config/services.xml`?
    answers:
      - { value: "`<service id=\"App\\Service\\MyService\"><property name=\"mailer\" type=\"service\" id=\"mailer\"/></service>`", correct: true }
      - { value: "`<service id=\"App\\Service\\MyService\" property=\"mailer\" service=\"mailer\"/>`", correct: false }
      - { value: "`<service id=\"App\\Service\\MyService\"><set-property name=\"mailer\" service=\"mailer\"/></service>`", correct: false }
      - { value: "`<service id=\"App\\Service\\MyService\"><argument property=\"mailer\" service=\"mailer\"/></service>`", correct: false }
    help: |
      In XML service definitions, property injection is configured using the `<property>` tag with `name`, `type="service"`, and `id` attributes.
      https://symfony.com/doc/current/service_container/injection_types.html#property-injection

  -
    question: >
      What is the purpose of the `alias` keyword in service definitions?
    answers:
      - { value: "To provide an alternative name for an existing service, allowing it to be referenced by multiple IDs.", correct: true }
      - { value: "To create a new instance of a service with a different name.", correct: false }
      - { value: "To make a service private.", correct: false }
      - { value: "To define a service that is a copy of another service.", correct: false }
    help: |
      An alias allows a service to be referred to by more than one ID. This is useful for providing a shorter or more descriptive name for a service, or for backward compatibility.
      https://symfony.com/doc/current/service_container/alias_private.html#aliasing-services

  -
    question: >
      Which of the following is true about the `#[Autowire]` attribute's `expression` parameter?
    answers:
      - { value: "The expression is evaluated by the Symfony Expression Language component at compile time.", correct: true }
      - { value: "The expression is a regular PHP expression evaluated at runtime.", correct: false }
      - { value: "The expression can only reference parameters, not services.", correct: false }
      - { value: "The expression is used to define a new service.", correct: false }
    help: |
      Expressions within `#[Autowire]` are parsed and evaluated by the Symfony Expression Language component during the container compilation process, allowing for powerful dynamic value injection.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-expression

  -
    question: >
      What is the main benefit of using PHP for service definitions compared to YAML or XML?
    answers:
      - { value: "It allows for more complex, conditional, and programmatic service definitions using full PHP logic.", correct: true }
      - { value: "It is always faster to load than YAML or XML.", correct: false }
      - { value: "It prevents autowiring from being used.", correct: false }
      - { value: "It is the only format that supports service tags.", correct: false }
    help: |
      PHP configuration files offer the most flexibility, allowing you to use conditional logic, loops, and other PHP features to dynamically define services, which is not possible with static YAML or XML.
      https://symfony.com/doc/current/components/dependency_injection.html#php-configuration

  -
    question: >
      When defining a service, what is the purpose of the `file` option?
    answers:
      - { value: "To specify the path to the PHP file containing the service's class definition, if it's not discoverable by the autoloader.", correct: true }
      - { value: "To define the configuration file for the service.", correct: false }
      - { value: "To specify the log file for the service.", correct: false }
      - { value: "To define a temporary file for the service's operations.", correct: false }
    help: |
      The `file` option is rarely needed in modern Symfony applications due to Composer's autoloader, but it can be used to explicitly point to the PHP file where the service's class is defined.
      https://symfony.com/doc/current/service_container.html#the-file-option

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Container::has()` method?
    answers:
      - { value: "To check if a service or parameter with a given ID exists in the container.", correct: true }
      - { value: "To check if a service has any dependencies.", correct: false }
      - { value: "To check if a service is public.", correct: false }
      - { value: "To check if a service has been instantiated.", correct: false }
    help: |
      The `has()` method allows you to safely check for the existence of a service or parameter by its ID without attempting to retrieve it, which would throw an exception if it doesn't exist.
      https://symfony.com/doc/current/service_container.html#retrieving-services

  -
    question: >
      Which of the following is true about the `Symfony\Component\DependencyInjection\Container::get()` method for retrieving services?
    answers:
      - { value: "It throws a `ServiceNotFoundException` if the requested service does not exist or is private.", correct: true }
      - { value: "It returns `null` if the service is not found.", correct: false }
      - { value: "It automatically instantiates the service even if it's lazy-loaded.", correct: false }
      - { value: "It can only retrieve public services.", correct: true }
    help: |
      The `get()` method is used to retrieve services. It will throw a `ServiceNotFoundException` if the service ID is unknown or if the service is private. It can only retrieve public services.
      https://symfony.com/doc/current/service_container.html#retrieving-services

  -
    question: >
      What is the main difference between `arguments` and `calls` in a service definition?
    answers:
      - { value: "`arguments` are passed to the service's constructor, while `calls` invoke methods on the service instance after construction.", correct: true }
      - { value: "`arguments` are for parameters, `calls` are for services.", correct: false }
      - { value: "`arguments` are for public properties, `calls` are for private properties.", correct: false }
      - { value: "They are interchangeable and serve the same purpose.", correct: false }
    help: |
      `arguments` define the dependencies injected via the constructor. `calls` define methods that are invoked on the service object after it has been created, typically for setter injection or other initialization logic.
      https://symfony.com/doc/current/service_container/injection_types.html

  -
    question: >
      When is it appropriate to use a "synthetic" service?
    answers:
      - { value: "When a service instance is created externally (e.g., by a third-party library or a legacy system) and needs to be made available in the container.", correct: true }
      - { value: "When a service is very simple and has no dependencies.", correct: false }
      - { value: "When you want to prevent a service from being garbage collected.", correct: false }
      - { value: "When you need to define a service that is always lazy-loaded.", correct: false }
    help: |
      Synthetic services are useful for integrating external objects into the Dependency Injection Container that are not instantiated by the container itself.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: >
      Which of the following is true about the `Symfony\Component\DependencyInjection\Container::hasParameter()` method?
    answers:
      - { value: "It checks if a parameter with the given name exists in the container.", correct: true }
      - { value: "It checks if a service has a parameter.", correct: false }
      - { value: "It retrieves the value of a parameter.", correct: false }
      - { value: "It checks if a parameter is public.", correct: false }
    help: |
      The `hasParameter()` method allows you to verify the existence of a parameter by its name in the container.
      https://symfony.com/doc/current/service_container/parameters.html

  -
    question: >
      What is the main purpose of the `Symfony\Component\DependencyInjection\Extension\PrependExtensionInterface`?
    answers:
      - { value: "It allows a bundle's extension to modify the configuration of other bundles' extensions before they are loaded.", correct: true }
      - { value: "It allows a bundle to define its own default configuration.", correct: false }
      - { value: "It defines the interface for all service container extensions.", correct: false }
      - { value: "It provides methods for loading configuration files.", correct: false }
    help: |
      Implementing `PrependExtensionInterface` enables a bundle to "prepend" configuration to other bundles, allowing it to influence their default settings or provide necessary configurations that other bundles might rely on.
      https://symfony.com/doc/current/bundles/prepend_extension.html

  -
    question: >
      Which of the following describes the behavior of a service defined with `deprecated: true`?
    answers:
      - { value: "It marks the service as deprecated, triggering a deprecation warning when the service is used.", correct: true }
      - { value: "It prevents the service from being instantiated.", correct: false }
      - { value: "It automatically removes the service from the container.", correct: false }
      - { value: "It makes the service private.", correct: false }
    help: |
      The `deprecated: true` option is used to mark a service as deprecated, which helps developers identify and update their code to use newer alternatives.
      https://symfony.com/doc/current/service_container/deprecated_services.html

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Container::getParameter()` method?
    answers:
      - { value: "To retrieve the value of a parameter by its name from the container.", correct: true }
      - { value: "To define a new parameter.", correct: false }
      - { value: "To retrieve a service by its ID.", correct: false }
      - { value: "To check if a parameter exists.", correct: false }
    help: |
      The `getParameter()` method is used to retrieve the value of a previously defined container parameter.
      https://symfony.com/doc/current/service_container/parameters.html

  -
    question: >
      What is the primary benefit of using "bindings" in `services.yaml`?
    answers:
      - { value: "To reduce repetitive configuration for common dependencies by automatically injecting them based on type-hinted argument names or types.", correct: true }
      - { value: "To create aliases for services.", correct: false }
      - { value: "To define services that are always lazy-loaded.", correct: false }
      - { value: "To make services public by default.", correct: false }
    help: |
      Bindings allow you to define a mapping between argument names/types and specific services or parameters, which Symfony will automatically apply during autowiring, significantly reducing boilerplate configuration.
      https://symfony.com/doc/current/service_container/autowiring.html#binding-arguments-by-name-or-type

  -
    question: >
      Which of the following is true about the `Symfony\Component\DependencyInjection\ContainerBuilder::addDefinitions()` method?
    answers:
      - { value: "It adds an array of service definitions to the container builder.", correct: true }
      - { value: "It adds a single service definition.", correct: false }
      - { value: "It adds an array of parameters.", correct: false }
      - { value: "It adds an array of compiler passes.", correct: false }
    help: |
      The `addDefinitions()` method allows you to add multiple service definitions (as `Definition` objects) to the `ContainerBuilder` at once.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Definition` class?
    answers:
      - { value: "It represents a single service definition within the container, holding all its configuration (class, arguments, calls, tags, etc.).", correct: true }
      - { value: "It is the main container class.", correct: false }
      - { value: "It is used to retrieve services at runtime.", correct: false }
      - { value: "It is a factory for creating services.", correct: false }
    help: |
      A `Definition` object encapsulates all the information required to create and configure a service, including its class, constructor arguments, method calls, and tags.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html#service-definition

  -
    question: >
      Which of the following is a valid way to define a service `App\Service\MyService` in `config/services.php`?
    answers:
      - { value: "`$services->set(App\\Service\\MyService::class);`", correct: true }
      - { value: "`$services->add(App\\Service\\MyService::class);`", correct: false }
      - { value: "`$services->define(App\\Service\\MyService::class);`", correct: false }
      - { value: "`$services->register(App\\Service\\MyService::class);`", correct: false }
    help: |
      In PHP service definitions using `ContainerConfigurator`, the `set()` method is used to define a new service.
      https://symfony.com/doc/current/components/dependency_injection.html#php-configuration

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\ContainerBuilder::compile()` method?
    answers:
      - { value: "To finalize the container, run all compiler passes, and optimize the service definitions for production use.", correct: true }
      - { value: "To add new services to the container.", correct: false }
      - { value: "To retrieve services from the container.", correct: false }
      - { value: "To load configuration files.", correct: false }
    help: |
      The `compile()` method triggers the container's compilation process, which includes running compiler passes, optimizing definitions, and preparing the container for efficient runtime use.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      Which of the following is true about the `#[Autowire]` attribute when used with `expression`?
    answers:
      - { value: "It allows for injecting values that are not directly services or parameters, but results of arbitrary logic.", correct: true }
      - { value: "It can only be used with simple string expressions.", correct: false }
      - { value: "It makes the service a factory.", correct: false }
      - { value: "It prevents the service from being autowired by type.", correct: false }
    help: |
      The `expression` parameter of `#[Autowire]` provides significant flexibility, enabling injection of complex values derived from Symfony Expression Language.
      https://symfony.com/doc/current/service_container/autowiring.html#autowire-expression

  -
    question: >
      What is the primary role of the `Symfony\Component\DependencyInjection\Extension\ExtensionInterface`?
    answers:
      - { value: "It defines the interface for bundle extensions, allowing them to load configuration and service definitions into the container.", correct: true }
      - { value: "It defines the interface for all services.", correct: false }
      - { value: "It defines the interface for compiler passes.", correct: false }
      - { value: "It defines the interface for parameters.", correct: false }
    help: |
      Bundle extensions implement `ExtensionInterface` to integrate their configuration and services into the main application's Dependency Injection Container.
      https://symfony.com/doc/current/bundles/extension.html#loading-configuration

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Container::initialized()` method?
    answers:
      - { value: "To check if a service has already been instantiated by the container.", correct: true }
      - { value: "To check if the container itself has been initialized.", correct: false }
      - { value: "To trigger the instantiation of a service.", correct: false }
      - { value: "To check if a service is lazy-loaded.", correct: false }
    help: |
      The `initialized()` method can be used to determine if a specific service has already been created by the container, which can be useful for debugging or specific logic.
      https://symfony.com/doc/current/service_container.html#retrieving-services

  -
    question: >
      Which of the following is true about service IDs in Symfony?
    answers:
      - { value: "They are unique identifiers for services within the container.", correct: true }
      - { value: "They must always match the fully qualified class name of the service.", correct: false }
      - { value: "They are case-insensitive.", correct: false }
      - { value: "They are only used for private services.", correct: false }
    help: |
      Service IDs are unique strings that identify services within the container, allowing them to be referenced and injected. While often the FQCN, they can be any unique string.
      https://symfony.com/doc/current/service_container.html#service-ids

  -
    question: >
      What is the purpose of the `#[Autowire(service: 'monolog.logger.request')]` attribute in a controller method argument?
    answers:
      - { value: "To inject a specific named logger channel into the controller method.", correct: true }
      - { value: "To make the `LoggerInterface` optional.", correct: false }
      - { value: "To prevent any logger from being injected.", correct: false }
      - { value: "To define a new logger service.", correct: false }
    help: |
      In controller arguments, `#[Autowire(service: ...)]` allows you to explicitly specify which service (by its ID) should be injected, which is crucial when multiple services implement the same interface.
      https://symfony.com/doc/current/controller.html#autowiring-specific-services-or-parameters

  -
    question: >
      What is the key benefit of using constructor injection over setter or property injection for mandatory dependencies?
    answers:
      - { value: "It ensures that the service is always in a valid state after instantiation, as all required dependencies are provided at creation time.", correct: true }
      - { value: "It allows for lazy loading of dependencies.", correct: false }
      - { value: "It makes the service immutable by default.", correct: false }
      - { value: "It simplifies the configuration of optional dependencies.", correct: false }
    help: |
      Constructor injection guarantees that all essential dependencies are present when an object is created, making the object's state predictable and valid from the start.
      https://symfony.com/doc/current/service_container/injection_types.html#constructor-injection

  -
    question: >
      Which of the following is true about the `Symfony\Component\DependencyInjection\Container::getRemovedIds()` method?
    answers:
      - { value: "It returns an array of service IDs that were removed during the container compilation process.", correct: true }
      - { value: "It returns an array of services that are no longer used.", correct: false }
      - { value: "It removes services from the container at runtime.", correct: false }
      - { value: "It returns an array of private services.", correct: false }
    help: |
      `getRemovedIds()` can be useful for debugging compiler passes or understanding which services were optimized away during compilation.
      https://symfony.com/doc/current/components/dependency_injection/compilation.html

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Container::set()` method when dealing with synthetic services?
    answers:
      - { value: "To inject an already instantiated object into the container, making it available as a service under a specific ID.", correct: true }
      - { value: "To define a new service in the container.", correct: false }
      - { value: "To retrieve a service from the container.", correct: false }
      - { value: "To modify an existing service definition.", correct: false }
    help: |
      For synthetic services, `set()` is the mechanism by which an external object instance is provided to the container, rather than the container instantiating it.
      https://symfony.com/doc/current/service_container/synthetic_services.html

  -
    question: >
      Which of the following describes a "circular dependency" in the context of Dependency Injection?
    answers:
      - { value: "When two or more services directly or indirectly depend on each other, forming a loop that prevents their successful instantiation.", correct: true }
      - { value: "When a service has too many dependencies.", correct: false }
      - { value: "When a service is configured to be both public and private.", correct: false }
      - { value: "When a service is decorated multiple times.", correct: false }
    help: |
      Circular dependencies occur when service A needs service B, and service B needs service A (or a chain of services leading back to A), making it impossible for the container to create either without the other.
      https://symfony.com/doc/current/service_container/circular_dependencies.html

  -
    question: >
      How can circular dependencies sometimes be resolved in Symfony?
    answers:
      - { value: "By using setter injection for one of the dependencies, making it optional during initial construction.", correct: true }
      - { value: "By making both services private.", correct: false }
      - { value: "By making both services lazy-loaded.", correct: true }
      - { value: "By increasing the priority of one of the services.", correct: false }
    help: |
      Circular dependencies can often be resolved by breaking the cycle, for example, by using setter injection for one of the dependencies (if it's not strictly required in the constructor) or by making one of the services lazy-loaded (e.g., via a service closure).
      https://symfony.com/doc/current/service_container/circular_dependencies.html

  -
    question: >
      What is the primary role of the `Symfony\Component\DependencyInjection\Container::getServiceIds()` method?
    answers:
      - { value: "To retrieve an array of all public service IDs currently available in the container.", correct: true }
      - { value: "To retrieve an array of all private service IDs.", correct: false }
      - { value: "To retrieve an array of all parameters.", correct: false }
      - { value: "To retrieve an array of all compiler passes.", correct: false }
    help: |
      The `getServiceIds()` method provides a list of all public service IDs that can be retrieved from the container.
      https://symfony.com/doc/current/service_container.html#retrieving-services

  -
    question: >
      What is the purpose of the `Symfony\Component\DependencyInjection\Container::hasService()` method?
    answers:
      - { value: "To check if a service with a given ID exists and is public.", correct: true }
      - { value: "To check if a service exists, regardless of its public/private status.", correct: false }
      - { value: "To check if a service has been instantiated.", correct: false }
      - { value: "To check if a service is lazy-loaded.", correct: false }
    help: |
      `hasService()` specifically checks for the existence of a *public* service by its ID. For any service (public or private), `has()` is more appropriate.
      https://symfony.com/doc/current/service_container.html#retrieving-services

  -
    question: >
      Which of the following is true about the default behavior of service autowiring in Symfony 7?
    answers:
      - { value: "It attempts to inject dependencies based on type-hints in constructors, setters, and public properties.", correct: true }
      - { value: "It only works for services defined in YAML files.", correct: false }
      - { value: "It requires explicit `#[Autowire]` attributes for all dependencies.", correct: false }
      - { value: "It is disabled by default in new Symfony projects.", correct: false }
    help: |
      Autowiring is a core feature in Symfony 7, enabled by default, and simplifies dependency injection by automatically resolving dependencies based on type-hints.
      https://symfony.com/doc/current/service_container/autowiring.html