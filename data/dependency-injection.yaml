category: Dependency Injection
questions:
  - question: What is the primary role of the Symfony Service Container?
    answers:
      - value: To manage the instantiation and dependencies of services.
        correct: true
      - value: To handle HTTP requests and responses.
        correct: false
      - value: To define database schema migrations.
        correct: false
      - value: To compile Twig templates into PHP code.
        correct: false
    help: The Symfony Service Container is a tool that manages the instantiation of
      services and injects their dependencies, promoting loose coupling and
      reusability.
  - question: Which of the following methods is used to retrieve a service from the
      container by its ID?
    answers:
      - value: "`$container->get('service_id')`"
        correct: true
      - value: "`$container->find('service_id')`"
        correct: false
      - value: "`$container->load('service_id')`"
        correct: false
      - value: "`$container->resolve('service_id')`"
        correct: false
    help: The `get()` method is used to retrieve a service instance from the
      container. This is typically discouraged in favor of autowiring or
      explicit injection.
  - question: In Symfony, what is the default scope for services defined in the
      container?
    answers:
      - value: Prototype (new instance every time)
        correct: false
      - value: Request (new instance per request)
        correct: false
      - value: Singleton (shared, one instance per container)
        correct: true
      - value: Session (new instance per user session)
        correct: false
    help: By default, services in Symfony are 'shared' (singleton), meaning only one
      instance of the service is created and reused throughout the application's
      lifecycle for a given container.
  - question: |-
      Consider the following YAML service definition:

      ```yaml
      services:
          App\Service\MyService:
              public: false
      ```

      What is the implication of setting `public: false` for a service?
    answers:
      - value: The service cannot be retrieved directly using
          `$container->get('App\\Service\\MyService')`.
        correct: true
      - value: The service can only be injected via constructor arguments.
        correct: false
      - value: The service will not be autowired.
        correct: false
      - value: The service will be lazily loaded.
        correct: false
    help: "Setting a service to `public: false` (private) means it cannot be
      accessed directly from the container using `get()`. It can only be
      injected as a dependency into other services."
  - question: Which of the following is a valid way to define a service in Symfony
      using PHP attributes?
    answers:
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\DependencyInjection\Attribute\AsService;

          #[AsService]
          class MyService
          {
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\DependencyInjection\Attribute\Service;

          #[Service]
          class MyService
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\DependencyInjection\Attribute\RegisterService;

          #[RegisterService]
          class MyService
          {
              // ...
          }
          ```
        correct: false
    help: The `#[AsService]` attribute is used to register a class as a service in
      Symfony 7.0.
  - question: >-
      Given the following PHP class:


      ```php

      namespace App\Service;


      use App\Mailer\MailerInterface;


      class NewsletterManager

      {
          public function __construct(
              private MailerInterface $mailer,
          ) {}
      }

      ```


      How would you configure this service for constructor injection in
      `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\NewsletterManager:
                  arguments: ['@App\\Mailer\\MailerInterface']
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\NewsletterManager:
                  calls:
                      - setMailer: ['@App\\Mailer\\MailerInterface']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\NewsletterManager:
                  properties:
                      mailer: '@App\\Mailer\\MailerInterface'
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\NewsletterManager:
                  autowire: true
          ```
        correct: true
    help: "For constructor injection, you can either explicitly define arguments
      using `arguments: ['@service_id']` or rely on autowiring if enabled, which
      will automatically inject the `MailerInterface`."
  - question: Which attribute should be used on a setter method to ensure it's
      called by autowiring for an optional dependency?
    answers:
      - value: "`#[Required]`"
        correct: true
      - value: "`#[Optional]`"
        correct: false
      - value: "`#[Autowire]`"
        correct: false
      - value: "`#[Inject]`"
        correct: false
    help: The `#[Required]` attribute marks a setter method as mandatory for
      autowiring, ensuring the dependency is provided. If the dependency cannot
      be resolved, an error will be thrown.
  - question: What is 'immutable setter injection' (or 'wither injection') in
      Symfony, and how is it configured?
    answers:
      - value: It's a method that returns a new instance of the service with the
          dependency set, promoting immutability. Configured with
          `!returns_clone` in YAML or `returns-clone="true"` in XML.
        correct: true
      - value: It's a setter method that modifies the current instance and returns
          `void`. Configured with `calls:` in YAML.
        correct: false
      - value: It's a constructor argument that is marked as optional. Configured with
          `#[Optional]` attribute.
        correct: false
      - value: It's a public property that is directly assigned a dependency. Configured
          with `properties:` in YAML.
        correct: false
    help: Immutable setter injection involves a method that clones the object, sets
      the dependency on the new instance, and returns the cloned instance.
      Symfony needs to be told to use the returned clone, which is done via
      `!returns_clone` in YAML or `returns-clone="true"` in XML.
  - question: >-
      Consider the following PHP class:


      ```php

      namespace App\Service;


      use Psr\Log\LoggerInterface;

      use Symfony\Contracts\Service\Attribute\Required;


      class MyService

      {
          #[Required]
          public LoggerInterface $logger;

          // ...
      }

      ```


      What type of injection is demonstrated here, and what is the role of
      `#[Required]`?
    answers:
      - value: Property injection; `#[Required]` ensures the `logger` property is
          autowired.
        correct: true
      - value: Constructor injection; `#[Required]` makes the constructor argument
          mandatory.
        correct: false
      - value: Setter injection; `#[Required]` forces the `setLogger` method to be
          called.
        correct: false
      - value: Method injection; `#[Required]` indicates the method must be called after
          instantiation.
        correct: false
    help: This is property injection. The `#[Required]` attribute ensures that
      Symfony's autowiring mechanism will attempt to inject a `LoggerInterface`
      into this public property.
  - question: How can you inject a service into a public property of another service
      using YAML configuration?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  properties:
                      myProperty: '@App\\Service\\AnotherService'
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  arguments:
                      - '@App\\Service\\AnotherService'
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  calls:
                      - setMyProperty: ['@App\\Service\\AnotherService']
          ```
        correct: false
    help: Property injection is configured using the `properties:` key in YAML
      service definitions, mapping the property name to the service ID.
  - question: Which of the following is the correct way to define a container
      parameter in `config/services.php`?
    answers:
      - value: |-
          ```php
          // config/services.php
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $container->parameters()
                  ->set('app.mailer.transport', 'sendmail');
          };
          ```
        correct: true
      - value: |-
          ```php
          // config/services.php
          use Symfony\Component\DependencyInjection\ContainerBuilder;

          $container = new ContainerBuilder();
          $container->addParameter('app.mailer.transport', 'sendmail');
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          $parameters['app.mailer.transport'] = 'sendmail';
          ```
        correct: false
    help: In PHP service configuration files using `ContainerConfigurator`,
      parameters are defined via `$container->parameters()->set('name',
      'value');`.
  - question: How would you inject the value of the `kernel.project_dir` parameter
      into a service's constructor using PHP attributes?
    answers:
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire('%kernel.project_dir%')]
                  string $projectDir
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Inject;

          class MyService
          {
              public function __construct(
                  #[Inject('kernel.project_dir')]
                  string $projectDir
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          class MyService
          {
              public function __construct(
                  string $projectDir = '%kernel.project_dir%'
              ) {}
          }
          ```
        correct: false
    help: The `#[Autowire]` attribute can be used to inject parameter values
      directly into constructor arguments or properties by specifying the
      parameter name with `%` delimiters.
  - question: What is the correct syntax to reference a container parameter named
      `app.upload_directory` in a YAML service definition?
    answers:
      - value: "`%app.upload_directory%`"
        correct: true
      - value: "`$app.upload_directory`"
        correct: false
      - value: "`@app.upload_directory`"
        correct: false
      - value: "`#app.upload_directory`"
        correct: false
    help: Container parameters are referenced using the `%parameter_name%` syntax in
      YAML, XML, and PHP configurations.
  - question: Which of the following built-in services provides access to the
      current request and its attributes?
    answers:
      - value: "`request_stack`"
        correct: true
      - value: "`http_kernel`"
        correct: false
      - value: "`router`"
        correct: false
      - value: "`event_dispatcher`"
        correct: false
    help: The `request_stack` service (an instance of
      `Symfony\Component\HttpFoundation\RequestStack`) is used to access the
      current request, especially in contexts where the request might not be
      directly available (e.g., in console commands or background processes).
  - question: You want to inject a specific logger channel, for example,
      `monolog.logger.security`, into your service. How would you achieve this
      using the `#[Autowire]` attribute?
    answers:
      - value: |-
          ```php
          use Psr\Log\LoggerInterface;
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(service: 'monolog.logger.security')]
                  LoggerInterface $securityLogger
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use Psr\Log\LoggerInterface;
          use Symfony\Component\DependencyInjection\Attribute\Target;

          class MyService
          {
              public function __construct(
                  #[Target('monolog.logger.security')]
                  LoggerInterface $securityLogger
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          use Psr\Log\LoggerInterface;

          class MyService
          {
              public function __construct(
                  LoggerInterface $monolog_logger_security
              ) {}
          }
          ```
        correct: false
    help: "The `#[Autowire(service: 'service_id')]` attribute allows you to
      explicitly specify which service ID should be injected, overriding
      autowiring's default behavior."
  - question: What is the primary purpose of autowiring in Symfony's Dependency
      Injection Component?
    answers:
      - value: To automatically inject dependencies into services based on type hints.
        correct: true
      - value: To automatically generate service definitions from class files.
        correct: false
      - value: To automatically compile the container for production.
        correct: false
      - value: To automatically register all classes as public services.
        correct: false
    help: Autowiring simplifies dependency injection by automatically identifying
      and injecting dependencies based on type hints in constructors, setter
      methods, or properties.
  - question: You have two services, `App\Service\SmsNotifier` and
      `App\Service\EmailNotifier`, both implementing
      `App\Notifier\NotifierInterface`. How can you autowire `SmsNotifier`
      specifically into a service's constructor using attributes?
    answers:
      - value: |-
          ```php
          use App\Notifier\NotifierInterface;
          use Symfony\Component\DependencyInjection\Attribute\Target;

          class MyService
          {
              public function __construct(
                  #[Target('App\\Service\\SmsNotifier')]
                  NotifierInterface $smsNotifier
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use App\Notifier\NotifierInterface;
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(service: 'App\\Service\\SmsNotifier')]
                  NotifierInterface $smsNotifier
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use App\Notifier\NotifierInterface;

          class MyService
          {
              public function __construct(
                  NotifierInterface $smsNotifier = new App\Service\SmsNotifier()
              ) {}
          }
          ```
        correct: false
    help: "Both `#[Target]` and `#[Autowire(service: ...)]` can be used to specify a
      particular service to inject when multiple services implement the same
      interface. `#[Target]` is specifically designed for this scenario, while
      `#[Autowire(service: ...)]` is more general for explicit service
      injection."
  - question: What is the purpose of the `#[AutowireIterator]` attribute?
    answers:
      - value: To inject all services tagged with a specific name as an `iterable` (or
          `array`).
        correct: true
      - value: To iterate over all available services in the container.
        correct: false
      - value: To automatically create a service for each item in an array.
        correct: false
      - value: To inject a single service repeatedly.
        correct: false
    help: The `#[AutowireIterator]` attribute simplifies collecting all services
      that have been tagged with a specific name, injecting them as an iterable
      collection (e.g., `iterable $handlers` or `array $handlers`).
  - question: You have multiple services tagged with `app.command_handler`. How can
      you inject them as an iterable collection into a constructor using
      `#[AutowireIterator]`?
    answers:
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\AutowireIterator;

          class CommandBus
          {
              public function __construct(
                  #[AutowireIterator('app.command_handler')]
                  private iterable $handlers
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class CommandBus
          {
              public function __construct(
                  #[Autowire(tag: 'app.command_handler')]
                  private iterable $handlers
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          class CommandBus
          {
              public function __construct(
                  private iterable $handlers
              ) {
                  // ... manually collect tagged services
              }
          }
          ```
        correct: false
    help: The `#[AutowireIterator('tag_name')]` attribute is the correct way to
      autowire a collection of services identified by a specific tag.
  - question: What is the primary purpose of service tags in Symfony's Dependency
      Injection Component?
    answers:
      - value: To allow services to be identified and collected by other services or
          Compiler Passes.
        correct: true
      - value: To define the visibility (public/private) of a service.
        correct: false
      - value: To specify the arguments for a service's constructor.
        correct: false
      - value: To mark services for lazy loading.
        correct: false
    help: Tags are metadata attached to services that allow the container to find
      and group related services, often used by Compiler Passes or for
      collecting services into an iterable.
  - question: How do you apply a tag named `app.event_subscriber` to a service using
      PHP attributes?
    answers:
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\AsService;

          #[AsService]
          #[AsService(tags: ['app.event_subscriber'])]
          class MySubscriber
          {
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Tag;

          #[Tag('app.event_subscriber')]
          class MySubscriber
          {
              // ...
          }
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

          #[AsEventListener]
          class MySubscriber
          {
              // ...
          }
          ```
        correct: false
    help: While `#[AsEventListener]` is specific for event listeners, for general
      tagging using `#[AsService]`, you can pass tags as an argument.
      Alternatively, you can use `#[Autoconfigure]` for more complex
      autoconfiguration rules including tags.
  - question: When would you typically use a Service Locator in Symfony?
    answers:
      - value: When you need to lazily load a subset of services that are not always
          needed.
        correct: true
      - value: As a general replacement for constructor injection for all dependencies.
        correct: false
      - value: To access private services directly from outside the container.
        correct: false
      - value: To define global application configuration.
        correct: false
    help: Service Locators are useful for injecting a collection of services that
      are only needed conditionally or lazily, avoiding injecting all of them
      upfront. They should be used sparingly to avoid the 'Service Locator
      anti-pattern'.
  - question: Which interface should a class implement to be recognized as a Service
      Locator in Symfony?
    answers:
      - value: "`Psr\\Container\\ContainerInterface`"
        correct: true
      - value: "`Symfony\\Contracts\\Service\\ServiceSubscriberInterface`"
        correct: true
      - value: "`Symfony\\Component\\DependencyInjection\\ContainerAwareInterface`"
        correct: false
      - value: "`Psr\\Container\\ServiceLocatorInterface`"
        correct: false
    help: A class can become a service locator by implementing
      `Psr\Container\ContainerInterface` or, more commonly in Symfony, by
      implementing `Symfony\Contracts\Service\ServiceSubscriberInterface` and
      defining the `getSubscribedServices()` method.
  - question: What is the purpose of the `getSubscribedServices()` method when
      implementing `ServiceSubscriberInterface`?
    answers:
      - value: It declares the services that the class might request from the service
          locator.
        correct: true
      - value: It registers the class itself as a service in the container.
        correct: false
      - value: It defines the public methods available on the service locator.
        correct: false
      - value: It specifies the compiler passes to be executed for the service locator.
        correct: false
    help: The `getSubscribedServices()` method returns an array mapping service IDs
      (or type-hints) to their expected types, allowing Symfony to optimize the
      service locator and check for circular dependencies.
  - question: How can you inject a Service Locator containing specific services into
      a constructor using PHP attributes?
    answers:
      - value: >-
          ```php

          use Psr\Container\ContainerInterface;

          use Symfony\Component\DependencyInjection\Attribute\AutowireLocator;


          class MyService

          {
              public function __construct(
                  #[AutowireLocator(['mailer' => 'App\\Mailer\\MailerInterface', 'logger' => 'Psr\\Log\\LoggerInterface'])]
                  private ContainerInterface $locator
              ) {}
          }

          ```
        correct: true
      - value: |-
          ```php
          use Psr\Container\ContainerInterface;
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(locator: ['mailer', 'logger'])]
                  private ContainerInterface $locator
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          use Psr\Container\ContainerInterface;

          class MyService
          {
              public function __construct(
                  private ContainerInterface $locator
              ) {
                  $this->locator->set('mailer', 'App\\Mailer\\MailerInterface');
              }
          }
          ```
        correct: false
    help: The `#[AutowireLocator]` attribute is used to define a service locator,
      specifying the services it should contain as an associative array where
      keys are the service names within the locator and values are their service
      IDs or class names.
  - question: What is 'service decoration' in Symfony's Dependency Injection Component?
    answers:
      - value: Replacing an existing service with a new one, while still being able to
          access the original ('inner') service.
        correct: true
      - value: Adding new methods to an existing service at runtime.
        correct: false
      - value: Wrapping a service with a proxy to add logging or caching functionality.
        correct: true
      - value: Changing the class of an existing service.
        correct: false
    help: Service decoration allows you to wrap an existing service with a new one,
      often to add or modify behavior without changing the original service's
      code. The original service is typically injected into the decorator as the
      'inner' service.
  - question: You want to decorate the `app.mailer` service with
      `App\Mailer\LoggingMailer`. Which YAML configuration correctly sets up the
      decoration?
    answers:
      - value: |-
          ```yaml
          services:
              App\Mailer\LoggingMailer:
                  decorates: app.mailer
                  arguments: ['@.inner', '@logger']
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Mailer\LoggingMailer:
                  parent: app.mailer
                  arguments: ['@logger']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              app.mailer:
                  class: App\Mailer\LoggingMailer
                  arguments: ['@logger']
          ```
        correct: false
    help: The `decorates` keyword is used to specify which service is being
      decorated. The special `@.inner` argument is used to inject the original,
      decorated service into the decorator's constructor.
  - question: When decorating a service, how do you typically access the original
      (inner) service within your decorator class?
    answers:
      - value: By injecting it into the decorator's constructor, often with the special
          `@.inner` reference in configuration.
        correct: true
      - value: By calling `$this->container->get('original_service_id')`.
        correct: false
      - value: The inner service is automatically available as a public property.
        correct: false
    help: The decorated service is usually injected into the decorator's
      constructor. In YAML/XML/PHP configuration, you use `@.inner` to refer to
      the original service.
  - question: When would you use a service factory in Symfony?
    answers:
      - value: When a service cannot be instantiated directly with `new ClassName()` and
          requires a static method or a method on another service to create it.
        correct: true
      - value: To create multiple instances of a shared service.
        correct: false
      - value: To define a service that depends on an external API.
        correct: false
      - value: To mark a service as public.
        correct: false
    help: Factories are used when the service's instantiation logic is more complex
      than a simple `new` call, such as when it depends on a static method or a
      method of another service.
  - question: How do you define a service factory in `config/services.yaml` that
      uses a method on another service to create an instance?
    answers:
      - value: |-
          ```yaml
          services:
              App\Factory\MailerFactory:
                  # ...

              App\Service\Mailer:
                  factory: ['@App\\Factory\\MailerFactory', 'createMailer']
                  arguments: ['%env(MAILER_DSN)%']
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\Mailer:
                  class: App\Factory\MailerFactory::createMailer
                  arguments: ['%env(MAILER_DSN)%']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\Mailer:
                  calls:
                      - createMailer: ['%env(MAILER_DSN)%']
          ```
        correct: false
    help: The `factory` key in YAML allows you to specify a callable that will be
      used to create the service instance. It can be an array with a service ID
      and a method name, or a class name and a static method name.
  - question: What is the primary purpose of a Compiler Pass in Symfony's Dependency
      Injection Component?
    answers:
      - value: To modify service definitions before the container is compiled and
          dumped.
        correct: true
      - value: To compile Twig templates into PHP code.
        correct: false
      - value: To optimize database queries at runtime.
        correct: false
      - value: To handle incoming HTTP requests.
        correct: false
    help: Compiler Passes allow you to programmatically manipulate the service
      container's definitions during the compilation phase, enabling advanced
      features like collecting tagged services or modifying service arguments.
  - question: When are Compiler Passes executed in the Symfony application lifecycle?
    answers:
      - value: During the container compilation phase, before it is built and dumped.
        correct: true
      - value: On every incoming HTTP request.
        correct: false
      - value: When a service is first retrieved from the container.
        correct: false
      - value: Only in the production environment.
        correct: false
    help: Compiler Passes are a crucial part of the container's compilation process,
      running once during the cache warm-up (or on first request in dev) to
      optimize and finalize service definitions.
  - question: Which method must a class implement to be recognized as a Compiler Pass?
    answers:
      - value: "`process(ContainerBuilder $container)`"
        correct: true
      - value: "`compile(ContainerBuilder $container)`"
        correct: false
      - value: "`build(ContainerBuilder $container)`"
        correct: false
      - value: "`load(ContainerBuilder $container)`"
        correct: false
    help: A Compiler Pass must implement the `CompilerPassInterface` and its
      `process()` method, which receives the `ContainerBuilder` instance
      allowing manipulation of service definitions.
  - question: What is 'semantic configuration' in the context of Symfony bundles?
    answers:
      - value: A structured way for bundles to define and validate their configuration
          options, often exposed via `config/packages/*.yaml` files.
        correct: true
      - value: A method for automatically generating service IDs based on class names.
        correct: false
      - value: A system for translating configuration values into different languages.
        correct: false
      - value: A way to define database table schemas.
        correct: false
    help: Semantic configuration allows bundles to define a clear, validated
      structure for their configuration, making it easier for users to configure
      bundles and preventing invalid settings.
  - question: Which class is responsible for defining the configuration tree for a
      Symfony bundle's semantic configuration?
    answers:
      - value: "`Configuration` (implementing `ConfigurationInterface`)"
        correct: true
      - value: "`Extension` (implementing `ExtensionInterface`)"
        correct: false
      - value: "`Bundle` (extending `AbstractBundle`)"
        correct: false
      - value: "`ContainerBuilder`"
        correct: false
    help: The `Configuration` class, which implements `ConfigurationInterface`,
      defines the structure and validation rules for a bundle's configuration
      using a `TreeBuilder`.
  - question: How can you access the `kernel.debug` parameter within a bundle's
      `Configuration` class to set a default value for a configuration option?
    answers:
      - value: By injecting `kernel.debug` into the `Configuration` class's constructor.
        correct: true
      - value: By calling `$container->getParameter('kernel.debug')` directly in
          `getConfigTreeBuilder()`.
        correct: false
      - value: It's not possible to access parameters in the `Configuration` class.
        correct: false
    help: To use container parameters like `kernel.debug` within your
      `Configuration` class, you should inject them into its constructor. This
      allows you to use their values when building the configuration tree.
  - question: Which of the following is a correct way to register a service in
      `config/services.yaml` with a specific class and arguments?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  class: App\Service\MyService
                  arguments:
                      - '@logger'
                      - '%app.param%'
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              my_service:
                  class: App\Service\MyService
                  args: ['@logger', '%app.param%']
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  constructor_args:
                      - '@logger'
                      - '%app.param%'
          ```
        correct: false
    help: The `arguments` key is used to define constructor arguments for a service
      in YAML. Service IDs are prefixed with `@` and parameters with `%`.
  - question: You have a service `App\Service\ReportGenerator` that needs a
      `Psr\Log\LoggerInterface`. How can you configure it for setter injection
      in `config/services.php`?
    answers:
      - value: |-
          ```php
          // config/services.php
          use App\Service\ReportGenerator;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();

              $services->set(ReportGenerator::class)
                  ->call('setLogger', [service('logger')]);
          };
          ```
        correct: true
      - value: |-
          ```php
          // config/services.php
          use App\Service\ReportGenerator;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();

              $services->set(ReportGenerator::class)
                  ->args(service('logger'));
          };
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          use App\Service\ReportGenerator;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();

              $services->set(ReportGenerator::class)
                  ->property('logger', service('logger'));
          };
          ```
        correct: false
    help: In PHP service configuration, the `call()` method is used to configure
      setter injection, specifying the method name and its arguments.
  - question: What is the primary benefit of using constructor injection over setter
      or property injection?
    answers:
      - value: It ensures that the service is always in a valid state after
          construction, as all required dependencies are provided.
        correct: true
      - value: It allows for optional dependencies that can be set later.
        correct: false
      - value: It makes the service's properties public and easily accessible.
        correct: false
      - value: It reduces the number of arguments in the constructor.
        correct: false
    help: Constructor injection ensures that all necessary dependencies are provided
      at the time of object creation, making the object's state consistent and
      valid from the start.
  - question: Which of the following is a valid way to disable autowiring for a
      specific service in `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  autowire: false
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  autoconfigure: false
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\MyService:
                  inject: false
          ```
        correct: false
    help: "The `autowire: false` option explicitly disables autowiring for a
      particular service definition."
  - question: You want to inject an environment variable `APP_ENV` into a service.
      How can you achieve this using the `#[Autowire]` attribute, ensuring it's
      treated as a boolean?
    answers:
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(env: 'bool:APP_ENV')]
                  private bool $isProduction
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire('%env(APP_ENV)%')]
                  private bool $isProduction
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(param: 'env(APP_ENV)')]
                  private bool $isProduction
              ) {}
          }
          ```
        correct: false
    help: The `env:` option within `#[Autowire]` allows injecting environment
      variables, and you can use processors like `bool:` to cast the value to a
      specific type.
  - question: What is the purpose of the `#[AutowireServiceClosure]` attribute?
    answers:
      - value: To automatically create an anonymous function (closure) that returns a
          service, useful for lazy-loading or non-shared service dependencies.
        correct: true
      - value: To define a service that is itself a PHP closure.
        correct: false
      - value: To inject a service that is only available at runtime.
        correct: false
      - value: To ensure a service is always shared.
        correct: false
    help: The `#[AutowireServiceClosure]` attribute allows you to inject a service
      as a callable (closure) that, when invoked, returns the actual service
      instance. This is particularly useful for lazy-loading services that might
      not always be needed, improving performance.
  - question: You have a console command `App\Command\MyCommand`. How do you
      register it as a service and ensure its dependencies are autowired, using
      PHP attributes?
    answers:
      - value: |-
          ```php
          namespace App\Command;

          use Symfony\Component\Console\Attribute\AsCommand;
          use Psr\Log\LoggerInterface;

          #[AsCommand(name: 'app:my-command', description: 'My custom command')]
          class MyCommand
          {
              public function __construct(private LoggerInterface $logger) {}
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          namespace App\Command;

          use Symfony\Component\Console\Command\Command;
          use Psr\Log\LoggerInterface;

          class MyCommand extends Command
          {
              protected static $defaultName = 'app:my-command';
              public function __construct(private LoggerInterface $logger) {}
              // ...
          }
          ```
        correct: true
      - value: |-
          ```php
          namespace App\Command;

          class MyCommand
          {
              // No attributes needed, Symfony automatically registers commands
              public function __construct(private LoggerInterface $logger) {}
              // ...
          }
          ```
        correct: false
    help: Symfony 7.0 supports commands as services. By using the `#[AsCommand]`
      attribute on a class (which doesn't necessarily need to extend `Command`
      if it has an `__invoke` method), Symfony will automatically register it as
      a service and autowire its dependencies.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\Attribute\AsAlias` attribute?
    answers:
      - value: To define an alias for a service, allowing it to be referenced by an
          alternative name.
        correct: true
      - value: To mark a service as an abstract definition.
        correct: false
      - value: To create a synthetic service.
        correct: false
      - value: To define a service that is only available in specific environments.
        correct: false
    help: The `#[AsAlias]` attribute allows you to create an alias for an existing
      service, making it accessible under a different ID. This is often used for
      backward compatibility or to provide more semantic names.
  - question: How can you make an existing object instance available as a service in
      the container at runtime (e.g., in a test or during bootstrapping)?
    answers:
      - value: Using `$container->set('service_id', $instance);`
        correct: true
      - value: Using `$container->add('service_id', $instance);`
        correct: false
      - value: Using `$container->register('service_id', $instance);`
        correct: false
      - value: Using `$container->load($instance);`
        correct: false
    help: The `set()` method on `ContainerBuilder` (or the compiled container)
      allows you to inject an already instantiated object as a service, making
      it a 'synthetic' service.
  - question: Which of the following is a key advantage of using Dependency Injection?
    answers:
      - value: Reduced coupling between components.
        correct: true
      - value: Improved testability of code.
        correct: true
      - value: Easier management of complex object graphs.
        correct: true
      - value: Automatic generation of all application code.
        correct: false
    help: Dependency Injection promotes loose coupling, making components more
      independent and easier to test, maintain, and reuse. It also centralizes
      the configuration of dependencies.
  - question: What happens if Symfony's autowiring encounters multiple services
      implementing the same interface, and no specific service is targeted?
    answers:
      - value: It will throw an autowiring exception, indicating ambiguity.
        correct: true
      - value: It will inject the first service it finds alphabetically.
        correct: false
      - value: It will inject all services as an array.
        correct: false
      - value: It will automatically create an alias for one of them.
        correct: false
    help: "When autowiring encounters an ambiguous type hint (multiple services
      implement the same interface), it will throw an exception. You need to
      resolve this ambiguity using `#[Target]`, `#[Autowire(service: ...)]`, or
      by aliasing one of the services."
  - question: You want to dynamically add a compiler pass to your bundle's
      extension. In which method of your bundle's `Extension` class would you
      typically do this?
    answers:
      - value: "`build(ContainerBuilder $container)`"
        correct: true
      - value: "`load(array $configs, ContainerBuilder $container)`"
        correct: false
      - value: "`prepend(ContainerBuilder $container)`"
        correct: false
      - value: "`configure(ContainerBuilder $container)`"
        correct: false
    help: Compiler passes are added in the `build()` method of your bundle's
      `Extension` class, which is called during the container compilation
      process.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\ContainerBuilder::registerForAutoconfiguration()`
      method?
    answers:
      - value: To define autoconfiguration rules (e.g., tags) for services that
          implement a specific interface or extend a class.
        correct: true
      - value: To register a new service with a custom ID.
        correct: false
      - value: To enable or disable autowiring for a specific class.
        correct: false
      - value: To compile the container based on a given interface.
        correct: false
    help: "`registerForAutoconfiguration()` allows you to apply common
      configurations (like tags) to all services that implement a certain
      interface or extend a specific class, without explicitly defining them for
      each service."
  - question: When defining a service in `config/services.yaml`, how can you mark it
      as non-shared (i.e., a new instance is created every time it's requested)?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\TransientService:
                  shared: false
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\TransientService:
                  scope: prototype
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\TransientService:
                  singleton: false
          ```
        correct: false
    help: "Setting `shared: false` for a service definition in YAML ensures that a
      new instance of the service is created every time it is retrieved from the
      container."
  - question: Which of the following is a valid way to load service definitions from
      an XML file into a `ContainerBuilder`?
    answers:
      - value: |-
          ```php
          use Symfony\Component\Config\FileLocator;
          use Symfony\Component\DependencyInjection\ContainerBuilder;
          use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

          $container = new ContainerBuilder();
          $loader = new XmlFileLoader($container, new FileLocator(__DIR__));
          $loader->load('services.xml');
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\ContainerBuilder;

          $container = new ContainerBuilder();
          $container->loadXml('services.xml');
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Loader\XmlLoader;

          $loader = new XmlLoader();
          $container = $loader->load('services.xml');
          ```
        correct: false
    help: The `XmlFileLoader` class is used to load service definitions from XML
      files into a `ContainerBuilder` instance, typically with a `FileLocator`
      to resolve file paths.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\Attribute\Autoconfigure` attribute?
    answers:
      - value: To define autoconfiguration rules (e.g., tags, method calls) directly on
          a class.
        correct: true
      - value: To automatically configure all services in a namespace.
        correct: false
      - value: To enable autowiring for a specific class.
        correct: false
      - value: To mark a service as a compiler pass.
        correct: false
    help: The `#[Autoconfigure]` attribute provides a way to apply various
      autoconfiguration rules, such as adding tags or method calls, directly to
      a service class, similar to `registerForAutoconfiguration` but for a
      single class.
  - question: You have a service `App\Service\DataProcessor` that needs access to
      the `router` service. How would you inject it using constructor injection
      in a PHP class, assuming autowiring is enabled?
    answers:
      - value: |-
          ```php
          namespace App\Service;

          use Symfony\Component\Routing\RouterInterface;

          class DataProcessor
          {
              public function __construct(
                  private RouterInterface $router,
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          namespace App\Service;

          class DataProcessor
          {
              public function __construct(
                  private $router,
              ) {
                  $this->router = $this->container->get('router');
              }
          }
          ```
        correct: false
      - value: |-
          ```php
          namespace App\Service;

          class DataProcessor
          {
              public function __construct(
                  private Symfony\Component\Routing\Router $router,
              ) {}
          }
          ```
        correct: true
    help: With autowiring enabled, Symfony can automatically inject services based
      on their type-hints. `RouterInterface` is the recommended type-hint for
      the router service.
  - question: What is the purpose of the `prependExtensionConfig()` method in a
      bundle's `Extension` class (or `prependExtension()` in `AbstractBundle`)?
    answers:
      - value: To allow a bundle to add configuration to other bundles' extensions
          before their `load()` methods are called.
        correct: true
      - value: To load the bundle's own configuration from YAML files.
        correct: false
      - value: To define new parameters for the container.
        correct: false
      - value: To register compiler passes for the bundle.
        correct: false
    help: The `prependExtensionConfig()` method (or implementing
      `PrependExtensionInterface` and its `prepend()` method) allows a bundle to
      'prepend' configuration to other bundles, which can be useful for setting
      default values or overriding existing configuration before the main
      configuration loading.
  - question: You need to inject the `event_dispatcher` service. Which interface
      should you type-hint for autowiring?
    answers:
      - value: "`Symfony\\Component\\EventDispatcher\\EventDispatcherInterface`"
        correct: true
      - value: "`Psr\\EventDispatcher\\EventDispatcherInterface`"
        correct: true
      - value: "`EventDispatcher`"
        correct: false
      - value: "`Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface`"
        correct: true
    help: Symfony's `event_dispatcher` service implements multiple interfaces,
      including `Psr\EventDispatcher\EventDispatcherInterface`,
      `Symfony\Component\EventDispatcher\EventDispatcherInterface`, and
      `Symfony\Contracts\EventDispatcher\EventDispatcherInterface`. Any of these
      can be used for type-hinting.
  - question: What is the main reason to avoid directly accessing services from the
      container using `$container->get()` in your application code?
    answers:
      - value: It creates tight coupling between your code and the service container,
          making it harder to test and reuse components.
        correct: true
      - value: It is less performant than autowiring.
        correct: false
      - value: It can only retrieve public services.
        correct: true
      - value: It leads to memory leaks.
        correct: false
    help: Directly accessing the container (the 'Service Locator' anti-pattern)
      introduces tight coupling and makes your classes harder to test in
      isolation, as they implicitly depend on the container's state. It also
      only works for public services.
  - question: How can you inject the `profiler` service into a controller using
      autowiring?
    answers:
      - value: |-
          ```php
          use Symfony\Component\HttpKernel\Profiler\Profiler;

          class MyController extends AbstractController
          {
              public function index(Profiler $profiler): Response
              {
                  // ...
              }
          }
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\HttpKernel\Profiler\ProfilerInterface;

          class MyController extends AbstractController
          {
              public function index(ProfilerInterface $profiler): Response
              {
                  // ...
              }
          }
          ```
        correct: true
      - value: |-
          ```php
          class MyController extends AbstractController
          {
              public function index(): Response
              {
                  $profiler = $this->container->get('profiler');
                  // ...
              }
          }
          ```
        correct: false
    help: If the `profiler` service is public (which it typically is in dev
      environments), you can autowire it by type-hinting
      `Symfony\Component\HttpKernel\Profiler\Profiler` or
      `Symfony\Component\HttpKernel\Profiler\ProfilerInterface`.
  - question: What is the purpose of the `#[Target]` attribute in Symfony's
      Dependency Injection?
    answers:
      - value: To specify a named service to be injected when multiple services
          implement the same interface.
        correct: true
      - value: To define the target class for a service alias.
        correct: false
      - value: To mark a service as a target for decoration.
        correct: false
      - value: To specify the target environment for a service.
        correct: false
    help: The `#[Target]` attribute helps resolve autowiring ambiguities by
      explicitly naming the service ID that should be injected when multiple
      services satisfy a type-hint.
  - question: Which of the following is a valid way to define a parameter in
      `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          parameters:
              app.items_per_page: 10
          ```
        correct: true
      - value: |-
          ```yaml
          params:
              app.items_per_page: 10
          ```
        correct: false
      - value: |-
          ```yaml
          config:
              app.items_per_page: 10
          ```
        correct: false
    help: Parameters are defined under the `parameters:` key in YAML configuration
      files.
  - question: You have a service `App\Service\NotificationSender` that needs to send
      different types of notifications (email, SMS). You want to inject a
      collection of notifier services, each implementing `NotifierInterface`.
      How would you achieve this using tags and autowiring?
    answers:
      - value: Tag each notifier service (e.g., `app.notifier`). Then, in
          `NotificationSender`, type-hint `iterable $notifiers` and use
          `#[AutowireIterator('app.notifier')]`.
        correct: true
      - value: Create a service locator and manually add each notifier service to it.
        correct: false
      - value: Inject `ContainerInterface` and retrieve each notifier service by its ID.
        correct: false
    help: Using tags and `#[AutowireIterator]` is the idiomatic Symfony way to
      inject a collection of services that share a common tag or interface.
  - question: What is the primary benefit of using `ContainerConfigurator` in
      `config/services.php` over directly manipulating `ContainerBuilder`?
    answers:
      - value: It provides a more fluent and readable API for defining services and
          parameters.
        correct: true
      - value: It allows for dynamic service creation at runtime.
        correct: false
      - value: It enables hot-reloading of service definitions without clearing the
          cache.
        correct: false
      - value: It is the only way to define private services.
        correct: false
    help: "`ContainerConfigurator` offers a more modern, fluent, and less verbose
      way to define services and parameters in PHP configuration files compared
      to the older `ContainerBuilder` API."
  - question: Which of the following is a valid way to register a service in
      `config/services.php` using `ContainerConfigurator`?
    answers:
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set(MyService::class);
          };
          ```
        correct: true
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;

          return [
              MyService::class => null,
          ];
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;
          use Symfony\Component\DependencyInjection\ContainerBuilder;

          $container = new ContainerBuilder();
          $container->register(MyService::class);
          ```
        correct: false
    help: The `set()` method on the `$services` object (obtained from
      `$container->services()`) is the standard way to register services in PHP
      configuration files using `ContainerConfigurator`.
  - question: What is the purpose of the `Symfony\Component\Config\FileLocator`
      class when loading service definitions?
    answers:
      - value: To locate configuration files (e.g., `services.yaml`, `services.xml`,
          `services.php`) within a given set of paths.
        correct: true
      - value: To parse the content of configuration files.
        correct: false
      - value: To validate the syntax of configuration files.
        correct: false
      - value: To cache the loaded service definitions.
        correct: false
    help: The `FileLocator` helps loaders (like `YamlFileLoader`, `XmlFileLoader`,
      `PhpFileLoader`) find the actual configuration files on the filesystem by
      searching through a defined set of directories.
  - question: You have a service `App\Service\LegacyService` that exposes a public
      property `$config` which needs to be injected with an array. How would you
      configure this in `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\LegacyService:
                  properties:
                      config:
                          key1: value1
                          key2: value2
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\LegacyService:
                  arguments:
                      $config:
                          key1: value1
                          key2: value2
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\LegacyService:
                  calls:
                      - setConfig:
                          - { key1: value1, key2: value2 }
          ```
        correct: false
    help: The `properties:` key is used for property injection. You can directly
      provide scalar values, arrays, or references to other services/parameters.
  - question: What is the role of the `Extension` class (implementing
      `ExtensionInterface`) in a Symfony bundle regarding Dependency Injection?
    answers:
      - value: It loads the bundle's service definitions and configuration into the
          `ContainerBuilder`.
        correct: true
      - value: It defines the bundle's routing configuration.
        correct: false
      - value: It registers the bundle's console commands.
        correct: false
      - value: It handles HTTP requests for the bundle.
        correct: false
    help: The `Extension` class is the entry point for a bundle's dependency
      injection configuration. Its `load()` method is responsible for loading
      service definitions (from YAML, XML, PHP files) and processing semantic
      configuration.
  - question: Which of the following built-in services is responsible for resolving
      a controller and its arguments from a request?
    answers:
      - value: "`controller_resolver`"
        correct: true
      - value: "`argument_resolver`"
        correct: true
      - value: "`router`"
        correct: false
      - value: "`http_kernel`"
        correct: false
    help: The `controller_resolver` finds the controller callable, and the
      `argument_resolver` determines and provides the arguments for that
      callable based on type-hints and attributes.
  - question: What is the purpose of the `#[Required]` attribute when applied to a
      public property?
    answers:
      - value: It ensures that autowiring will attempt to inject a dependency into that
          property.
        correct: true
      - value: It makes the property immutable.
        correct: false
      - value: It marks the property as a service itself.
        correct: false
      - value: It prevents the property from being autowired.
        correct: false
    help: The `#[Required]` attribute on a public property signals to Symfony's
      autowiring that this property must be injected with a dependency.
  - question: You want to inject the `twig` environment service. Which class or
      interface should you type-hint?
    answers:
      - value: "`Twig\\Environment`"
        correct: true
      - value: "`Twig_Environment`"
        correct: false
      - value: "`Symfony\\Bundle\\TwigBundle\\TwigEngine`"
        correct: false
      - value: "`Twig\\Loader\\LoaderInterface`"
        correct: false
    help: The core Twig environment service is typically type-hinted as
      `Twig\Environment` for autowiring.
  - question: "What is the difference between `#[Autowire(service: 'service_id')]`
      and `#[Target('service_id')]`?"
    answers:
      - value: "`#[Autowire(service: ...)]` is a general attribute for explicit service
          injection, while `#[Target(...)]` is specifically for resolving
          ambiguity when multiple services implement the same interface."
        correct: true
      - value: "`#[Autowire(service: ...)]` is for constructor injection, and
          `#[Target(...)]` is for setter injection."
        correct: false
      - value: They are interchangeable and serve the exact same purpose.
        correct: false
    help: While both can achieve explicit service injection, `#[Target]` is
      semantically clearer for resolving type-hint ambiguities, indicating which
      specific implementation of an interface should be used.
  - question: Consider a scenario where you have a `ReportGenerator` service that
      needs a `LoggerInterface` but it's an optional dependency. How can you
      configure this using YAML to prevent an error if the logger is not
      available?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\ReportGenerator:
                  calls:
                      - setLogger: ['@logger', !ignore_on_invalid: true]
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\ReportGenerator:
                  calls:
                      - setLogger: ['@logger', on_invalid: ignore]
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\ReportGenerator:
                  arguments:
                      - '@logger?'
          ```
        correct: true
    help: "For optional constructor arguments, you can append a `?` to the service
      ID. For setter calls, you would typically make the setter argument
      nullable in PHP and rely on autowiring, or use `on_invalid: ignore` in
      older Symfony versions (though this is less common with modern
      autowiring)."
  - question: What is the correct way to define a service as an alias for another
      service in `config/services.php`?
    answers:
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->alias('my_alias', MyService::class);
          };
          ```
        correct: true
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set('my_alias', service(MyService::class));
          };
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyService;
          use Symfony\Component\DependencyInjection\ContainerBuilder;

          $container = new ContainerBuilder();
          $container->setAlias('my_alias', MyService::class);
          ```
        correct: true
    help: In `ContainerConfigurator`, use `$services->alias('alias_id',
      'original_service_id')`. With `ContainerBuilder`, use
      `$container->setAlias('alias_id', 'original_service_id')`.
  - question: "What is the purpose of the `public: true` or `public: false` setting
      for a service in Symfony?"
    answers:
      - value: It controls whether the service can be retrieved directly from the
          container using `$container->get()`.
        correct: true
      - value: It determines if the service's methods are publicly accessible.
        correct: false
      - value: It affects whether the service is autowired.
        correct: false
      - value: It defines if the service is shared or not.
        correct: false
    help: The `public` setting exclusively controls whether a service can be
      accessed directly from the container via `get()`. Private services can
      only be injected as dependencies.
  - question: Which of the following is NOT a recommended practice for dependency
      injection in Symfony?
    answers:
      - value: Using constructor injection for all required dependencies.
        correct: false
      - value: Directly accessing the service container in your business logic classes.
        correct: true
      - value: Autowiring services based on type hints.
        correct: false
      - value: Using service tags to collect related services.
        correct: false
    help: Directly accessing the container (the Service Locator anti-pattern) leads
      to tightly coupled code that is difficult to test and maintain.
  - question: You want to define a service that should always be a new instance
      every time it's injected. How do you configure this in
      `config/services.php`?
    answers:
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyNonSharedService;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set(MyNonSharedService::class)
                  ->shared(false);
          };
          ```
        correct: true
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyNonSharedService;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set(MyNonSharedService::class)
                  ->instance('new');
          };
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          use App\Service\MyNonSharedService;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->set(MyNonSharedService::class);
              $services->setShared(false);
          };
          ```
        correct: false
    help: The `shared(false)` method on a service definition in PHP configuration
      explicitly marks the service as non-shared (prototype scope).
  - question: What is the main benefit of using PHP attributes for service
      configuration compared to YAML or XML files?
    answers:
      - value: Configuration is co-located with the code, improving readability and
          discoverability.
        correct: true
      - value: They are always more performant than file-based configurations.
        correct: false
      - value: They allow for more complex logical conditions in service definitions.
        correct: false
      - value: They eliminate the need for the Dependency Injection component.
        correct: false
    help: PHP attributes for DI configuration offer the advantage of having the
      service definition directly alongside the class itself, making it easier
      to understand how a class is configured as a service.
  - question: When is the `ContainerBuilder::compile()` method typically called?
    answers:
      - value: During the application's boot process, especially in production or when
          clearing the cache.
        correct: true
      - value: On every HTTP request.
        correct: false
      - value: When a new service is registered.
        correct: false
      - value: Only during unit tests.
        correct: false
    help: The `compile()` method triggers the container compilation process,
      including the execution of compiler passes, and results in a highly
      optimized, cached container.
  - question: Which of the following is a valid way to define a service in
      `config/services.php` using a static factory method?
    answers:
      - value: |-
          ```php
          // config/services.php
          use App\Factory\MailerFactory;
          use App\Service\Mailer;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set(Mailer::class)
                  ->factory([MailerFactory::class, 'create']);
          };
          ```
        correct: true
      - value: |-
          ```php
          // config/services.php
          use App\Factory\MailerFactory;
          use App\Service\Mailer;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->services();
              $services->set(Mailer::class)
                  ->call('create', [MailerFactory::class]);
          };
          ```
        correct: false
      - value: |-
          ```php
          // config/services.php
          use App\Factory\MailerFactory;
          use App\Service\Mailer;
          use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

          return function(ContainerConfigurator $container): void {
              $services = $container->set(Mailer::class, MailerFactory::create());
          };
          ```
        correct: false
    help: The `factory()` method on a service definition in PHP configuration is
      used to specify a callable (e.g., a static method on a class) that will be
      used to create the service instance.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\ContainerBuilder::registerAttributeForAutoconfiguration()`
      method?
    answers:
      - value: To register a PHP attribute and define a callback that applies
          configurations (e.g., tags) to services using that attribute.
        correct: true
      - value: To automatically register all classes with attributes as services.
        correct: false
      - value: To disable autoconfiguration for specific attributes.
        correct: false
      - value: To define a new custom PHP attribute.
        correct: false
    help: "`registerAttributeForAutoconfiguration()` allows you to create custom
      attributes that, when applied to a service class, automatically trigger
      specific configuration rules (like adding tags or method calls) via a
      provided callback."
  - question: You have a service `App\Service\CacheWarmer` that needs to execute a
      method `warm()` after all other services have been instantiated. How can
      you configure this in `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\CacheWarmer:
                  public: true
                  calls:
                      - warm: []
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\CacheWarmer:
                  public: true
                  lazy: true
                  calls:
                      - warm: []
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\CacheWarmer:
                  public: true
                  autowire: true
                  warmup_method: warm
          ```
        correct: false
    help: The `calls:` section in a service definition is used to specify methods
      that should be called on the service instance after it has been
      instantiated and its constructor dependencies injected. This is commonly
      used for post-construction initialization.
  - question: What is the role of the
      `Symfony\Component\DependencyInjection\Container` class at runtime?
    answers:
      - value: It is the compiled, optimized version of the `ContainerBuilder` used to
          retrieve services efficiently.
        correct: true
      - value: It is used to define new services dynamically.
        correct: false
      - value: It handles the parsing of configuration files.
        correct: false
      - value: It is primarily used during the compilation phase.
        correct: false
    help: After compilation, the `ContainerBuilder` is transformed into a highly
      optimized, usually cached, `Container` instance (or a subclass thereof)
      that is used at runtime to quickly retrieve service instances.
  - question: You have a service that needs to be injected with the current
      `kernel.environment` parameter. How would you do this in
      `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\EnvironmentChecker:
                  arguments: ['%kernel.environment%']
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\EnvironmentChecker:
                  arguments:
                      - '@kernel.environment'
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\EnvironmentChecker:
                  environment: '%kernel.environment%'
          ```
        correct: false
    help: Parameters are injected into service arguments using the
      `%parameter_name%` syntax.
  - question: What is the purpose of the `#[AsService]` attribute's `id` parameter?
    answers:
      - value: To explicitly define the service ID, overriding the default autowired ID
          (usually the FQCN).
        correct: true
      - value: To define an alias for the service.
        correct: false
      - value: To mark the service as public.
        correct: false
      - value: To specify the class name of the service.
        correct: false
    help: By default, autowired services get an ID equal to their Fully Qualified
      Class Name (FQCN). The `id` parameter in `#[AsService]` allows you to
      assign a custom, explicit ID.
  - question: Which of the following is a valid way to load service definitions from
      a PHP file into a `ContainerBuilder`?
    answers:
      - value: |-
          ```php
          use Symfony\Component\Config\FileLocator;
          use Symfony\Component\DependencyInjection\ContainerBuilder;
          use Symfony\Component\DependencyInjection\Loader\PhpFileLoader;

          $container = new ContainerBuilder();
          $loader = new PhpFileLoader($container, new FileLocator(__DIR__));
          $loader->load('services.php');
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\ContainerBuilder;

          $container = new ContainerBuilder();
          $container->loadPhp('services.php');
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Loader\PhpLoader;

          $loader = new PhpLoader();
          $container = $loader->load('services.php');
          ```
        correct: false
    help: The `PhpFileLoader` class is used to load service definitions from PHP
      files into a `ContainerBuilder` instance, typically with a `FileLocator`
      to resolve file paths.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\ContainerBuilder` class?
    answers:
      - value: It is used to build and compile the service container from various
          configuration sources (YAML, XML, PHP, attributes).
        correct: true
      - value: It is the runtime container used to retrieve services.
        correct: false
      - value: It provides a simple API for defining services in PHP.
        correct: false
      - value: It manages environment variables.
        correct: false
    help: The `ContainerBuilder` is the central class during the compilation phase
      of the Dependency Injection component. It collects all service
      definitions, parameters, and compiler passes before compiling them into an
      optimized runtime container.
  - question: Which of the following is a valid way to define a service in
      `config/services.yaml` with a specific tag and an attribute for that tag?
    answers:
      - value: |-
          ```yaml
          services:
              App\Service\MyHandler:
                  tags:
                      - { name: app.handler, priority: 10 }
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\MyHandler:
                  tag: app.handler
                  tag_attributes:
                      priority: 10
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\MyHandler:
                  tags:
                      app.handler: { priority: 10 }
          ```
        correct: false
    help: Tags are defined as a list under the `tags:` key. Each tag can be an
      object with a `name` property and additional attributes.
  - question: What is the primary benefit of using autowiring for service injection?
    answers:
      - value: It reduces the amount of explicit configuration needed for services.
        correct: true
      - value: It makes services immutable by default.
        correct: false
      - value: It automatically creates new classes for missing dependencies.
        correct: false
      - value: It forces all services to be public.
        correct: false
    help: Autowiring significantly reduces boilerplate configuration by
      automatically resolving and injecting dependencies based on type hints,
      leading to cleaner service definitions.
  - question: You want to define a service that is an alias for
      `Psr\Log\LoggerInterface` to point to `monolog.logger`. How would you do
      this in `config/services.yaml`?
    answers:
      - value: |-
          ```yaml
          services:
              Psr\Log\LoggerInterface: '@monolog.logger'
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              Psr\Log\LoggerInterface:
                  alias: monolog.logger
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              Psr\Log\LoggerInterface:
                  target: monolog.logger
          ```
        correct: false
    help: In YAML, you can create an alias by mapping the alias ID to the original
      service ID using the `@` prefix.
  - question: What is the purpose of the `#[AsCommand]` attribute in Symfony Console
      commands?
    answers:
      - value: To register a PHP class as a console command service and define its name
          and description.
        correct: true
      - value: To mark a method as the entry point for a console command.
        correct: false
      - value: To inject arguments into a console command.
        correct: false
      - value: To define a console command as a compiler pass.
        correct: false
    help: The `#[AsCommand]` attribute simplifies registering console commands as
      services, allowing them to benefit from dependency injection and
      autowiring without explicit service definitions in YAML/XML/PHP files.
  - question: Which of the following describes a 'synthetic service' in Symfony's
      Dependency Injection Component?
    answers:
      - value: A service whose instance is created and injected into the container at
          runtime, rather than being defined in configuration files.
        correct: true
      - value: A service that is generated automatically by autowiring.
        correct: false
      - value: A service that is an alias to another service.
        correct: false
      - value: A service that is only used for testing purposes.
        correct: false
    help: Synthetic services are those that are not instantiated by the container
      itself but are instead provided to the container as already existing
      objects using `$container->set()`.
  - question: What is the main advantage of using `#[Required]` on a setter method
      compared to making a constructor argument nullable for an optional
      dependency?
    answers:
      - value: "`#[Required]` ensures the setter is called if the dependency is
          available, providing a clear contract for optional injection, while a
          nullable constructor argument might require manual checks."
        correct: true
      - value: "`#[Required]` makes the dependency mandatory, whereas a nullable
          constructor argument makes it optional."
        correct: false
      - value: "`#[Required]` is only for autowiring, while nullable constructor
          arguments work with explicit configuration."
        correct: false
    help: "`#[Required]` on a setter provides a clean way to signal that a
      dependency *should* be injected if available, and Symfony will ensure the
      setter is called. For truly optional dependencies, a nullable constructor
      argument is also valid, but `#[Required]` is explicit for setters."
  - question: You need to inject a specific instance of `DateTimeImmutable` into a
      service, but you want to create it using an expression. How can you do
      this with the `#[Autowire]` attribute?
    answers:
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(expression: 'new \\DateTimeImmutable()')]
                  private \DateTimeImmutable $now
              ) {}
          }
          ```
        correct: true
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(param: 'new \\DateTimeImmutable()')]
                  private \DateTimeImmutable $now
              ) {}
          }
          ```
        correct: false
      - value: |-
          ```php
          use Symfony\Component\DependencyInjection\Attribute\Autowire;

          class MyService
          {
              public function __construct(
                  #[Autowire(service: 'new \\DateTimeImmutable()')]
                  private \DateTimeImmutable $now
              ) {}
          }
          ```
        correct: false
    help: The `expression:` option within `#[Autowire]` allows you to inject the
      result of a Symfony Expression Language expression, providing powerful
      dynamic injection capabilities.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\Extension\PrependExtensionInterface`?
    answers:
      - value: It allows a bundle's extension to modify the container builder by
          prepending configuration to other extensions before their `load`
          methods are called.
        correct: true
      - value: It defines the interface for all service container extensions.
        correct: false
      - value: It enables a bundle to register new compiler passes.
        correct: false
      - value: It is used to load environment variables into the container.
        correct: false
    help: Bundles implementing `PrependExtensionInterface` can influence the
      configuration of other bundles by prepending their own configuration,
      which is processed early in the compilation process.
  - question: Which of the following is a common use case for a Compiler Pass?
    answers:
      - value: Collecting all services tagged with a specific name and injecting them
          into another service.
        correct: true
      - value: Handling form submissions.
        correct: false
      - value: Rendering Twig templates.
        correct: false
      - value: Sending emails.
        correct: false
    help: Compiler Passes are frequently used to find services with specific tags
      and then inject references to those services into a 'collector' service,
      creating a collection of related services.
  - question: What is the primary difference between `ContainerBuilder` and
      `Container` in Symfony's DI component?
    answers:
      - value: "`ContainerBuilder` is used during compilation to define services, while
          `Container` is the optimized runtime object used to retrieve
          services."
        correct: true
      - value: "`ContainerBuilder` is for development, and `Container` is for
          production."
        correct: false
      - value: "`ContainerBuilder` allows service retrieval, but `Container` does not."
        correct: false
      - value: "`ContainerBuilder` is for parameters, and `Container` is for services."
        correct: false
    help: "`ContainerBuilder` is mutable and used to build the container, while
      `Container` is the immutable, compiled version that provides fast access
      to services at runtime."
  - question: You have a service `App\Service\MyService` and you want to ensure that
      if `Psr\Log\LoggerInterface` is available, it's injected via a setter
      method `setLogger`. If not, the service should still function. How would
      you configure this without `#[Required]`?
    answers:
      - value: Make the `setLogger` method accept a nullable `LoggerInterface` (e.g.,
          `setLogger(?LoggerInterface $logger)`). Symfony's autowiring will
          handle it gracefully.
        correct: true
      - value: "Set `autowire: false` for `MyService` and manually define the `logger`
          argument as optional."
        correct: false
      - value: Use a factory to conditionally inject the logger.
        correct: false
    help: For truly optional setter dependencies, the best practice is to make the
      setter argument nullable. Autowiring will then inject the logger if
      available, or `null` if not, without throwing an error.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\Attribute\Autowire` attribute's
      `param` option?
    answers:
      - value: To inject a container parameter by its name.
        correct: true
      - value: To inject an environment variable.
        correct: false
      - value: To inject a service by its ID.
        correct: false
      - value: To define a new parameter.
        correct: false
    help: The `param` option within `#[Autowire]` is specifically used to inject the
      value of a container parameter into a constructor argument or property.
  - question: Which of the following is a built-in service that provides access to
      the current application environment (e.g., 'dev', 'prod')?
    answers:
      - value: "`kernel.environment` (parameter)"
        correct: true
      - value: "`kernel` (service)"
        correct: true
      - value: "`env` (function)"
        correct: false
      - value: "`app.env` (parameter)"
        correct: false
    help: The application environment is available as the `kernel.environment`
      parameter. You can also get it from the `kernel` service via
      `$kernel->getEnvironment()`.
  - question: What is the main advantage of using `#[Autowire]` with an `expression`
      over other injection methods?
    answers:
      - value: It allows for highly dynamic and complex value injection based on runtime
          logic or other container elements.
        correct: true
      - value: It is the most performant way to inject services.
        correct: false
      - value: It simplifies the definition of simple scalar values.
        correct: false
      - value: It automatically creates new services based on the expression.
        correct: false
    help: The `expression` option in `#[Autowire]` leverages Symfony's Expression
      Language, enabling you to inject values derived from complex logic, other
      services, parameters, or even environment variables in a single attribute.
  - question: When should you prefer constructor injection over setter injection?
    answers:
      - value: For mandatory dependencies that are required for the object to be
          functional.
        correct: true
      - value: For optional dependencies that might not always be available.
        correct: false
      - value: When you want to avoid changing the constructor signature.
        correct: false
      - value: When dealing with circular dependencies.
        correct: false
    help: Constructor injection is best for 'required' dependencies, ensuring that
      an object is always created in a valid state with all its essential
      collaborators.
  - question: What is a 'circular dependency' in the context of Dependency Injection?
    answers:
      - value: When Service A depends on Service B, and Service B simultaneously depends
          on Service A, leading to an infinite loop during instantiation.
        correct: true
      - value: When a service is configured with too many arguments.
        correct: false
      - value: When a service calls itself recursively.
        correct: false
      - value: When a service is defined in multiple configuration files.
        correct: false
    help: A circular dependency occurs when two or more services directly or
      indirectly depend on each other, creating a loop that the container cannot
      resolve during instantiation. Symfony detects and reports these.
  - question: How can you resolve a circular dependency between two services,
      `ServiceA` and `ServiceB`, if both require each other in their
      constructors?
    answers:
      - value: Change one of the dependencies to setter injection or lazy injection
          (e.g., using a service locator or a proxy).
        correct: true
      - value: Make both services public.
        correct: false
      - value: Increase the priority of one of the services.
        correct: false
      - value: Merge `ServiceA` and `ServiceB` into a single service.
        correct: true
    help: Circular dependencies in constructors are problematic. Solutions involve
      breaking the cycle by using setter injection for one dependency (if it's
      optional), lazy injection (e.g., with a proxy or service locator), or
      re-evaluating the design to merge the services if they are too tightly
      coupled.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\ContainerBuilder::addCompilerPass()`
      method?
    answers:
      - value: To register a custom `CompilerPass` that will be executed during the
          container compilation.
        correct: true
      - value: To add a new service to the container.
        correct: false
      - value: To define a new parameter for the container.
        correct: false
      - value: To compile a single service definition.
        correct: false
    help: The `addCompilerPass()` method is used to register your custom
      `CompilerPass` implementations with the `ContainerBuilder`, ensuring they
      are run when the container is compiled.
  - question: Which of the following is a valid way to define a service in
      `config/services.yaml` that is an abstract definition (cannot be
      instantiated directly, only extended)?
    answers:
      - value: |-
          ```yaml
          services:
              _defaults:
                  autowire: true
                  autoconfigure: true

              App\Service\AbstractBaseService:
                  abstract: true
          ```
        correct: true
      - value: |-
          ```yaml
          services:
              App\Service\AbstractBaseService:
                  instantiate: false
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              App\Service\AbstractBaseService:
                  type: abstract
          ```
        correct: false
    help: "Setting `abstract: true` for a service definition marks it as an abstract
      service, meaning it cannot be instantiated directly but can be used as a
      parent for other service definitions."
  - question: What is the primary use case for the `_defaults` section in
      `config/services.yaml`?
    answers:
      - value: To define default configuration options (like autowire, autoconfigure,
          public) for all services defined in that file or section.
        correct: true
      - value: To define global parameters for the entire application.
        correct: false
      - value: To specify default arguments for all services.
        correct: false
      - value: To declare services that are only used in development.
        correct: false
    help: The `_defaults` section provides a convenient way to apply common
      configurations (like enabling autowire and autoconfigure) to a group of
      services, reducing repetition.
  - question: You want to inject the `router` service into a class. Which interface
      is generally preferred for type-hinting when autowiring, and why?
    answers:
      - value: "`Symfony\\Component\\Routing\\RouterInterface` because it promotes loose
          coupling and allows for different router implementations."
        correct: true
      - value: "`Symfony\\Component\\Routing\\Router` because it's the concrete class
          and provides direct access to all methods."
        correct: false
      - value: "`Router` because it's simpler to type-hint."
        correct: false
    help: Type-hinting against interfaces (like `RouterInterface`) is a best
      practice in DI because it promotes loose coupling. Your code depends on an
      abstraction, not a concrete implementation, making it more flexible and
      testable.
  - question: What is the purpose of the
      `Symfony\Component\DependencyInjection\ContainerBuilder::findTaggedServiceIds()`
      method in a Compiler Pass?
    answers:
      - value: To retrieve a list of all service IDs that have a specific tag.
        correct: true
      - value: To find a service by its ID and check if it has a tag.
        correct: false
      - value: To add a tag to an existing service.
        correct: false
      - value: To remove a tag from a service.
        correct: false
    help: The `findTaggedServiceIds()` method is a crucial tool for Compiler Passes,
      allowing them to discover and process services based on their assigned
      tags.
  - question: Which of the following is a valid way to define a parameter in
      `config/packages/my_bundle.yaml` for a bundle's semantic configuration?
    answers:
      - value: |-
          ```yaml
          my_bundle:
              some_setting: value
              another_setting: true
          ```
        correct: true
      - value: |-
          ```yaml
          parameters:
              my_bundle.some_setting: value
          ```
        correct: false
      - value: |-
          ```yaml
          services:
              my_bundle.some_setting: value
          ```
        correct: false
    help: Semantic configuration for bundles is typically placed under the bundle's
      root key (e.g., `my_bundle:`) in `config/packages/*.yaml` files.
